diff --git a/configure.ac b/configure.ac
index 3a1c46a..decc46f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -20,32 +20,36 @@
 #
 # Process this file with autoconf to produce a configure script
 
-AC_PREREQ(2.57)
+# Initialize Autoconf
+AC_PREREQ([2.60])
 AC_INIT([xf86-video-ati],
-        6.13.1,
+        [6.13.99],
         [https://bugs.freedesktop.org/enter_bug.cgi?product=xorg],
-        xf86-video-ati)
+        [xf86-video-ati])
 
 AC_CONFIG_SRCDIR([Makefile.am])
-AM_CONFIG_HEADER([config.h])
+AC_CONFIG_HEADERS([config.h])
 
-# Require xorg-macros: XORG_DEFAULT_OPTIONS
-m4_ifndef([XORG_MACROS_VERSION], 
-          [m4_fatal([must install xorg-macros 1.3 or later before running autoconf/autogen])])
-XORG_MACROS_VERSION(1.3)
+# Require X.Org macros 1.8 or later for MAN_SUBSTS set by XORG_MANPAGE_SECTIONS
+m4_ifndef([XORG_MACROS_VERSION],
+          [m4_fatal([must install xorg-macros 1.8 or later before running autoconf/autogen])])
+XORG_MACROS_VERSION(1.8)
 XORG_DEFAULT_OPTIONS
 
 AC_CONFIG_AUX_DIR(.)
 
+# Initialize Automake
 AM_INIT_AUTOMAKE([foreign dist-bzip2])
 AC_SYS_LARGEFILE
 
 AM_MAINTAINER_MODE
 
-# Checks for programs.
+# Initialize libtool
 AC_DISABLE_STATIC
 AC_PROG_LIBTOOL
-AC_PROG_CC
+
+# Checks for programs.
+AM_PROG_CC_C_O
 
 if test "x$GCC" = "xyes"; then
 	CPPFLAGS="$CPPFLAGS -Wall"
@@ -53,42 +57,38 @@ fi
 
 AH_TOP([#include "xorg-server.h"])
 
+# Define a configure option for an alternate module directory
 AC_ARG_WITH(xorg-module-dir,
-            AC_HELP_STRING([--with-xorg-module-dir=DIR],
+            AS_HELP_STRING([--with-xorg-module-dir=DIR],
                            [Default xorg module directory [[default=$libdir/xorg/modules]]]),
             [moduledir="$withval"],
             [moduledir="$libdir/xorg/modules"])
 
-AC_ARG_ENABLE(dri, AC_HELP_STRING([--disable-dri],
+AC_ARG_ENABLE(dri, AS_HELP_STRING([--disable-dri],
                                   [Disable DRI support [[default=auto]]]),
               [DRI="$enableval"],
               [DRI=auto])
 
 AC_ARG_ENABLE(exa,
-              AC_HELP_STRING([--disable-exa],
+              AS_HELP_STRING([--disable-exa],
                              [Disable EXA support [[default=enabled]]]),
               [EXA="$enableval"],
               [EXA=yes])
 
 AC_ARG_ENABLE(kms,
-              AC_HELP_STRING([--disable-kms],
+              AS_HELP_STRING([--disable-kms],
                              [Disable KMS support [[default=enabled]]]),
               [DRM_MODE="$enableval"],
               [DRM_MODE=yes])
 
-AC_ARG_WITH(xserver-source,AC_HELP_STRING([--with-xserver-source=XSERVER_SOURCE],
-                                          [Path to X server source tree]),
-                           [ XSERVER_SOURCE="$withval" ],
-                           [ XSERVER_SOURCE="" ])
-
-# Checks for extensions
+# Store the list of server defined optional extensions in REQUIRED_MODULES
 XORG_DRIVER_CHECK_EXT(RANDR, randrproto)
 XORG_DRIVER_CHECK_EXT(RENDER, renderproto)
 XORG_DRIVER_CHECK_EXT(XV, videoproto)
 XORG_DRIVER_CHECK_EXT(DPMSExtension, xextproto)
 
-# Checks for pkg-config packages
-PKG_CHECK_MODULES(XORG, [xorg-server >= 1.2 xproto fontsproto $REQUIRED_MODULES])
+# Obtain compiler/linker options for the driver dependencies
+PKG_CHECK_MODULES(XORG, [xorg-server >= 1.3 xproto fontsproto $REQUIRED_MODULES])
 PKG_CHECK_MODULES(XEXT, [xextproto >= 7.0.99.1],
                   HAVE_XEXTPROTO_71="yes"; AC_DEFINE(HAVE_XEXTPROTO_71, 1, [xextproto 7.1 available]),
                   HAVE_XEXTPROTO_71="no")
@@ -96,8 +96,6 @@ AM_CONDITIONAL(HAVE_XEXTPROTO_71, [ test "$HAVE_XEXTPROTO_71" = "yes" ])
 
 # Checks for libraries.
 
-# Checks for header files.
-AC_HEADER_STDC
 
 if test "$DRI" != no; then
 	PKG_CHECK_MODULES(DRI, [libdrm >= 2.2 xf86driproto])
@@ -165,11 +163,6 @@ fi
 AM_CONDITIONAL(DRM_MODE, test x$DRM_MODE = xyes)
 AM_CONDITIONAL(LIBUDEV, test x$LIBUDEV = xyes)
 
-save_CFLAGS="$CFLAGS"
-CFLAGS="$XORG_CFLAGS"
-AC_CHECK_HEADER(xf86Modes.h,[XMODES=yes],[XMODES=no],[#include "xorg-server.h"])
-CFLAGS="$save_CFLAGS"
-
 AC_DEFINE(USE_XAA, 1, [Build support for XAA])
 
 # Properly handle EXA.
@@ -240,48 +233,6 @@ AC_CHECK_DECL(XSERVER_LIBPCIACCESS,
 	      [XSERVER_LIBPCIACCESS=yes],[XSERVER_LIBPCIACCESS=no],
 	      [#include "xorg-server.h"])
 
-AM_CONDITIONAL(XMODES, test "x$XMODES" = xno)
-
-if test "x$XSERVER_SOURCE" = x; then
-        if test -d ../../xserver; then
-                XSERVER_SOURCE="`cd ../../xserver && pwd`"
-        fi
-fi
-
-if test -d "$XSERVER_SOURCE"; then
-        case "$XSERVER_SOURCE" in
-        /*)
-                ;;
-        *)
-                XSERVER_SOURCE="`cd $XSERVER_SOURCE && pwd`"
-        esac
-        if test -f src/modes/xf86Modes.h; then
-                :
-        else
-                ln -sf $XSERVER_SOURCE/hw/xfree86/modes src/modes
-        fi
-
-        if test -f src/parser/xf86Parser.h; then
-                :
-        else
-                ln -sf $XSERVER_SOURCE/hw/xfree86/parser src/parser
-        fi
-fi
-if test "x$XMODES" = xyes; then
-        AC_MSG_NOTICE([X server has new mode code])
-        AC_DEFINE(XMODES, 1,[X server has built-in mode code])
-        XMODES_CFLAGS=
-else
-        if test -f src/modes/xf86Modes.h -a -f src/parser/xf86Parser.h; then
-                AC_MSG_NOTICE([X server is missing new mode code, using local copy])
-        else
-                AC_MSG_ERROR([Must have X server >= 1.3 source tree for mode setting code. Please specify --with-xserver-source])
-        fi
-        XMODES_CFLAGS='-DXF86_MODES_RENAME -I$(top_srcdir)/src -I$(top_srcdir)/src/modes -I$(top_srcdir)/src/parser'
-fi
-
-AC_SUBST([XMODES_CFLAGS])
-
 CPPFLAGS="$SAVE_CPPFLAGS"
 
 AM_CONDITIONAL(USE_EXA, test "x$USE_EXA" = xyes)
@@ -359,12 +310,6 @@ case $host_os in
   AC_DEFINE(FGL_LINUX, 1, [Use linux pragma pack]) ;;
 esac
 
-AC_SUBST([XORG_CFLAGS])
-AC_SUBST([DRI_CFLAGS])
-AC_SUBST([LIBDRM_RADEON_CFLAGS])
-AC_SUBST([LIBDRM_RADEON_LIBS])
-AC_SUBST([LIBUDEV_CFLAGS])
-AC_SUBST([LIBUDEV_LIBS])
 AC_SUBST([moduledir])
 
 DRIVER_NAME=ati
@@ -382,11 +327,12 @@ AC_MSG_NOTICE(
 [Please install that driver as well for rage128-based cards.]
 )
 
-AC_OUTPUT([
-	Makefile
-	src/Makefile
-	man/Makefile
+AC_CONFIG_FILES([
+                Makefile
+                src/Makefile
+                man/Makefile
 ])
+AC_OUTPUT
 
 dnl
 dnl Output some configuration info for the user
diff --git a/man/Makefile.am b/man/Makefile.am
index 9496782..8533765 100644
--- a/man/Makefile.am
+++ b/man/Makefile.am
@@ -31,25 +31,11 @@ EXTRA_DIST = @DRIVER_NAME@.man radeon.man
 
 CLEANFILES = $(driverman_DATA)
 
-SED = sed
-
-# Strings to replace in man pages
-XORGRELSTRING = @PACKAGE_STRING@
-  XORGMANNAME = X Version 11
-
-MAN_SUBSTS = \
-	-e 's|__vendorversion__|"$(XORGRELSTRING)" "$(XORGMANNAME)"|' \
-	-e 's|__xorgversion__|"$(XORGRELSTRING)" "$(XORGMANNAME)"|' \
-	-e 's|__xservername__|Xorg|g' \
-	-e 's|__xconfigfile__|xorg.conf|g' \
-	-e 's|__projectroot__|$(prefix)|g' \
-	-e 's|__appmansuffix__|$(APP_MAN_SUFFIX)|g' \
-	-e 's|__drivermansuffix__|$(DRIVER_MAN_SUFFIX)|g' \
-	-e 's|__adminmansuffix__|$(ADMIN_MAN_SUFFIX)|g' \
-	-e 's|__miscmansuffix__|$(MISC_MAN_SUFFIX)|g' \
-	-e 's|__filemansuffix__|$(FILE_MAN_SUFFIX)|g'
+
+# String replacements in MAN_SUBSTS now come from xorg-macros.m4 via configure
+
 
 SUFFIXES = .$(DRIVER_MAN_SUFFIX) .man
 
 .man.$(DRIVER_MAN_SUFFIX):
-	sed $(MAN_SUBSTS) < $< > $@
+	$(AM_V_GEN)$(SED) $(MAN_SUBSTS) < $< > $@
diff --git a/src/AtomBios/CD_Operations.c b/src/AtomBios/CD_Operations.c
index ae27049..9d399d5 100644
--- a/src/AtomBios/CD_Operations.c
+++ b/src/AtomBios/CD_Operations.c
@@ -505,13 +505,16 @@ VOID ProcessMove(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 
 VOID ProcessMask(PARSER_TEMP_DATA STACK_BASED * pParserTempData)
 {
+    UINT8 src;
 
     pParserTempData->DestData32=GetDestination[pParserTempData->ParametersType.Destination](pParserTempData);
+    src = pParserTempData->CD_Mask.SrcAlignment;
     pParserTempData->SourceData32=GetParametersDirect(pParserTempData);
     pParserTempData->Index=GetSource[pParserTempData->ParametersType.Source](pParserTempData);
     pParserTempData->SourceData32 <<= DestinationAlignmentShift[pParserTempData->CD_Mask.DestAlignment];
     pParserTempData->SourceData32 |= ~(AlignmentMask[pParserTempData->CD_Mask.SrcAlignment] << DestinationAlignmentShift[pParserTempData->CD_Mask.DestAlignment]);
     pParserTempData->DestData32   &= pParserTempData->SourceData32;
+    pParserTempData->Index        >>= SourceAlignmentShift[src];
     pParserTempData->Index        &= AlignmentMask[pParserTempData->CD_Mask.SrcAlignment];
     pParserTempData->Index        <<= DestinationAlignmentShift[pParserTempData->CD_Mask.DestAlignment];
     pParserTempData->DestData32   |= pParserTempData->Index;
diff --git a/src/AtomBios/includes/atombios.h b/src/AtomBios/includes/atombios.h
index 66b238f..1bc72c3 100644
--- a/src/AtomBios/includes/atombios.h
+++ b/src/AtomBios/includes/atombios.h
@@ -2391,10 +2391,10 @@ typedef struct _ATOM_INTEGRATED_SYSTEM_INFO_V5
 #define ATOM_DEVICE_DFP4_SUPPORT                          (0x1L << ATOM_DEVICE_DFP4_INDEX )
 #define ATOM_DEVICE_DFP5_SUPPORT                          (0x1L << ATOM_DEVICE_DFP5_INDEX )
 
-#define ATOM_DEVICE_CRT_SUPPORT                           ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_CRT2_SUPPORT
-#define ATOM_DEVICE_DFP_SUPPORT                           ATOM_DEVICE_DFP1_SUPPORT | ATOM_DEVICE_DFP2_SUPPORT |  ATOM_DEVICE_DFP3_SUPPORT | ATOM_DEVICE_DFP4_SUPPORT | ATOM_DEVICE_DFP5_SUPPORT | ATOM_DEVICE_DFP6_SUPPORT
-#define ATOM_DEVICE_TV_SUPPORT                            ATOM_DEVICE_TV1_SUPPORT
-#define ATOM_DEVICE_LCD_SUPPORT                           ATOM_DEVICE_LCD1_SUPPORT | ATOM_DEVICE_LCD2_SUPPORT
+#define ATOM_DEVICE_CRT_SUPPORT                           (ATOM_DEVICE_CRT1_SUPPORT | ATOM_DEVICE_CRT2_SUPPORT)
+#define ATOM_DEVICE_DFP_SUPPORT                           (ATOM_DEVICE_DFP1_SUPPORT | ATOM_DEVICE_DFP2_SUPPORT |  ATOM_DEVICE_DFP3_SUPPORT | ATOM_DEVICE_DFP4_SUPPORT | ATOM_DEVICE_DFP5_SUPPORT | ATOM_DEVICE_DFP6_SUPPORT)
+#define ATOM_DEVICE_TV_SUPPORT                            (ATOM_DEVICE_TV1_SUPPORT)
+#define ATOM_DEVICE_LCD_SUPPORT                           (ATOM_DEVICE_LCD1_SUPPORT | ATOM_DEVICE_LCD2_SUPPORT)
 
 #define ATOM_DEVICE_CONNECTOR_TYPE_MASK                   0x000000F0
 #define ATOM_DEVICE_CONNECTOR_TYPE_SHIFT                  0x00000004
@@ -2838,7 +2838,7 @@ typedef struct _ATOM_SPREAD_SPECTRUM_ASSIGNMENT
   UCHAR               ucSS_Step;
   UCHAR               ucSS_Delay;
   UCHAR               ucSS_Id;
-  UCHAR               ucRecommandedRef_Div;
+  UCHAR               ucRecommendedRef_Div;
   UCHAR               ucSS_Range;               //it was reserved for V11
 }ATOM_SPREAD_SPECTRUM_ASSIGNMENT;
 
@@ -2912,7 +2912,7 @@ typedef struct _ATOM_ANALOG_TV_INFO_V1_2
   UCHAR                    ucTV_BootUpDefaultStandard; 
   UCHAR                    ucExt_TV_ASIC_ID;
   UCHAR                    ucExt_TV_ASIC_SlaveAddr;
-  ATOM_DTD_FORMAT          aModeTimings[MAX_SUPPORTED_TV_TIMING];
+  ATOM_DTD_FORMAT          aModeTimings[MAX_SUPPORTED_TV_TIMING_V1_2];
 }ATOM_ANALOG_TV_INFO_V1_2;
 
 typedef struct _ATOM_DPCD_INFO
@@ -3780,7 +3780,7 @@ typedef struct _ATOM_ASIC_SS_ASSIGNMENT
 	UCHAR								ucReserved[2];
 }ATOM_ASIC_SS_ASSIGNMENT;
 
-//Define ucClockIndication, SW uses the IDs below to search if the SS is requried/enabled on a clock branch/signal type.
+//Define ucClockIndication, SW uses the IDs below to search if the SS is required/enabled on a clock branch/signal type.
 //SS is not required or enabled if a match is not found.
 #define ASIC_INTERNAL_MEMORY_SS			1
 #define ASIC_INTERNAL_ENGINE_SS			2
@@ -5742,6 +5742,9 @@ typedef struct _ATOM_PPLIB_THERMALCONTROLLER
 #define ATOM_PP_THERMALCONTROLLER_RV6xx     7
 #define ATOM_PP_THERMALCONTROLLER_RV770     8
 #define ATOM_PP_THERMALCONTROLLER_ADT7473   9
+#define ATOM_PP_THERMALCONTROLLER_EXTERNAL_GPIO     11
+#define ATOM_PP_THERMALCONTROLLER_EVERGREEN 12
+#define ATOM_PP_THERMALCONTROLLER_ADT7473_WITH_INTERNAL   0x89    // ADT7473 Fan Control + Internal Thermal Controller
 
 typedef struct _ATOM_PPLIB_STATE
 {
@@ -5749,6 +5752,26 @@ typedef struct _ATOM_PPLIB_STATE
     UCHAR ucClockStateIndices[1]; // variable-sized
 } ATOM_PPLIB_STATE;
 
+typedef struct _ATOM_PPLIB_FANTABLE
+{
+    UCHAR   ucFanTableFormat;                // Change this if the table format changes or version changes so that the other fields are not the same.
+    UCHAR   ucTHyst;                         // Temperature hysteresis. Integer.
+    USHORT  usTMin;                          // The temperature, in 0.01 centigrades, below which we just run at a minimal PWM.
+    USHORT  usTMed;                          // The middle temperature where we change slopes.
+    USHORT  usTHigh;                         // The high point above TMed for adjusting the second slope.
+    USHORT  usPWMMin;                        // The minimum PWM value in percent (0.01% increments).
+    USHORT  usPWMMed;                        // The PWM value (in percent) at TMed.
+    USHORT  usPWMHigh;                       // The PWM value at THigh.
+} ATOM_PPLIB_FANTABLE;
+
+typedef struct _ATOM_PPLIB_EXTENDEDHEADER
+{
+    USHORT  usSize;
+    ULONG   ulMaxEngineClock;   // For Overdrive.
+    ULONG   ulMaxMemoryClock;   // For Overdrive.
+    // Add extra system parameters here, always adjust size to include all fields.
+} ATOM_PPLIB_EXTENDEDHEADER;
+
 //// ATOM_PPLIB_POWERPLAYTABLE::ulPlatformCaps
 #define ATOM_PP_PLATFORM_CAP_BACKBIAS 1
 #define ATOM_PP_PLATFORM_CAP_POWERPLAY 2
@@ -5762,6 +5785,12 @@ typedef struct _ATOM_PPLIB_STATE
 #define ATOM_PP_PLATFORM_CAP_SIDEPORTCONTROL 512
 #define ATOM_PP_PLATFORM_CAP_TURNOFFPLL_ASPML1 1024
 #define ATOM_PP_PLATFORM_CAP_HTLINKCONTROL 2048
+#define ATOM_PP_PLATFORM_CAP_MVDDCONTROL 4096
+#define ATOM_PP_PLATFORM_CAP_GOTO_BOOT_ON_ALERT 0x2000              // Go to boot state on alerts, e.g. on an AC->DC transition.
+#define ATOM_PP_PLATFORM_CAP_DONT_WAIT_FOR_VBLANK_ON_ALERT 0x4000   // Do NOT wait for VBLANK during an alert (e.g. AC->DC transition).
+#define ATOM_PP_PLATFORM_CAP_VDDCI_CONTROL 0x8000                   // Does the driver control VDDCI independently from VDDC.
+#define ATOM_PP_PLATFORM_CAP_REGULATOR_HOT 0x00010000               // Enable the 'regulator hot' feature.
+#define ATOM_PP_PLATFORM_CAP_BACO          0x00020000               // Does the driver supports BACO state.
 
 typedef struct _ATOM_PPLIB_POWERPLAYTABLE
 {
@@ -5797,6 +5826,21 @@ typedef struct _ATOM_PPLIB_POWERPLAYTABLE
 
 } ATOM_PPLIB_POWERPLAYTABLE;
 
+typedef struct _ATOM_PPLIB_POWERPLAYTABLE2
+{
+    ATOM_PPLIB_POWERPLAYTABLE basicTable;
+    UCHAR   ucNumCustomThermalPolicy;
+    USHORT  usCustomThermalPolicyArrayOffset;
+}ATOM_PPLIB_POWERPLAYTABLE2, *LPATOM_PPLIB_POWERPLAYTABLE2;
+
+typedef struct _ATOM_PPLIB_POWERPLAYTABLE3
+{
+    ATOM_PPLIB_POWERPLAYTABLE2 basicTable2;
+    USHORT                     usFormatID;                      // To be used ONLY by PPGen.
+    USHORT                     usFanTableOffset;
+    USHORT                     usExtendendedHeaderOffset;
+} ATOM_PPLIB_POWERPLAYTABLE3, *LPATOM_PPLIB_POWERPLAYTABLE3;
+
 //// ATOM_PPLIB_NONCLOCK_INFO::usClassification
 #define ATOM_PPLIB_CLASSIFICATION_UI_MASK          0x0007
 #define ATOM_PPLIB_CLASSIFICATION_UI_SHIFT         0
@@ -5816,7 +5860,9 @@ typedef struct _ATOM_PPLIB_POWERPLAYTABLE
 #define ATOM_PPLIB_CLASSIFICATION_UVDSTATE               0x0400
 #define ATOM_PPLIB_CLASSIFICATION_3DLOW                  0x0800
 #define ATOM_PPLIB_CLASSIFICATION_ACPI                   0x1000
-// remaining 3 bits are reserved
+#define ATOM_PPLIB_CLASSIFICATION_HD2STATE               0x2000
+#define ATOM_PPLIB_CLASSIFICATION_HDSTATE                0x4000
+#define ATOM_PPLIB_CLASSIFICATION_SDSTATE                0x8000
 
 //// ATOM_PPLIB_NONCLOCK_INFO::ulCapsAndSettings
 #define ATOM_PPLIB_SINGLE_DISPLAY_ONLY           0x00000001
@@ -5840,9 +5886,15 @@ typedef struct _ATOM_PPLIB_POWERPLAYTABLE
 
 #define ATOM_PPLIB_SOFTWARE_DISABLE_LOADBALANCING        0x00001000
 #define ATOM_PPLIB_SOFTWARE_ENABLE_SLEEP_FOR_TIMESTAMPS  0x00002000
+#define ATOM_PPLIB_DISALLOW_ON_DC                        0x00004000
 #define ATOM_PPLIB_ENABLE_VARIBRIGHT                     0x00008000
 
-#define ATOM_PPLIB_DISALLOW_ON_DC                       0x00004000
+//memory related flags
+#define ATOM_PPLIB_SWSTATE_MEMORY_DLL_OFF               0x000010000
+
+//M3 Arb    //2bits, current 3 sets of parameters in total
+#define ATOM_PPLIB_M3ARB_MASK                       0x00060000
+#define ATOM_PPLIB_M3ARB_SHIFT                      17
 
 // Contained in an array starting at the offset
 // in ATOM_PPLIB_POWERPLAYTABLE::usNonClockInfoArrayOffset.
@@ -5860,6 +5912,9 @@ typedef struct _ATOM_PPLIB_NONCLOCK_INFO
 // Contained in an array starting at the offset
 // in ATOM_PPLIB_POWERPLAYTABLE::usClockInfoArrayOffset.
 // referenced from ATOM_PPLIB_STATE::ucClockStateIndices
+#define ATOM_PPLIB_NONCLOCKINFO_VER1      12
+#define ATOM_PPLIB_NONCLOCKINFO_VER2      24
+
 typedef struct _ATOM_PPLIB_R600_CLOCK_INFO
 {
       USHORT usEngineClockLow;
@@ -5882,6 +5937,23 @@ typedef struct _ATOM_PPLIB_R600_CLOCK_INFO
 #define ATOM_PPLIB_R600_FLAGS_BACKBIASENABLE    4
 #define ATOM_PPLIB_R600_FLAGS_MEMORY_ODT_OFF    8
 #define ATOM_PPLIB_R600_FLAGS_MEMORY_DLL_OFF    16
+#define ATOM_PPLIB_R600_FLAGS_LOWPOWER         32   // On the RV770 use 'low power' setting (sequencer S0).
+
+typedef struct _ATOM_PPLIB_EVERGREEN_CLOCK_INFO
+{
+      USHORT usEngineClockLow;
+      UCHAR  ucEngineClockHigh;
+
+      USHORT usMemoryClockLow;
+      UCHAR  ucMemoryClockHigh;
+
+      USHORT usVDDC;
+      USHORT usVDDCI;
+      USHORT usUnused;
+
+      ULONG ulFlags; // ATOM_PPLIB_R600_FLAGS_*
+
+} ATOM_PPLIB_EVERGREEN_CLOCK_INFO;
 
 typedef struct _ATOM_PPLIB_RS780_CLOCK_INFO
 
@@ -5895,7 +5967,7 @@ typedef struct _ATOM_PPLIB_RS780_CLOCK_INFO
       UCHAR  ucPadding;                   // For proper alignment and size.
       USHORT usVDDC;                      // For the 780, use: None, Low, High, Variable
       UCHAR  ucMaxHTLinkWidth;            // From SBIOS - {2, 4, 8, 16}
-      UCHAR  ucMinHTLinkWidth;            // From SBIOS - {2, 4, 8, 16}. Effective only if CDLW enabled. Minimum down stream width could be bigger as display BW requriement.
+      UCHAR  ucMinHTLinkWidth;            // From SBIOS - {2, 4, 8, 16}. Effective only if CDLW enabled. Minimum down stream width could be bigger as display BW requirement.
       USHORT usHTLinkFreq;                // See definition ATOM_PPLIB_RS780_HTLINKFREQ_xxx or in MHz(>=200).
       ULONG  ulFlags; 
 } ATOM_PPLIB_RS780_CLOCK_INFO;
diff --git a/src/Makefile.am b/src/Makefile.am
index 0ce46b0..033047e 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -48,36 +48,18 @@ RADEON_ATOMBIOS_SOURCES = \
         AtomBios/includes/ObjectID.h \
         AtomBios/includes/regsdef.h
 
-XMODE_SRCS=\
-        local_xf86Rename.h \
-	parser/xf86Parser.h \
-        parser/xf86Optrec.h \
-        modes/xf86Modes.h \
-        modes/xf86Modes.c \
-        modes/xf86cvt.c \
-        modes/xf86Crtc.h \
-        modes/xf86Crtc.c \
-        modes/xf86Cursors.c \
-        modes/xf86EdidModes.c \
-        modes/xf86RandR12.c \
-        modes/xf86RandR12.h \
-        modes/xf86Rename.h \
-        modes/xf86Rotate.c \
-        modes/xf86DiDGA.c
-
 if XF86DRM_MODE
 RADEON_KMS_SRCS=radeon_dri2.c radeon_kms.c drmmode_display.c radeon_vbo.c
 endif
 
 if USE_EXA
-RADEON_EXA_SOURCES = radeon_exa.c r600_exa.c r6xx_accel.c r600_textured_videofuncs.c r600_shader.c
+RADEON_EXA_SOURCES = radeon_exa.c r600_exa.c r6xx_accel.c r600_textured_videofuncs.c r600_shader.c radeon_exa_shared.c
 endif
 
 AM_CFLAGS = \
             @LIBDRM_RADEON_CFLAGS@ \
             @XORG_CFLAGS@ \
             @DRI_CFLAGS@ \
-            @XMODES_CFLAGS@ \
             @LIBUDEV_CFLAGS@ \
             -DDISABLE_EASF \
             -DENABLE_ALL_SERVICE_FUNCTIONS \
@@ -116,11 +98,6 @@ radeon_drv_la_SOURCES = \
 	$(RADEON_DRI_SRCS) $(RADEON_EXA_SOURCES) atombios_output.c atombios_crtc.c \
 	$(RADEON_KMS_SRCS)
 
-if XMODES
-radeon_drv_la_SOURCES += \
-	$(XMODE_SRCS)
-endif
-
 theatre_detect_drv_la_LTLIBRARIES = theatre_detect_drv.la
 theatre_detect_drv_la_LDFLAGS = -module -avoid-version
 theatre_detect_drv_ladir = @moduledir@/multimedia
@@ -143,7 +120,6 @@ theatre200_drv_la_SOURCES = \
 	theatre200.c theatre200_module.c
 
 EXTRA_DIST = \
-	$(XMODE_SRCS) \
 	radeon_render.c \
 	radeon_accelfuncs.c \
 	radeon_textured_videofuncs.c \
@@ -163,6 +139,7 @@ EXTRA_DIST = \
 	radeon_dummy_bufmgr.h \
 	radeon_exa_render.c \
 	radeon_exa_funcs.c \
+	radeon_exa_shared.h \
 	radeon.h \
 	radeon_macros.h \
 	radeon_probe.h \
diff --git a/src/ati_pciids_gen.h b/src/ati_pciids_gen.h
index b4479ac..4784d88 100644
--- a/src/ati_pciids_gen.h
+++ b/src/ati_pciids_gen.h
@@ -462,6 +462,8 @@
 #define PCI_CHIP_CYPRESS_6888 0x6888
 #define PCI_CHIP_CYPRESS_6889 0x6889
 #define PCI_CHIP_CYPRESS_688A 0x688A
+#define PCI_CHIP_CYPRESS_688C 0x688C
+#define PCI_CHIP_CYPRESS_688D 0x688D
 #define PCI_CHIP_CYPRESS_6898 0x6898
 #define PCI_CHIP_CYPRESS_6899 0x6899
 #define PCI_CHIP_CYPRESS_689E 0x689E
@@ -491,6 +493,7 @@
 #define PCI_CHIP_CEDAR_68E8 0x68E8
 #define PCI_CHIP_CEDAR_68E9 0x68E9
 #define PCI_CHIP_CEDAR_68F1 0x68F1
+#define PCI_CHIP_CEDAR_68F2 0x68F2
 #define PCI_CHIP_CEDAR_68F8 0x68F8
 #define PCI_CHIP_CEDAR_68F9 0x68F9
 #define PCI_CHIP_CEDAR_68FE 0x68FE
diff --git a/src/atombios_crtc.c b/src/atombios_crtc.c
index 6f083b4..d0ffa07 100644
--- a/src/atombios_crtc.c
+++ b/src/atombios_crtc.c
@@ -347,6 +347,164 @@ atombios_pick_pll(xf86CrtcPtr crtc)
     }
 }
 
+union adjust_pixel_clock {
+	ADJUST_DISPLAY_PLL_PS_ALLOCATION v1;
+	ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 v3;
+};
+
+static uint32_t atombios_adjust_pll(xf86CrtcPtr crtc, DisplayModePtr mode, int *pll_flags_p)
+{
+    RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
+    ScrnInfoPtr pScrn = crtc->scrn;
+    RADEONInfoPtr  info = RADEONPTR(pScrn);
+    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
+    uint32_t adjusted_clock = mode->Clock;
+    RADEONOutputPrivatePtr radeon_output = NULL;
+    radeon_encoder_ptr radeon_encoder = NULL;
+    xf86OutputPtr output;
+    int pll_flags = 0;
+    int i;
+
+    if (IS_AVIVO_VARIANT) {
+	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE))
+	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
+	else
+	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+    } else {
+	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
+	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
+	else
+	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+    }
+
+    if (IS_AVIVO_VARIANT) {
+	if ((info->ChipFamily == CHIP_FAMILY_RS600) ||
+	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
+	    (info->ChipFamily == CHIP_FAMILY_RS740))
+	    pll_flags |= /*RADEON_PLL_USE_FRAC_FB_DIV |*/
+		RADEON_PLL_PREFER_CLOSEST_LOWER;
+	if (IS_DCE32_VARIANT && mode->Clock > 200000) /* range limits??? */
+	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
+	else
+	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
+    } else {
+	pll_flags |= RADEON_PLL_LEGACY;
+
+	if (mode->Clock > 200000) /* range limits??? */
+	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
+	else
+	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
+    }
+    
+    for (i = 0; i < xf86_config->num_output; i++) {
+	output = xf86_config->output[i];
+	if (output->crtc == crtc) {
+	    radeon_output = output->driver_private;
+	    radeon_encoder = radeon_get_encoder(output);
+	    if (IS_AVIVO_VARIANT) {
+		/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
+		if (radeon_encoder &&
+		    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1) &&
+		    !IS_DCE3_VARIANT)
+		    adjusted_clock *= 2;
+		if (radeon_output->active_device &
+		    (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT)) {
+		    pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;
+		    radeon_crtc->pll_algo = RADEON_PLL_OLD;
+		}
+	    } else {
+		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT |
+						    ATOM_DEVICE_DFP_SUPPORT))
+		    pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;
+		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT))
+		    pll_flags |= (RADEON_PLL_USE_BIOS_DIVS | RADEON_PLL_USE_REF_DIV);
+	    }
+    	    if (IS_DCE3_VARIANT)
+		break;
+	}
+    }
+    
+    if (IS_DCE3_VARIANT) {
+	union adjust_pixel_clock args;
+	int major, minor, index;
+	AtomBiosArgRec data;
+	unsigned char *space;
+
+	memset(&args, 0, sizeof(args));
+
+	index = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);
+
+	atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
+
+	data.exec.index = index;
+	data.exec.dataSpace = (void *)&space;
+	data.exec.pspace = &args;
+
+	switch(major) {
+	case 1:
+	    switch(minor) {
+	    case 1:
+	    case 2:
+		args.v1.usPixelClock = cpu_to_le16(adjusted_clock / 10);
+		args.v1.ucTransmitterID = radeon_encoder->encoder_id;
+		args.v1.ucEncodeMode = atombios_get_encoder_mode(output);
+
+		ErrorF("before %d\n", args.v1.usPixelClock);
+		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
+		    adjusted_clock = le16_to_cpu(args.v1.usPixelClock) * 10;
+		}
+		ErrorF("after %d\n", args.v1.usPixelClock);
+		break;
+	    case 3:
+		args.v3.sInput.usPixelClock = cpu_to_le16(adjusted_clock / 10);
+		args.v3.sInput.ucTransmitterID = radeon_encoder->encoder_id;
+		args.v3.sInput.ucEncodeMode = atombios_get_encoder_mode(output);
+		args.v3.sInput.ucDispPllConfig = 0;
+		if (radeon_output->coherent_mode || (args.v3.sInput.ucEncodeMode == ATOM_ENCODER_MODE_DP))
+		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_COHERENT_MODE;
+		if (adjusted_clock > 165000)
+		    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_DUAL_LINK;
+		// if SS
+		//    args.v3.sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;
+
+		ErrorF("before %d 0x%x\n", args.v3.sInput.usPixelClock, args.v3.sInput.ucDispPllConfig);
+		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
+		    adjusted_clock = args.v3.sOutput.ulDispPllFreq * 10;
+		    if (args.v3.sOutput.ucRefDiv) {
+			pll_flags |= RADEON_PLL_USE_REF_DIV;
+			info->pll.reference_div = args.v3.sOutput.ucRefDiv;
+		    }
+		    if (args.v3.sOutput.ucPostDiv) {
+			pll_flags |= RADEON_PLL_USE_POST_DIV;
+			info->pll.post_div = args.v3.sOutput.ucPostDiv;
+		    }
+		    ErrorF("after %d %d %d\n", args.v3.sOutput.ulDispPllFreq,
+			   args.v3.sOutput.ucRefDiv, args.v3.sOutput.ucPostDiv);
+		}
+		break;
+	    default:
+		ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
+		goto out;
+	    }
+	    break;
+	default:
+	    ErrorF("%s: Unknown table version %d %d\n", __func__, major, minor);
+	    goto out;
+	}
+    }
+out:
+    *pll_flags_p = pll_flags;
+    return adjusted_clock;
+}
+				    
+union set_pixel_clock {
+	SET_PIXEL_CLOCK_PS_ALLOCATION base;
+	PIXEL_CLOCK_PARAMETERS v1;
+	PIXEL_CLOCK_PARAMETERS_V2 v2;
+	PIXEL_CLOCK_PARAMETERS_V3 v3;
+	PIXEL_CLOCK_PARAMETERS_V5 v5;
+};
+
 static void
 atombios_crtc_set_dcpll(xf86CrtcPtr crtc)
 {
@@ -357,7 +515,7 @@ atombios_crtc_set_dcpll(xf86CrtcPtr crtc)
     radeon_encoder_ptr radeon_encoder = NULL;
     int index;
     int major, minor, i;
-    PIXEL_CLOCK_PARAMETERS_V5 args;
+    union set_pixel_clock args;
     AtomBiosArgRec data;
     unsigned char *space;
 
@@ -390,25 +548,10 @@ atombios_crtc_set_dcpll(xf86CrtcPtr crtc)
     case 1:
 	switch(minor) {
 	case 5:
-	    args.ucCRTC = ATOM_CRTC_INVALID;
+	    args.v5.ucCRTC = ATOM_CRTC_INVALID;
 	    /* XXX: get this from the firmwareinfo table */
-	    args.usPixelClock = 60000; // 600 Mhz
-	    args.ucPostDiv = info->pll.pll_out_max / 60000;
-	    if (info->pll.reference_freq == 10000) {
-		// 100 Mhz ref clock
-		args.ucRefDiv = 7;
-		args.usFbDiv = cpu_to_le16(84);
-		args.ulFbDivDecFrac = cpu_to_le32(0);
-	    } else {
-		// 27 Mhz ref clock
-		args.ucRefDiv = 2;
-		args.usFbDiv = cpu_to_le16(88);
-		args.ulFbDivDecFrac = cpu_to_le32(888889);
-	    }
-	    args.ucPpll = ATOM_DCPLL;
-	    args.ucMiscInfo = 0; //HDMI depth
-	    args.ucTransmitterID = radeon_encoder->encoder_id;
-	    args.ucEncoderMode = atombios_get_encoder_mode(output);
+	    args.v5.usPixelClock = info->default_dispclk;
+	    args.v5.ucPpll = ATOM_DCPLL;
 	    break;
 	default:
 	    ErrorF("Unknown table version\n");
@@ -439,200 +582,66 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
     RADEONCrtcPrivatePtr radeon_crtc = crtc->driver_private;
     ScrnInfoPtr pScrn = crtc->scrn;
     RADEONInfoPtr  info = RADEONPTR(pScrn);
-    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
     unsigned char *RADEONMMIO = info->MMIO;
     int index;
-    uint32_t sclock = mode->Clock;
+    uint32_t sclock;
     uint32_t ref_div = 0, fb_div = 0, frac_fb_div = 0, post_div = 0;
-    int major, minor, i;
-    SET_PIXEL_CLOCK_PS_ALLOCATION spc_param;
-    PIXEL_CLOCK_PARAMETERS_V2 *spc2_ptr;
-    PIXEL_CLOCK_PARAMETERS_V3 *spc3_ptr;
-    PIXEL_CLOCK_PARAMETERS_V5 *spc5_ptr;
+    int major, minor;
+    union set_pixel_clock args;
     xf86OutputPtr output = NULL;
-    RADEONOutputPrivatePtr radeon_output = NULL;
+    xf86CrtcConfigPtr   xf86_config = XF86_CRTC_CONFIG_PTR(crtc->scrn);
     radeon_encoder_ptr radeon_encoder = NULL;
     int pll_flags = 0;
     uint32_t temp;
     AtomBiosArgRec data;
     unsigned char *space;
+    int i;
 
-    memset(&spc_param, 0, sizeof(spc_param));
-
-    if (IS_AVIVO_VARIANT) {
-	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, TRUE))
-	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
-	else
-	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
-    } else {
-	if (xf86ReturnOptValBool(info->Options, OPTION_NEW_PLL, FALSE))
-	    radeon_crtc->pll_algo = RADEON_PLL_NEW;
-	else
-	    radeon_crtc->pll_algo = RADEON_PLL_OLD;
-    }
-
-    if (IS_AVIVO_VARIANT) {
-	if ((info->ChipFamily == CHIP_FAMILY_RS600) ||
-	    (info->ChipFamily == CHIP_FAMILY_RS690) ||
-	    (info->ChipFamily == CHIP_FAMILY_RS740))
-	    pll_flags |= RADEON_PLL_USE_FRAC_FB_DIV | RADEON_PLL_PREFER_CLOSEST_LOWER;
-	if (IS_DCE3_VARIANT && mode->Clock > 200000) /* range limits??? */
-	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
-	else
-	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
-
-	for (i = 0; i < xf86_config->num_output; i++) {
-	    xf86OutputPtr output = xf86_config->output[i];
-	    if (output->crtc == crtc) {
-		radeon_output = output->driver_private;
-		radeon_encoder = radeon_get_encoder(output);
-		/* DVO wants 2x pixel clock if the DVO chip is in 12 bit mode */
-		/* AdjustDisplayPll handles this on DCE3.x */
-		if (radeon_encoder &&
-		    (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1) &&
-		    !IS_DCE3_VARIANT)
-		    sclock *= 2;
-		if (radeon_output->active_device &
-		    (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT)) {
-		    pll_flags |= RADEON_PLL_PREFER_CLOSEST_LOWER;
-		    radeon_crtc->pll_algo = RADEON_PLL_OLD;
-		}
-	    }
-	}
+    memset(&args, 0, sizeof(args));
 
-	/* disable spread spectrum clocking for now -- thanks Hedy Lamarr */
-	if (IS_DCE4_VARIANT) {
-	    /* XXX 6 crtcs, but only 2 plls */
-	    switch (radeon_crtc->pll_id) {
-	    case ATOM_PPLL1:
-		temp = INREG(EVERGREEN_P1PLL_SS_CNTL);
-		OUTREG(EVERGREEN_P1PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
-		break;
-	    case ATOM_PPLL2:
-		temp = INREG(EVERGREEN_P2PLL_SS_CNTL);
-		OUTREG(EVERGREEN_P2PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
-		break;
-	    }
-	} else {
-	    if (radeon_crtc->crtc_id == 0) {
-		temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
-		OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
-	    } else {
-		temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
-		OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
-	    }
+    if (IS_DCE4_VARIANT) {
+	/* XXX 6 crtcs, but only 2 plls */
+	switch (radeon_crtc->pll_id) {
+	case ATOM_PPLL1:
+	    temp = INREG(EVERGREEN_P1PLL_SS_CNTL);
+	    OUTREG(EVERGREEN_P1PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
+	    break;
+	case ATOM_PPLL2:
+	    temp = INREG(EVERGREEN_P2PLL_SS_CNTL);
+	    OUTREG(EVERGREEN_P2PLL_SS_CNTL, temp & ~EVERGREEN_PxPLL_SS_EN);
+	    break;
 	}
     } else {
-	pll_flags |= RADEON_PLL_LEGACY;
-
-	for (i = 0; i < xf86_config->num_output; i++) {
-	    xf86OutputPtr output = xf86_config->output[i];
-	    RADEONOutputPrivatePtr radeon_output = output->driver_private;
-
-	    if (output->crtc == crtc) {
-		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT |
-						    ATOM_DEVICE_DFP_SUPPORT))
-		    pll_flags |= RADEON_PLL_NO_ODD_POST_DIV;
-		if (radeon_output->active_device & (ATOM_DEVICE_LCD_SUPPORT))
-		    pll_flags |= (RADEON_PLL_USE_BIOS_DIVS | RADEON_PLL_USE_REF_DIV);
-	    }
+	if (radeon_crtc->crtc_id == 0) {
+	    temp = INREG(AVIVO_P1PLL_INT_SS_CNTL);
+	    OUTREG(AVIVO_P1PLL_INT_SS_CNTL, temp & ~1);
+	} else {
+	    temp = INREG(AVIVO_P2PLL_INT_SS_CNTL);
+	    OUTREG(AVIVO_P2PLL_INT_SS_CNTL, temp & ~1);
 	}
-
-	if (mode->Clock > 200000) /* range limits??? */
-	    pll_flags |= RADEON_PLL_PREFER_HIGH_FB_DIV;
-	else
-	    pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
     }
 
     if (IS_DCE3_VARIANT) {
-	ADJUST_DISPLAY_PLL_PS_ALLOCATION adjust_pll_param;
-	ADJUST_DISPLAY_PLL_PS_ALLOCATION *adp_ptr;
-	ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3 *adp3_ptr;
-
-	/* Can't really do cloning easily on DCE3 cards */
 	for (i = 0; i < xf86_config->num_output; i++) {
 	    output = xf86_config->output[i];
 	    if (output->crtc == crtc) {
-		radeon_output = output->driver_private;
 		radeon_encoder = radeon_get_encoder(output);
 		break;
 	    }
 	}
 
-	if (radeon_output == NULL) {
+	if (output->driver_private == NULL) {
 	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No output assigned to crtc!\n");
 	    return;
 	}
-
 	if (radeon_encoder == NULL) {
 	    xf86DrvMsg(crtc->scrn->scrnIndex, X_ERROR, "No encoder assigned to output!\n");
 	    return;
 	}
-
-	memset(&adjust_pll_param, 0, sizeof(adjust_pll_param));
-
-	index = GetIndexIntoMasterTable(COMMAND, AdjustDisplayPll);
-	atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
-
-	data.exec.index = index;
-	data.exec.dataSpace = (void *)&space;
-	data.exec.pspace = &adjust_pll_param;
-
-	switch(major) {
-	case 1:
-	    switch(minor) {
-	    case 1:
-	    case 2:
-		adp_ptr = (ADJUST_DISPLAY_PLL_PS_ALLOCATION*)&adjust_pll_param.usPixelClock;
-		adp_ptr->usPixelClock = cpu_to_le16(sclock / 10);
-		adp_ptr->ucTransmitterID = radeon_encoder->encoder_id;
-		adp_ptr->ucEncodeMode = atombios_get_encoder_mode(output);
-
-		ErrorF("before %d\n", adp_ptr->usPixelClock);
-		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
-		    sclock = le16_to_cpu(adp_ptr->usPixelClock) * 10;
-		}
-		ErrorF("after %d\n", adp_ptr->usPixelClock);
-		break;
-	    case 3:
-		adp3_ptr = (ADJUST_DISPLAY_PLL_PS_ALLOCATION_V3*)&adjust_pll_param.usPixelClock;
-		adp3_ptr->sInput.usPixelClock = cpu_to_le16(sclock / 10);
-		adp3_ptr->sInput.ucTransmitterID = radeon_encoder->encoder_id;
-		adp3_ptr->sInput.ucEncodeMode = atombios_get_encoder_mode(output);
-		adp3_ptr->sInput.ucDispPllConfig = 0;
-		if (radeon_output->coherent_mode || (adp3_ptr->sInput.ucEncodeMode == ATOM_ENCODER_MODE_DP))
-		    adp3_ptr->sInput.ucDispPllConfig |= DISPPLL_CONFIG_COHERENT_MODE;
-		if (sclock > 165000)
-		    adp3_ptr->sInput.ucDispPllConfig |= DISPPLL_CONFIG_DUAL_LINK;
-		// if SS
-		//    adp3_ptr->sInput.ucDispPllConfig |= DISPPLL_CONFIG_SS_ENABLE;
-
-		ErrorF("before %d 0x%x\n", adp3_ptr->sInput.usPixelClock, adp3_ptr->sInput.ucDispPllConfig);
-		if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
-		    sclock = adp3_ptr->sOutput.ulDispPllFreq * 10;
-		    if (adp3_ptr->sOutput.ucRefDiv) {
-			pll_flags |= RADEON_PLL_USE_REF_DIV;
-			info->pll.reference_div = adp3_ptr->sOutput.ucRefDiv;
-		    }
-		    if (adp3_ptr->sOutput.ucPostDiv) {
-			pll_flags |= RADEON_PLL_USE_POST_DIV;
-			info->pll.post_div = adp3_ptr->sOutput.ucPostDiv;
-		    }
-		    ErrorF("after %d %d %d\n", adp3_ptr->sOutput.ulDispPllFreq,
-			   adp3_ptr->sOutput.ucRefDiv, adp3_ptr->sOutput.ucPostDiv);
-		}
-		break;
-	    default:
-		ErrorF("Unknown table version\n");
-		exit(-1);
-	    }
-	    break;
-	default:
-	    ErrorF("Unknown table version\n");
-	    exit(-1);
-	}
     }
 
+    sclock = atombios_adjust_pll(crtc, mode, &pll_flags);
+
     RADEONComputePLL(crtc, &info->pll, sclock, &temp,
 		     &fb_div, &frac_fb_div, &ref_div, &post_div, pll_flags);
     sclock = temp; /* 10 khz */
@@ -654,40 +663,37 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
 	switch(minor) {
 	case 1:
 	case 2:
-	    spc2_ptr = (PIXEL_CLOCK_PARAMETERS_V2*)&spc_param.sPCLKInput;
-	    spc2_ptr->usPixelClock = cpu_to_le16(mode->Clock / 10);
-	    spc2_ptr->usRefDiv = cpu_to_le16(ref_div);
-	    spc2_ptr->usFbDiv = cpu_to_le16(fb_div);
-	    spc2_ptr->ucFracFbDiv = frac_fb_div;
-	    spc2_ptr->ucPostDiv = post_div;
-	    spc2_ptr->ucPpll = radeon_crtc->pll_id;
-	    spc2_ptr->ucCRTC = radeon_crtc->crtc_id;
-	    spc2_ptr->ucRefDivSrc = 1;
+	    args.v2.usPixelClock = cpu_to_le16(mode->Clock / 10);
+	    args.v2.usRefDiv = cpu_to_le16(ref_div);
+	    args.v2.usFbDiv = cpu_to_le16(fb_div);
+	    args.v2.ucFracFbDiv = frac_fb_div;
+	    args.v2.ucPostDiv = post_div;
+	    args.v2.ucPpll = radeon_crtc->pll_id;
+	    args.v2.ucCRTC = radeon_crtc->crtc_id;
+	    args.v2.ucRefDivSrc = 1;
 	    break;
 	case 3:
-	    spc3_ptr = (PIXEL_CLOCK_PARAMETERS_V3*)&spc_param.sPCLKInput;
-	    spc3_ptr->usPixelClock = cpu_to_le16(mode->Clock / 10);
-	    spc3_ptr->usRefDiv = cpu_to_le16(ref_div);
-	    spc3_ptr->usFbDiv = cpu_to_le16(fb_div);
-	    spc3_ptr->ucFracFbDiv = frac_fb_div;
-	    spc3_ptr->ucPostDiv = post_div;
-	    spc3_ptr->ucPpll = radeon_crtc->pll_id;
-	    spc3_ptr->ucMiscInfo = (radeon_crtc->crtc_id << 2);
-	    spc3_ptr->ucTransmitterId = radeon_encoder->encoder_id;
-	    spc3_ptr->ucEncoderMode = atombios_get_encoder_mode(output);
+	    args.v3.usPixelClock = cpu_to_le16(mode->Clock / 10);
+	    args.v3.usRefDiv = cpu_to_le16(ref_div);
+	    args.v3.usFbDiv = cpu_to_le16(fb_div);
+	    args.v3.ucFracFbDiv = frac_fb_div;
+	    args.v3.ucPostDiv = post_div;
+	    args.v3.ucPpll = radeon_crtc->pll_id;
+	    args.v3.ucMiscInfo = (radeon_crtc->crtc_id << 2);
+	    args.v3.ucTransmitterId = radeon_encoder->encoder_id;
+	    args.v3.ucEncoderMode = atombios_get_encoder_mode(output);
 	    break;
 	case 5:
-	    spc5_ptr = (PIXEL_CLOCK_PARAMETERS_V5*)&spc_param.sPCLKInput;
-	    spc5_ptr->ucCRTC = radeon_crtc->crtc_id;
-	    spc5_ptr->usPixelClock = cpu_to_le16(mode->Clock / 10);
-	    spc5_ptr->ucRefDiv = ref_div;
-	    spc5_ptr->usFbDiv = cpu_to_le16(fb_div);
-	    spc5_ptr->ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);
-	    spc5_ptr->ucPostDiv = post_div;
-	    spc5_ptr->ucPpll = radeon_crtc->pll_id;
-	    spc5_ptr->ucMiscInfo = 0; //HDMI depth
-	    spc5_ptr->ucTransmitterID = radeon_encoder->encoder_id;
-	    spc5_ptr->ucEncoderMode = atombios_get_encoder_mode(output);
+	    args.v5.ucCRTC = radeon_crtc->crtc_id;
+	    args.v5.usPixelClock = cpu_to_le16(mode->Clock / 10);
+	    args.v5.ucRefDiv = ref_div;
+	    args.v5.usFbDiv = cpu_to_le16(fb_div);
+	    args.v5.ulFbDivDecFrac = cpu_to_le32(frac_fb_div * 100000);
+	    args.v5.ucPostDiv = post_div;
+	    args.v5.ucPpll = radeon_crtc->pll_id;
+	    args.v5.ucMiscInfo = 0; //HDMI depth
+	    args.v5.ucTransmitterID = radeon_encoder->encoder_id;
+	    args.v5.ucEncoderMode = atombios_get_encoder_mode(output);
 	    break;
 	default:
 	    ErrorF("Unknown table version\n");
@@ -701,7 +707,7 @@ atombios_crtc_set_pll(xf86CrtcPtr crtc, DisplayModePtr mode)
 
     data.exec.index = index;
     data.exec.dataSpace = (void *)&space;
-    data.exec.pspace = &spc_param;
+    data.exec.pspace = &args;
 
     if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
 	ErrorF("Set CRTC %d PLL success\n", radeon_crtc->crtc_id);
diff --git a/src/atombios_output.c b/src/atombios_output.c
index 3e2d301..da76683 100644
--- a/src/atombios_output.c
+++ b/src/atombios_output.c
@@ -67,8 +67,6 @@ const char *device_name[12] = {
 
 static void do_displayport_link_train(xf86OutputPtr output);
 
-static void atombios_set_output_crtc_source(xf86OutputPtr output);
-
 static int
 atombios_output_dac_setup(xf86OutputPtr output, int action)
 {
@@ -559,19 +557,40 @@ dp_link_clock_for_mode_clock(RADEONOutputPrivatePtr radeon_output,
  * - 2 DIG encoder blocks.
  * DIG1/2 can drive UNIPHY0/1/2 link A or link B
  *
+ * DCE 4.0
+ * - 3 DIG transmitter blocks UNPHY0/1/2 (links A and B).
+ * Supports up to 6 digital outputs
+ * - 6 DIG encoder blocks.
+ * - DIG to PHY mapping is hardcoded
+ * DIG1 drives UNIPHY0 link A, A+B
+ * DIG2 drives UNIPHY0 link B
+ * DIG3 drives UNIPHY1 link A, A+B
+ * DIG4 drives UNIPHY1 link B
+ * DIG5 drives UNIPHY2 link A, A+B
+ * DIG6 drives UNIPHY2 link B
+ *
  * Routing
  * crtc -> dig encoder -> UNIPHY/LVTMA (1 or 2 links)
  * Examples:
  * crtc0 -> dig2 -> LVTMA links A+B
  * crtc1 -> dig1 -> UNIPHY0 link B
+ * crtc0 -> dig1 -> UNIPHY2 link  A   -> LVDS
+ * crtc1 -> dig2 -> UNIPHY1 link  B+A -> TMDS/HDMI
  */
+
+union dig_encoder_control {
+	DIG_ENCODER_CONTROL_PS_ALLOCATION v1;
+	DIG_ENCODER_CONTROL_PARAMETERS_V2 v2;
+	DIG_ENCODER_CONTROL_PARAMETERS_V3 v3;
+};
+
 static int
 atombios_output_dig_encoder_setup(xf86OutputPtr output, int action)
 {
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
     RADEONInfoPtr info       = RADEONPTR(output->scrn);
     radeon_encoder_ptr radeon_encoder = radeon_get_encoder(output);
-    DIG_ENCODER_CONTROL_PS_ALLOCATION disp_data;
+    union dig_encoder_control disp_data;
     AtomBiosArgRec data;
     unsigned char *space;
     int index = 0, major, minor;
@@ -582,55 +601,49 @@ atombios_output_dig_encoder_setup(xf86OutputPtr output, int action)
 
     memset(&disp_data,0, sizeof(disp_data));
 
-    if (radeon_output->dig_encoder)
+    if (IS_DCE4_VARIANT)
+	index = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);
+    else if (radeon_output->dig_encoder)
         index = GetIndexIntoMasterTable(COMMAND, DIG2EncoderControl);
     else
         index = GetIndexIntoMasterTable(COMMAND, DIG1EncoderControl);
 
     atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
 
-    disp_data.ucAction = action;
-    disp_data.usPixelClock = cpu_to_le16(clock / 10);
+    disp_data.v1.ucAction = action;
+    disp_data.v1.usPixelClock = cpu_to_le16(clock / 10);
+    disp_data.v1.ucEncoderMode = atombios_get_encoder_mode(output);
 
-    if (IS_DCE32_VARIANT) {
+    if (disp_data.v1.ucEncoderMode == ATOM_ENCODER_MODE_DP) {
+	if (dp_link_clock_for_mode_clock(radeon_output, clock) == 27000)
+	    disp_data.v1.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;
+	disp_data.v1.ucLaneNum = dp_lanes_for_mode_clock(radeon_output, clock);
+    } else if (clock > 165000)
+	disp_data.v1.ucLaneNum = 8;
+    else
+	disp_data.v1.ucLaneNum = 4;
+
+    if (IS_DCE4_VARIANT) {
+	disp_data.v3.acConfig.ucDigSel = radeon_output->dig_encoder;
+	disp_data.v3.ucBitPerColor = PANEL_8BIT_PER_COLOR;
+    } else {
 	switch (radeon_encoder->encoder_id) {
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
-	    disp_data.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;
+	    disp_data.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER1;
 	    break;
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
-	    disp_data.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER2;
+	    disp_data.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER2;
 	    break;
 	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
-	    disp_data.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER3;
-	    break;
-	}
-    } else {
-	switch (radeon_encoder->encoder_id) {
-	case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
-	    disp_data.ucConfig = ATOM_ENCODER_CONFIG_UNIPHY;
-	    break;
-	case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
-	    disp_data.ucConfig = ATOM_ENCODER_CONFIG_LVTMA;
+	    disp_data.v1.ucConfig = ATOM_ENCODER_CONFIG_V2_TRANSMITTER3;
 	    break;
 	}
+	if (radeon_output->linkb)
+	    disp_data.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;
+	else
+	    disp_data.v1.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;
     }
 
-    disp_data.ucEncoderMode = atombios_get_encoder_mode(output);
-
-    if (disp_data.ucEncoderMode == ATOM_ENCODER_MODE_DP) {
-	if (dp_link_clock_for_mode_clock(radeon_output, clock) == 27000)
-	    disp_data.ucConfig |= ATOM_ENCODER_CONFIG_DPLINKRATE_2_70GHZ;
-	disp_data.ucLaneNum = dp_lanes_for_mode_clock(radeon_output, clock);
-    } else if (clock > 165000)
-	disp_data.ucLaneNum = 8;
-    else
-	disp_data.ucLaneNum = 4;
-
-    if (radeon_output->linkb)
-	disp_data.ucConfig |= ATOM_ENCODER_CONFIG_LINKB;
-    else
-	disp_data.ucConfig |= ATOM_ENCODER_CONFIG_LINKA;
-
     data.exec.index = index;
     data.exec.dataSpace = (void *)&space;
     data.exec.pspace = &disp_data;
@@ -645,54 +658,6 @@ atombios_output_dig_encoder_setup(xf86OutputPtr output, int action)
 
 }
 
-static int
-atombios_dce4_output_dig_encoder_setup(xf86OutputPtr output, int action)
-{
-    RADEONOutputPrivatePtr radeon_output = output->driver_private;
-    RADEONInfoPtr info       = RADEONPTR(output->scrn);
-    radeon_encoder_ptr radeon_encoder = radeon_get_encoder(output);
-    DIG_ENCODER_CONTROL_PARAMETERS_V3 disp_data;
-    AtomBiosArgRec data;
-    unsigned char *space;
-    int index;
-    int clock = radeon_output->pixel_clock;
-
-    if (radeon_encoder == NULL)
-	return ATOM_NOT_IMPLEMENTED;
-
-    memset(&disp_data,0, sizeof(disp_data));
-
-    index = GetIndexIntoMasterTable(COMMAND, DIGxEncoderControl);
-
-    disp_data.ucAction = action;
-    disp_data.usPixelClock = cpu_to_le16(clock / 10);
-    disp_data.ucEncoderMode = atombios_get_encoder_mode(output);
-    disp_data.acConfig.ucDigSel = radeon_output->dig_encoder;
-
-    if (disp_data.ucEncoderMode == ATOM_ENCODER_MODE_DP) {
-	if (dp_link_clock_for_mode_clock(radeon_output, clock) == 27000)
-	    disp_data.acConfig.ucDPLinkRate = 1;
-	disp_data.ucLaneNum = dp_lanes_for_mode_clock(radeon_output, clock);
-    } else if (clock > 165000)
-	disp_data.ucLaneNum = 8;
-    else
-	disp_data.ucLaneNum = 4;
-
-    disp_data.ucBitPerColor = PANEL_8BIT_PER_COLOR;
-
-    data.exec.index = index;
-    data.exec.dataSpace = (void *)&space;
-    data.exec.pspace = &disp_data;
-
-    if (RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data) == ATOM_SUCCESS) {
-	ErrorF("Output DIG%d encoder setup success\n", radeon_output->dig_encoder);
-	return ATOM_SUCCESS;
-    }
-
-    ErrorF("Output DIG%d setup failed\n", radeon_output->dig_encoder);
-    return ATOM_NOT_IMPLEMENTED;
-}
-
 union dig_transmitter_control {
     DIG_TRANSMITTER_CONTROL_PS_ALLOCATION v1;
     DIG_TRANSMITTER_CONTROL_PARAMETERS_V2 v2;
@@ -733,25 +698,22 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
     atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
 
     disp_data.v1.ucAction = action;
+    if (action == ATOM_TRANSMITTER_ACTION_INIT) {
+        disp_data.v1.usInitInfo = radeon_output->connector_object_id;
+    } else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {
+	disp_data.v1.asMode.ucLaneSel = lane_num;
+	disp_data.v1.asMode.ucLaneSet = lane_set;
+    } else {
+	if (radeon_output->MonType == MT_DP) 
+	    disp_data.v1.usPixelClock =
+		cpu_to_le16(dp_link_clock_for_mode_clock(radeon_output, clock));
+	else if (clock > 165000)
+	    disp_data.v1.usPixelClock = cpu_to_le16((clock / 2) / 10);
+	else
+	    disp_data.v1.usPixelClock = cpu_to_le16(clock / 10);
+    }
 
     if (IS_DCE4_VARIANT) {
-	if (action == ATOM_TRANSMITTER_ACTION_INIT) {
-	    disp_data.v3.usInitInfo = radeon_output->connector_object_id;
-	} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {
-	    disp_data.v3.asMode.ucLaneSel = lane_num;
-	    disp_data.v3.asMode.ucLaneSet = lane_set;
-	} else {
-	    if (radeon_output->MonType == MT_DP) {
-		disp_data.v3.usPixelClock =
-		    cpu_to_le16(dp_link_clock_for_mode_clock(radeon_output, clock));
-	    } else if (clock > 165000) {
-		disp_data.v3.usPixelClock = cpu_to_le16((clock / 2) / 10);
-		disp_data.v3.acConfig.fDualLinkConnector = 1;
-	    } else {
-		disp_data.v3.usPixelClock = cpu_to_le16(clock / 10);
-	    }
-	}
-
 	if (radeon_output->MonType == MT_DP)
 	    disp_data.v3.ucLaneNum = dp_lanes_for_mode_clock(radeon_output, clock);
 	else if (clock > 165000)
@@ -765,7 +727,7 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
 	}
 
 	// select the PLL for the UNIPHY
-	if (radeon_output->MonType == MT_DP)
+	if (radeon_output->MonType == MT_DP && info->dp_extclk)
 	    disp_data.v3.acConfig.ucRefClkSource = 2; /* ext clk */
 	else
 	    disp_data.v3.acConfig.ucRefClkSource = radeon_output->pll_id;
@@ -790,25 +752,10 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
 	else if (radeon_output->active_device & (ATOM_DEVICE_DFP_SUPPORT)) {
 	    if (radeon_output->coherent_mode)
 		disp_data.v3.acConfig.fCoherentMode = 1;
+	    if (clock > 165000)
+		disp_data.v3.acConfig.fDualLinkConnector = 1;
 	}
     } else if (IS_DCE32_VARIANT) {
-	if (action == ATOM_TRANSMITTER_ACTION_INIT) {
-	    disp_data.v2.usInitInfo = radeon_output->connector_object_id;
-	} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {
-	    disp_data.v2.asMode.ucLaneSel = lane_num;
-	    disp_data.v2.asMode.ucLaneSet = lane_set;
-	} else {
-	    if (radeon_output->MonType == MT_DP) {
-		disp_data.v2.usPixelClock =
-		    cpu_to_le16(dp_link_clock_for_mode_clock(radeon_output, clock));
-		disp_data.v2.acConfig.fDPConnector = 1;
-	    } else if (clock > 165000) {
-		disp_data.v2.usPixelClock = cpu_to_le16((clock / 2) / 10);
-		disp_data.v2.acConfig.fDualLinkConnector = 1;
-	    } else {
-		disp_data.v2.usPixelClock = cpu_to_le16(clock / 10);
-	    }
-	}
 	if (radeon_output->dig_encoder)
 	    disp_data.v2.acConfig.ucEncoderSel = 1;
 
@@ -839,21 +786,6 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
     } else {
 	disp_data.v1.ucConfig = ATOM_TRANSMITTER_CONFIG_CLKSRC_PPLL;
 
-	if (action == ATOM_TRANSMITTER_ACTION_INIT) {
-	    disp_data.v1.usInitInfo = radeon_output->connector_object_id;
-	} else if (action == ATOM_TRANSMITTER_ACTION_SETUP_VSEMPH) {
-	    disp_data.v1.asMode.ucLaneSel = lane_num;
-	    disp_data.v1.asMode.ucLaneSet = lane_set;
-	} else {
-	    if (radeon_output->MonType == MT_DP)
-		disp_data.v1.usPixelClock =
-		    cpu_to_le16(dp_link_clock_for_mode_clock(radeon_output, clock));
-	    else if (clock > 165000)
-		disp_data.v1.usPixelClock = cpu_to_le16((clock / 2) / 10);
-	    else
-		disp_data.v1.usPixelClock = cpu_to_le16(clock / 10);
-	}
-
 	if (radeon_output->dig_encoder)
 	    disp_data.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_DIG2_ENCODER;
 	else
@@ -880,8 +812,6 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
 	    }
 	    break;
 	}
-	if (clock > 165000)
-	    disp_data.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_8LANE_LINK;
 	if (radeon_output->linkb)
 	    disp_data.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_LINKB;
 	else
@@ -892,6 +822,8 @@ atombios_output_dig_transmitter_setup(xf86OutputPtr output, int action, uint8_t
 	else if (radeon_output->active_device & (ATOM_DEVICE_DFP_SUPPORT)) {
 	    if (radeon_output->coherent_mode)
 		disp_data.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_COHERENT;
+	    if (clock > 165000)
+		disp_data.v1.ucConfig |= ATOM_TRANSMITTER_CONFIG_8LANE_LINK;
 	}
     }
 
@@ -1415,13 +1347,14 @@ atombios_output_dpms(xf86OutputPtr output, int mode)
     case DPMSModeOn:
 	radeon_encoder->devices |= radeon_output->active_device;
 	if (is_dig) {
-	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0);
+	    if (!IS_DCE4_VARIANT)
+		atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_ENABLE_OUTPUT, 0, 0);
 	    if (((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
 		 (radeon_output->ConnectorType == CONNECTOR_EDP)) &&
 		(radeon_output->MonType == MT_DP)) {
 		do_displayport_link_train(output);
 		if (IS_DCE4_VARIANT)
-		    atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_VIDEO_ON);
+		    atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_VIDEO_ON);
 	    }
 	}
 	else {
@@ -1447,13 +1380,14 @@ atombios_output_dpms(xf86OutputPtr output, int mode)
 	radeon_encoder->devices &= ~(radeon_output->active_device);
 	if (!radeon_encoder->devices) {
 	    if (is_dig) {
+		if (!IS_DCE4_VARIANT)
+		    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_DISABLE_OUTPUT, 0, 0);
 		if (((radeon_output->ConnectorType == CONNECTOR_DISPLAY_PORT) ||
 		     (radeon_output->ConnectorType == CONNECTOR_EDP)) &&
 		    (radeon_output->MonType == MT_DP)) {
 		    if (IS_DCE4_VARIANT)
-			atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_VIDEO_OFF);
+			atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_VIDEO_OFF);
 		}
-		atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_DISABLE_OUTPUT, 0, 0);
 	    } else {
 		disp_data.ucAction = ATOM_DISABLE;
 		data.exec.index = index;
@@ -1473,7 +1407,12 @@ atombios_output_dpms(xf86OutputPtr output, int mode)
     }
 }
 
-static void
+union crtc_source_param {
+    SELECT_CRTC_SOURCE_PS_ALLOCATION v1;
+    SELECT_CRTC_SOURCE_PARAMETERS_V2 v2;
+};
+
+void
 atombios_set_output_crtc_source(xf86OutputPtr output)
 {
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
@@ -1482,16 +1421,15 @@ atombios_set_output_crtc_source(xf86OutputPtr output)
     radeon_encoder_ptr radeon_encoder = radeon_get_encoder(output);
     AtomBiosArgRec data;
     unsigned char *space;
-    SELECT_CRTC_SOURCE_PS_ALLOCATION crtc_src_param;
-    SELECT_CRTC_SOURCE_PARAMETERS_V2 crtc_src_param2;
+    union crtc_source_param args;
     int index = GetIndexIntoMasterTable(COMMAND, SelectCRTC_Source);
     int major, minor;
 
     if (radeon_encoder == NULL)
 	return;
 
-    memset(&crtc_src_param, 0, sizeof(crtc_src_param));
-    memset(&crtc_src_param2, 0, sizeof(crtc_src_param2));
+    memset(&args, 0, sizeof(args));
+
     atombios_get_command_table_version(info->atomBIOS, index, &major, &minor);
 
     /*ErrorF("select crtc source table is %d %d\n", major, minor);*/
@@ -1503,55 +1441,54 @@ atombios_set_output_crtc_source(xf86OutputPtr output)
 	case 1:
 	default:
 	    if (IS_AVIVO_VARIANT)
-		crtc_src_param.ucCRTC = radeon_crtc->crtc_id;
+		args.v1.ucCRTC = radeon_crtc->crtc_id;
 	    else {
 		if (radeon_encoder->encoder_id == ENCODER_OBJECT_ID_INTERNAL_DAC1)
-		    crtc_src_param.ucCRTC = radeon_crtc->crtc_id;
+		    args.v1.ucCRTC = radeon_crtc->crtc_id;
 		else
-		    crtc_src_param.ucCRTC = radeon_crtc->crtc_id << 2;
+		    args.v1.ucCRTC = radeon_crtc->crtc_id << 2;
 	    }
 	    switch (radeon_encoder->encoder_id) {
 	    case ENCODER_OBJECT_ID_INTERNAL_TMDS1:
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_TMDS1:
-		crtc_src_param.ucDevice = ATOM_DEVICE_DFP1_INDEX;
+		args.v1.ucDevice = ATOM_DEVICE_DFP1_INDEX;
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_LVDS:
 	    case ENCODER_OBJECT_ID_INTERNAL_LVTM1:
 		if (radeon_output->active_device & ATOM_DEVICE_LCD1_SUPPORT)
-		    crtc_src_param.ucDevice = ATOM_DEVICE_LCD1_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_LCD1_INDEX;
 		else
-		    crtc_src_param.ucDevice = ATOM_DEVICE_DFP3_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_DFP3_INDEX;
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_DVO1:
 	    case ENCODER_OBJECT_ID_INTERNAL_DDI:
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
-		crtc_src_param.ucDevice = ATOM_DEVICE_DFP2_INDEX;
+		args.v1.ucDevice = ATOM_DEVICE_DFP2_INDEX;
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_DAC1:
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
 		if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT))
-		    crtc_src_param.ucDevice = ATOM_DEVICE_TV1_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;
 		else if (radeon_output->active_device & (ATOM_DEVICE_CV_SUPPORT))
-		    crtc_src_param.ucDevice = ATOM_DEVICE_CV_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_CV_INDEX;
 		else
-		    crtc_src_param.ucDevice = ATOM_DEVICE_CRT1_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_CRT1_INDEX;
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_DAC2:
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
 		if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT))
-		    crtc_src_param.ucDevice = ATOM_DEVICE_TV1_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_TV1_INDEX;
 		else if (radeon_output->active_device & (ATOM_DEVICE_CV_SUPPORT))
-		    crtc_src_param.ucDevice = ATOM_DEVICE_CV_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_CV_INDEX;
 		else
-		    crtc_src_param.ucDevice = ATOM_DEVICE_CRT2_INDEX;
+		    args.v1.ucDevice = ATOM_DEVICE_CRT2_INDEX;
 		break;
 	    }
-	    data.exec.pspace = &crtc_src_param;
-	    /*ErrorF("device sourced: 0x%x\n", crtc_src_param.ucDevice);*/
+	    /*ErrorF("device sourced: 0x%x\n", args.v1.ucDevice);*/
 	    break;
 	case 2:
-	    crtc_src_param2.ucCRTC = radeon_crtc->crtc_id;
-	    crtc_src_param2.ucEncodeMode = atombios_get_encoder_mode(output);
+	    args.v2.ucCRTC = radeon_crtc->crtc_id;
+	    args.v2.ucEncodeMode = atombios_get_encoder_mode(output);
 	    switch (radeon_encoder->encoder_id) {
 	    case ENCODER_OBJECT_ID_INTERNAL_UNIPHY:
 	    case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
@@ -1559,44 +1496,46 @@ atombios_set_output_crtc_source(xf86OutputPtr output)
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
  		switch (radeon_output->dig_encoder) {
  		case 0:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG1_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG1_ENCODER_ID;
  		    break;
  		case 1:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG2_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG2_ENCODER_ID;
  		    break;
  		case 2:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG3_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG3_ENCODER_ID;
  		    break;
  		case 3:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG4_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG4_ENCODER_ID;
  		    break;
  		case 4:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG5_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG5_ENCODER_ID;
  		    break;
  		case 5:
- 		    crtc_src_param2.ucEncoderID = ASIC_INT_DIG6_ENCODER_ID;
+ 		    args.v2.ucEncoderID = ASIC_INT_DIG6_ENCODER_ID;
  		    break;
  		}
 		break;
+	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DVO1:
+		args.v2.ucEncoderID = ASIC_INT_DVO_ENCODER_ID;
+		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC1:
 		if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT))
-		    crtc_src_param2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
 		else if (radeon_output->active_device & (ATOM_DEVICE_CV_SUPPORT))
-		    crtc_src_param2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
 		else
-		    crtc_src_param2.ucEncoderID = ASIC_INT_DAC1_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_DAC1_ENCODER_ID;
 		break;
 	    case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_DAC2:
 		if (radeon_output->active_device & (ATOM_DEVICE_TV_SUPPORT))
-		    crtc_src_param2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
 		else if (radeon_output->active_device & (ATOM_DEVICE_CV_SUPPORT))
-		    crtc_src_param2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_TV_ENCODER_ID;
 		else
-		    crtc_src_param2.ucEncoderID = ASIC_INT_DAC2_ENCODER_ID;
+		    args.v2.ucEncoderID = ASIC_INT_DAC2_ENCODER_ID;
 		break;
 	    }
-	    data.exec.pspace = &crtc_src_param2;
-	    /*ErrorF("device sourced: 0x%x\n", crtc_src_param2.ucEncoderID);*/
+	    /*ErrorF("device sourced: 0x%x\n", args.v2.ucEncoderID);*/
 	    break;
 	}
 	break;
@@ -1605,6 +1544,7 @@ atombios_set_output_crtc_source(xf86OutputPtr output)
 	exit(-1);
     }
 
+    data.exec.pspace = &args;
     data.exec.index = index;
     data.exec.dataSpace = (void *)&space;
 
@@ -1757,7 +1697,7 @@ atombios_output_mode_set(xf86OutputPtr output,
     atombios_output_scaler_setup(output);
     atombios_set_output_crtc_source(output);
 
-    if (IS_AVIVO_VARIANT) {
+    if (IS_AVIVO_VARIANT && !IS_DCE4_VARIANT) {
 	if (radeon_output->active_device & (ATOM_DEVICE_CV_SUPPORT | ATOM_DEVICE_TV_SUPPORT))
 	    atombios_output_yuv_setup(output, TRUE);
 	else
@@ -1777,17 +1717,20 @@ atombios_output_mode_set(xf86OutputPtr output,
     case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 	/* disable encoder and transmitter */
 	/* setup and enable the encoder and transmitter */
-	atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);
-	if (IS_DCE4_VARIANT)
-	    atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_SETUP);
-	else {
+	if (IS_DCE4_VARIANT) {
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);
+	    atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_SETUP);
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_INIT, 0, 0);
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0);
+	} else {
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_DISABLE, 0, 0);
 	    atombios_output_dig_encoder_setup(output, ATOM_DISABLE);
 	    atombios_output_dig_encoder_setup(output, ATOM_ENABLE);
+
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_INIT, 0, 0);
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0);
+	    atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0);
 	}
-	atombios_output_dig_encoder_setup(output, ATOM_ENABLE);
-	atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_INIT, 0, 0);
-	atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_SETUP, 0, 0);
-	atombios_output_dig_transmitter_setup(output, ATOM_TRANSMITTER_ACTION_ENABLE, 0, 0);
 	break;
     case ENCODER_OBJECT_ID_INTERNAL_DDI:
 	atombios_output_ddia_setup(output, ATOM_ENABLE);
@@ -2063,6 +2006,7 @@ RADEONProcessAuxCH(xf86OutputPtr output, uint8_t *req_bytes, uint8_t num_bytes,
     AtomBiosArgRec data;
     unsigned char *space;
     unsigned char *base;
+    int retry_count = 0;
 
     memset(&args, 0, sizeof(args));
     if (info->atomBIOS->fbBase)
@@ -2072,6 +2016,7 @@ RADEONProcessAuxCH(xf86OutputPtr output, uint8_t *req_bytes, uint8_t num_bytes,
     else
 	return FALSE;
 
+retry:
     memcpy(base, req_bytes, num_bytes);
 
     args.v1.lpAuxRequest = 0;
@@ -2087,9 +2032,11 @@ RADEONProcessAuxCH(xf86OutputPtr output, uint8_t *req_bytes, uint8_t num_bytes,
     data.exec.pspace = &args;
 
     RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data);
-    if (args.v1.ucReplyStatus) {
-	ErrorF("failed to get auxch %02x%02x %02x %02x %02x\n",
-	       req_bytes[1], req_bytes[0], req_bytes[2], req_bytes[3], args.v1.ucReplyStatus);
+    if (args.v1.ucReplyStatus && !args.v1.ucDataOutLen) {
+	if (args.v1.ucReplyStatus == 0x20 && retry_count++ < 10)
+		goto retry;
+	ErrorF("failed to get auxch %02x%02x %02x %02x %02x after %d retries\n",
+	       req_bytes[1], req_bytes[0], req_bytes[2], req_bytes[3], args.v1.ucReplyStatus, retry_count);
 	return FALSE;
     }
     if (args.v1.ucDataOutLen && read_byte && read_buf_len) {
@@ -2127,7 +2074,7 @@ RADEONDPEncoderService(xf86OutputPtr output, int action, uint8_t ucconfig, uint8
 
     RHDAtomBiosFunc(info->atomBIOS->scrnIndex, info->atomBIOS, ATOMBIOS_EXEC, &data);
 
-    ErrorF("%s: %d\n", __func__, args.ucStatus);
+    ErrorF("%s: %d %d\n", __func__, action, args.ucStatus);
     return args.ucStatus;
 }
 
@@ -2600,6 +2547,11 @@ static int radeon_dp_link_required(int pixel_clock)
     return pixel_clock * 3;
 }
 
+static int link_bw_avail(int max_link_clock, int max_lanes)
+{
+    return (max_link_clock * max_lanes * 8) / 10;
+}
+
 Bool radeon_dp_mode_fixup(xf86OutputPtr output, DisplayModePtr mode, DisplayModePtr adjusted_mode)
 {
     RADEONOutputPrivatePtr radeon_output = output->driver_private;
@@ -2610,7 +2562,7 @@ Bool radeon_dp_mode_fixup(xf86OutputPtr output, DisplayModePtr mode, DisplayMode
 
     for (lane_count = 1; lane_count <= max_lane_count; lane_count <<= 1) {
 	for (clock = 0; clock <= max_clock; clock++) {
-	    int link_avail = radeon_dp_link_clock(bws[clock]) * lane_count;
+	    int link_avail = link_bw_avail(radeon_dp_link_clock(bws[clock]), lane_count);
 
 	    if (radeon_dp_link_required(mode->Clock) <= link_avail) {
 		radeon_output->dp_lane_count = lane_count;
@@ -2683,8 +2635,8 @@ static void do_displayport_link_train(xf86OutputPtr output)
 
     /* start local training start */
     if (IS_DCE4_VARIANT) {
-	atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_START);
-	atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1);
+	atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_START);
+	atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN1);
     } else {
 	RADEONDPEncoderService(output, ATOM_DP_ACTION_TRAINING_START, enc_id, 0);
 	RADEONDPEncoderService(output, ATOM_DP_ACTION_TRAINING_PATTERN_SEL, enc_id, 0);
@@ -2744,7 +2696,7 @@ static void do_displayport_link_train(xf86OutputPtr output)
     channel_eq = FALSE;
     dp_set_training(output, DP_TRAINING_PATTERN_2);
     if (IS_DCE4_VARIANT)
-	atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2);
+	atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_PATTERN2);
     else
 	RADEONDPEncoderService(output, ATOM_DP_ACTION_TRAINING_PATTERN_SEL, enc_id, 1);
 
@@ -2778,7 +2730,7 @@ static void do_displayport_link_train(xf86OutputPtr output)
 
     dp_set_training(output, DP_TRAINING_PATTERN_DISABLE);
     if (IS_DCE4_VARIANT)
-	atombios_dce4_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE);
+	atombios_output_dig_encoder_setup(output, ATOM_ENCODER_CMD_DP_LINK_TRAINING_COMPLETE);
     else
 	RADEONDPEncoderService(output, ATOM_DP_ACTION_TRAINING_COMPLETE, enc_id, 0);
 
diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index 1366b36..6a4a32d 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -347,7 +347,8 @@ drmmode_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
 		}
 	}
 
-	if (pScrn->pScreen)
+	if (pScrn->pScreen &&
+		!xf86ReturnOptValBool(info->Options, OPTION_SW_CURSOR, FALSE))
 		xf86_reload_cursors(pScrn->pScreen);
 
 done:
@@ -1100,8 +1101,11 @@ drmmode_xf86crtc_resize (ScrnInfoPtr scrn, int width, int height)
 	if (!info->front_bo)
 		goto fail;
 
-	if (info->allowColorTiling)
-	    tiling_flags |= RADEON_TILING_MACRO;
+	/* no tiled scanout on r6xx+ yet */
+	if (info->allowColorTiling) {
+		if (info->ChipFamily < CHIP_FAMILY_R600)
+			tiling_flags |= RADEON_TILING_MACRO;
+	}
 #if X_BYTE_ORDER == X_BIG_ENDIAN
 	switch (cpp) {
 	case 4:
diff --git a/src/local_xf86Rename.h b/src/local_xf86Rename.h
deleted file mode 100644
index 5102170..0000000
--- a/src/local_xf86Rename.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*
- * Copyright  2006 Keith Packard
- *
- * Permission to use, copy, modify, distribute, and sell this software and its
- * documentation for any purpose is hereby granted without fee, provided that
- * the above copyright notice appear in all copies and that both that copyright
- * notice and this permission notice appear in supporting documentation, and
- * that the name of the copyright holders not be used in advertising or
- * publicity pertaining to distribution of the software without specific,
- * written prior permission.  The copyright holders make no representations
- * about the suitability of this software for any purpose.  It is provided "as
- * is" without express or implied warranty.
- *
- * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
- * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
- * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
- * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
- * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
- * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
- * OF THIS SOFTWARE.
- */
-
-#define XF86NAME(x) radeon_##x
diff --git a/src/pcidb/ati_pciids.csv b/src/pcidb/ati_pciids.csv
index 6f101b2..05028fe 100644
--- a/src/pcidb/ati_pciids.csv
+++ b/src/pcidb/ati_pciids.csv
@@ -463,6 +463,8 @@
 "0x6888","CYPRESS_6888","CYPRESS",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
 "0x6889","CYPRESS_6889","CYPRESS",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
 "0x688A","CYPRESS_688A","CYPRESS",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
+"0x688C","CYPRESS_688C","CYPRESS",,,,,,"AMD Firestream 9370"
+"0x688D","CYPRESS_688D","CYPRESS",,,,,,"AMD Firestream 9350"
 "0x6898","CYPRESS_6898","CYPRESS",,,,,,"ATI Radeon HD 5800 Series"
 "0x6899","CYPRESS_6899","CYPRESS",,,,,,"ATI Radeon HD 5800 Series"
 "0x689E","CYPRESS_689E","CYPRESS",,,,,,"ATI Radeon HD 5800 Series"
@@ -487,11 +489,12 @@
 "0x68DE","REDWOOD_68DE","REDWOOD",,,,,,"REDWOOD"
 "0x68E0","CEDAR_68E0","CEDAR",1,,,,,"ATI Mobility Radeon HD 5000 Series"
 "0x68E1","CEDAR_68E1","CEDAR",1,,,,,"ATI Mobility Radeon HD 5000 Series"
-"0x68E4","CEDAR_68E4","CEDAR",1,,,,,"CEDAR"
-"0x68E5","CEDAR_68E5","CEDAR",1,,,,,"CEDAR"
+"0x68E4","CEDAR_68E4","CEDAR",1,,,,,"ATI Mobility Radeon Graphics"
+"0x68E5","CEDAR_68E5","CEDAR",1,,,,,"ATI Mobility Radeon Graphics"
 "0x68E8","CEDAR_68E8","CEDAR",,,,,,"CEDAR"
 "0x68E9","CEDAR_68E9","CEDAR",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
 "0x68F1","CEDAR_68F1","CEDAR",,,,,,"ATI FirePro (FireGL) Graphics Adapter"
+"0x68F2","CEDAR_68F2","CEDAR",,,,,,"ATI FirePro 2270"
 "0x68F8","CEDAR_68F8","CEDAR",,,,,,"CEDAR"
 "0x68F9","CEDAR_68F9","CEDAR",,,,,,"ATI Radeon HD 5450"
 "0x68FE","CEDAR_68FE","CEDAR",,,,,,"CEDAR"
diff --git a/src/r600_exa.c b/src/r600_exa.c
index b1c024a..d6e98ff 100644
--- a/src/r600_exa.c
+++ b/src/r600_exa.c
@@ -38,44 +38,11 @@
 #include "r600_shader.h"
 #include "r600_reg.h"
 #include "r600_state.h"
+#include "radeon_exa_shared.h"
 #include "radeon_vbo.h"
 
-#define RADEON_TRACE_FALL 0
-#define RADEON_TRACE_DRAW 0
-
-#if RADEON_TRACE_FALL
-#define RADEON_FALLBACK(x)     		\
-do {					\
-	ErrorF("%s: ", __FUNCTION__);	\
-	ErrorF x;			\
-	return FALSE;			\
-} while (0)
-#else
-#define RADEON_FALLBACK(x) return FALSE
-#endif
-
-extern PixmapPtr
-RADEONGetDrawablePixmap(DrawablePtr pDrawable);
-
 /* #define SHOW_VERTEXES */
 
-#       define RADEON_ROP3_ZERO             0x00000000
-#       define RADEON_ROP3_DSa              0x00880000
-#       define RADEON_ROP3_SDna             0x00440000
-#       define RADEON_ROP3_S                0x00cc0000
-#       define RADEON_ROP3_DSna             0x00220000
-#       define RADEON_ROP3_D                0x00aa0000
-#       define RADEON_ROP3_DSx              0x00660000
-#       define RADEON_ROP3_DSo              0x00ee0000
-#       define RADEON_ROP3_DSon             0x00110000
-#       define RADEON_ROP3_DSxn             0x00990000
-#       define RADEON_ROP3_Dn               0x00550000
-#       define RADEON_ROP3_SDno             0x00dd0000
-#       define RADEON_ROP3_Sn               0x00330000
-#       define RADEON_ROP3_DSno             0x00bb0000
-#       define RADEON_ROP3_DSan             0x00770000
-#       define RADEON_ROP3_ONE              0x00ff0000
-
 uint32_t RADEON_ROP[16] = {
     RADEON_ROP3_ZERO, /* GXclear        */
     RADEON_ROP3_DSa,  /* Gxand          */
@@ -95,80 +62,6 @@ uint32_t RADEON_ROP[16] = {
     RADEON_ROP3_ONE,  /* GXset          */
 };
 
-static void R600VlineHelperClear(ScrnInfoPtr pScrn)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    struct radeon_accel_state *accel_state = info->accel_state;
-
-    accel_state->vline_crtc = NULL;
-    accel_state->vline_y1 = -1;
-    accel_state->vline_y2 = 0;
-}
-
-static void R600VlineHelperSet(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    struct radeon_accel_state *accel_state = info->accel_state;
-
-    accel_state->vline_crtc = radeon_pick_best_crtc(pScrn, x1, x2, y1, y2);
-    if (accel_state->vline_y1 == -1)
-	accel_state->vline_y1 = y1;
-    if (y1 < accel_state->vline_y1)
-	accel_state->vline_y1 = y1;
-    if (y2 > accel_state->vline_y2)
-	accel_state->vline_y2 = y2;
-}
-
-static Bool R600ValidPM(uint32_t pm, int bpp)
-{
-    uint8_t r, g, b, a;
-    Bool ret = FALSE;
-
-    switch (bpp) {
-    case 8:
-	a = pm & 0xff;
-	if ((a == 0) || (a == 0xff))
-	    ret = TRUE;
-	break;
-    case 16:
-	r = (pm >> 11) & 0x1f;
-	g = (pm >> 5) & 0x3f;
-	b = (pm >> 0) & 0x1f;
-	if (((r == 0) || (r == 0x1f)) &&
-	    ((g == 0) || (g == 0x3f)) &&
-	    ((b == 0) || (b == 0x1f)))
-	    ret = TRUE;
-	break;
-    case 32:
-	a = (pm >> 24) & 0xff;
-	r = (pm >> 16) & 0xff;
-	g = (pm >> 8) & 0xff;
-	b = (pm >> 0) & 0xff;
-	if (((a == 0) || (a == 0xff)) &&
-	    ((r == 0) || (r == 0xff)) &&
-	    ((g == 0) || (g == 0xff)) &&
-	    ((b == 0) || (b == 0xff)))
-	    ret = TRUE;
-	break;
-    default:
-	break;
-    }
-    return ret;
-}
-
-static Bool R600CheckBPP(int bpp)
-{
-	switch (bpp) {
-	case 8:
-	case 16:
-	case 32:
-		return TRUE;
-	default:
-		break;
-	}
-	return FALSE;
-}
-
 Bool
 R600SetAccelState(ScrnInfoPtr pScrn,
 		  struct r600_accel_object *src0,
@@ -179,7 +72,6 @@ R600SetAccelState(ScrnInfoPtr pScrn,
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     struct radeon_accel_state *accel_state = info->accel_state;
-    int ret;
 
     if (src0) {
 	memcpy(&accel_state->src_obj[0], src0, sizeof(struct r600_accel_object));
@@ -234,6 +126,7 @@ R600SetAccelState(ScrnInfoPtr pScrn,
     accel_state->ps_size = 512;
 #if defined(XF86DRM_MODE)
     if (info->cs) {
+	int ret;
 	accel_state->vs_mc_addr = vs_offset;
 	accel_state->ps_mc_addr = ps_offset;
 
@@ -265,22 +158,9 @@ R600SetAccelState(ScrnInfoPtr pScrn,
     return TRUE;
 }
 
-#if defined(XF86DRM_MODE)
-static inline void radeon_add_pixmap(struct radeon_cs *cs, PixmapPtr pPix, int read_domains, int write_domain)
-{
-    struct radeon_exa_pixmap_priv *driver_priv = exaGetPixmapDriverPrivate(pPix);
-
-    radeon_cs_space_add_persistent_bo(cs, driver_priv->bo, read_domains, write_domain);
-}
-#endif
-
 static void
 R600DoneSolid(PixmapPtr pPix);
 
-static void
-R600DoneComposite(PixmapPtr pDst);
-
-
 static Bool
 R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
 {
@@ -294,9 +174,9 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     float ps_alu_consts[4];
     struct r600_accel_object dst;
 
-    if (!R600CheckBPP(pPix->drawable.bitsPerPixel))
+    if (!RADEONCheckBPP(pPix->drawable.bitsPerPixel))
 	RADEON_FALLBACK(("R600CheckDatatype failed\n"));
-    if (!R600ValidPM(pm, pPix->drawable.bitsPerPixel))
+    if (!RADEONValidPM(pm, pPix->drawable.bitsPerPixel))
 	RADEON_FALLBACK(("invalid planemask\n"));
 
 #if defined(XF86DRM_MODE)
@@ -315,7 +195,7 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     dst.height = pPix->drawable.height;
     dst.bpp = pPix->drawable.bitsPerPixel;
     dst.domain = RADEON_GEM_DOMAIN_VRAM;
-	
+
     if (!R600SetAccelState(pScrn,
 			   NULL,
 			   NULL,
@@ -329,7 +209,7 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     CLEAR (ps_conf);
 
     radeon_vbo_check(pScrn, 16);
-    r600_cp_start(pScrn);
+    radeon_cp_start(pScrn);
 
     set_default_state(pScrn, accel_state->ib);
 
@@ -338,24 +218,15 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     set_window_scissor(pScrn, accel_state->ib, 0, 0, accel_state->dst_obj.width, accel_state->dst_obj.height);
 
     /* Shader */
-
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->vs_size, accel_state->vs_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     vs_conf.shader_addr         = accel_state->vs_mc_addr;
+    vs_conf.shader_size         = accel_state->vs_size;
     vs_conf.num_gprs            = 2;
     vs_conf.stack_size          = 0;
     vs_conf.bo                  = accel_state->shaders_bo;
     vs_setup                    (pScrn, accel_state->ib, &vs_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->ps_size, accel_state->ps_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     ps_conf.shader_addr         = accel_state->ps_mc_addr;
+    ps_conf.shader_size         = accel_state->ps_size;
     ps_conf.num_gprs            = 1;
     ps_conf.stack_size          = 0;
     ps_conf.uncached_first_inst = 1;
@@ -364,20 +235,6 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     ps_conf.bo                  = accel_state->shaders_bo;
     ps_setup                    (pScrn, accel_state->ib, &ps_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* Render setup */
-    if (accel_state->planemask & 0x000000ff)
-	pmask |= 4; /* B */
-    if (accel_state->planemask & 0x0000ff00)
-	pmask |= 2; /* G */
-    if (accel_state->planemask & 0x00ff0000)
-	pmask |= 1; /* R */
-    if (accel_state->planemask & 0xff000000)
-	pmask |= 8; /* A */
-    BEGIN_BATCH(6);
-    EREG(accel_state->ib, CB_TARGET_MASK,                      (pmask << TARGET0_ENABLE_shift));
-    EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[accel_state->rop]);
-    END_BATCH();
-
     cb_conf.id = 0;
     cb_conf.w = accel_state->dst_obj.pitch;
     cb_conf.h = accel_state->dst_obj.height;
@@ -398,23 +255,36 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     cb_conf.blend_clamp = 1;
     set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
+    /* Render setup */
+    if (accel_state->planemask & 0x000000ff)
+	pmask |= 4; /* B */
+    if (accel_state->planemask & 0x0000ff00)
+	pmask |= 2; /* G */
+    if (accel_state->planemask & 0x00ff0000)
+	pmask |= 1; /* R */
+    if (accel_state->planemask & 0xff000000)
+	pmask |= 8; /* A */
+    BEGIN_BATCH(20);
+    EREG(accel_state->ib, CB_TARGET_MASK,                      (pmask << TARGET0_ENABLE_shift));
+    EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[accel_state->rop]);
+
     /* Interpolator setup */
     /* one unused export from VS (VS_EXPORT_COUNT is zero based, count minus one) */
-    BEGIN_BATCH(18);
     EREG(accel_state->ib, SPI_VS_OUT_CONFIG, (0 << VS_EXPORT_COUNT_shift));
     EREG(accel_state->ib, SPI_VS_OUT_ID_0, (0 << SEMANTIC_0_shift));
-
-    /* Enabling flat shading needs both FLAT_SHADE_bit in SPI_PS_INPUT_CNTL_x
-     * *and* FLAT_SHADE_ENA_bit in SPI_INTERP_CONTROL_0 */
-    /* no VS exports as PS input (NUM_INTERP is not zero based, no minus one) */
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_0,                 (0 << NUM_INTERP_shift));
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_1,                 0);
     /* color semantic id 0 -> GPR[0] */
-    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 <<2),       ((0    << SEMANTIC_shift)	|
+    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 << 2),       ((0    << SEMANTIC_shift)	|
 								  (0x03 << DEFAULT_VAL_shift)	|
 								  FLAT_SHADE_bit		|
 								  SEL_CENTROID_bit));
-    EREG(accel_state->ib, SPI_INTERP_CONTROL_0,                FLAT_SHADE_ENA_bit);
+
+    /* Enabling flat shading needs both FLAT_SHADE_bit in SPI_PS_INPUT_CNTL_x
+     * *and* FLAT_SHADE_ENA_bit in SPI_INTERP_CONTROL_0 */
+    /* no VS exports as PS input (NUM_INTERP is not zero based, no minus one) */
+    PACK0(accel_state->ib, SPI_PS_IN_CONTROL_0, 3);
+    E32(accel_state->ib, (0 << NUM_INTERP_shift));
+    E32(accel_state->ib, 0);
+    E32(accel_state->ib, FLAT_SHADE_ENA_bit);
     END_BATCH();
 
     /* PS alu constants */
@@ -446,7 +316,7 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
 		   sizeof(ps_alu_consts) / SQ_ALU_CONSTANT_offset, ps_alu_consts);
 
     if (accel_state->vsync)
-	R600VlineHelperClear(pScrn);
+	RADEONVlineHelperClear(pScrn);
 
     return TRUE;
 }
@@ -461,7 +331,7 @@ R600Solid(PixmapPtr pPix, int x1, int y1, int x2, int y2)
     float *vb;
 
     if (accel_state->vsync)
-	R600VlineHelperSet(pScrn, x1, y1, x2, y2);
+	RADEONVlineHelperSet(pScrn, x1, y1, x2, y2);
 
     vb = radeon_vbo_space(pScrn, 8);
 
@@ -511,7 +381,7 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     CLEAR (ps_conf);
 
     radeon_vbo_check(pScrn, 16);
-    r600_cp_start(pScrn);
+    radeon_cp_start(pScrn);
 
     set_default_state(pScrn, accel_state->ib);
 
@@ -520,24 +390,15 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     set_window_scissor(pScrn, accel_state->ib, 0, 0, accel_state->dst_obj.width, accel_state->dst_obj.height);
 
     /* Shader */
-
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->vs_size, accel_state->vs_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     vs_conf.shader_addr         = accel_state->vs_mc_addr;
+    vs_conf.shader_size         = accel_state->vs_size;
     vs_conf.num_gprs            = 2;
     vs_conf.stack_size          = 0;
     vs_conf.bo                  = accel_state->shaders_bo;
     vs_setup                    (pScrn, accel_state->ib, &vs_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->ps_size, accel_state->ps_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     ps_conf.shader_addr         = accel_state->ps_mc_addr;
+    ps_conf.shader_size         = accel_state->ps_size;
     ps_conf.num_gprs            = 1;
     ps_conf.stack_size          = 0;
     ps_conf.uncached_first_inst = 1;
@@ -546,11 +407,6 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     ps_conf.bo                  = accel_state->shaders_bo;
     ps_setup                    (pScrn, accel_state->ib, &ps_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* flush texture cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit,
-			accel_state->src_size[0], accel_state->src_obj[0].offset,
-			accel_state->src_obj[0].bo, accel_state->src_obj[0].domain, 0);
-
     /* Texture */
     tex_res.id                  = 0;
     tex_res.w                   = accel_state->src_obj[0].width;
@@ -560,6 +416,7 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     tex_res.dim                 = SQ_TEX_DIM_2D;
     tex_res.base                = accel_state->src_obj[0].offset;
     tex_res.mip_base            = accel_state->src_obj[0].offset;
+    tex_res.size                = accel_state->src_size[0];
     tex_res.bo                  = accel_state->src_obj[0].bo;
     tex_res.mip_bo              = accel_state->src_obj[0].bo;
     if (accel_state->src_obj[0].bpp == 8) {
@@ -598,21 +455,6 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     tex_samp.mip_filter         = 0;			/* no mipmap */
     set_tex_sampler             (pScrn, accel_state->ib, &tex_samp);
 
-
-    /* Render setup */
-    if (accel_state->planemask & 0x000000ff)
-	pmask |= 4; /* B */
-    if (accel_state->planemask & 0x0000ff00)
-	pmask |= 2; /* G */
-    if (accel_state->planemask & 0x00ff0000)
-	pmask |= 1; /* R */
-    if (accel_state->planemask & 0xff000000)
-	pmask |= 8; /* A */
-    BEGIN_BATCH(6);
-    EREG(accel_state->ib, CB_TARGET_MASK,                      (pmask << TARGET0_ENABLE_shift));
-    EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[accel_state->rop]);
-    END_BATCH();
-
     cb_conf.id = 0;
     cb_conf.w = accel_state->dst_obj.pitch;
     cb_conf.h = accel_state->dst_obj.height;
@@ -632,22 +474,35 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     cb_conf.blend_clamp = 1;
     set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
+    /* Render setup */
+    if (accel_state->planemask & 0x000000ff)
+	pmask |= 4; /* B */
+    if (accel_state->planemask & 0x0000ff00)
+	pmask |= 2; /* G */
+    if (accel_state->planemask & 0x00ff0000)
+	pmask |= 1; /* R */
+    if (accel_state->planemask & 0xff000000)
+	pmask |= 8; /* A */
+    BEGIN_BATCH(20);
+    EREG(accel_state->ib, CB_TARGET_MASK,                      (pmask << TARGET0_ENABLE_shift));
+    EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[accel_state->rop]);
+
     /* Interpolator setup */
     /* export tex coord from VS */
-    BEGIN_BATCH(18);
     EREG(accel_state->ib, SPI_VS_OUT_CONFIG, ((1 - 1) << VS_EXPORT_COUNT_shift));
     EREG(accel_state->ib, SPI_VS_OUT_ID_0, (0 << SEMANTIC_0_shift));
+    /* color semantic id 0 -> GPR[0] */
+    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 << 2),       ((0    << SEMANTIC_shift)	|
+								(0x01 << DEFAULT_VAL_shift)	|
+								SEL_CENTROID_bit));
 
     /* Enabling flat shading needs both FLAT_SHADE_bit in SPI_PS_INPUT_CNTL_x
      * *and* FLAT_SHADE_ENA_bit in SPI_INTERP_CONTROL_0 */
     /* input tex coord from VS */
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_0,                 ((1 << NUM_INTERP_shift)));
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_1,                 0);
-    /* color semantic id 0 -> GPR[0] */
-    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 <<2),       ((0    << SEMANTIC_shift)	|
-								(0x01 << DEFAULT_VAL_shift)	|
-								SEL_CENTROID_bit));
-    EREG(accel_state->ib, SPI_INTERP_CONTROL_0,                0);
+    PACK0(accel_state->ib, SPI_PS_IN_CONTROL_0, 3);
+    E32(accel_state->ib, ((1 << NUM_INTERP_shift)));
+    E32(accel_state->ib, 0);
+    E32(accel_state->ib, 0);
     END_BATCH();
 
 }
@@ -713,11 +568,11 @@ R600PrepareCopy(PixmapPtr pSrc,   PixmapPtr pDst,
     struct radeon_accel_state *accel_state = info->accel_state;
     struct r600_accel_object src_obj, dst_obj;
 
-    if (!R600CheckBPP(pSrc->drawable.bitsPerPixel))
+    if (!RADEONCheckBPP(pSrc->drawable.bitsPerPixel))
 	RADEON_FALLBACK(("R600CheckDatatype src failed\n"));
-    if (!R600CheckBPP(pDst->drawable.bitsPerPixel))
+    if (!RADEONCheckBPP(pDst->drawable.bitsPerPixel))
 	RADEON_FALLBACK(("R600CheckDatatype dst failed\n"));
-    if (!R600ValidPM(planemask, pDst->drawable.bitsPerPixel))
+    if (!RADEONValidPM(planemask, pDst->drawable.bitsPerPixel))
 	RADEON_FALLBACK(("Invalid planemask\n"));
 
     dst_obj.pitch = exaGetPixmapPitch(pDst) / (pDst->drawable.bitsPerPixel / 8);
@@ -800,7 +655,7 @@ R600PrepareCopy(PixmapPtr pSrc,   PixmapPtr pDst,
 	R600DoPrepareCopy(pScrn);
 
     if (accel_state->vsync)
-	R600VlineHelperClear(pScrn);
+	RADEONVlineHelperClear(pScrn);
 
     return TRUE;
 }
@@ -819,7 +674,7 @@ R600Copy(PixmapPtr pDst,
 	return;
 
     if (accel_state->vsync)
-	R600VlineHelperSet(pScrn, dstX, dstY, dstX + w, dstY + h);
+	RADEONVlineHelperSet(pScrn, dstX, dstY, dstX + w, dstY + h);
 
     if (accel_state->same_surface && accel_state->copy_area) {
 	uint32_t orig_offset, tmp_offset;
@@ -1073,11 +928,6 @@ static Bool R600TextureSetup(PicturePtr pPict, PixmapPtr pPix,
 	    break;
     }
 
-    /* flush texture cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit,
-			accel_state->src_size[unit], accel_state->src_obj[unit].offset,
-			accel_state->src_obj[unit].bo, accel_state->src_obj[unit].domain, 0);
-
     /* Texture */
     tex_res.id                  = unit;
     tex_res.w                   = w;
@@ -1087,6 +937,7 @@ static Bool R600TextureSetup(PicturePtr pPict, PixmapPtr pPix,
     tex_res.dim                 = SQ_TEX_DIM_2D;
     tex_res.base                = accel_state->src_obj[unit].offset;
     tex_res.mip_base            = accel_state->src_obj[unit].offset;
+    tex_res.size                = accel_state->src_size[unit];
     tex_res.format              = R600TexFormats[i].card_fmt;
     tex_res.bo                  = accel_state->src_obj[unit].bo;
     tex_res.mip_bo              = accel_state->src_obj[unit].bo;
@@ -1430,7 +1281,7 @@ static Bool R600PrepareComposite(int op, PicturePtr pSrcPicture,
 			       &src_obj,
 			       &mask_obj,
 			       &dst_obj,
-			       accel_state->comp_vs_offset, accel_state->comp_mask_ps_offset,
+			       accel_state->comp_vs_offset, accel_state->comp_ps_offset,
 			       3, 0xffffffff))
 	    return FALSE;
 
@@ -1471,7 +1322,7 @@ static Bool R600PrepareComposite(int op, PicturePtr pSrcPicture,
     else
         radeon_vbo_check(pScrn, 16);
 
-    r600_cp_start(pScrn);
+    radeon_cp_start(pScrn);
 
     set_default_state(pScrn, accel_state->ib);
 
@@ -1481,68 +1332,45 @@ static Bool R600PrepareComposite(int op, PicturePtr pSrcPicture,
 
     if (!R600TextureSetup(pSrcPicture, pSrc, 0)) {
         R600IBDiscard(pScrn, accel_state->ib);
-        r600_vb_discard(pScrn);
+        radeon_vb_discard(pScrn);
         return FALSE;
     }
 
     if (pMask) {
         if (!R600TextureSetup(pMaskPicture, pMask, 1)) {
             R600IBDiscard(pScrn, accel_state->ib);
-            r600_vb_discard(pScrn);
+            radeon_vb_discard(pScrn);
             return FALSE;
         }
     } else
         accel_state->is_transform[1] = FALSE;
 
-    if (pMask)
+    if (pMask) {
 	set_bool_consts(pScrn, accel_state->ib, SQ_BOOL_CONST_vs, (1 << 0));
-    else
+	set_bool_consts(pScrn, accel_state->ib, SQ_BOOL_CONST_ps, (1 << 0));
+    } else {
 	set_bool_consts(pScrn, accel_state->ib, SQ_BOOL_CONST_vs, (0 << 0));
+	set_bool_consts(pScrn, accel_state->ib, SQ_BOOL_CONST_ps, (0 << 0));
+    }
 
     /* Shader */
-
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->vs_size, accel_state->vs_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     vs_conf.shader_addr         = accel_state->vs_mc_addr;
+    vs_conf.shader_size         = accel_state->vs_size;
     vs_conf.num_gprs            = 3;
     vs_conf.stack_size          = 1;
     vs_conf.bo                  = accel_state->shaders_bo;
     vs_setup                    (pScrn, accel_state->ib, &vs_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->ps_size, accel_state->ps_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     ps_conf.shader_addr         = accel_state->ps_mc_addr;
+    ps_conf.shader_size         = accel_state->ps_size;
     ps_conf.num_gprs            = 3;
-    ps_conf.stack_size          = 0;
+    ps_conf.stack_size          = 1;
     ps_conf.uncached_first_inst = 1;
     ps_conf.clamp_consts        = 0;
     ps_conf.export_mode         = 2;
     ps_conf.bo                  = accel_state->shaders_bo;
     ps_setup                    (pScrn, accel_state->ib, &ps_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    BEGIN_BATCH(9);
-    EREG(accel_state->ib, CB_TARGET_MASK,                      (0xf << TARGET0_ENABLE_shift));
-
-    blendcntl = R600GetBlendCntl(op, pMaskPicture, pDstPicture->format);
-
-    if (info->ChipFamily == CHIP_FAMILY_R600) {
-	/* no per-MRT blend on R600 */
-	EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[3] | (1 << TARGET_BLEND_ENABLE_shift));
-	EREG(accel_state->ib, CB_BLEND_CONTROL,                    blendcntl);
-    } else {
-	EREG(accel_state->ib, CB_COLOR_CONTROL,                    (RADEON_ROP[3] |
-								    (1 << TARGET_BLEND_ENABLE_shift) |
-								    PER_MRT_BLEND_bit));
-	EREG(accel_state->ib, CB_BLEND0_CONTROL,                   blendcntl);
-    }
-    END_BATCH();
-
     cb_conf.id = 0;
     cb_conf.w = accel_state->dst_obj.pitch;
     cb_conf.h = accel_state->dst_obj.height;
@@ -1579,38 +1407,60 @@ static Bool R600PrepareComposite(int op, PicturePtr pSrcPicture,
     cb_conf.blend_clamp = 1;
     set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
+    BEGIN_BATCH(24);
+    EREG(accel_state->ib, CB_TARGET_MASK,                      (0xf << TARGET0_ENABLE_shift));
+
+    blendcntl = R600GetBlendCntl(op, pMaskPicture, pDstPicture->format);
+
+    if (info->ChipFamily == CHIP_FAMILY_R600) {
+	/* no per-MRT blend on R600 */
+	EREG(accel_state->ib, CB_COLOR_CONTROL,                    RADEON_ROP[3] | (1 << TARGET_BLEND_ENABLE_shift));
+	EREG(accel_state->ib, CB_BLEND_CONTROL,                    blendcntl);
+    } else {
+	EREG(accel_state->ib, CB_COLOR_CONTROL,                    (RADEON_ROP[3] |
+								    (1 << TARGET_BLEND_ENABLE_shift) |
+								    PER_MRT_BLEND_bit));
+	EREG(accel_state->ib, CB_BLEND0_CONTROL,                   blendcntl);
+    }
+
     /* Interpolator setup */
-    BEGIN_BATCH(21);
     if (pMask) {
 	/* export 2 tex coords from VS */
 	EREG(accel_state->ib, SPI_VS_OUT_CONFIG, ((2 - 1) << VS_EXPORT_COUNT_shift));
 	/* src = semantic id 0; mask = semantic id 1 */
 	EREG(accel_state->ib, SPI_VS_OUT_ID_0, ((0 << SEMANTIC_0_shift) |
 						  (1 << SEMANTIC_1_shift)));
-	/* input 2 tex coords from VS */
-	EREG(accel_state->ib, SPI_PS_IN_CONTROL_0, (2 << NUM_INTERP_shift));
     } else {
 	/* export 1 tex coords from VS */
 	EREG(accel_state->ib, SPI_VS_OUT_CONFIG, ((1 - 1) << VS_EXPORT_COUNT_shift));
 	/* src = semantic id 0 */
 	EREG(accel_state->ib, SPI_VS_OUT_ID_0,   (0 << SEMANTIC_0_shift));
-	/* input 1 tex coords from VS */
-	EREG(accel_state->ib, SPI_PS_IN_CONTROL_0, (1 << NUM_INTERP_shift));
     }
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_1,                 0);
+
+    PACK0(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 << 2), 2);
     /* SPI_PS_INPUT_CNTL_0 maps to GPR[0] - load with semantic id 0 */
-    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 <<2),       ((0    << SEMANTIC_shift)	|
-								(0x01 << DEFAULT_VAL_shift)	|
-								SEL_CENTROID_bit));
+    E32(accel_state->ib, ((0    << SEMANTIC_shift)	|
+			  (0x01 << DEFAULT_VAL_shift)	|
+			  SEL_CENTROID_bit));
     /* SPI_PS_INPUT_CNTL_1 maps to GPR[1] - load with semantic id 1 */
-    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (1 <<2),       ((1    << SEMANTIC_shift)	|
-								(0x01 << DEFAULT_VAL_shift)	|
-								SEL_CENTROID_bit));
-    EREG(accel_state->ib, SPI_INTERP_CONTROL_0,                0);
+    E32(accel_state->ib, ((1    << SEMANTIC_shift)	|
+			  (0x01 << DEFAULT_VAL_shift)	|
+			  SEL_CENTROID_bit));
+
+    PACK0(accel_state->ib, SPI_PS_IN_CONTROL_0, 3);
+    if (pMask) {
+	/* input 2 tex coords from VS */
+	E32(accel_state->ib, (2 << NUM_INTERP_shift));
+    } else {
+	/* input 1 tex coords from VS */
+	E32(accel_state->ib, (1 << NUM_INTERP_shift));
+    }
+    E32(accel_state->ib, 0);
+    E32(accel_state->ib, 0);
     END_BATCH();
 
     if (accel_state->vsync)
-	R600VlineHelperClear(pScrn);
+	RADEONVlineHelperClear(pScrn);
 
     return TRUE;
 }
@@ -1630,7 +1480,7 @@ static void R600Composite(PixmapPtr pDst,
        srcX, srcY, maskX, maskY,dstX, dstY, w, h); */
 
     if (accel_state->vsync)
-	R600VlineHelperSet(pScrn, dstX, dstY, dstX + w, dstY + h);
+	RADEONVlineHelperSet(pScrn, dstX, dstY, dstX + w, dstY + h);
 
     if (accel_state->msk_pic) {
 
@@ -1692,10 +1542,10 @@ static void R600DoneComposite(PixmapPtr pDst)
     int vtx_size;
 
     if (accel_state->vsync)
-	cp_wait_vline_sync(pScrn, accel_state->ib, pDst,
-			   accel_state->vline_crtc,
-			   accel_state->vline_y1,
-			   accel_state->vline_y2);
+       cp_wait_vline_sync(pScrn, accel_state->ib, pDst,
+                          accel_state->vline_crtc,
+                          accel_state->vline_y1,
+                          accel_state->vline_y2);
 
     vtx_size = accel_state->msk_pic ? 24 : 16;
 
@@ -1792,7 +1642,7 @@ R600CopyToVRAM(ScrnInfoPtr pScrn,
     }
 
     R600IBDiscard(pScrn, scratch);
-    r600_vb_discard(pScrn);
+    radeon_vb_discard(pScrn);
 
     return TRUE;
 }
@@ -1906,7 +1756,7 @@ R600DownloadFromScreen(PixmapPtr pSrc, int x, int y, int w, int h,
     }
 
     R600IBDiscard(pScrn, scratch);
-    r600_vb_discard(pScrn);
+    radeon_vb_discard(pScrn);
 
     return TRUE;
 
@@ -1989,7 +1839,7 @@ R600UploadToScreenCS(PixmapPtr pDst, int x, int y, int w, int h,
     radeon_bo_unmap(scratch);
 
     if (info->accel_state->vsync)
-	R600VlineHelperSet(pScrn, x, y, x + w, y + h);
+	RADEONVlineHelperSet(pScrn, x, y, x + w, y + h);
 
     /* blit from gart to vram */
     R600DoPrepareCopy(pScrn);
@@ -2222,16 +2072,12 @@ R600LoadShaders(ScrnInfoPtr pScrn)
     accel_state->comp_ps_offset = 2560;
     R600_comp_ps(ChipSet, shader + accel_state->comp_ps_offset / 4);
 
-    /*  comp mask ps --------------------------------------- */
-    accel_state->comp_mask_ps_offset = 3072;
-    R600_comp_mask_ps(ChipSet, shader + accel_state->comp_mask_ps_offset / 4);
-
     /*  xv vs --------------------------------------- */
-    accel_state->xv_vs_offset = 3584;
+    accel_state->xv_vs_offset = 3072;
     R600_xv_vs(ChipSet, shader + accel_state->xv_vs_offset / 4);
 
     /*  xv ps --------------------------------------- */
-    accel_state->xv_ps_offset = 4096;
+    accel_state->xv_ps_offset = 3584;
     R600_xv_ps(ChipSet, shader + accel_state->xv_ps_offset / 4);
 
 #ifdef XF86DRM_MODE
@@ -2305,6 +2151,9 @@ R600DrawInit(ScreenPtr pScreen)
 	info->accel_state->exa->FinishAccess = RADEONFinishAccess_CS;
 	info->accel_state->exa->UploadToScreen = R600UploadToScreenCS;
 	info->accel_state->exa->DownloadFromScreen = R600DownloadFromScreenCS;
+#if (EXA_VERSION_MAJOR == 2 && EXA_VERSION_MINOR >= 5)
+        info->accel_state->exa->CreatePixmap2 = RADEONEXACreatePixmap2;
+#endif
     } else
 #endif
 #endif
@@ -2379,7 +2228,9 @@ R600DrawInit(ScreenPtr pScreen)
     info->accel_state->dst_obj.bo = NULL;
     info->accel_state->copy_area_bo = NULL;
     info->accel_state->vb_start_op = -1;
-    R600VlineHelperClear(pScrn);
+    info->accel_state->finish_op = r600_finish_op;
+    info->accel_state->verts_per_op = 3;
+    RADEONVlineHelperClear(pScrn);
 
 #ifdef XF86DRM_MODE
     radeon_vbo_init_lists(pScrn);
diff --git a/src/r600_shader.c b/src/r600_shader.c
index 7e25f6d..e2a4163 100644
--- a/src/r600_shader.c
+++ b/src/r600_shader.c
@@ -1149,230 +1149,6 @@ int R600_xv_ps(RADEONChipFamily ChipSet, uint32_t* shader)
     return i;
 }
 
-/* comp mask ps --------------------------------------- */
-int R600_comp_mask_ps(RADEONChipFamily ChipSet, uint32_t* shader)
-{
-    int i = 0;
-
-    /* 0 */
-    shader[i++] = CF_DWORD0(ADDR(8));
-    shader[i++] = CF_DWORD1(POP_COUNT(0),
-			    CF_CONST(0),
-			    COND(SQ_CF_COND_ACTIVE),
-			    I_COUNT(2),
-			    CALL_COUNT(0),
-			    END_OF_PROGRAM(0),
-			    VALID_PIXEL_MODE(0),
-			    CF_INST(SQ_CF_INST_TEX),
-			    WHOLE_QUAD_MODE(0),
-			    BARRIER(1));
-
-    /* 1 */
-    shader[i++] = CF_ALU_DWORD0(ADDR(3),
-				KCACHE_BANK0(0),
-				KCACHE_BANK1(0),
-				KCACHE_MODE0(SQ_CF_KCACHE_NOP));
-    shader[i++] = CF_ALU_DWORD1(KCACHE_MODE1(SQ_CF_KCACHE_NOP),
-				KCACHE_ADDR0(0),
-				KCACHE_ADDR1(0),
-				I_COUNT(4),
-				USES_WATERFALL(0),
-				CF_INST(SQ_CF_INST_ALU),
-				WHOLE_QUAD_MODE(0),
-				BARRIER(1));
-
-    /* 2 */
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(CF_PIXEL_MRT0),
-					  TYPE(SQ_EXPORT_PIXEL),
-					  RW_GPR(2),
-					  RW_REL(ABSOLUTE),
-					  INDEX_GPR(0),
-					  ELEM_SIZE(1));
-
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
-					       SRC_SEL_Y(SQ_SEL_Y),
-					       SRC_SEL_Z(SQ_SEL_Z),
-					       SRC_SEL_W(SQ_SEL_W),
-					       R6xx_ELEM_LOOP(0),
-					       BURST_COUNT(1),
-					       END_OF_PROGRAM(1),
-					       VALID_PIXEL_MODE(0),
-					       CF_INST(SQ_CF_INST_EXPORT_DONE),
-					       WHOLE_QUAD_MODE(0),
-					       BARRIER(1));
-
-    /* 3 - alu 0 */
-    /* MUL gpr[2].x gpr[1].x gpr[0].x */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
-			     SRC0_REL(ABSOLUTE),
-			     SRC0_ELEM(ELEM_X),
-			     SRC0_NEG(0),
-			     SRC1_SEL(0),
-			     SRC1_REL(ABSOLUTE),
-			     SRC1_ELEM(ELEM_X),
-			     SRC1_NEG(0),
-			     INDEX_MODE(SQ_INDEX_LOOP),
-			     PRED_SEL(SQ_PRED_SEL_OFF),
-			     LAST(0));
-    shader[i++] = ALU_DWORD1_OP2(ChipSet,
-				 SRC0_ABS(0),
-				 SRC1_ABS(0),
-				 UPDATE_EXECUTE_MASK(0),
-				 UPDATE_PRED(0),
-				 WRITE_MASK(1),
-				 FOG_MERGE(0),
-				 OMOD(SQ_ALU_OMOD_OFF),
-				 ALU_INST(SQ_OP2_INST_MUL),
-				 BANK_SWIZZLE(SQ_ALU_VEC_012),
-				 DST_GPR(2),
-				 DST_REL(ABSOLUTE),
-				 DST_ELEM(ELEM_X),
-				 CLAMP(1));
-    /* 4 - alu 1 */
-    /* MUL gpr[2].y gpr[1].y gpr[0].y */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
-			     SRC0_REL(ABSOLUTE),
-			     SRC0_ELEM(ELEM_Y),
-			     SRC0_NEG(0),
-			     SRC1_SEL(0),
-			     SRC1_REL(ABSOLUTE),
-			     SRC1_ELEM(ELEM_Y),
-			     SRC1_NEG(0),
-			     INDEX_MODE(SQ_INDEX_LOOP),
-			     PRED_SEL(SQ_PRED_SEL_OFF),
-			     LAST(0));
-    shader[i++] = ALU_DWORD1_OP2(ChipSet,
-				 SRC0_ABS(0),
-				 SRC1_ABS(0),
-				 UPDATE_EXECUTE_MASK(0),
-				 UPDATE_PRED(0),
-				 WRITE_MASK(1),
-				 FOG_MERGE(0),
-				 OMOD(SQ_ALU_OMOD_OFF),
-				 ALU_INST(SQ_OP2_INST_MUL),
-				 BANK_SWIZZLE(SQ_ALU_VEC_012),
-				 DST_GPR(2),
-				 DST_REL(ABSOLUTE),
-				 DST_ELEM(ELEM_Y),
-				 CLAMP(1));
-    /* 5 - alu 2 */
-    /* MUL gpr[2].z gpr[1].z gpr[0].z */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
-			     SRC0_REL(ABSOLUTE),
-			     SRC0_ELEM(ELEM_Z),
-			     SRC0_NEG(0),
-			     SRC1_SEL(0),
-			     SRC1_REL(ABSOLUTE),
-			     SRC1_ELEM(ELEM_Z),
-			     SRC1_NEG(0),
-			     INDEX_MODE(SQ_INDEX_LOOP),
-			     PRED_SEL(SQ_PRED_SEL_OFF),
-			     LAST(0));
-    shader[i++] = ALU_DWORD1_OP2(ChipSet,
-				 SRC0_ABS(0),
-				 SRC1_ABS(0),
-				 UPDATE_EXECUTE_MASK(0),
-				 UPDATE_PRED(0),
-				 WRITE_MASK(1),
-				 FOG_MERGE(0),
-				 OMOD(SQ_ALU_OMOD_OFF),
-				 ALU_INST(SQ_OP2_INST_MUL),
-				 BANK_SWIZZLE(SQ_ALU_VEC_012),
-				 DST_GPR(2),
-				 DST_REL(ABSOLUTE),
-				 DST_ELEM(ELEM_Z),
-				 CLAMP(1));
-    /* 6 - alu 3 */
-    /* MUL gpr[2].w gpr[1].w gpr[0].w */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
-			     SRC0_REL(ABSOLUTE),
-			     SRC0_ELEM(ELEM_W),
-			     SRC0_NEG(0),
-			     SRC1_SEL(0),
-			     SRC1_REL(ABSOLUTE),
-			     SRC1_ELEM(ELEM_W),
-			     SRC1_NEG(0),
-			     INDEX_MODE(SQ_INDEX_LOOP),
-			     PRED_SEL(SQ_PRED_SEL_OFF),
-			     LAST(1));
-    shader[i++] = ALU_DWORD1_OP2(ChipSet,
-				 SRC0_ABS(0),
-				 SRC1_ABS(0),
-				 UPDATE_EXECUTE_MASK(0),
-				 UPDATE_PRED(0),
-				 WRITE_MASK(1),
-				 FOG_MERGE(0),
-				 OMOD(SQ_ALU_OMOD_OFF),
-				 ALU_INST(SQ_OP2_INST_MUL),
-				 BANK_SWIZZLE(SQ_ALU_VEC_012),
-				 DST_GPR(2),
-				 DST_REL(ABSOLUTE),
-				 DST_ELEM(ELEM_W),
-				 CLAMP(1));
-    /* 7 */
-    shader[i++] = 0x00000000;
-    shader[i++] = 0x00000000;
-
-    /* 8/9 - src */
-    shader[i++] = TEX_DWORD0(TEX_INST(SQ_TEX_INST_SAMPLE),
-			     BC_FRAC_MODE(0),
-			     FETCH_WHOLE_QUAD(0),
-			     RESOURCE_ID(0),
-			     SRC_GPR(0),
-			     SRC_REL(ABSOLUTE),
-			     R7xx_ALT_CONST(0));
-    shader[i++] = TEX_DWORD1(DST_GPR(0),
-			     DST_REL(ABSOLUTE),
-			     DST_SEL_X(SQ_SEL_X),
-			     DST_SEL_Y(SQ_SEL_Y),
-			     DST_SEL_Z(SQ_SEL_Z),
-			     DST_SEL_W(SQ_SEL_W),
-			     LOD_BIAS(0),
-			     COORD_TYPE_X(TEX_NORMALIZED),
-			     COORD_TYPE_Y(TEX_NORMALIZED),
-			     COORD_TYPE_Z(TEX_NORMALIZED),
-			     COORD_TYPE_W(TEX_NORMALIZED));
-    shader[i++] = TEX_DWORD2(OFFSET_X(0),
-			     OFFSET_Y(0),
-			     OFFSET_Z(0),
-			     SAMPLER_ID(0),
-			     SRC_SEL_X(SQ_SEL_X),
-			     SRC_SEL_Y(SQ_SEL_Y),
-			     SRC_SEL_Z(SQ_SEL_0),
-			     SRC_SEL_W(SQ_SEL_1));
-    shader[i++] = TEX_DWORD_PAD;
-    /* 10/11 - mask */
-    shader[i++] = TEX_DWORD0(TEX_INST(SQ_TEX_INST_SAMPLE),
-			     BC_FRAC_MODE(0),
-			     FETCH_WHOLE_QUAD(0),
-			     RESOURCE_ID(1),
-			     SRC_GPR(1),
-			     SRC_REL(ABSOLUTE),
-			     R7xx_ALT_CONST(0));
-    shader[i++] = TEX_DWORD1(DST_GPR(1),
-			     DST_REL(ABSOLUTE),
-			     DST_SEL_X(SQ_SEL_X),
-			     DST_SEL_Y(SQ_SEL_Y),
-			     DST_SEL_Z(SQ_SEL_Z),
-			     DST_SEL_W(SQ_SEL_W),
-			     LOD_BIAS(0),
-			     COORD_TYPE_X(TEX_NORMALIZED),
-			     COORD_TYPE_Y(TEX_NORMALIZED),
-			     COORD_TYPE_Z(TEX_NORMALIZED),
-			     COORD_TYPE_W(TEX_NORMALIZED));
-    shader[i++] = TEX_DWORD2(OFFSET_X(0),
-			     OFFSET_Y(0),
-			     OFFSET_Z(0),
-			     SAMPLER_ID(1),
-			     SRC_SEL_X(SQ_SEL_X),
-			     SRC_SEL_Y(SQ_SEL_Y),
-			     SRC_SEL_Z(SQ_SEL_0),
-			     SRC_SEL_W(SQ_SEL_1));
-    shader[i++] = TEX_DWORD_PAD;
-
-    return i;
-}
-
 /* comp vs --------------------------------------- */
 int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 {
@@ -1391,7 +1167,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                             WHOLE_QUAD_MODE(0),
                             BARRIER(0));
     /* 1 */
-    shader[i++] = CF_DWORD0(ADDR(28));
+    shader[i++] = CF_DWORD0(ADDR(9));
     shader[i++] = CF_DWORD1(POP_COUNT(0),
                             CF_CONST(0),
                             COND(SQ_CF_COND_NOT_BOOL),
@@ -1415,7 +1191,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                             WHOLE_QUAD_MODE(0),
                             BARRIER(1));
     /* 3 - mask sub */
-    shader[i++] = CF_DWORD0(ADDR(22));
+    shader[i++] = CF_DWORD0(ADDR(32));
     shader[i++] = CF_DWORD1(POP_COUNT(0),
 			    CF_CONST(0),
 			    COND(SQ_CF_COND_ACTIVE),
@@ -1428,7 +1204,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			    BARRIER(1));
 
     /* 4 - ALU */
-    shader[i++] = CF_ALU_DWORD0(ADDR(9),
+    shader[i++] = CF_ALU_DWORD0(ADDR(14),
 				KCACHE_BANK0(0),
 				KCACHE_BANK1(0),
 				KCACHE_MODE0(SQ_CF_KCACHE_NOP));
@@ -1507,32 +1283,107 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			    CF_INST(SQ_CF_INST_RETURN),
 			    WHOLE_QUAD_MODE(0),
 			    BARRIER(1));
+    /* 9 - non-mask sub */
+    shader[i++] = CF_DWORD0(ADDR(38));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+			    CF_CONST(0),
+			    COND(SQ_CF_COND_ACTIVE),
+			    I_COUNT(2),
+			    CALL_COUNT(0),
+			    END_OF_PROGRAM(0),
+			    VALID_PIXEL_MODE(0),
+			    CF_INST(SQ_CF_INST_VTX),
+			    WHOLE_QUAD_MODE(0),
+			    BARRIER(1));
 
+    /* 10 - ALU */
+    shader[i++] = CF_ALU_DWORD0(ADDR(26),
+				KCACHE_BANK0(0),
+				KCACHE_BANK1(0),
+				KCACHE_MODE0(SQ_CF_KCACHE_NOP));
+    shader[i++] = CF_ALU_DWORD1(KCACHE_MODE1(SQ_CF_KCACHE_NOP),
+				KCACHE_ADDR0(0),
+				KCACHE_ADDR1(0),
+				I_COUNT(6),
+				USES_WATERFALL(0),
+				CF_INST(SQ_CF_INST_ALU),
+				WHOLE_QUAD_MODE(0),
+				BARRIER(1));
 
-    /* 9 srcX MAD */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(256),
-                             SRC0_REL(ABSOLUTE),
-                             SRC0_ELEM(ELEM_Y),
-                             SRC0_NEG(0),
-                             SRC1_SEL(1),
-                             SRC1_REL(ABSOLUTE),
-                             SRC1_ELEM(ELEM_Y),
-                             SRC1_NEG(0),
-                             INDEX_MODE(SQ_INDEX_LOOP),
-                             PRED_SEL(SQ_PRED_SEL_OFF),
-                             LAST(1));
-    shader[i++] = ALU_DWORD1_OP3(SRC2_SEL(256),
-                                 SRC2_REL(ABSOLUTE),
-                                 SRC2_ELEM(ELEM_Z),
-                                 SRC2_NEG(0),
-                                 ALU_INST(SQ_OP3_INST_MULADD),
-                                 BANK_SWIZZLE(SQ_ALU_VEC_012),
-                                 DST_GPR(1),
-                                 DST_REL(ABSOLUTE),
-                                 DST_ELEM(ELEM_Z),
-                                 CLAMP(0));
-    /* 10 srcY MAD */
-    shader[i++] = ALU_DWORD0(SRC0_SEL(257),
+    /* 11 - dst */
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(CF_POS0),
+					  TYPE(SQ_EXPORT_POS),
+					  RW_GPR(1),
+					  RW_REL(ABSOLUTE),
+					  INDEX_GPR(0),
+					  ELEM_SIZE(0));
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
+					       SRC_SEL_Y(SQ_SEL_Y),
+					       SRC_SEL_Z(SQ_SEL_0),
+					       SRC_SEL_W(SQ_SEL_1),
+					       R6xx_ELEM_LOOP(0),
+					       BURST_COUNT(0),
+					       END_OF_PROGRAM(0),
+					       VALID_PIXEL_MODE(0),
+					       CF_INST(SQ_CF_INST_EXPORT_DONE),
+					       WHOLE_QUAD_MODE(0),
+					       BARRIER(1));
+    /* 12 - src */
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(0),
+					  TYPE(SQ_EXPORT_PARAM),
+					  RW_GPR(0),
+					  RW_REL(ABSOLUTE),
+					  INDEX_GPR(0),
+					  ELEM_SIZE(0));
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
+					       SRC_SEL_Y(SQ_SEL_Y),
+					       SRC_SEL_Z(SQ_SEL_0),
+					       SRC_SEL_W(SQ_SEL_1),
+					       R6xx_ELEM_LOOP(0),
+					       BURST_COUNT(0),
+					       END_OF_PROGRAM(0),
+					       VALID_PIXEL_MODE(0),
+					       CF_INST(SQ_CF_INST_EXPORT_DONE),
+					       WHOLE_QUAD_MODE(0),
+					       BARRIER(0));
+    /* 13 */
+    shader[i++] = CF_DWORD0(ADDR(0));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+			    CF_CONST(0),
+			    COND(SQ_CF_COND_ACTIVE),
+			    I_COUNT(0),
+			    CALL_COUNT(0),
+			    END_OF_PROGRAM(0),
+			    VALID_PIXEL_MODE(0),
+			    CF_INST(SQ_CF_INST_RETURN),
+			    WHOLE_QUAD_MODE(0),
+			    BARRIER(1));
+
+
+    /* 14 srcX MAD - mask */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(256),
+                             SRC0_REL(ABSOLUTE),
+                             SRC0_ELEM(ELEM_Y),
+                             SRC0_NEG(0),
+                             SRC1_SEL(1),
+                             SRC1_REL(ABSOLUTE),
+                             SRC1_ELEM(ELEM_Y),
+                             SRC1_NEG(0),
+                             INDEX_MODE(SQ_INDEX_LOOP),
+                             PRED_SEL(SQ_PRED_SEL_OFF),
+                             LAST(1));
+    shader[i++] = ALU_DWORD1_OP3(SRC2_SEL(256),
+                                 SRC2_REL(ABSOLUTE),
+                                 SRC2_ELEM(ELEM_Z),
+                                 SRC2_NEG(0),
+                                 ALU_INST(SQ_OP3_INST_MULADD),
+                                 BANK_SWIZZLE(SQ_ALU_VEC_012),
+                                 DST_GPR(1),
+                                 DST_REL(ABSOLUTE),
+                                 DST_ELEM(ELEM_Z),
+                                 CLAMP(0));
+    /* 15 srcY MAD */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(257),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
                              SRC0_NEG(0),
@@ -1554,7 +1405,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_W),
                                  CLAMP(0));
 
-    /* 11 srcX MAD */
+    /* 16 srcX MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(256),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1576,7 +1427,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
-    /* 12 srcY MAD */
+    /* 17 srcY MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(257),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1599,7 +1450,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
 
-    /* 13 maskX MAD */
+    /* 18 maskX MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(258),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1622,7 +1473,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_Z),
                                  CLAMP(0));
 
-    /* 14 maskY MAD */
+    /* 19 maskY MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(259),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1645,7 +1496,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_W),
                                  CLAMP(0));
 
-    /* 15 srcX MAD */
+    /* 20 srcX MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(258),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1667,7 +1518,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
-    /* 16 srcY MAD */
+    /* 21 srcY MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(259),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1690,7 +1541,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
 
-    /* 17 srcX / w */
+    /* 22 srcX / w */
     shader[i++] = ALU_DWORD0(SRC0_SEL(1),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1717,7 +1568,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
 
-    /* 18 srcY / h */
+    /* 23 srcY / h */
     shader[i++] = ALU_DWORD0(SRC0_SEL(1),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1744,7 +1595,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
 
-    /* 19 maskX / w */
+    /* 24 maskX / w */
     shader[i++] = ALU_DWORD0(SRC0_SEL(0),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -1771,7 +1622,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
 
-    /* 20 maskY / h */
+    /* 25 maskY / h */
     shader[i++] = ALU_DWORD0(SRC0_SEL(0),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1797,164 +1648,8 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
-    /* 21 */
-    shader[i++] = 0x00000000;
-    shader[i++] = 0x00000000;
-
-    /* 22/23 - dst */
-    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
-			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
-			     FETCH_WHOLE_QUAD(0),
-			     BUFFER_ID(0),
-			     SRC_GPR(0),
-			     SRC_REL(ABSOLUTE),
-			     SRC_SEL_X(SQ_SEL_X),
-			     MEGA_FETCH_COUNT(24));
-    shader[i++] = VTX_DWORD1_GPR(DST_GPR(2),
-				 DST_REL(0),
-				 DST_SEL_X(SQ_SEL_X),
-				 DST_SEL_Y(SQ_SEL_Y),
-				 DST_SEL_Z(SQ_SEL_0),
-				 DST_SEL_W(SQ_SEL_1),
-				 USE_CONST_FIELDS(0),
-				 DATA_FORMAT(FMT_32_32_FLOAT),
-				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
-				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
-				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
-    shader[i++] = VTX_DWORD2(OFFSET(0),
-			     ENDIAN_SWAP(ENDIAN_NONE),
-			     CONST_BUF_NO_STRIDE(0),
-			     MEGA_FETCH(1));
-    shader[i++] = VTX_DWORD_PAD;
-    /* 24/25 - src */
-    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
-			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
-			     FETCH_WHOLE_QUAD(0),
-			     BUFFER_ID(0),
-			     SRC_GPR(0),
-			     SRC_REL(ABSOLUTE),
-			     SRC_SEL_X(SQ_SEL_X),
-			     MEGA_FETCH_COUNT(8));
-    shader[i++] = VTX_DWORD1_GPR(DST_GPR(1),
-				 DST_REL(0),
-				 DST_SEL_X(SQ_SEL_X),
-				 DST_SEL_Y(SQ_SEL_Y),
-				 DST_SEL_Z(SQ_SEL_1),
-				 DST_SEL_W(SQ_SEL_0),
-				 USE_CONST_FIELDS(0),
-				 DATA_FORMAT(FMT_32_32_FLOAT),
-				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
-				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
-				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
-    shader[i++] = VTX_DWORD2(OFFSET(8),
-			     ENDIAN_SWAP(ENDIAN_NONE),
-			     CONST_BUF_NO_STRIDE(0),
-			     MEGA_FETCH(0));
-    shader[i++] = VTX_DWORD_PAD;
-    /* 26/27 - mask */
-    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
-			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
-			     FETCH_WHOLE_QUAD(0),
-			     BUFFER_ID(0),
-			     SRC_GPR(0),
-			     SRC_REL(ABSOLUTE),
-			     SRC_SEL_X(SQ_SEL_X),
-			     MEGA_FETCH_COUNT(8));
-    shader[i++] = VTX_DWORD1_GPR(DST_GPR(0),
-				 DST_REL(0),
-				 DST_SEL_X(SQ_SEL_X),
-				 DST_SEL_Y(SQ_SEL_Y),
-				 DST_SEL_Z(SQ_SEL_1),
-				 DST_SEL_W(SQ_SEL_0),
-				 USE_CONST_FIELDS(0),
-				 DATA_FORMAT(FMT_32_32_FLOAT),
-				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
-				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
-				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
-    shader[i++] = VTX_DWORD2(OFFSET(16),
-			     ENDIAN_SWAP(ENDIAN_NONE),
-			     CONST_BUF_NO_STRIDE(0),
-			     MEGA_FETCH(0));
-    shader[i++] = VTX_DWORD_PAD;
-
-    /* 28 - non-mask sub */
-    shader[i++] = CF_DWORD0(ADDR(40));
-    shader[i++] = CF_DWORD1(POP_COUNT(0),
-			    CF_CONST(0),
-			    COND(SQ_CF_COND_ACTIVE),
-			    I_COUNT(2),
-			    CALL_COUNT(0),
-			    END_OF_PROGRAM(0),
-			    VALID_PIXEL_MODE(0),
-			    CF_INST(SQ_CF_INST_VTX),
-			    WHOLE_QUAD_MODE(0),
-			    BARRIER(1));
-
-    /* 29 - ALU */
-    shader[i++] = CF_ALU_DWORD0(ADDR(33),
-				KCACHE_BANK0(0),
-				KCACHE_BANK1(0),
-				KCACHE_MODE0(SQ_CF_KCACHE_NOP));
-    shader[i++] = CF_ALU_DWORD1(KCACHE_MODE1(SQ_CF_KCACHE_NOP),
-				KCACHE_ADDR0(0),
-				KCACHE_ADDR1(0),
-				I_COUNT(6),
-				USES_WATERFALL(0),
-				CF_INST(SQ_CF_INST_ALU),
-				WHOLE_QUAD_MODE(0),
-				BARRIER(1));
-
-    /* 30 - dst */
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(CF_POS0),
-					  TYPE(SQ_EXPORT_POS),
-					  RW_GPR(1),
-					  RW_REL(ABSOLUTE),
-					  INDEX_GPR(0),
-					  ELEM_SIZE(0));
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
-					       SRC_SEL_Y(SQ_SEL_Y),
-					       SRC_SEL_Z(SQ_SEL_0),
-					       SRC_SEL_W(SQ_SEL_1),
-					       R6xx_ELEM_LOOP(0),
-					       BURST_COUNT(0),
-					       END_OF_PROGRAM(0),
-					       VALID_PIXEL_MODE(0),
-					       CF_INST(SQ_CF_INST_EXPORT_DONE),
-					       WHOLE_QUAD_MODE(0),
-					       BARRIER(1));
-    /* 31 - src */
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(0),
-					  TYPE(SQ_EXPORT_PARAM),
-					  RW_GPR(0),
-					  RW_REL(ABSOLUTE),
-					  INDEX_GPR(0),
-					  ELEM_SIZE(0));
-    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
-					       SRC_SEL_Y(SQ_SEL_Y),
-					       SRC_SEL_Z(SQ_SEL_0),
-					       SRC_SEL_W(SQ_SEL_1),
-					       R6xx_ELEM_LOOP(0),
-					       BURST_COUNT(0),
-					       END_OF_PROGRAM(0),
-					       VALID_PIXEL_MODE(0),
-					       CF_INST(SQ_CF_INST_EXPORT_DONE),
-					       WHOLE_QUAD_MODE(0),
-					       BARRIER(0));
-    /* 32 */
-    shader[i++] = CF_DWORD0(ADDR(0));
-    shader[i++] = CF_DWORD1(POP_COUNT(0),
-			    CF_CONST(0),
-			    COND(SQ_CF_COND_ACTIVE),
-			    I_COUNT(0),
-			    CALL_COUNT(0),
-			    END_OF_PROGRAM(0),
-			    VALID_PIXEL_MODE(0),
-			    CF_INST(SQ_CF_INST_RETURN),
-			    WHOLE_QUAD_MODE(0),
-			    BARRIER(1));
-
 
-    /* 33 srcX MAD */
+    /* 26 srcX MAD - non-mask */
     shader[i++] = ALU_DWORD0(SRC0_SEL(256),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1976,7 +1671,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_Z),
                                  CLAMP(0));
-    /* 34 srcY MAD */
+    /* 27 srcY MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(257),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -1999,7 +1694,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_W),
                                  CLAMP(0));
 
-    /* 35 srcX MAD */
+    /* 28 srcX MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(256),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -2021,7 +1716,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
-    /* 36 srcY MAD */
+    /* 29 srcY MAD */
     shader[i++] = ALU_DWORD0(SRC0_SEL(257),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -2043,7 +1738,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_REL(ABSOLUTE),
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
-    /* 37 srcX / w */
+    /* 30 srcX / w */
     shader[i++] = ALU_DWORD0(SRC0_SEL(0),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_X),
@@ -2070,7 +1765,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_X),
                                  CLAMP(0));
 
-    /* 38 srcY / h */
+    /* 31 srcY / h */
     shader[i++] = ALU_DWORD0(SRC0_SEL(0),
                              SRC0_REL(ABSOLUTE),
                              SRC0_ELEM(ELEM_Y),
@@ -2097,11 +1792,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
                                  DST_ELEM(ELEM_Y),
                                  CLAMP(0));
 
-    /* 39 */
-    shader[i++] = 0x00000000;
-    shader[i++] = 0x00000000;
-
-    /* 40/41 - dst */
+    /* 32/33 - dst - mask */
     shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
 			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
 			     FETCH_WHOLE_QUAD(0),
@@ -2109,8 +1800,8 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			     SRC_GPR(0),
 			     SRC_REL(ABSOLUTE),
 			     SRC_SEL_X(SQ_SEL_X),
-			     MEGA_FETCH_COUNT(16));
-    shader[i++] = VTX_DWORD1_GPR(DST_GPR(1),
+			     MEGA_FETCH_COUNT(24));
+    shader[i++] = VTX_DWORD1_GPR(DST_GPR(2),
 				 DST_REL(0),
 				 DST_SEL_X(SQ_SEL_X),
 				 DST_SEL_Y(SQ_SEL_Y),
@@ -2126,7 +1817,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			     CONST_BUF_NO_STRIDE(0),
 			     MEGA_FETCH(1));
     shader[i++] = VTX_DWORD_PAD;
-    /* 42/43 - src */
+    /* 34/35 - src */
     shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
 			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
 			     FETCH_WHOLE_QUAD(0),
@@ -2135,7 +1826,7 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			     SRC_REL(ABSOLUTE),
 			     SRC_SEL_X(SQ_SEL_X),
 			     MEGA_FETCH_COUNT(8));
-    shader[i++] = VTX_DWORD1_GPR(DST_GPR(0),
+    shader[i++] = VTX_DWORD1_GPR(DST_GPR(1),
 				 DST_REL(0),
 				 DST_SEL_X(SQ_SEL_X),
 				 DST_SEL_Y(SQ_SEL_Y),
@@ -2151,17 +1842,188 @@ int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* shader)
 			     CONST_BUF_NO_STRIDE(0),
 			     MEGA_FETCH(0));
     shader[i++] = VTX_DWORD_PAD;
+    /* 36/37 - mask */
+    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
+			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
+			     FETCH_WHOLE_QUAD(0),
+			     BUFFER_ID(0),
+			     SRC_GPR(0),
+			     SRC_REL(ABSOLUTE),
+			     SRC_SEL_X(SQ_SEL_X),
+			     MEGA_FETCH_COUNT(8));
+    shader[i++] = VTX_DWORD1_GPR(DST_GPR(0),
+				 DST_REL(0),
+				 DST_SEL_X(SQ_SEL_X),
+				 DST_SEL_Y(SQ_SEL_Y),
+				 DST_SEL_Z(SQ_SEL_1),
+				 DST_SEL_W(SQ_SEL_0),
+				 USE_CONST_FIELDS(0),
+				 DATA_FORMAT(FMT_32_32_FLOAT),
+				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
+				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
+				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
+    shader[i++] = VTX_DWORD2(OFFSET(16),
+			     ENDIAN_SWAP(ENDIAN_NONE),
+			     CONST_BUF_NO_STRIDE(0),
+			     MEGA_FETCH(0));
+    shader[i++] = VTX_DWORD_PAD;
 
-    return i;
-}
-
-/* comp ps --------------------------------------- */
-int R600_comp_ps(RADEONChipFamily ChipSet, uint32_t* shader)
-{
-    int i = 0;
-
-    /* 0 */
-    shader[i++] = CF_DWORD0(ADDR(2));
+    /* 38/39 - dst - non-mask */
+    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
+			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
+			     FETCH_WHOLE_QUAD(0),
+			     BUFFER_ID(0),
+			     SRC_GPR(0),
+			     SRC_REL(ABSOLUTE),
+			     SRC_SEL_X(SQ_SEL_X),
+			     MEGA_FETCH_COUNT(16));
+    shader[i++] = VTX_DWORD1_GPR(DST_GPR(1),
+				 DST_REL(0),
+				 DST_SEL_X(SQ_SEL_X),
+				 DST_SEL_Y(SQ_SEL_Y),
+				 DST_SEL_Z(SQ_SEL_0),
+				 DST_SEL_W(SQ_SEL_1),
+				 USE_CONST_FIELDS(0),
+				 DATA_FORMAT(FMT_32_32_FLOAT),
+				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
+				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
+				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
+    shader[i++] = VTX_DWORD2(OFFSET(0),
+			     ENDIAN_SWAP(ENDIAN_NONE),
+			     CONST_BUF_NO_STRIDE(0),
+			     MEGA_FETCH(1));
+    shader[i++] = VTX_DWORD_PAD;
+    /* 40/41 - src */
+    shader[i++] = VTX_DWORD0(VTX_INST(SQ_VTX_INST_FETCH),
+			     FETCH_TYPE(SQ_VTX_FETCH_VERTEX_DATA),
+			     FETCH_WHOLE_QUAD(0),
+			     BUFFER_ID(0),
+			     SRC_GPR(0),
+			     SRC_REL(ABSOLUTE),
+			     SRC_SEL_X(SQ_SEL_X),
+			     MEGA_FETCH_COUNT(8));
+    shader[i++] = VTX_DWORD1_GPR(DST_GPR(0),
+				 DST_REL(0),
+				 DST_SEL_X(SQ_SEL_X),
+				 DST_SEL_Y(SQ_SEL_Y),
+				 DST_SEL_Z(SQ_SEL_1),
+				 DST_SEL_W(SQ_SEL_0),
+				 USE_CONST_FIELDS(0),
+				 DATA_FORMAT(FMT_32_32_FLOAT),
+				 NUM_FORMAT_ALL(SQ_NUM_FORMAT_SCALED),
+				 FORMAT_COMP_ALL(SQ_FORMAT_COMP_SIGNED),
+				 SRF_MODE_ALL(SRF_MODE_ZERO_CLAMP_MINUS_ONE));
+    shader[i++] = VTX_DWORD2(OFFSET(8),
+			     ENDIAN_SWAP(ENDIAN_NONE),
+			     CONST_BUF_NO_STRIDE(0),
+			     MEGA_FETCH(0));
+    shader[i++] = VTX_DWORD_PAD;
+
+    return i;
+}
+
+/* comp ps --------------------------------------- */
+int R600_comp_ps(RADEONChipFamily ChipSet, uint32_t* shader)
+{
+    int i = 0;
+
+    /* 0 */
+    shader[i++] = CF_DWORD0(ADDR(3));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+                            CF_CONST(0),
+                            COND(SQ_CF_COND_BOOL),
+                            I_COUNT(0),
+                            CALL_COUNT(0),
+                            END_OF_PROGRAM(0),
+                            VALID_PIXEL_MODE(0),
+                            CF_INST(SQ_CF_INST_CALL),
+                            WHOLE_QUAD_MODE(0),
+                            BARRIER(0));
+    /* 1 */
+    shader[i++] = CF_DWORD0(ADDR(7));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+                            CF_CONST(0),
+                            COND(SQ_CF_COND_NOT_BOOL),
+                            I_COUNT(0),
+                            CALL_COUNT(0),
+                            END_OF_PROGRAM(0),
+                            VALID_PIXEL_MODE(0),
+                            CF_INST(SQ_CF_INST_CALL),
+                            WHOLE_QUAD_MODE(0),
+                            BARRIER(0));
+    /* 2 */
+    shader[i++] = CF_DWORD0(ADDR(0));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+                            CF_CONST(0),
+                            COND(SQ_CF_COND_ACTIVE),
+                            I_COUNT(0),
+                            CALL_COUNT(0),
+                            END_OF_PROGRAM(1),
+                            VALID_PIXEL_MODE(0),
+                            CF_INST(SQ_CF_INST_NOP),
+                            WHOLE_QUAD_MODE(0),
+                            BARRIER(1));
+
+    /* 3 - mask sub */
+    shader[i++] = CF_DWORD0(ADDR(14));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+			    CF_CONST(0),
+			    COND(SQ_CF_COND_ACTIVE),
+			    I_COUNT(2),
+			    CALL_COUNT(0),
+			    END_OF_PROGRAM(0),
+			    VALID_PIXEL_MODE(0),
+			    CF_INST(SQ_CF_INST_TEX),
+			    WHOLE_QUAD_MODE(0),
+			    BARRIER(1));
+
+    /* 4 */
+    shader[i++] = CF_ALU_DWORD0(ADDR(10),
+				KCACHE_BANK0(0),
+				KCACHE_BANK1(0),
+				KCACHE_MODE0(SQ_CF_KCACHE_NOP));
+    shader[i++] = CF_ALU_DWORD1(KCACHE_MODE1(SQ_CF_KCACHE_NOP),
+				KCACHE_ADDR0(0),
+				KCACHE_ADDR1(0),
+				I_COUNT(4),
+				USES_WATERFALL(0),
+				CF_INST(SQ_CF_INST_ALU),
+				WHOLE_QUAD_MODE(0),
+				BARRIER(1));
+
+    /* 5 */
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(CF_PIXEL_MRT0),
+					  TYPE(SQ_EXPORT_PIXEL),
+					  RW_GPR(2),
+					  RW_REL(ABSOLUTE),
+					  INDEX_GPR(0),
+					  ELEM_SIZE(1));
+    shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
+					       SRC_SEL_Y(SQ_SEL_Y),
+					       SRC_SEL_Z(SQ_SEL_Z),
+					       SRC_SEL_W(SQ_SEL_W),
+					       R6xx_ELEM_LOOP(0),
+					       BURST_COUNT(1),
+					       END_OF_PROGRAM(0),
+					       VALID_PIXEL_MODE(0),
+					       CF_INST(SQ_CF_INST_EXPORT_DONE),
+					       WHOLE_QUAD_MODE(0),
+					       BARRIER(1));
+    /* 6 */
+    shader[i++] = CF_DWORD0(ADDR(0));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+			    CF_CONST(0),
+			    COND(SQ_CF_COND_ACTIVE),
+			    I_COUNT(0),
+			    CALL_COUNT(0),
+			    END_OF_PROGRAM(0),
+			    VALID_PIXEL_MODE(0),
+			    CF_INST(SQ_CF_INST_RETURN),
+			    WHOLE_QUAD_MODE(0),
+			    BARRIER(1));
+
+    /* 7 non-mask sub */
+    shader[i++] = CF_DWORD0(ADDR(18));
     shader[i++] = CF_DWORD1(POP_COUNT(0),
 			    CF_CONST(0),
 			    COND(SQ_CF_COND_ACTIVE),
@@ -2172,28 +2034,204 @@ int R600_comp_ps(RADEONChipFamily ChipSet, uint32_t* shader)
 			    CF_INST(SQ_CF_INST_TEX),
 			    WHOLE_QUAD_MODE(0),
 			    BARRIER(1));
-    /* 1 */
+    /* 8 */
     shader[i++] = CF_ALLOC_IMP_EXP_DWORD0(ARRAY_BASE(CF_PIXEL_MRT0),
 					  TYPE(SQ_EXPORT_PIXEL),
 					  RW_GPR(0),
 					  RW_REL(ABSOLUTE),
 					  INDEX_GPR(0),
 					  ELEM_SIZE(1));
-
     shader[i++] = CF_ALLOC_IMP_EXP_DWORD1_SWIZ(SRC_SEL_X(SQ_SEL_X),
 					       SRC_SEL_Y(SQ_SEL_Y),
 					       SRC_SEL_Z(SQ_SEL_Z),
 					       SRC_SEL_W(SQ_SEL_W),
 					       R6xx_ELEM_LOOP(0),
 					       BURST_COUNT(1),
-					       END_OF_PROGRAM(1),
+					       END_OF_PROGRAM(0),
 					       VALID_PIXEL_MODE(0),
 					       CF_INST(SQ_CF_INST_EXPORT_DONE),
 					       WHOLE_QUAD_MODE(0),
 					       BARRIER(1));
+    /* 9 */
+    shader[i++] = CF_DWORD0(ADDR(0));
+    shader[i++] = CF_DWORD1(POP_COUNT(0),
+			    CF_CONST(0),
+			    COND(SQ_CF_COND_ACTIVE),
+			    I_COUNT(0),
+			    CALL_COUNT(0),
+			    END_OF_PROGRAM(0),
+			    VALID_PIXEL_MODE(0),
+			    CF_INST(SQ_CF_INST_RETURN),
+			    WHOLE_QUAD_MODE(0),
+			    BARRIER(1));
+
+    /* 10 - alu 0 */
+    /* MUL gpr[2].x gpr[1].x gpr[0].x */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
+			     SRC0_REL(ABSOLUTE),
+			     SRC0_ELEM(ELEM_X),
+			     SRC0_NEG(0),
+			     SRC1_SEL(0),
+			     SRC1_REL(ABSOLUTE),
+			     SRC1_ELEM(ELEM_X),
+			     SRC1_NEG(0),
+			     INDEX_MODE(SQ_INDEX_LOOP),
+			     PRED_SEL(SQ_PRED_SEL_OFF),
+			     LAST(0));
+    shader[i++] = ALU_DWORD1_OP2(ChipSet,
+				 SRC0_ABS(0),
+				 SRC1_ABS(0),
+				 UPDATE_EXECUTE_MASK(0),
+				 UPDATE_PRED(0),
+				 WRITE_MASK(1),
+				 FOG_MERGE(0),
+				 OMOD(SQ_ALU_OMOD_OFF),
+				 ALU_INST(SQ_OP2_INST_MUL),
+				 BANK_SWIZZLE(SQ_ALU_VEC_012),
+				 DST_GPR(2),
+				 DST_REL(ABSOLUTE),
+				 DST_ELEM(ELEM_X),
+				 CLAMP(1));
+    /* 11 - alu 1 */
+    /* MUL gpr[2].y gpr[1].y gpr[0].y */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
+			     SRC0_REL(ABSOLUTE),
+			     SRC0_ELEM(ELEM_Y),
+			     SRC0_NEG(0),
+			     SRC1_SEL(0),
+			     SRC1_REL(ABSOLUTE),
+			     SRC1_ELEM(ELEM_Y),
+			     SRC1_NEG(0),
+			     INDEX_MODE(SQ_INDEX_LOOP),
+			     PRED_SEL(SQ_PRED_SEL_OFF),
+			     LAST(0));
+    shader[i++] = ALU_DWORD1_OP2(ChipSet,
+				 SRC0_ABS(0),
+				 SRC1_ABS(0),
+				 UPDATE_EXECUTE_MASK(0),
+				 UPDATE_PRED(0),
+				 WRITE_MASK(1),
+				 FOG_MERGE(0),
+				 OMOD(SQ_ALU_OMOD_OFF),
+				 ALU_INST(SQ_OP2_INST_MUL),
+				 BANK_SWIZZLE(SQ_ALU_VEC_012),
+				 DST_GPR(2),
+				 DST_REL(ABSOLUTE),
+				 DST_ELEM(ELEM_Y),
+				 CLAMP(1));
+    /* 12 - alu 2 */
+    /* MUL gpr[2].z gpr[1].z gpr[0].z */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
+			     SRC0_REL(ABSOLUTE),
+			     SRC0_ELEM(ELEM_Z),
+			     SRC0_NEG(0),
+			     SRC1_SEL(0),
+			     SRC1_REL(ABSOLUTE),
+			     SRC1_ELEM(ELEM_Z),
+			     SRC1_NEG(0),
+			     INDEX_MODE(SQ_INDEX_LOOP),
+			     PRED_SEL(SQ_PRED_SEL_OFF),
+			     LAST(0));
+    shader[i++] = ALU_DWORD1_OP2(ChipSet,
+				 SRC0_ABS(0),
+				 SRC1_ABS(0),
+				 UPDATE_EXECUTE_MASK(0),
+				 UPDATE_PRED(0),
+				 WRITE_MASK(1),
+				 FOG_MERGE(0),
+				 OMOD(SQ_ALU_OMOD_OFF),
+				 ALU_INST(SQ_OP2_INST_MUL),
+				 BANK_SWIZZLE(SQ_ALU_VEC_012),
+				 DST_GPR(2),
+				 DST_REL(ABSOLUTE),
+				 DST_ELEM(ELEM_Z),
+				 CLAMP(1));
+    /* 13 - alu 3 */
+    /* MUL gpr[2].w gpr[1].w gpr[0].w */
+    shader[i++] = ALU_DWORD0(SRC0_SEL(1),
+			     SRC0_REL(ABSOLUTE),
+			     SRC0_ELEM(ELEM_W),
+			     SRC0_NEG(0),
+			     SRC1_SEL(0),
+			     SRC1_REL(ABSOLUTE),
+			     SRC1_ELEM(ELEM_W),
+			     SRC1_NEG(0),
+			     INDEX_MODE(SQ_INDEX_LOOP),
+			     PRED_SEL(SQ_PRED_SEL_OFF),
+			     LAST(1));
+    shader[i++] = ALU_DWORD1_OP2(ChipSet,
+				 SRC0_ABS(0),
+				 SRC1_ABS(0),
+				 UPDATE_EXECUTE_MASK(0),
+				 UPDATE_PRED(0),
+				 WRITE_MASK(1),
+				 FOG_MERGE(0),
+				 OMOD(SQ_ALU_OMOD_OFF),
+				 ALU_INST(SQ_OP2_INST_MUL),
+				 BANK_SWIZZLE(SQ_ALU_VEC_012),
+				 DST_GPR(2),
+				 DST_REL(ABSOLUTE),
+				 DST_ELEM(ELEM_W),
+				 CLAMP(1));
 
+    /* 14/15 - src - mask */
+    shader[i++] = TEX_DWORD0(TEX_INST(SQ_TEX_INST_SAMPLE),
+			     BC_FRAC_MODE(0),
+			     FETCH_WHOLE_QUAD(0),
+			     RESOURCE_ID(0),
+			     SRC_GPR(0),
+			     SRC_REL(ABSOLUTE),
+			     R7xx_ALT_CONST(0));
+    shader[i++] = TEX_DWORD1(DST_GPR(0),
+			     DST_REL(ABSOLUTE),
+			     DST_SEL_X(SQ_SEL_X),
+			     DST_SEL_Y(SQ_SEL_Y),
+			     DST_SEL_Z(SQ_SEL_Z),
+			     DST_SEL_W(SQ_SEL_W),
+			     LOD_BIAS(0),
+			     COORD_TYPE_X(TEX_NORMALIZED),
+			     COORD_TYPE_Y(TEX_NORMALIZED),
+			     COORD_TYPE_Z(TEX_NORMALIZED),
+			     COORD_TYPE_W(TEX_NORMALIZED));
+    shader[i++] = TEX_DWORD2(OFFSET_X(0),
+			     OFFSET_Y(0),
+			     OFFSET_Z(0),
+			     SAMPLER_ID(0),
+			     SRC_SEL_X(SQ_SEL_X),
+			     SRC_SEL_Y(SQ_SEL_Y),
+			     SRC_SEL_Z(SQ_SEL_0),
+			     SRC_SEL_W(SQ_SEL_1));
+    shader[i++] = TEX_DWORD_PAD;
+    /* 16/17 - mask */
+    shader[i++] = TEX_DWORD0(TEX_INST(SQ_TEX_INST_SAMPLE),
+			     BC_FRAC_MODE(0),
+			     FETCH_WHOLE_QUAD(0),
+			     RESOURCE_ID(1),
+			     SRC_GPR(1),
+			     SRC_REL(ABSOLUTE),
+			     R7xx_ALT_CONST(0));
+    shader[i++] = TEX_DWORD1(DST_GPR(1),
+			     DST_REL(ABSOLUTE),
+			     DST_SEL_X(SQ_SEL_X),
+			     DST_SEL_Y(SQ_SEL_Y),
+			     DST_SEL_Z(SQ_SEL_Z),
+			     DST_SEL_W(SQ_SEL_W),
+			     LOD_BIAS(0),
+			     COORD_TYPE_X(TEX_NORMALIZED),
+			     COORD_TYPE_Y(TEX_NORMALIZED),
+			     COORD_TYPE_Z(TEX_NORMALIZED),
+			     COORD_TYPE_W(TEX_NORMALIZED));
+    shader[i++] = TEX_DWORD2(OFFSET_X(0),
+			     OFFSET_Y(0),
+			     OFFSET_Z(0),
+			     SAMPLER_ID(1),
+			     SRC_SEL_X(SQ_SEL_X),
+			     SRC_SEL_Y(SQ_SEL_Y),
+			     SRC_SEL_Z(SQ_SEL_0),
+			     SRC_SEL_W(SQ_SEL_1));
+    shader[i++] = TEX_DWORD_PAD;
 
-    /* 2/3 - src */
+    /* 18/19 - src - non-mask */
     shader[i++] = TEX_DWORD0(TEX_INST(SQ_TEX_INST_SAMPLE),
 			     BC_FRAC_MODE(0),
 			     FETCH_WHOLE_QUAD(0),
diff --git a/src/r600_shader.h b/src/r600_shader.h
index 6c12614..a68d6c2 100644
--- a/src/r600_shader.h
+++ b/src/r600_shader.h
@@ -353,7 +353,6 @@ extern int R600_xv_vs(RADEONChipFamily ChipSet, uint32_t* shader);
 extern int R600_xv_ps(RADEONChipFamily ChipSet, uint32_t* shader);
 
 extern int R600_comp_vs(RADEONChipFamily ChipSet, uint32_t* vs);
-extern int R600_comp_mask_ps(RADEONChipFamily ChipSet, uint32_t* ps);
 extern int R600_comp_ps(RADEONChipFamily ChipSet, uint32_t* ps);
 
 #endif
diff --git a/src/r600_state.h b/src/r600_state.h
index 43dc929..151f402 100644
--- a/src/r600_state.h
+++ b/src/r600_state.h
@@ -70,6 +70,7 @@ typedef struct {
 /* Shader */
 typedef struct {
     uint64_t shader_addr;
+    uint32_t shader_size;
     int num_gprs;
     int stack_size;
     int dx10_clamp;
@@ -113,6 +114,7 @@ typedef struct {
     int format;
     uint64_t base;
     uint64_t mip_base;
+    uint32_t size;
     int format_comp_x;
     int format_comp_y;
     int format_comp_z;
@@ -283,9 +285,6 @@ start_3d(ScrnInfoPtr pScrn, drmBufPtr ib);
 void
 set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf, uint32_t domain);
 void
-cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type, uint32_t size, uint64_t mc_addr,
-		    struct radeon_bo *bo, uint32_t rdomains, uint32_t wdomain);
-void
 cp_wait_vline_sync(ScrnInfoPtr pScrn, drmBufPtr ib, PixmapPtr pPix, xf86CrtcPtr crtc, int start, int stop);
 void
 fs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *fs_conf, uint32_t domain);
@@ -298,8 +297,6 @@ set_alu_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, int count, float *co
 void
 set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val);
 void
-set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res, uint32_t domain);
-void
 set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res, uint32_t domain);
 void
 set_tex_sampler (ScrnInfoPtr pScrn, drmBufPtr ib, tex_sampler_t *s);
@@ -320,12 +317,6 @@ draw_immd(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf, uint32_t *i
 void
 draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf);
 
-Bool
-r600_vb_get(ScrnInfoPtr pScrn);
-void
-r600_vb_discard(ScrnInfoPtr pScrn);
-int
-r600_cp_start(ScrnInfoPtr pScrn);
 void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size);
 
 Bool
@@ -339,6 +330,9 @@ R600SetAccelState(ScrnInfoPtr pScrn,
 extern Bool RADEONPrepareAccess_CS(PixmapPtr pPix, int index);
 extern void RADEONFinishAccess_CS(PixmapPtr pPix, int index);
 extern void *RADEONEXACreatePixmap(ScreenPtr pScreen, int size, int align);
+extern void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
+				    int depth, int usage_hint, int bitsPerPixel,
+				    int *new_pitch);
 extern void RADEONEXADestroyPixmap(ScreenPtr pScreen, void *driverPriv);
 extern struct radeon_bo *radeon_get_pixmap_bo(PixmapPtr pPix);
 extern Bool RADEONEXAPixmapIsOffscreen(PixmapPtr pPix);
diff --git a/src/r600_textured_videofuncs.c b/src/r600_textured_videofuncs.c
index 2a86df3..e18a9c8 100644
--- a/src/r600_textured_videofuncs.c
+++ b/src/r600_textured_videofuncs.c
@@ -45,6 +45,7 @@
 
 #include "damage.h"
 
+#include "radeon_exa_shared.h"
 #include "radeon_vbo.h"
 
 /* Parameters for ITU-R BT.601 and ITU-R BT.709 colour spaces
@@ -206,7 +207,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 #endif
 
     radeon_vbo_check(pScrn, 16);
-    r600_cp_start(pScrn);
+    radeon_cp_start(pScrn);
 
     set_default_state(pScrn, accel_state->ib);
 
@@ -228,24 +229,15 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     }
 
     /* Shader */
-
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->vs_size, accel_state->vs_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     vs_conf.shader_addr         = accel_state->vs_mc_addr;
+    vs_conf.shader_size         = accel_state->vs_size;
     vs_conf.num_gprs            = 2;
     vs_conf.stack_size          = 0;
     vs_conf.bo                  = accel_state->shaders_bo;
     vs_setup                    (pScrn, accel_state->ib, &vs_conf, RADEON_GEM_DOMAIN_VRAM);
 
-    /* flush SQ cache */
-    cp_set_surface_sync(pScrn, accel_state->ib, SH_ACTION_ENA_bit,
-			accel_state->ps_size, accel_state->ps_mc_addr,
-			accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
-
     ps_conf.shader_addr         = accel_state->ps_mc_addr;
+    ps_conf.shader_size         = accel_state->ps_size;
     ps_conf.num_gprs            = 3;
     ps_conf.stack_size          = 1;
     ps_conf.uncached_first_inst = 1;
@@ -264,11 +256,6 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     case FOURCC_I420:
 	accel_state->src_size[0] = accel_state->src_obj[0].pitch * pPriv->h;
 
-	/* flush texture cache */
-	cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit, accel_state->src_size[0],
-			    accel_state->src_obj[0].offset,
-			    accel_state->src_obj[0].bo, accel_state->src_obj[0].domain, 0);
-
 	/* Y texture */
 	tex_res.id                  = 0;
 	tex_res.w                   = accel_state->src_obj[0].width;
@@ -278,6 +265,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.dim                 = SQ_TEX_DIM_2D;
 	tex_res.base                = accel_state->src_obj[0].offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset;
+	tex_res.size                = accel_state->src_size[0];
 	tex_res.bo                  = accel_state->src_obj[0].bo;
 	tex_res.mip_bo              = accel_state->src_obj[0].bo;
 
@@ -309,11 +297,6 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	set_tex_sampler             (pScrn, accel_state->ib, &tex_samp);
 
 	/* U or V texture */
-	cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit,
-			    accel_state->src_size[0] / 4,
-			    accel_state->src_obj[0].offset + pPriv->planev_offset,
-			    accel_state->src_obj[0].bo, accel_state->src_obj[0].domain, 0);
-
 	tex_res.id                  = 1;
 	tex_res.format              = FMT_8;
 	tex_res.w                   = accel_state->src_obj[0].width >> 1;
@@ -327,6 +310,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planev_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planev_offset;
+	tex_res.size                = accel_state->src_size[0] / 4;
 	set_tex_resource            (pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* U or V sampler */
@@ -334,11 +318,6 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	set_tex_sampler             (pScrn, accel_state->ib, &tex_samp);
 
 	/* U or V texture */
-	cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit,
-			    accel_state->src_size[0] / 4,
-			    accel_state->src_obj[0].offset + pPriv->planeu_offset,
-			    accel_state->src_obj[0].bo, accel_state->src_obj[0].domain, 0);
-
 	tex_res.id                  = 2;
 	tex_res.format              = FMT_8;
 	tex_res.w                   = accel_state->src_obj[0].width >> 1;
@@ -352,6 +331,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planeu_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planeu_offset;
+	tex_res.size                = accel_state->src_size[0] / 4;
 	set_tex_resource            (pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -363,11 +343,6 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     default:
 	accel_state->src_size[0] = accel_state->src_obj[0].pitch * pPriv->h;
 
-	/* flush texture cache */
-	cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit, accel_state->src_size[0],
-			    accel_state->src_obj[0].offset,
-			    accel_state->src_obj[0].bo, accel_state->src_obj[0].domain, 0);
-
 	/* Y texture */
 	tex_res.id                  = 0;
 	tex_res.w                   = accel_state->src_obj[0].width;
@@ -377,6 +352,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.dim                 = SQ_TEX_DIM_2D;
 	tex_res.base                = accel_state->src_obj[0].offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset;
+	tex_res.size                = accel_state->src_size[0];
 	tex_res.bo                  = accel_state->src_obj[0].bo;
 	tex_res.mip_bo              = accel_state->src_obj[0].bo;
 
@@ -429,6 +405,7 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 
 	tex_res.base                = accel_state->src_obj[0].offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset;
+	tex_res.size                = accel_state->src_size[0];
 	set_tex_resource            (pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -437,12 +414,6 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	break;
     }
 
-    /* Render setup */
-    BEGIN_BATCH(6);
-    EREG(accel_state->ib, CB_TARGET_MASK,                      (0x0f << TARGET0_ENABLE_shift));
-    EREG(accel_state->ib, CB_COLOR_CONTROL,                    (0xcc << ROP3_shift)); /* copy */
-    END_BATCH();
-
     cb_conf.id = 0;
     cb_conf.w = accel_state->dst_obj.pitch;
     cb_conf.h = accel_state->dst_obj.height;
@@ -471,20 +442,25 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     cb_conf.blend_clamp = 1;
     set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
+    /* Render setup */
+    BEGIN_BATCH(20);
+    EREG(accel_state->ib, CB_TARGET_MASK,                      (0x0f << TARGET0_ENABLE_shift));
+    EREG(accel_state->ib, CB_COLOR_CONTROL,                    (0xcc << ROP3_shift)); /* copy */
+
     /* Interpolator setup */
     /* export tex coords from VS */
-    BEGIN_BATCH(18);
     EREG(accel_state->ib, SPI_VS_OUT_CONFIG, ((1 - 1) << VS_EXPORT_COUNT_shift));
     EREG(accel_state->ib, SPI_VS_OUT_ID_0, (0 << SEMANTIC_0_shift));
+    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 << 2),       ((0    << SEMANTIC_shift)	|
+								(0x03 << DEFAULT_VAL_shift)	|
+								SEL_CENTROID_bit));
 
     /* Enabling flat shading needs both FLAT_SHADE_bit in SPI_PS_INPUT_CNTL_x
      * *and* FLAT_SHADE_ENA_bit in SPI_INTERP_CONTROL_0 */
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_0,                 ((1 << NUM_INTERP_shift)));
-    EREG(accel_state->ib, SPI_PS_IN_CONTROL_1,                 0);
-    EREG(accel_state->ib, SPI_PS_INPUT_CNTL_0 + (0 <<2),       ((0    << SEMANTIC_shift)	|
-								(0x03 << DEFAULT_VAL_shift)	|
-								SEL_CENTROID_bit));
-    EREG(accel_state->ib, SPI_INTERP_CONTROL_0,                0);
+    PACK0(accel_state->ib, SPI_PS_IN_CONTROL_0, 3);
+    E32(accel_state->ib, ((1 << NUM_INTERP_shift)));
+    E32(accel_state->ib, 0);
+    E32(accel_state->ib, 0);
     END_BATCH();
 
     vs_alu_consts[0] = 1.0 / pPriv->w;
diff --git a/src/r6xx_accel.c b/src/r6xx_accel.c
index 0edfe8b..86817bd 100644
--- a/src/r6xx_accel.c
+++ b/src/r6xx_accel.c
@@ -39,6 +39,7 @@
 
 #include "radeon_drm.h"
 #include "radeon_vbo.h"
+#include "radeon_exa_shared.h"
 
 /* we try and batch operations together under KMS -
    but it doesn't work yet without misrendering */
@@ -85,34 +86,9 @@ void R600CPFlushIndirect(ScrnInfoPtr pScrn, drmBufPtr ib)
 void R600IBDiscard(ScrnInfoPtr pScrn, drmBufPtr ib)
 {
 #if defined(XF86DRM_MODE)
-    int ret;
     RADEONInfoPtr info = RADEONPTR(pScrn);
     if (info->cs) {
-	if (info->accel_state->ib_reset_op) {
-	    /* if we have data just reset the CS and ignore the operation */
-	    info->cs->cdw = info->accel_state->ib_reset_op;
-	    info->accel_state->ib_reset_op = 0;
-	    return;
-	}
-	if (info->accel_state->vb_ptr) {
-	    info->accel_state->vb_ptr = NULL;
-	}
-
-	info->accel_state->vb_offset = 0;
-	info->accel_state->vb_start_op = -1;
-
-	if (CS_FULL(info->cs)) {
-	    radeon_cs_flush_indirect(pScrn);
-	    return;
-	}
-	radeon_cs_erase(info->cs);
-	ret = radeon_cs_space_check(info->cs);
-	if (ret)
-	    ErrorF("space check failed in flush\n");
-	if (info->dri2.enabled) {
-		info->accel_state->XInited3D = FALSE;
-		info->accel_state->engineMode = EXA_ENGINEMODE_UNKNOWN;
-	}
+        radeon_ib_discard(pScrn);
     }
 #endif
     if (!ib) return;
@@ -282,19 +258,24 @@ set_render_target(ScrnInfoPtr pScrn, drmBufPtr ib, cb_config_t *cb_conf, uint32_
     EREG(ib, (CB_COLOR0_FRAG + (4 * cb_conf->id)), (0     >> 8));	// FMASK per-tile data base/256
     RELOC_BATCH(cb_conf->bo, 0, domain);
     END_BATCH();
-    BEGIN_BATCH(12);
+    BEGIN_BATCH(9);
     // pitch only for ARRAY_LINEAR_GENERAL, other tiling modes require addrlib
     EREG(ib, (CB_COLOR0_SIZE + (4 * cb_conf->id)), ((pitch << PITCH_TILE_MAX_shift)	|
 						    (slice << SLICE_TILE_MAX_shift)));
     EREG(ib, (CB_COLOR0_VIEW + (4 * cb_conf->id)), ((0    << SLICE_START_shift)		|
 						    (0    << SLICE_MAX_shift)));
-    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
     EREG(ib, (CB_COLOR0_MASK + (4 * cb_conf->id)), ((0    << CMASK_BLOCK_MAX_shift)	|
 						    (0    << FMASK_TILE_MAX_shift)));
     END_BATCH();
+
+    BEGIN_BATCH(3 + 2);
+    EREG(ib, (CB_COLOR0_INFO + (4 * cb_conf->id)), cb_color_info);
+    RELOC_BATCH(cb_conf->bo, 0, domain);
+    END_BATCH();
+
 }
 
-void
+static void
 cp_set_surface_sync(ScrnInfoPtr pScrn, drmBufPtr ib, uint32_t sync_type, uint32_t size, uint64_t mc_addr,
 		    struct radeon_bo *bo, uint32_t rdomains, uint32_t wdomain)
 {
@@ -437,6 +418,11 @@ vs_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *vs_conf, uint32_t dom
     if (vs_conf->uncached_first_inst)
 	sq_pgm_resources |= UNCACHED_FIRST_INST_bit;
 
+    /* flush SQ cache */
+    cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
+			vs_conf->shader_size, vs_conf->shader_addr,
+			vs_conf->bo, domain, 0);
+
     BEGIN_BATCH(3 + 2);
     EREG(ib, SQ_PGM_START_VS, vs_conf->shader_addr >> 8);
     RELOC_BATCH(vs_conf->bo, domain, 0);
@@ -466,6 +452,11 @@ ps_setup(ScrnInfoPtr pScrn, drmBufPtr ib, shader_config_t *ps_conf, uint32_t dom
     if (ps_conf->clamp_consts)
 	sq_pgm_resources |= CLAMP_CONSTS_bit;
 
+    /* flush SQ cache */
+    cp_set_surface_sync(pScrn, ib, SH_ACTION_ENA_bit,
+			ps_conf->shader_size, ps_conf->shader_addr,
+			ps_conf->bo, domain, 0);
+
     BEGIN_BATCH(3 + 2);
     EREG(ib, SQ_PGM_START_PS, ps_conf->shader_addr >> 8);
     RELOC_BATCH(ps_conf->bo, domain, 0);
@@ -504,10 +495,11 @@ set_bool_consts(ScrnInfoPtr pScrn, drmBufPtr ib, int offset, uint32_t val)
     END_BATCH();
 }
 
-void
+static void
 set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res, uint32_t domain)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state;
     uint32_t sq_vtx_constant_word2;
 
     sq_vtx_constant_word2 = ((((res->vb_addr) >> 32) & BASE_ADDRESS_HI_mask) |
@@ -524,6 +516,22 @@ set_vtx_resource(ScrnInfoPtr pScrn, drmBufPtr ib, vtx_resource_t *res, uint32_t
     if (res->srf_mode_all)
 	    sq_vtx_constant_word2 |= SQ_VTX_CONSTANT_WORD2_0__SRF_MODE_ALL_bit;
 
+    /* flush vertex cache */
+    if ((info->ChipFamily == CHIP_FAMILY_RV610) ||
+	(info->ChipFamily == CHIP_FAMILY_RV620) ||
+	(info->ChipFamily == CHIP_FAMILY_RS780) ||
+	(info->ChipFamily == CHIP_FAMILY_RS880) ||
+	(info->ChipFamily == CHIP_FAMILY_RV710))
+	cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
+			    accel_state->vb_offset, accel_state->vb_mc_addr,
+			    res->bo,
+			    domain, 0);
+    else
+	cp_set_surface_sync(pScrn, ib, VC_ACTION_ENA_bit,
+			    accel_state->vb_offset, accel_state->vb_mc_addr,
+			    res->bo,
+			    domain, 0);
+
     BEGIN_BATCH(9 + 2);
     PACK0(ib, SQ_VTX_RESOURCE + res->id * SQ_VTX_RESOURCE_offset, 7);
     E32(ib, res->vb_addr & 0xffffffff);				// 0: BASE_ADDRESS
@@ -590,6 +598,11 @@ set_tex_resource(ScrnInfoPtr pScrn, drmBufPtr ib, tex_resource_t *tex_res, uint3
     if (tex_res->interlaced)
 	sq_tex_resource_word6 |= INTERLACED_bit;
 
+    /* flush texture cache */
+    cp_set_surface_sync(pScrn, ib, TC_ACTION_ENA_bit,
+			tex_res->size, tex_res->base,
+			tex_res->bo, domain, 0);
+
     BEGIN_BATCH(9 + 4);
     PACK0(ib, SQ_TEX_RESOURCE + tex_res->id * SQ_TEX_RESOURCE_offset, 7);
     E32(ib, sq_tex_resource_word0);
@@ -877,7 +890,13 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
 
     sq_setup(pScrn, ib, &sq_conf);
 
-    BEGIN_BATCH(83);
+    /* set fake reloc for unused depth */
+    BEGIN_BATCH(3 + 2);
+    EREG(ib, DB_DEPTH_INFO, 0);
+    RELOC_BATCH(accel_state->shaders_bo, RADEON_GEM_DOMAIN_VRAM, 0);
+    END_BATCH();
+
+    BEGIN_BATCH(80);
     if (info->ChipFamily < CHIP_FAMILY_RV770) {
 	EREG(ib, TA_CNTL_AUX, (( 3 << GRADIENT_CREDIT_shift) |
 				 - (28 << TD_FIFO_CREDIT_shift)));
@@ -920,7 +939,6 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
     E32(ib, 0); // SQ_GS_VERT_ITEMSIZE
 
     // DB
-    EREG(ib, DB_DEPTH_INFO,                       0);
     EREG(ib, DB_DEPTH_CONTROL,                    0);
     PACK0(ib, DB_RENDER_CONTROL, 2);
     E32(ib, STENCIL_COMPRESS_DISABLE_bit | DEPTH_COMPRESS_DISABLE_bit);
@@ -1038,7 +1056,7 @@ set_default_state(ScrnInfoPtr pScrn, drmBufPtr ib)
     // VGT
     BEGIN_BATCH(43);
     PACK0(ib, VGT_MAX_VTX_INDX, 4);
-    E32(ib, 2048); /* XXX set to a reasonably large number of indices */ // VGT_MAX_VTX_INDX
+    E32(ib, 0xffffff); // VGT_MAX_VTX_INDX
     E32(ib, 0); // VGT_MIN_VTX_INDX
     E32(ib, 0); // VGT_INDX_OFFSET
     E32(ib, 0); // VGT_MULTI_PRIM_IB_RESET_INDX
@@ -1138,57 +1156,6 @@ draw_auto(ScrnInfoPtr pScrn, drmBufPtr ib, draw_config_t *draw_conf)
     END_BATCH();
 }
 
-Bool
-r600_vb_get(ScrnInfoPtr pScrn)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    struct radeon_accel_state *accel_state = info->accel_state;
-
-    accel_state->vb_mc_addr = info->gartLocation + info->dri->bufStart +
-	(accel_state->ib->idx*accel_state->ib->total)+
-	(accel_state->ib->total / 2);
-    accel_state->vb_total = (accel_state->ib->total / 2);
-    accel_state->vb_ptr = (pointer)((char*)accel_state->ib->address +
-				    (accel_state->ib->total / 2));
-    accel_state->vb_offset = 0;
-    return TRUE;
-}
-
-void
-r600_vb_discard(ScrnInfoPtr pScrn)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-
-    info->accel_state->vb_start_op = -1;
-}
-
-
-
-int
-r600_cp_start(ScrnInfoPtr pScrn)
-{
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    struct radeon_accel_state *accel_state = info->accel_state;
-
-#if defined(XF86DRM_MODE)
-    if (info->cs) {
-	if (CS_FULL(info->cs)) {
-	    radeon_cs_flush_indirect(pScrn);
-	}
-	accel_state->ib_reset_op = info->cs->cdw;
-	accel_state->vb_start_op = accel_state->vb_offset;
-    } else
-#endif
-    {
-	accel_state->ib = RADEONCPGetBuffer(pScrn);
-	if (!r600_vb_get(pScrn)) {
-	    return -1;
-	}
-	accel_state->vb_start_op = accel_state->vb_offset;
-    }
-    return 0;
-}
-
 void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size)
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
@@ -1204,26 +1171,10 @@ void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size)
 
     if (accel_state->vb_offset == accel_state->vb_start_op) {
         R600IBDiscard(pScrn, accel_state->ib);
-	r600_vb_discard(pScrn);
+	radeon_vb_discard(pScrn);
 	return;
     }
 
-    /* flush vertex cache */
-    if ((info->ChipFamily == CHIP_FAMILY_RV610) ||
-	(info->ChipFamily == CHIP_FAMILY_RV620) ||
-	(info->ChipFamily == CHIP_FAMILY_RS780) ||
-	(info->ChipFamily == CHIP_FAMILY_RS880) ||
-	(info->ChipFamily == CHIP_FAMILY_RV710))
-	cp_set_surface_sync(pScrn, accel_state->ib, TC_ACTION_ENA_bit,
-			    accel_state->vb_offset, accel_state->vb_mc_addr,
-			    accel_state->vb_bo,
-			    RADEON_GEM_DOMAIN_GTT, 0);
-    else
-	cp_set_surface_sync(pScrn, accel_state->ib, VC_ACTION_ENA_bit,
-			    accel_state->vb_offset, accel_state->vb_mc_addr,
-			    accel_state->vb_bo,
-			    RADEON_GEM_DOMAIN_GTT, 0);
-
     /* Vertex buffer setup */
     accel_state->vb_size = accel_state->vb_offset - accel_state->vb_start_op;
     vtx_res.id              = SQ_VTX_RESOURCE_vs;
@@ -1260,31 +1211,3 @@ void r600_finish_op(ScrnInfoPtr pScrn, int vtx_size)
 	R600CPFlushIndirect(pScrn, accel_state->ib);
 }
 
-void r600_vb_no_space(ScrnInfoPtr pScrn, int vert_size)
-{
-#ifdef XF86DRM_MODE
-    RADEONInfoPtr info = RADEONPTR(pScrn);
-    struct radeon_accel_state *accel_state = info->accel_state; 
-
-    if (info->cs) {
-	if (accel_state->vb_bo) {
-	    if (accel_state->vb_start_op != accel_state->vb_offset) { 
-		r600_finish_op(pScrn, vert_size);
-		accel_state->ib_reset_op = info->cs->cdw;
-	    }
-	    
-	    /* release the current VBO */
-	    radeon_vbo_put(pScrn);
-	}
-	
-	/* get a new one */
-	radeon_vbo_get(pScrn);
-	return;
-    }
-#endif 
-
-    if (accel_state->vb_start_op != -1) {
-	r600_finish_op(pScrn, vert_size);
-	r600_cp_start(pScrn);
-    }
-}
diff --git a/src/radeon.h b/src/radeon.h
index 56bc076..134a4cf 100644
--- a/src/radeon.h
+++ b/src/radeon.h
@@ -721,7 +721,7 @@ struct radeon_accel_state {
     uint32_t          *draw_header;
     unsigned          vtx_count;
     unsigned          num_vtx;
-
+    unsigned          verts_per_op;
     Bool              vsync;
 
     drmBufPtr         ib;
@@ -741,7 +741,7 @@ struct radeon_accel_state {
     struct radeon_dma_bo bo_reserved;
     Bool use_vbos;
 #endif
-
+    void (*finish_op)(ScrnInfoPtr, int);
     // shader storage
     ExaOffscreenArea  *shaders;
     struct radeon_bo  *shaders_bo;
@@ -751,7 +751,6 @@ struct radeon_accel_state {
     uint32_t          copy_ps_offset;
     uint32_t          comp_vs_offset;
     uint32_t          comp_ps_offset;
-    uint32_t          comp_mask_ps_offset;
     uint32_t          xv_vs_offset;
     uint32_t          xv_ps_offset;
 
@@ -873,6 +872,8 @@ typedef struct {
     Bool              ddc2;
 
     RADEONPLLRec      pll;
+    int               default_dispclk;
+    int               dp_extclk;
 
     int               RamWidth;
     float	      sclk;		/* in MHz */
@@ -1036,6 +1037,12 @@ typedef struct {
     uint64_t vram_size;
     uint64_t gart_size;
     drmmode_rec drmmode;
+    /* r6xx+ tile config */
+    uint32_t tile_config;
+    int group_bytes;
+    int num_channels;
+    int num_banks;
+    int r7xx_bank_op;
 #else
     /* fake bool */
     Bool cs;
diff --git a/src/radeon_atombios.c b/src/radeon_atombios.c
index 996e6ee..61b5372 100644
--- a/src/radeon_atombios.c
+++ b/src/radeon_atombios.c
@@ -2307,6 +2307,13 @@ RADEONGetATOMClockInfo(ScrnInfoPtr pScrn)
 	    pll->pll_out_min = 64800;
     }
 
+    if (IS_DCE4_VARIANT) {
+	info->default_dispclk =
+	    le32_to_cpu(atomDataPtr->FirmwareInfo.FirmwareInfo_V_2_1->ulDefaultDispEngineClkFreq);
+	if (info->default_dispclk == 0)
+	    info->default_dispclk = 60000;
+	info->dp_extclk = le16_to_cpu(atomDataPtr->FirmwareInfo.FirmwareInfo_V_2_1->usUniphyDPModeExtClkFreq);
+    }
     return TRUE;
 }
 
diff --git a/src/radeon_atombios.h b/src/radeon_atombios.h
index 1f21c46..866c4bf 100644
--- a/src/radeon_atombios.h
+++ b/src/radeon_atombios.h
@@ -194,6 +194,7 @@ typedef struct _atomDataTables
         ATOM_FIRMWARE_INFO_V1_2         *FirmwareInfo_V_1_2;
         ATOM_FIRMWARE_INFO_V1_3         *FirmwareInfo_V_1_3;
         ATOM_FIRMWARE_INFO_V1_4         *FirmwareInfo_V_1_4;
+        ATOM_FIRMWARE_INFO_V2_1         *FirmwareInfo_V_2_1;
     } FirmwareInfo;
     ATOM_DAC_INFO                       *DAC_Info;
     union {
@@ -287,4 +288,5 @@ radeon_add_encoder(ScrnInfoPtr pScrn, uint32_t encoder_id, uint32_t device_suppo
 extern uint32_t
 radeon_get_encoder_id_from_supported_device(ScrnInfoPtr pScrn, uint32_t supported_device, int dac);
 
+void atombios_set_output_crtc_source(xf86OutputPtr output);
 #endif /*  RHD_ATOMBIOS_H_ */
diff --git a/src/radeon_chipinfo_gen.h b/src/radeon_chipinfo_gen.h
index 3fc2a53..239c017 100644
--- a/src/radeon_chipinfo_gen.h
+++ b/src/radeon_chipinfo_gen.h
@@ -382,6 +382,8 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x6888, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
  { 0x6889, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
  { 0x688A, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
+ { 0x688C, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
+ { 0x688D, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
  { 0x6898, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
  { 0x6899, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
  { 0x689E, CHIP_FAMILY_CYPRESS, 0, 0, 0, 0, 0 },
@@ -411,6 +413,7 @@ static RADEONCardInfo RADEONCards[] = {
  { 0x68E8, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
  { 0x68E9, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
  { 0x68F1, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
+ { 0x68F2, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
  { 0x68F8, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
  { 0x68F9, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
  { 0x68FE, CHIP_FAMILY_CEDAR, 0, 0, 0, 0, 0 },
diff --git a/src/radeon_chipset_gen.h b/src/radeon_chipset_gen.h
index e38579b..1ea8b36 100644
--- a/src/radeon_chipset_gen.h
+++ b/src/radeon_chipset_gen.h
@@ -382,6 +382,8 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_CYPRESS_6888, "ATI FirePro (FireGL) Graphics Adapter" },
   { PCI_CHIP_CYPRESS_6889, "ATI FirePro (FireGL) Graphics Adapter" },
   { PCI_CHIP_CYPRESS_688A, "ATI FirePro (FireGL) Graphics Adapter" },
+  { PCI_CHIP_CYPRESS_688C, "AMD Firestream 9370" },
+  { PCI_CHIP_CYPRESS_688D, "AMD Firestream 9350" },
   { PCI_CHIP_CYPRESS_6898, "ATI Radeon HD 5800 Series" },
   { PCI_CHIP_CYPRESS_6899, "ATI Radeon HD 5800 Series" },
   { PCI_CHIP_CYPRESS_689E, "ATI Radeon HD 5800 Series" },
@@ -406,11 +408,12 @@ static SymTabRec RADEONChipsets[] = {
   { PCI_CHIP_REDWOOD_68DE, "REDWOOD" },
   { PCI_CHIP_CEDAR_68E0, "ATI Mobility Radeon HD 5000 Series" },
   { PCI_CHIP_CEDAR_68E1, "ATI Mobility Radeon HD 5000 Series" },
-  { PCI_CHIP_CEDAR_68E4, "CEDAR" },
-  { PCI_CHIP_CEDAR_68E5, "CEDAR" },
+  { PCI_CHIP_CEDAR_68E4, "ATI Mobility Radeon Graphics" },
+  { PCI_CHIP_CEDAR_68E5, "ATI Mobility Radeon Graphics" },
   { PCI_CHIP_CEDAR_68E8, "CEDAR" },
   { PCI_CHIP_CEDAR_68E9, "ATI FirePro (FireGL) Graphics Adapter" },
   { PCI_CHIP_CEDAR_68F1, "ATI FirePro (FireGL) Graphics Adapter" },
+  { PCI_CHIP_CEDAR_68F2, "ATI FirePro 2270" },
   { PCI_CHIP_CEDAR_68F8, "CEDAR" },
   { PCI_CHIP_CEDAR_68F9, "ATI Radeon HD 5450" },
   { PCI_CHIP_CEDAR_68FE, "CEDAR" },
diff --git a/src/radeon_cursor.c b/src/radeon_cursor.c
index 538c8b2..8eff9d1 100644
--- a/src/radeon_cursor.c
+++ b/src/radeon_cursor.c
@@ -225,7 +225,7 @@ radeon_crtc_hide_cursor (xf86CrtcPtr crtc)
     if (IS_DCE4_VARIANT) {
 	evergreen_lock_cursor(crtc, TRUE);
 	evergreen_setup_cursor(crtc, FALSE);
-	evergreen_lock_cursor(crtc, TRUE);
+	evergreen_lock_cursor(crtc, FALSE);
     } else if (IS_AVIVO_VARIANT) {
 	avivo_lock_cursor(crtc, TRUE);
 	avivo_setup_cursor(crtc, FALSE);
@@ -265,7 +265,12 @@ radeon_crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
     if (yorigin >= CURSOR_HEIGHT) yorigin = CURSOR_HEIGHT - 1;
 
     if (IS_DCE4_VARIANT) {
-	/* XXX - does evergreen need a similar hack as below? */
+	/* avivo cursor spans the full fb width */
+	if (crtc->rotatedData == NULL) {
+	    x += crtc->x;
+	    y += crtc->y;
+	}
+
 	evergreen_lock_cursor(crtc, TRUE);
 	OUTREG(EVERGREEN_CUR_POSITION + radeon_crtc->crtc_offset, ((xorigin ? 0 : x) << 16)
 	       | (yorigin ? 0 : y));
diff --git a/src/radeon_dri2.c b/src/radeon_dri2.c
index a0ed085..4cafbc6 100644
--- a/src/radeon_dri2.c
+++ b/src/radeon_dri2.c
@@ -101,13 +101,25 @@ radeon_dri2_create_buffers(DrawablePtr drawable,
 	    switch(attachments[i]) {
 	    case DRI2BufferDepth:
 	    case DRI2BufferDepthStencil:
-		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
+		if (info->ChipFamily >= CHIP_FAMILY_R600)
+		    /* macro is the preferred setting, but the 2D detiling for software
+		     * fallbacks in mesa still has issues on some configurations
+		     */
+		    flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
+		else
+		    flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
 		break;
 	    case DRI2BufferBackLeft:
 	    case DRI2BufferBackRight:
 	    case DRI2BufferFakeFrontLeft:
 	    case DRI2BufferFakeFrontRight:
-		flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
+		if (info->ChipFamily >= CHIP_FAMILY_R600)
+		    /* macro is the preferred setting, but the 2D detiling for software
+		     * fallbacks in mesa still has issues on some configurations
+		     */
+		    flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
+		else
+		    flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
 		break;
 	    default:
 		flags = 0;
@@ -183,13 +195,25 @@ radeon_dri2_create_buffer(DrawablePtr drawable,
 	switch(attachment) {
 	case DRI2BufferDepth:
 	case DRI2BufferDepthStencil:
-	    flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
+	    /* macro is the preferred setting, but the 2D detiling for software
+	     * fallbacks in mesa still has issues on some configurations
+	     */
+	    if (info->ChipFamily >= CHIP_FAMILY_R600)
+		flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
+	    else
+		flags = RADEON_CREATE_PIXMAP_TILING_MACRO | RADEON_CREATE_PIXMAP_TILING_MICRO;
 	    break;
 	case DRI2BufferBackLeft:
 	case DRI2BufferBackRight:
 	case DRI2BufferFakeFrontLeft:
 	case DRI2BufferFakeFrontRight:
-	    flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
+	    if (info->ChipFamily >= CHIP_FAMILY_R600)
+		/* macro is the preferred setting, but the 2D detiling for software
+		 * fallbacks in mesa still has issues on some configurations
+		 */
+		flags = RADEON_CREATE_PIXMAP_TILING_MICRO;
+	    else
+		flags = RADEON_CREATE_PIXMAP_TILING_MACRO;
 	    break;
 	default:
 	    flags = 0;
diff --git a/src/radeon_exa.c b/src/radeon_exa.c
index d7fba65..814c864 100644
--- a/src/radeon_exa.c
+++ b/src/radeon_exa.c
@@ -42,6 +42,7 @@
 #include "radeon_macros.h"
 #include "radeon_probe.h"
 #include "radeon_version.h"
+#include "radeon_exa_shared.h"
 
 #include "xf86.h"
 
@@ -50,26 +51,6 @@
 #define RINFO_FROM_SCREEN(pScr) ScrnInfoPtr pScrn =  xf86Screens[pScr->myNum]; \
     RADEONInfoPtr info   = RADEONPTR(pScrn)
 
-#define RADEON_TRACE_FALL 0
-#define RADEON_TRACE_DRAW 0
-
-#if RADEON_TRACE_FALL
-#define RADEON_FALLBACK(x)     		\
-do {					\
-	ErrorF("%s: ", __FUNCTION__);	\
-	ErrorF x;			\
-	return FALSE;			\
-} while (0)
-#else
-#define RADEON_FALLBACK(x) return FALSE
-#endif
-
-#if RADEON_TRACE_DRAW
-#define TRACE do { ErrorF("TRACE: %s\n", __FUNCTION__); } while(0)
-#else
-#define TRACE
-#endif
-
 static struct {
     int rop;
     int pattern;
@@ -121,18 +102,6 @@ static __inline__ uint32_t F_TO_DW(float val)
 }
 
 
-#ifdef XF86DRM_MODE
-
-static inline void radeon_add_pixmap(struct radeon_cs *cs, PixmapPtr pPix, int read_domains, int write_domain)
-{
-    struct radeon_exa_pixmap_priv *driver_priv = exaGetPixmapDriverPrivate(pPix);
-
-    radeon_cs_space_add_persistent_bo(cs, driver_priv->bo, read_domains, write_domain);
-}
-
-#endif /* XF86DRM_MODE */
-
-
 /* Assumes that depth 15 and 16 can be used as depth 16, which is okay since we
  * require src and dest datatypes to be equal.
  */
@@ -461,11 +430,27 @@ void *RADEONEXACreatePixmap2(ScreenPtr pScreen, int width, int height,
         tiling &= ~RADEON_TILING_MACRO;
     }
 
-    if (tiling) {
-	height = RADEON_ALIGN(height, 16);
-	pixmap_align = 256;
-    } else
-	pixmap_align = 64;
+    if (info->ChipFamily >= CHIP_FAMILY_R600) {
+	int bpe = bitsPerPixel / 8;
+
+	if (tiling & RADEON_TILING_MACRO) {
+	    height = RADEON_ALIGN(height, info->num_banks * 8);
+	    pixmap_align = MAX(info->num_banks,
+			       (((info->group_bytes / 8) / bpe) * info->num_banks)) * 8 * bpe;
+	} else if (tiling & RADEON_TILING_MICRO) {
+	    height = RADEON_ALIGN(height, 8);
+	    pixmap_align = MAX(8, (info->group_bytes / (8 * bpe))) * bpe;
+	} else {
+	    height = RADEON_ALIGN(height, 8);
+	    pixmap_align = 256; /* 8 * bpe */
+	}
+    } else {
+	if (tiling) {
+	    height = RADEON_ALIGN(height, 16);
+	    pixmap_align = 256;
+	} else
+	    pixmap_align = 64;
+    }
 
     padded_width = ((width * bitsPerPixel + FB_MASK) >> FB_SHIFT) * sizeof(FbBits);
     padded_width = RADEON_ALIGN(padded_width, pixmap_align);
diff --git a/src/radeon_exa_render.c b/src/radeon_exa_render.c
index cf773b0..da72416 100644
--- a/src/radeon_exa_render.c
+++ b/src/radeon_exa_render.c
@@ -496,14 +496,6 @@ static Bool FUNC_NAME(R100TextureSetup)(PicturePtr pPict, PixmapPtr pPix,
 
 #ifdef ONLY_ONCE
 
-PixmapPtr
-RADEONGetDrawablePixmap(DrawablePtr pDrawable)
-{
-    if (pDrawable->type == DRAWABLE_WINDOW)
-	return pDrawable->pScreen->GetWindowPixmap((WindowPtr)pDrawable);
-    else
-	return (PixmapPtr)pDrawable;
-}
 
 static Bool R100CheckComposite(int op, PicturePtr pSrcPicture,
 			       PicturePtr pMaskPicture, PicturePtr pDstPicture)
diff --git a/src/radeon_exa_shared.c b/src/radeon_exa_shared.c
new file mode 100644
index 0000000..d1926f4
--- /dev/null
+++ b/src/radeon_exa_shared.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2005 Eric Anholt
+ * Copyright 2005 Benjamin Herrenschmidt
+ * Copyright 2008 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <anholt@FreeBSD.org>
+ *    Zack Rusin <zrusin@trolltech.com>
+ *    Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *    Alex Deucher <alexander.deucher@amd.com>
+ *    Matthias Hopf <mhopf@suse.de>
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "radeon.h"
+#ifdef XF86DRI
+#include "radeon_drm.h"
+#endif
+#include "radeon_macros.h"
+#include "radeon_probe.h"
+#include "radeon_version.h"
+#include "radeon_vbo.h"
+
+PixmapPtr
+RADEONGetDrawablePixmap(DrawablePtr pDrawable)
+{
+    if (pDrawable->type == DRAWABLE_WINDOW)
+	return pDrawable->pScreen->GetWindowPixmap((WindowPtr)pDrawable);
+    else
+	return (PixmapPtr)pDrawable;
+}
+
+void RADEONVlineHelperClear(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state;
+
+    accel_state->vline_crtc = NULL;
+    accel_state->vline_y1 = -1;
+    accel_state->vline_y2 = 0;
+}
+
+void RADEONVlineHelperSet(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state;
+
+    accel_state->vline_crtc = radeon_pick_best_crtc(pScrn, x1, x2, y1, y2);
+    if (accel_state->vline_y1 == -1)
+	accel_state->vline_y1 = y1;
+    if (y1 < accel_state->vline_y1)
+	accel_state->vline_y1 = y1;
+    if (y2 > accel_state->vline_y2)
+	accel_state->vline_y2 = y2;
+}
+
+Bool RADEONValidPM(uint32_t pm, int bpp)
+{
+    uint8_t r, g, b, a;
+    Bool ret = FALSE;
+
+    switch (bpp) {
+    case 8:
+	a = pm & 0xff;
+	if ((a == 0) || (a == 0xff))
+	    ret = TRUE;
+	break;
+    case 16:
+	r = (pm >> 11) & 0x1f;
+	g = (pm >> 5) & 0x3f;
+	b = (pm >> 0) & 0x1f;
+	if (((r == 0) || (r == 0x1f)) &&
+	    ((g == 0) || (g == 0x3f)) &&
+	    ((b == 0) || (b == 0x1f)))
+	    ret = TRUE;
+	break;
+    case 32:
+	a = (pm >> 24) & 0xff;
+	r = (pm >> 16) & 0xff;
+	g = (pm >> 8) & 0xff;
+	b = (pm >> 0) & 0xff;
+	if (((a == 0) || (a == 0xff)) &&
+	    ((r == 0) || (r == 0xff)) &&
+	    ((g == 0) || (g == 0xff)) &&
+	    ((b == 0) || (b == 0xff)))
+	    ret = TRUE;
+	break;
+    default:
+	break;
+    }
+    return ret;
+}
+
+Bool RADEONCheckBPP(int bpp)
+{
+	switch (bpp) {
+	case 8:
+	case 16:
+	case 32:
+		return TRUE;
+	default:
+		break;
+	}
+	return FALSE;
+}
+
+static Bool radeon_vb_get(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state;
+
+    accel_state->vb_mc_addr = info->gartLocation + info->dri->bufStart +
+	(accel_state->ib->idx*accel_state->ib->total)+
+	(accel_state->ib->total / 2);
+    accel_state->vb_total = (accel_state->ib->total / 2);
+    accel_state->vb_ptr = (pointer)((char*)accel_state->ib->address +
+				    (accel_state->ib->total / 2));
+    accel_state->vb_offset = 0;
+    return TRUE;
+}
+
+void radeon_vb_discard(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+
+    info->accel_state->vb_start_op = -1;
+}
+
+int radeon_cp_start(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state;
+
+#if defined(XF86DRM_MODE)
+    if (info->cs) {
+	if (CS_FULL(info->cs)) {
+	    radeon_cs_flush_indirect(pScrn);
+	}
+	accel_state->ib_reset_op = info->cs->cdw;
+	accel_state->vb_start_op = accel_state->vb_offset;
+    } else
+#endif
+    {
+	accel_state->ib = RADEONCPGetBuffer(pScrn);
+	if (!radeon_vb_get(pScrn)) {
+	    return -1;
+	}
+	accel_state->vb_start_op = accel_state->vb_offset;
+    }
+    return 0;
+}
+
+void radeon_vb_no_space(ScrnInfoPtr pScrn, int vert_size)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    struct radeon_accel_state *accel_state = info->accel_state; 
+
+#if defined(XF86DRM_MODE)
+    if (info->cs) {
+	if (accel_state->vb_bo) {
+	    if (accel_state->vb_start_op != accel_state->vb_offset) { 
+		accel_state->finish_op(pScrn, vert_size);
+		accel_state->ib_reset_op = info->cs->cdw;
+	    }
+
+	    /* release the current VBO */
+	    radeon_vbo_put(pScrn);
+	}
+	/* get a new one */
+	radeon_vbo_get(pScrn);
+	return;
+    }
+#endif
+    if (accel_state->vb_start_op != -1) {
+        accel_state->finish_op(pScrn, vert_size);
+        radeon_cp_start(pScrn);
+    }
+    return;
+}
+
+#if defined(XF86DRM_MODE)
+void radeon_ib_discard(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr info = RADEONPTR(pScrn);
+    int ret;
+
+    if (info->accel_state->ib_reset_op) {
+        /* if we have data just reset the CS and ignore the operation */
+	info->cs->cdw = info->accel_state->ib_reset_op;
+	info->accel_state->ib_reset_op = 0;
+	goto out;
+    }
+
+    info->accel_state->vb_offset = 0;
+    info->accel_state->vb_start_op = -1;
+
+    if (CS_FULL(info->cs)) {
+	radeon_cs_flush_indirect(pScrn);
+	return;
+    }
+    radeon_cs_erase(info->cs);
+    ret = radeon_cs_space_check_with_bo(info->cs,
+					info->accel_state->vb_bo,
+					RADEON_GEM_DOMAIN_GTT, 0);
+    if (ret)
+	ErrorF("space check failed in flush\n");
+
+ out:
+    if (info->dri2.enabled) {
+	info->accel_state->XInited3D = FALSE;
+	info->accel_state->engineMode = EXA_ENGINEMODE_UNKNOWN;
+    }
+
+}
+#endif
diff --git a/src/radeon_exa_shared.h b/src/radeon_exa_shared.h
new file mode 100644
index 0000000..71068b1
--- /dev/null
+++ b/src/radeon_exa_shared.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2005 Eric Anholt
+ * Copyright 2005 Benjamin Herrenschmidt
+ * Copyright 2008 Advanced Micro Devices, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <anholt@FreeBSD.org>
+ *    Zack Rusin <zrusin@trolltech.com>
+ *    Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *    Alex Deucher <alexander.deucher@amd.com>
+ *    Matthias Hopf <mhopf@suse.de>
+ */
+#ifndef RADEON_EXA_SHARED_H
+
+#define RADEON_EXA_SHARED_H
+
+extern PixmapPtr RADEONGetDrawablePixmap(DrawablePtr pDrawable);
+
+extern void RADEONVlineHelperClear(ScrnInfoPtr pScrn);
+extern void RADEONVlineHelperSet(ScrnInfoPtr pScrn, int x1, int y1, int x2, int y2);
+extern Bool RADEONValidPM(uint32_t pm, int bpp);
+extern Bool RADEONCheckBPP(int bpp);
+
+#define RADEON_TRACE_FALL 0
+#define RADEON_TRACE_DRAW 0
+
+#if RADEON_TRACE_FALL
+#define RADEON_FALLBACK(x)     		\
+do {					\
+	ErrorF("%s: ", __FUNCTION__);	\
+	ErrorF x;			\
+	return FALSE;			\
+} while (0)
+#else
+#define RADEON_FALLBACK(x) return FALSE
+#endif
+
+#if RADEON_TRACE_DRAW
+#define TRACE do { ErrorF("TRACE: %s\n", __FUNCTION__); } while(0)
+#else
+#define TRACE
+#endif
+
+#ifdef XF86DRM_MODE
+static inline void radeon_add_pixmap(struct radeon_cs *cs, PixmapPtr pPix, int read_domains, int write_domain)
+{
+    struct radeon_exa_pixmap_priv *driver_priv = exaGetPixmapDriverPrivate(pPix);
+
+    radeon_cs_space_add_persistent_bo(cs, driver_priv->bo, read_domains, write_domain);
+}
+
+extern void radeon_ib_discard(ScrnInfoPtr pScrn);
+#endif /* XF86DRM_MODE */
+
+extern void radeon_vb_discard(ScrnInfoPtr pScrn);
+extern int radeon_cp_start(ScrnInfoPtr pScrn);
+extern void radeon_vb_no_space(ScrnInfoPtr pScrn, int vert_size);
+extern void radeon_vbo_done_composite(PixmapPtr pDst);
+
+#endif
diff --git a/src/radeon_kms.c b/src/radeon_kms.c
index c0d2ae6..ba13071 100644
--- a/src/radeon_kms.c
+++ b/src/radeon_kms.c
@@ -82,9 +82,6 @@ void radeon_cs_flush_indirect(ScrnInfoPtr pScrn)
     if (!info->cs->cdw)
 	return;
 
-    if (info->accel_state->vb_ptr)
-      info->accel_state->vb_ptr = NULL;
-
     /* release the current VBO so we don't block on mapping it later */
     if (info->accel_state->vb_offset && info->accel_state->vb_bo) {
         radeon_vbo_put(pScrn);
@@ -424,6 +421,74 @@ static Bool radeon_open_drm_master(ScrnInfoPtr pScrn)
     return TRUE;
 }
 
+static Bool r600_get_tile_config(ScrnInfoPtr pScrn)
+{
+    RADEONInfoPtr  info   = RADEONPTR(pScrn);
+    struct drm_radeon_info ginfo;
+    int r;
+    uint32_t tmp;
+
+    if (info->ChipFamily < CHIP_FAMILY_R600)
+	return FALSE;
+
+#ifndef RADEON_INFO_TILING_CONFIG
+#define RADEON_INFO_TILING_CONFIG 0x6
+#endif
+
+    memset(&ginfo, 0, sizeof(ginfo));
+    ginfo.request = RADEON_INFO_TILING_CONFIG;
+    ginfo.value = (uintptr_t)&tmp;
+    r = drmCommandWriteRead(info->dri->drmFD, DRM_RADEON_INFO, &ginfo, sizeof(ginfo));
+    if (r)
+	return FALSE;
+
+    info->tile_config = tmp;
+    info->r7xx_bank_op = 0;
+    if (info->ChipFamily >= CHIP_FAMILY_CEDAR) {
+	/* for now */
+	return FALSE;
+    } else {
+	switch((info->tile_config & 0xe) >> 1) {
+	case 0:
+	    info->num_channels = 1;
+	    break;
+	case 1:
+	    info->num_channels = 2;
+	    break;
+	case 2:
+	    info->num_channels = 4;
+	    break;
+	case 3:
+	    info->num_channels = 8;
+	    break;
+	default:
+	    return FALSE;
+	}
+	switch((info->tile_config & 0x30) >> 4) {
+	case 0:
+	    info->num_banks = 4;
+	    break;
+	case 1:
+	    info->num_banks = 8;
+	    break;
+	default:
+	    return FALSE;
+	}
+	switch((info->tile_config & 0xc0) >> 6) {
+	case 0:
+	    info->group_bytes = 256;
+	    break;
+	case 1:
+	    info->group_bytes = 512;
+	    break;
+	default:
+	    return FALSE;
+	}
+    }
+
+    return TRUE;
+}
+
 Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
 {
     RADEONInfoPtr     info;
@@ -487,18 +552,6 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
     if (!radeon_alloc_dri(pScrn))
 	return FALSE;
 
-    colorTilingDefault = info->ChipFamily >= CHIP_FAMILY_R300 &&
-                         info->ChipFamily <= CHIP_FAMILY_RS740;
-
-    info->allowColorTiling = xf86ReturnOptValBool(info->Options,
-                                        OPTION_COLOR_TILING, colorTilingDefault);
-    if (info->ChipFamily >= CHIP_FAMILY_R600) {
-	    xf86DrvMsg(pScrn->scrnIndex, X_WARNING, "Color tiling is not yet supported on R600/R700\n");
-	    info->allowColorTiling = FALSE;
-    }
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-	 "KMS Color Tiling: %sabled\n", info->allowColorTiling ? "en" : "dis");
-
     if (radeon_open_drm_master(pScrn) == FALSE) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
 	goto fail;
@@ -512,6 +565,25 @@ Bool RADEONPreInit_KMS(ScrnInfoPtr pScrn, int flags)
 	goto fail;
     }
 
+    colorTilingDefault = info->ChipFamily >= CHIP_FAMILY_R300 &&
+                         info->ChipFamily <= CHIP_FAMILY_RS740;
+
+    if (info->ChipFamily >= CHIP_FAMILY_R600) {
+	if (info->dri->pKernelDRMVersion->version_minor >= 6) {
+	    info->allowColorTiling = xf86ReturnOptValBool(info->Options,
+							  OPTION_COLOR_TILING, colorTilingDefault);
+	    if (info->allowColorTiling)
+		info->allowColorTiling = r600_get_tile_config(pScrn);
+	} else
+	    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+		       "R6xx+ KMS Color Tiling requires radeon drm 2.6.0 or newer\n");
+    } else
+	info->allowColorTiling = xf86ReturnOptValBool(info->Options,
+						      OPTION_COLOR_TILING, colorTilingDefault);
+
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+	 "KMS Color Tiling: %sabled\n", info->allowColorTiling ? "en" : "dis");
+
     if (drmmode_pre_init(pScrn, &info->drmmode, pScrn->bitsPerPixel / 8) == FALSE) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Kernel modesetting setup failed\n");
 	goto fail;
@@ -1041,8 +1113,10 @@ static Bool radeon_setup_kernel_mem(ScreenPtr pScreen)
                 ErrorF("Failed to map cursor buffer memory\n");
             }
         }
+	/* no tiled scanout on r6xx+ yet */
         if (info->allowColorTiling) {
-	    tiling_flags |= RADEON_TILING_MACRO;
+	    if (info->ChipFamily < CHIP_FAMILY_R600)
+		tiling_flags |= RADEON_TILING_MACRO;
         }
 #if X_BYTE_ORDER == X_BIG_ENDIAN
 	switch (cpp) {
diff --git a/src/radeon_output.c b/src/radeon_output.c
index 172b871..a0a682f 100644
--- a/src/radeon_output.c
+++ b/src/radeon_output.c
@@ -734,6 +734,9 @@ radeon_mode_prepare(xf86OutputPtr output)
     radeon_dpms(output, DPMSModeOff);
     radeon_crtc_dpms(output->crtc, DPMSModeOff);
 
+    if (IS_AVIVO_VARIANT || info->r4xx_atom)
+        atombios_set_output_crtc_source(output);
+
 }
 
 static void
@@ -2100,10 +2103,6 @@ void RADEONInitConnector(xf86OutputPtr output)
     else
 	radeon_output->rmx_type = RMX_OFF;
 
-    /* dce 3.2 chips have problems with low dot clocks, so use the scaler */
-    if (IS_DCE32_VARIANT && (radeon_output->devices & (ATOM_DEVICE_DFP_SUPPORT)))
-	radeon_output->rmx_type = RMX_FULL;
-
     if (!IS_AVIVO_VARIANT) {
 	if (radeon_output->devices & (ATOM_DEVICE_CRT2_SUPPORT)) {
 	    if (xf86ReturnOptValBool(info->Options, OPTION_TVDAC_LOAD_DETECT, FALSE))
diff --git a/src/radeon_pci_chipset_gen.h b/src/radeon_pci_chipset_gen.h
index c1ead9c..fe9919d 100644
--- a/src/radeon_pci_chipset_gen.h
+++ b/src/radeon_pci_chipset_gen.h
@@ -382,6 +382,8 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_CYPRESS_6888, PCI_CHIP_CYPRESS_6888, RES_SHARED_VGA },
  { PCI_CHIP_CYPRESS_6889, PCI_CHIP_CYPRESS_6889, RES_SHARED_VGA },
  { PCI_CHIP_CYPRESS_688A, PCI_CHIP_CYPRESS_688A, RES_SHARED_VGA },
+ { PCI_CHIP_CYPRESS_688C, PCI_CHIP_CYPRESS_688C, RES_SHARED_VGA },
+ { PCI_CHIP_CYPRESS_688D, PCI_CHIP_CYPRESS_688D, RES_SHARED_VGA },
  { PCI_CHIP_CYPRESS_6898, PCI_CHIP_CYPRESS_6898, RES_SHARED_VGA },
  { PCI_CHIP_CYPRESS_6899, PCI_CHIP_CYPRESS_6899, RES_SHARED_VGA },
  { PCI_CHIP_CYPRESS_689E, PCI_CHIP_CYPRESS_689E, RES_SHARED_VGA },
@@ -411,6 +413,7 @@ PciChipsets RADEONPciChipsets[] = {
  { PCI_CHIP_CEDAR_68E8, PCI_CHIP_CEDAR_68E8, RES_SHARED_VGA },
  { PCI_CHIP_CEDAR_68E9, PCI_CHIP_CEDAR_68E9, RES_SHARED_VGA },
  { PCI_CHIP_CEDAR_68F1, PCI_CHIP_CEDAR_68F1, RES_SHARED_VGA },
+ { PCI_CHIP_CEDAR_68F2, PCI_CHIP_CEDAR_68F2, RES_SHARED_VGA },
  { PCI_CHIP_CEDAR_68F8, PCI_CHIP_CEDAR_68F8, RES_SHARED_VGA },
  { PCI_CHIP_CEDAR_68F9, PCI_CHIP_CEDAR_68F9, RES_SHARED_VGA },
  { PCI_CHIP_CEDAR_68FE, PCI_CHIP_CEDAR_68FE, RES_SHARED_VGA },
diff --git a/src/radeon_pci_device_match_gen.h b/src/radeon_pci_device_match_gen.h
index 709d8cc..14e516f 100644
--- a/src/radeon_pci_device_match_gen.h
+++ b/src/radeon_pci_device_match_gen.h
@@ -382,6 +382,8 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_6888, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_6889, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_688A, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_688C, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_688D, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_6898, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_6899, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CYPRESS_689E, 0 ),
@@ -411,6 +413,7 @@ static const struct pci_id_match radeon_device_match[] = {
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68E8, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68E9, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68F1, 0 ),
+ ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68F2, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68F8, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68F9, 0 ),
  ATI_DEVICE_MATCH( PCI_CHIP_CEDAR_68FE, 0 ),
diff --git a/src/radeon_vbo.h b/src/radeon_vbo.h
index a8c70b3..b505f66 100644
--- a/src/radeon_vbo.h
+++ b/src/radeon_vbo.h
@@ -2,7 +2,7 @@
 #ifndef RADEON_VBO_H
 #define RADEON_VBO_H
 
-extern void r600_vb_no_space(ScrnInfoPtr pScrn, int vert_size);
+extern void radeon_vb_no_space(ScrnInfoPtr pScrn, int vert_size);
 extern void radeon_vbo_init_lists(ScrnInfoPtr pScrn);
 extern void radeon_vbo_free_lists(ScrnInfoPtr pScrn);
 extern void radeon_vbo_flush_bos(ScrnInfoPtr pScrn);
@@ -14,8 +14,8 @@ static inline void radeon_vbo_check(ScrnInfoPtr pScrn, int vert_size)
     RADEONInfoPtr info = RADEONPTR(pScrn);
     struct radeon_accel_state *accel_state = info->accel_state;
 
-    if ((accel_state->vb_offset + (3 * vert_size)) > accel_state->vb_total) {
-	r600_vb_no_space(pScrn, vert_size);
+    if ((accel_state->vb_offset + (accel_state->verts_per_op * vert_size)) > accel_state->vb_total) {
+	radeon_vb_no_space(pScrn, vert_size);
     }
 }
 
@@ -28,9 +28,8 @@ radeon_vbo_space(ScrnInfoPtr pScrn, int vert_size)
     
     /* we've ran out of space in the vertex buffer - need to get a
        new one */
-    if ((accel_state->vb_offset + (3 * vert_size)) > accel_state->vb_total) {
-	r600_vb_no_space(pScrn, vert_size);
-    }
+    radeon_vbo_check(pScrn, vert_size);
+
     accel_state->vb_op_vert_size = vert_size;
 #if defined(XF86DRM_MODE)
     if (info->cs) {
@@ -56,7 +55,7 @@ static inline void radeon_vbo_commit(ScrnInfoPtr pScrn)
     RADEONInfoPtr info = RADEONPTR(pScrn);
     struct radeon_accel_state *accel_state = info->accel_state;
 
-    accel_state->vb_offset += 3 * accel_state->vb_op_vert_size;
+    accel_state->vb_offset += accel_state->verts_per_op * accel_state->vb_op_vert_size;
 }
 
 #endif
