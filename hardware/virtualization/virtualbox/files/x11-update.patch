Index: src/VBox/Additions/x11/vboxvideo/vboxvideo_68.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo_68.c
+++ /dev/null
@@ -1,1353 +0,0 @@
-/** @file
- *
- * Linux Additions X11 graphics driver
- */
-
-/*
- * Copyright (C) 2006-2007 Oracle Corporation
- *
- * This file is part of VirtualBox Open Source Edition (OSE), as
- * available from http://www.virtualbox.org. This file is free software;
- * you can redistribute it and/or modify it under the terms of the GNU
- * General Public License (GPL) as published by the Free Software
- * Foundation, in version 2 as it comes in the "COPYING" file of the
- * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
- * --------------------------------------------------------------------
- *
- * This code is based on:
- *
- * X11 VESA driver
- *
- * Copyright (c) 2000 by Conectiva S.A. (http://www.conectiva.com)
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * CONECTIVA LINUX BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- * Except as contained in this notice, the name of Conectiva Linux shall
- * not be used in advertising or otherwise to promote the sale, use or other
- * dealings in this Software without prior written authorization from
- * Conectiva Linux.
- *
- * Authors: Paulo César Pereira de Andrade <pcpa@conectiva.com.br>
- */
-
-#define DEBUG_VERB 2
-
-#include "vboxvideo_68.h"
-#include "version-generated.h"
-#include "product-generated.h"
-
-/* All drivers initialising the SW cursor need this */
-#include "mipointer.h"
-
-/* All drivers implementing backing store need this */
-#include "mibstore.h"
-
-/* Colormap handling */
-#include "micmap.h"
-#include "xf86cmap.h"
-
-/* DPMS */
-/* #define DPMS_SERVER
-#include "extensions/dpms.h" */
-
-/* Mandatory functions */
-
-static const OptionInfoRec * VBOXAvailableOptions(int chipid, int busid);
-static void VBOXIdentify(int flags);
-static Bool VBOXProbe(DriverPtr drv, int flags);
-static Bool VBOXPreInit(ScrnInfoPtr pScrn, int flags);
-static Bool VBOXScreenInit(int Index, ScreenPtr pScreen, int argc,
-                           char **argv);
-static Bool VBOXEnterVT(int scrnIndex, int flags);
-static void VBOXLeaveVT(int scrnIndex, int flags);
-static Bool VBOXCloseScreen(int scrnIndex, ScreenPtr pScreen);
-static Bool VBOXSaveScreen(ScreenPtr pScreen, int mode);
-static Bool VBOXSwitchMode(int scrnIndex, DisplayModePtr pMode, int flags);
-static Bool VBOXSetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode);
-static void VBOXAdjustFrame(int scrnIndex, int x, int y, int flags);
-static void VBOXFreeScreen(int scrnIndex, int flags);
-static void VBOXFreeRec(ScrnInfoPtr pScrn);
-static void VBOXDisplayPowerManagementSet(ScrnInfoPtr pScrn, int mode,
-                                          int flags);
-
-/* locally used functions */
-static Bool VBOXMapVidMem(ScrnInfoPtr pScrn);
-static void VBOXUnmapVidMem(ScrnInfoPtr pScrn);
-static void VBOXLoadPalette(ScrnInfoPtr pScrn, int numColors,
-                            int *indices,
-                            LOCO *colors, VisualPtr pVisual);
-static void SaveFonts(ScrnInfoPtr pScrn);
-static void RestoreFonts(ScrnInfoPtr pScrn);
-static Bool VBOXSaveRestore(ScrnInfoPtr pScrn,
-                            vbeSaveRestoreFunction function);
-
-/* Initialise DGA */
-
-static Bool VBOXDGAInit(ScrnInfoPtr pScrn, ScreenPtr pScreen);
-
-/*
- * This contains the functions needed by the server after loading the
- * driver module.  It must be supplied, and gets added the driver list by
- * the Module Setup funtion in the dynamic case.  In the static case a
- * reference to this is compiled in, and this requires that the name of
- * this DriverRec be an upper-case version of the driver name.
- */
-
-DriverRec VBOXDRV = {
-    VBOX_VERSION,
-    VBOX_DRIVER_NAME,
-    VBOXIdentify,
-    VBOXProbe,
-    VBOXAvailableOptions,
-    NULL,
-    0
-};
-
-/* Supported chipsets */
-static SymTabRec VBOXChipsets[] =
-{
-    {VBOX_VESA_DEVICEID, "vbox"},
-    {-1,	 NULL}
-};
-
-static PciChipsets VBOXPCIchipsets[] = {
-  { VBOX_DEVICEID, VBOX_DEVICEID, RES_SHARED_VGA },
-  { -1,		-1,		    RES_UNDEFINED },
-};
-
-typedef enum {
-    OPTION_SHADOW_FB
-} VBOXOpts;
-
-/* No options for now */
-static const OptionInfoRec VBOXOptions[] = {
-    { -1,		NULL,		OPTV_NONE,	{0},	FALSE }
-};
-
-/*
- * List of symbols from other modules that this module references.  This
- * list is used to tell the loader that it is OK for symbols here to be
- * unresolved providing that it hasn't been told that they haven't been
- * told that they are essential via a call to xf86LoaderReqSymbols() or
- * xf86LoaderReqSymLists().  The purpose is this is to avoid warnings about
- * unresolved symbols that are not required.
- */
-static const char *fbSymbols[] = {
-    "fbPictureInit",
-    "fbScreenInit",
-    NULL
-};
-
-static const char *shadowfbSymbols[] = {
-  "ShadowFBInit2",
-  NULL
-};
-
-static const char *vbeSymbols[] = {
-    "VBEFreeModeInfo",
-    "VBEGetModeInfo",
-    "VBEGetVBEInfo",
-    "VBEGetVBEMode",
-    "VBEInit",
-    "VBESaveRestore",
-    "VBESetDisplayStart",
-    "VBESetGetDACPaletteFormat",
-    "VBESetGetLogicalScanlineLength",
-    "VBESetGetPaletteData",
-    "VBESetVBEMode",
-    "vbeDoEDID",
-    "vbeFree",
-    NULL
-};
-
-static const char *ramdacSymbols[] = {
-    "xf86InitCursor",
-    "xf86CreateCursorInfoRec",
-    NULL
-};
-
-#ifdef XFree86LOADER
-/* Module loader interface */
-static MODULESETUPPROTO(vboxSetup);
-
-static XF86ModuleVersionInfo vboxVersionRec =
-{
-    VBOX_DRIVER_NAME,
-    VBOX_VENDOR,
-    MODINFOSTRING1,
-    MODINFOSTRING2,
-    XF86_VERSION_CURRENT,
-    1,                          /* Module major version. Xorg-specific */
-    0,                          /* Module minor version. Xorg-specific */
-    0,                          /* Module patchlevel. Xorg-specific */
-    ABI_CLASS_VIDEODRV,	        /* This is a video driver */
-    ABI_VIDEODRV_VERSION,
-    MOD_CLASS_VIDEODRV,
-    {0, 0, 0, 0}
-};
-
-/*
- * This data is accessed by the loader.  The name must be the module name
- * followed by "ModuleData".
- */
-XF86ModuleData vboxvideoModuleData = { &vboxVersionRec, vboxSetup, NULL };
-
-static pointer
-vboxSetup(pointer Module, pointer Options, int *ErrorMajor, int *ErrorMinor)
-{
-    static Bool Initialised = FALSE;
-
-    if (!Initialised)
-    {
-        Initialised = TRUE;
-        xf86AddDriver(&VBOXDRV, Module, 0);
-        LoaderRefSymLists(fbSymbols,
-                          shadowfbSymbols,
-                          vbeSymbols,
-                          ramdacSymbols,
-                          NULL);
-        return (pointer)TRUE;
-    }
-
-    if (ErrorMajor)
-        *ErrorMajor = LDR_ONCEONLY;
-    return (NULL);
-}
-
-#endif  /* XFree86Loader defined */
-
-static const OptionInfoRec *
-VBOXAvailableOptions(int chipid, int busid)
-{
-    return (VBOXOptions);
-}
-
-static void
-VBOXIdentify(int flags)
-{
-    xf86PrintChipsets(VBOX_NAME, "guest driver for VirtualBox", VBOXChipsets);
-}
-
-/*
- * This function is called once, at the start of the first server generation to
- * do a minimal probe for supported hardware.
- */
-
-static Bool
-VBOXProbe(DriverPtr drv, int flags)
-{
-    Bool foundScreen = FALSE;
-    int numDevSections, numUsed;
-    GDevPtr *devSections;
-    int *usedChips;
-    int i;
-
-    /*
-     * Find the config file Device sections that match this
-     * driver, and return if there are none.
-     */
-    if ((numDevSections = xf86MatchDevice(VBOX_NAME,
-					  &devSections)) <= 0)
-	return (FALSE);
-
-    /* PCI BUS */
-    if (xf86GetPciVideoInfo()) {
-	numUsed = xf86MatchPciInstances(VBOX_NAME, VBOX_VENDORID,
-					VBOXChipsets, VBOXPCIchipsets,
-					devSections, numDevSections,
-					drv, &usedChips);
-	if (numUsed > 0) {
-	    if (flags & PROBE_DETECT)
-		foundScreen = TRUE;
-	    else {
-		for (i = 0; i < numUsed; i++) {
-		    ScrnInfoPtr pScrn = NULL;
-		    /* Allocate a ScrnInfoRec  */
-		    if ((pScrn = xf86ConfigPciEntity(pScrn,0,usedChips[i],
-						     VBOXPCIchipsets,NULL,
-						     NULL,NULL,NULL,NULL))) {
-			pScrn->driverVersion = VBOX_VERSION;
-			pScrn->driverName    = VBOX_DRIVER_NAME;
-			pScrn->name	     = VBOX_NAME;
-			pScrn->Probe	     = VBOXProbe;
-                        pScrn->PreInit       = VBOXPreInit;
-			pScrn->ScreenInit    = VBOXScreenInit;
-			pScrn->SwitchMode    = VBOXSwitchMode;
-			pScrn->AdjustFrame   = VBOXAdjustFrame;
-			pScrn->EnterVT       = VBOXEnterVT;
-			pScrn->LeaveVT       = VBOXLeaveVT;
-			pScrn->FreeScreen    = VBOXFreeScreen;
-			foundScreen = TRUE;
-		    }
-		}
-	    }
-	    xfree(usedChips);
-	}
-    }
-    xfree(devSections);
-
-    return (foundScreen);
-}
-
-static VBOXPtr
-VBOXGetRec(ScrnInfoPtr pScrn)
-{
-    if (!pScrn->driverPrivate)
-    {
-        pScrn->driverPrivate = xcalloc(sizeof(VBOXRec), 1);
-#if 0
-        ((VBOXPtr)pScrn->driverPrivate)->vbox_fd = -1;
-#endif
-    }
-
-    return ((VBOXPtr)pScrn->driverPrivate);
-}
-
-static void
-VBOXFreeRec(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-#if 0
-    xfree(pVBox->vbeInfo);
-#endif
-    xfree(pVBox->savedPal);
-    xfree(pVBox->fonts);
-    xfree(pScrn->driverPrivate);
-    pScrn->driverPrivate = NULL;
-}
-
-/*
- * QUOTE from the XFree86 DESIGN document:
- *
- * The purpose of this function is to find out all the information
- * required to determine if the configuration is usable, and to initialise
- * those parts of the ScrnInfoRec that can be set once at the beginning of
- * the first server generation.
- *
- * (...)
- *
- * This includes probing for video memory, clocks, ramdac, and all other
- * HW info that is needed. It includes determining the depth/bpp/visual
- * and related info. It includes validating and determining the set of
- * video modes that will be used (and anything that is required to
- * determine that).
- *
- * This information should be determined in the least intrusive way
- * possible. The state of the HW must remain unchanged by this function.
- * Although video memory (including MMIO) may be mapped within this
- * function, it must be unmapped before returning.
- *
- * END QUOTE
- */
-
-static Bool
-VBOXPreInit(ScrnInfoPtr pScrn, int flags)
-{
-    VBOXPtr pVBox;
-    Gamma gzeros = {0.0, 0.0, 0.0};
-    rgb rzeros = {0, 0, 0};
-    ClockRange *clockRanges;
-    int i;
-    DisplayModePtr m_prev;
-
-    /* Are we really starting the server, or is this just a dummy run? */
-    if (flags & PROBE_DETECT)
-        return (FALSE);
-
-    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-               "VirtualBox guest additions video driver version "
-               VBOX_VERSION_STRING "\n");
-
-    /* Get our private data from the ScrnInfoRec structure. */
-    pVBox = VBOXGetRec(pScrn);
-
-    /* Entity information seems to mean bus information. */
-    pVBox->pEnt = xf86GetEntityInfo(pScrn->entityList[0]);
-    if (pVBox->pEnt->location.type != BUS_PCI)
-        return FALSE;
-
-    /* The ramdac module is needed for the hardware cursor. */
-    if (!xf86LoadSubModule(pScrn, "ramdac"))
-        return FALSE;
-    xf86LoaderReqSymLists(ramdacSymbols, NULL);
-
-    /* We need the vbe module because we use VBE code to save and restore
-       text mode, in order to keep our code simple. */
-    if (!xf86LoadSubModule(pScrn, "vbe"))
-        return (FALSE);
-    xf86LoaderReqSymLists(vbeSymbols, NULL);
-
-    /* The framebuffer module. */
-    if (xf86LoadSubModule(pScrn, "fb") == NULL)
-        return (FALSE);
-    xf86LoaderReqSymLists(fbSymbols, NULL);
-
-    if (!xf86LoadSubModule(pScrn, "shadowfb"))
-        return FALSE;
-    xf86LoaderReqSymLists(shadowfbSymbols, NULL);
-
-    pVBox->pciInfo = xf86GetPciInfoForEntity(pVBox->pEnt->index);
-    pVBox->pciTag = pciTag(pVBox->pciInfo->bus,
-                           pVBox->pciInfo->device,
-                           pVBox->pciInfo->func);
-
-    /* Set up our ScrnInfoRec structure to describe our virtual
-       capabilities to X. */
-
-    pScrn->rgbBits = 8;
-
-    /* Let's create a nice, capable virtual monitor. */
-    pScrn->monitor = pScrn->confScreen->monitor;
-    pScrn->monitor->DDC = NULL;
-    pScrn->monitor->nHsync = 1;
-    pScrn->monitor->hsync[0].lo = 1;
-    pScrn->monitor->hsync[0].hi = 10000;
-    pScrn->monitor->nVrefresh = 1;
-    pScrn->monitor->vrefresh[0].lo = 1;
-    pScrn->monitor->vrefresh[0].hi = 100;
-
-    pScrn->chipset = "vbox";
-    pScrn->progClock = TRUE;
-
-    /* Determine the size of the VBox video RAM from PCI data*/
-#if 0
-    pScrn->videoRam = 1 << pVBox->pciInfo->size[0];
-#endif
-    /* Using the PCI information caused problems with non-powers-of-two
-       sized video RAM configurations */
-    pScrn->videoRam = inl(VBE_DISPI_IOPORT_DATA) / 1024;
-
-    /* Set up clock information that will support all modes we need. */
-    clockRanges = xnfcalloc(sizeof(ClockRange), 1);
-    clockRanges->next = NULL;
-    clockRanges->minClock = 1000;
-    clockRanges->maxClock = 1000000000;
-    clockRanges->clockIndex = -1;
-    clockRanges->ClockMulFactor = 1;
-    clockRanges->ClockDivFactor = 1;
-
-    /* This function asks X to choose a depth and bpp based on the
-       config file and the command line, and gives a default in
-       case none is specified.  Note that we only support 32bpp, not
-       24bpp.  After spending ages looking through the XFree86 4.2
-       source code however, I realised that it automatically uses
-       32bpp for depth 24 unless you explicitly add a "24 24"
-       format to its internal list. */
-    if (!xf86SetDepthBpp(pScrn, pScrn->videoRam >= 2048 ? 24 : 16, 0, 0,
-                         Support32bppFb))
-        return FALSE;
-    if (pScrn->bitsPerPixel != 32 && pScrn->bitsPerPixel != 16)
-    {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "The VBox additions only support 16 and 32bpp graphics modes\n");
-        return FALSE;
-    }
-    xf86PrintDepthBpp(pScrn);
-
-    /* Colour weight - we always call this, since we are always in
-       truecolour. */
-    if (!xf86SetWeight(pScrn, rzeros, rzeros))
-        return (FALSE);
-
-    /* visual init */
-    if (!xf86SetDefaultVisual(pScrn, -1))
-        return (FALSE);
-
-    xf86SetGamma(pScrn, gzeros);
-
-    /* To get around the problem of SUSE specifying a single, invalid mode in their
-     * Xorg.conf by default, we add an additional mode to the end of the user specified
-     * list. This means that if all user modes are invalid, X will try our mode before
-     * falling back to its standard mode list. */
-    if (pScrn->display->modes == NULL)
-    {
-        /* The user specified no modes at all - specify 1024x768 as a default. */
-        pScrn->display->modes    = xnfalloc(4 * sizeof(char*));
-        pScrn->display->modes[0] = "1024x768";
-        pScrn->display->modes[1] = "800x600";
-        pScrn->display->modes[2] = "640x480";
-        pScrn->display->modes[3] = NULL;
-    }
-    else
-    {
-        /* Add 1024x768 to the end of the mode list in case the others are all invalid. */
-        for (i = 0; pScrn->display->modes[i] != NULL; i++);
-        pScrn->display->modes      = xnfrealloc(pScrn->display->modes, (i + 4)
-                                   * sizeof(char *));
-        pScrn->display->modes[i  ] = "1024x768";
-        pScrn->display->modes[i+1] = "800x600";
-        pScrn->display->modes[i+2] = "640x480";
-        pScrn->display->modes[i+3] = NULL;
-    }
-
-    /* Create a builtin mode for every specified mode. This allows to specify arbitrary
-     * screen resolutions */
-    m_prev = NULL;
-    for (i = 0; pScrn->display->modes[i] != NULL; i++)
-    {
-        DisplayModePtr m;
-        int x = 0, y = 0;
-
-        if (sscanf(pScrn->display->modes[i], "%dx%d", &x, &y) == 2)
-        {
-            m                = xnfcalloc(sizeof(DisplayModeRec), 1);
-            m->status        = MODE_OK;
-            m->type          = M_T_BUILTIN;
-            /* VBox only supports screen widths which are a multiple of 8 */
-            m->HDisplay      = (x + 7) & ~7;
-            m->VDisplay      = y;
-            m->name          = strdup(pScrn->display->modes[i]);
-            if (!m_prev)
-                pScrn->modePool = m;
-            else
-                m_prev->next = m;
-            m->prev = m_prev;
-            m_prev  = m;
-        }
-    }
-
-    /* Set a sane minimum mode size and the maximum allowed by the available VRAM */
-    {
-        unsigned maxSize, trySize = 512;
-
-        do {
-            maxSize = trySize;
-            trySize += 128;
-        } while (trySize * trySize * pScrn->bitsPerPixel / 8 < (unsigned)pScrn->videoRam * 1024);
-
-        /* I don't know exactly what these are for (and they are only used in a couple
-           of places in the X server code). */
-        pScrn->display->virtualX = maxSize;
-        pScrn->display->virtualY = maxSize;
-        xf86DrvMsg(pScrn->scrnIndex, X_INFO,
-                   "The maximum supported resolution is currently %dx%d\n", maxSize, maxSize);
-    }
-
-    /* Filter out video modes not supported by the virtual hardware
-       we described. */
-    i = xf86ValidateModes(pScrn, pScrn->monitor->Modes,
-                          pScrn->display->modes,
-                          clockRanges, NULL, 64, pScrn->display->virtualX, 1,
-                          64, pScrn->display->virtualY, 0, 0,
-                          pScrn->videoRam * 1024, LOOKUP_BEST_REFRESH);
-
-    if (i <= 0) {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No usable graphics modes found.\n");
-        return (FALSE);
-    }
-    xf86PruneDriverModes(pScrn);
-
-    pScrn->currentMode = pScrn->modes;
-    pScrn->displayWidth = pScrn->virtualX;
-
-    xf86PrintModes(pScrn);
-
-    /* Set display resolution.  Perhaps we should read this from the host. */
-    xf86SetDpi(pScrn, 96, 96);
-
-    if (pScrn->modes == NULL) {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "No graphics modes available\n");
-        return (FALSE);
-    }
-
-    /* options */
-    xf86CollectOptions(pScrn, NULL);
-    if (!(pVBox->Options = xalloc(sizeof(VBOXOptions))))
-        return FALSE;
-    memcpy(pVBox->Options, VBOXOptions, sizeof(VBOXOptions));
-    xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pVBox->Options);
-
-    /* Framebuffer-related setup */
-    pScrn->bitmapBitOrder = BITMAP_BIT_ORDER;
-    return (TRUE);
-}
-
-/*
- * QUOTE from the XFree86 DESIGN document:
- *
- * This is called at the start of each server generation.
- *
- * (...)
- *
- * Decide which operations need to be placed under resource access
- * control. (...) Map any video memory or other memory regions. (...)
- * Save the video card state. (...) Initialise the initial video
- * mode.
- *
- * End QUOTE.Initialise the initial video mode.
- */
-static Bool
-VBOXScreenInit(int scrnIndex, ScreenPtr pScreen, int argc, char **argv)
-{
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-    VisualPtr visual;
-    unsigned flags;
-
-    /* We make use of the X11 VBE code to save and restore text mode, in
-       order to keep our code simple. */
-    if ((pVBox->pVbe = VBEInit(NULL, pVBox->pEnt->index)) == NULL)
-        return (FALSE);
-
-    if (pVBox->mapPhys == 0) {
-        pVBox->mapPhys = pVBox->pciInfo->memBase[0];
-/*        pVBox->mapSize = 1 << pVBox->pciInfo->size[0]; */
-        /* Using the PCI information caused problems with
-           non-powers-of-two sized video RAM configurations */
-        pVBox->mapSize = inl(VBE_DISPI_IOPORT_DATA);
-        pVBox->mapOff = 0;
-    }
-
-    if (!VBOXMapVidMem(pScrn))
-        return (FALSE);
-
-    /* save current video state */
-    VBOXSaveRestore(pScrn, MODE_SAVE);
-    pVBox->savedPal = VBESetGetPaletteData(pVBox->pVbe, FALSE, 0, 256,
-                                           NULL, FALSE, FALSE);
-
-    /* set first video mode */
-    if (!VBOXSetMode(pScrn, pScrn->currentMode))
-        return FALSE;
-
-    /* mi layer - reset the visual list (?)*/
-    miClearVisualTypes();
-    if (!xf86SetDefaultVisual(pScrn, -1))
-        return (FALSE);
-    if (!miSetVisualTypes(pScrn->depth, TrueColorMask,
-                          pScrn->rgbBits, TrueColor))
-        return (FALSE);
-    if (!miSetPixmapDepths())
-        return (FALSE);
-
-    /* I checked in the sources, and XFree86 4.2 does seem to support
-       this function for 32bpp. */
-    if (!fbScreenInit(pScreen, pVBox->base,
-                      pScrn->virtualX, pScrn->virtualY,
-                      pScrn->xDpi, pScrn->yDpi,
-                      pScrn->displayWidth, pScrn->bitsPerPixel))
-        return (FALSE);
-
-    /* Fixup RGB ordering */
-    visual = pScreen->visuals + pScreen->numVisuals;
-    while (--visual >= pScreen->visuals) {
-        if ((visual->class | DynamicClass) == DirectColor) {
-            visual->offsetRed   = pScrn->offset.red;
-            visual->offsetGreen = pScrn->offset.green;
-            visual->offsetBlue  = pScrn->offset.blue;
-            visual->redMask     = pScrn->mask.red;
-            visual->greenMask   = pScrn->mask.green;
-            visual->blueMask    = pScrn->mask.blue;
-        }
-    }
-
-    /* must be after RGB ordering fixed */
-    fbPictureInit(pScreen, 0, 0);
-
-    VBOXDGAInit(pScrn, pScreen);
-
-    xf86SetBlackWhitePixels(pScreen);
-    miInitializeBackingStore(pScreen);
-    xf86SetBackingStore(pScreen);
-
-    /* software cursor */
-    miDCInitialize(pScreen, xf86GetPointerScreenFuncs());
-
-    /* colourmap code - apparently, we need this even in Truecolour */
-    if (!miCreateDefColormap(pScreen))
-	return (FALSE);
-
-    flags = CMAP_RELOAD_ON_MODE_SWITCH;
-
-    if(!xf86HandleColormaps(pScreen, 256,
-        8 /* DAC is switchable to 8 bits per primary color */,
-        VBOXLoadPalette, NULL, flags))
-        return (FALSE);
-
-    pVBox->CloseScreen = pScreen->CloseScreen;
-    pScreen->CloseScreen = VBOXCloseScreen;
-    pScreen->SaveScreen = VBOXSaveScreen;
-
-    /* However, we probably do want to support power management -
-       even if we just use a dummy function. */
-    xf86DPMSInit(pScreen, VBOXDisplayPowerManagementSet, 0);
-
-    /* Report any unused options (only for the first generation) */
-    if (serverGeneration == 1)
-        xf86ShowUnusedOptions(pScrn->scrnIndex, pScrn->options);
-
-    if (vbox_open (pScrn, pScreen, pVBox)) {
-        if (vbox_cursor_init(pScreen) != TRUE)
-            xf86DrvMsg(scrnIndex, X_ERROR,
-                       "Unable to start the VirtualBox mouse pointer integration with the host system.\n");
-        if (vboxEnableVbva(pScrn) == TRUE)
-            xf86DrvMsg(scrnIndex, X_INFO,
-                      "The VBox video extensions are now enabled.\n");
-    } else
-        xf86DrvMsg(scrnIndex, X_ERROR, "Failed to open the VBox system device - make sure that the VirtualBox guest additions are properly installed.  If you are not sure, try reinstalling them.\n");
-    return (TRUE);
-}
-
-static Bool
-VBOXEnterVT(int scrnIndex, int flags)
-{
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    if (!VBOXSetMode(pScrn, pScrn->currentMode))
-        return FALSE;
-    if (pVBox->useVbva == TRUE)
-        vboxEnableVbva(pScrn);
-    return TRUE;
-}
-
-static void
-VBOXLeaveVT(int scrnIndex, int flags)
-{
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    VBOXSaveRestore(pScrn, MODE_RESTORE);
-    if (pVBox->useVbva == TRUE)
-        vboxDisableVbva(pScrn);
-}
-
-static Bool
-VBOXCloseScreen(int scrnIndex, ScreenPtr pScreen)
-{
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    if (pVBox->useVbva == TRUE)
-        vboxDisableVbva(pScrn);
-    if (pScrn->vtSema) {
-	VBOXSaveRestore(xf86Screens[scrnIndex], MODE_RESTORE);
-	VBESetGetPaletteData(pVBox->pVbe, TRUE, 0, 256,
-			     pVBox->savedPal, FALSE, TRUE);
-	VBOXUnmapVidMem(pScrn);
-    }
-    if (pVBox->pDGAMode) {
-	xfree(pVBox->pDGAMode);
-	pVBox->pDGAMode = NULL;
-	pVBox->nDGAMode = 0;
-    }
-    pScrn->vtSema = FALSE;
-
-    pScreen->CloseScreen = pVBox->CloseScreen;
-    return pScreen->CloseScreen(scrnIndex, pScreen);
-}
-
-static Bool
-VBOXSwitchMode(int scrnIndex, DisplayModePtr pMode, int flags)
-{
-    ScrnInfoPtr pScrn;
-    VBOXPtr pVBox;
-
-    pScrn = xf86Screens[scrnIndex];  /* Why does X have three ways of refering to the screen? */
-    pVBox = VBOXGetRec(pScrn);
-    if (pVBox->useVbva == TRUE)
-        if (vboxDisableVbva(pScrn) != TRUE)  /* This would be bad. */
-            return FALSE;
-    if (VBOXSetMode(pScrn, pMode) != TRUE)
-        return FALSE;
-    if (pVBox->useVbva == TRUE)
-        if (vboxEnableVbva(pScrn) != TRUE)  /* Bad but not fatal */
-            pVBox->useVbva = FALSE;
-    return TRUE;
-}
-
-/* Set a graphics mode */
-static Bool
-VBOXSetMode(ScrnInfoPtr pScrn, DisplayModePtr pMode)
-{
-    VBOXPtr pVBox;
-
-    int bpp = pScrn->depth == 24 ? 32 : 16;
-    int xRes = pMode->HDisplay;
-    if (pScrn->virtualX * pScrn->virtualY * bpp / 8
-        >= pScrn->videoRam * 1024)
-    {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Unable to set up a virtual screen size of %dx%d with %d Kb of video memory.  Please increase the video memory size.\n",
-                   pScrn->virtualX, pScrn->virtualY, pScrn->videoRam);
-        return FALSE;
-    }
-    /* We only support horizontal resolutions which are a multiple of 8.  Round down if
-       necessary. */
-    if (xRes % 8 != 0)
-    {
-        xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
-                   "VirtualBox only supports screen widths which are a multiple of 8.  Rounding down from %d to %d\n",
-                   xRes, xRes - (xRes % 8));
-        xRes = xRes - (xRes % 8);
-    }
-    pVBox = VBOXGetRec(pScrn);
-    /* We force a software cursor if the guests virtual resolution is different
-     * to it's actual resolution, as in this case host and guest will disagree
-     * about the pointer position. */
-    if (   (pScrn->virtualX - xRes >= 8)
-        || (pScrn->virtualY - pMode->VDisplay >= 8))
-        pVBox->forceSWCursor = TRUE;
-    else
-        pVBox->forceSWCursor = FALSE;
-
-    pScrn->vtSema = TRUE;
-    /* Disable linear framebuffer mode before making changes to the resolution. */
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_ENABLE);
-    outw(VBE_DISPI_IOPORT_DATA,
-         VBE_DISPI_DISABLED);
-    /* Unlike the resolution, the depth is fixed for a given screen
-       for the lifetime of the X session. */
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_BPP);
-    outw(VBE_DISPI_IOPORT_DATA, bpp);
-    /* HDisplay and VDisplay are actually monitor information about
-       the display part of the scanlines. */
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_XRES);
-    outw(VBE_DISPI_IOPORT_DATA, xRes);
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_YRES);
-    outw(VBE_DISPI_IOPORT_DATA, pMode->VDisplay);
-    /* Enable linear framebuffer mode. */
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_ENABLE);
-    outw(VBE_DISPI_IOPORT_DATA,
-         VBE_DISPI_ENABLED | VBE_DISPI_LFB_ENABLED);
-    /* Set the virtual resolution.  We are still using VESA to control
-       the virtual offset. */
-    outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_VIRT_WIDTH);
-    outw(VBE_DISPI_IOPORT_DATA, pScrn->displayWidth);
-    return (TRUE);
-}
-
-static void
-VBOXAdjustFrame(int scrnIndex, int x, int y, int flags)
-{
-    VBOXPtr pVBox = VBOXGetRec(xf86Screens[scrnIndex]);
-    ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
-
-    pVBox->viewportX = x;
-    pVBox->viewportY = y;
-    /* If VBVA is enabled the graphics card will not notice the change. */
-    if (pVBox->useVbva == TRUE)
-        vboxDisableVbva(pScrn);
-    VBESetDisplayStart(pVBox->pVbe, x, y, TRUE);
-    if (pVBox->useVbva == TRUE)
-        vboxEnableVbva(pScrn);
-}
-
-static void
-VBOXFreeScreen(int scrnIndex, int flags)
-{
-    VBOXFreeRec(xf86Screens[scrnIndex]);
-}
-
-static Bool
-VBOXMapVidMem(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    if (pVBox->base != NULL)
-        return (TRUE);
-
-    pScrn->memPhysBase = pVBox->mapPhys;
-    pScrn->fbOffset = pVBox->mapOff;
-
-    pVBox->base = xf86MapPciMem(pScrn->scrnIndex,
-                                VIDMEM_FRAMEBUFFER,
-                                pVBox->pciTag, pVBox->mapPhys,
-                                (unsigned) pVBox->mapSize);
-
-    if (pVBox->base) {
-        pScrn->memPhysBase = pVBox->mapPhys;
-        pVBox->VGAbase = xf86MapVidMem(pScrn->scrnIndex, 0,
-                                       0xa0000, 0x10000);
-    }
-
-    return (pVBox->base != NULL);
-}
-
-static void
-VBOXUnmapVidMem(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    if (pVBox->base == NULL)
-        return;
-
-    xf86UnMapVidMem(pScrn->scrnIndex, pVBox->base,
-                    (unsigned) pVBox->mapSize);
-    xf86UnMapVidMem(pScrn->scrnIndex, pVBox->VGAbase, 0x10000);
-    pVBox->base = NULL;
-}
-
-static void
-VBOXLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
-		LOCO *colors, VisualPtr pVisual)
-{
-#define WriteDacWriteAddr(value)	outb(VGA_DAC_WRITE_ADDR, value)
-#define WriteDacData(value)		outb(VGA_DAC_DATA, value);
-#undef DACDelay
-#define DACDelay()								\
-	do {									\
-	    unsigned char temp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);	\
-	    temp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);		\
-	} while (0)
-    int i, idx;
-
-    for (i = 0; i < numColors; i++) {
-	   idx = indices[i];
-	   WriteDacWriteAddr(idx);
-	   DACDelay();
-	   WriteDacData(colors[idx].red);
-	   DACDelay();
-	   WriteDacData(colors[idx].green);
-	   DACDelay();
-	   WriteDacData(colors[idx].blue);
-	   DACDelay();
-    }
-}
-
-/*
- * Just adapted from the std* functions in vgaHW.c
- */
-static void
-WriteAttr(int index, int value)
-{
-    CARD8 tmp;
-
-    tmp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
-
-    index |= 0x20;
-    outb(VGA_ATTR_INDEX, index);
-    outb(VGA_ATTR_DATA_W, value);
-}
-
-static int
-ReadAttr(int index)
-{
-    CARD8 tmp;
-
-    tmp = inb(VGA_IOBASE_COLOR + VGA_IN_STAT_1_OFFSET);
-
-    index |= 0x20;
-    outb(VGA_ATTR_INDEX, index);
-    return (inb(VGA_ATTR_DATA_R));
-}
-
-#define WriteMiscOut(value)	outb(VGA_MISC_OUT_W, value)
-#define ReadMiscOut()		inb(VGA_MISC_OUT_R)
-#define WriteSeq(index, value) \
-        outb(VGA_SEQ_INDEX, (index));\
-        outb(VGA_SEQ_DATA, value)
-
-static int
-ReadSeq(int index)
-{
-    outb(VGA_SEQ_INDEX, index);
-
-    return (inb(VGA_SEQ_DATA));
-}
-
-#define WriteGr(index, value)	outb(VGA_GRAPH_INDEX, index);\
-				outb(VGA_GRAPH_DATA, value)
-
-static int
-ReadGr(int index)
-{
-    outb(VGA_GRAPH_INDEX, index);
-
-    return (inb(VGA_GRAPH_DATA));
-}
-
-#define WriteCrtc(index, value)	outb(VGA_CRTC_INDEX_OFFSET, index);\
-				outb(VGA_CRTC_DATA_OFFSET, value)
-
-static void
-SeqReset(Bool start)
-{
-    if (start) {
-	   WriteSeq(0x00, 0x01);		/* Synchronous Reset */
-    }
-    else {
-	   WriteSeq(0x00, 0x03);		/* End Reset */
-    }
-}
-
-static void
-SaveFonts(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-    unsigned char miscOut, attr10, gr4, gr5, gr6, seq2, seq4, scrn;
-
-    if (pVBox->fonts != NULL)
-	return;
-
-    /* If in graphics mode, don't save anything */
-    attr10 = ReadAttr(0x10);
-    if (attr10 & 0x01)
-	return;
-
-    pVBox->fonts = xalloc(16384);
-
-    /* save the registers that are needed here */
-    miscOut = ReadMiscOut();
-    gr4 = ReadGr(0x04);
-    gr5 = ReadGr(0x05);
-    gr6 = ReadGr(0x06);
-    seq2 = ReadSeq(0x02);
-    seq4 = ReadSeq(0x04);
-
-    /* Force into colour mode */
-    WriteMiscOut(miscOut | 0x01);
-
-    scrn = ReadSeq(0x01) | 0x20;
-    SeqReset(TRUE);
-    WriteSeq(0x01, scrn);
-    SeqReset(FALSE);
-
-    WriteAttr(0x10, 0x01);	/* graphics mode */
-
-    /*font1 */
-    WriteSeq(0x02, 0x04);	/* write to plane 2 */
-    WriteSeq(0x04, 0x06);	/* enable plane graphics */
-    WriteGr(0x04, 0x02);	/* read plane 2 */
-    WriteGr(0x05, 0x00);	/* write mode 0, read mode 0 */
-    WriteGr(0x06, 0x05);	/* set graphics */
-    slowbcopy_frombus(pVBox->VGAbase, pVBox->fonts, 8192);
-
-    /* font2 */
-    WriteSeq(0x02, 0x08);	/* write to plane 3 */
-    WriteSeq(0x04, 0x06);	/* enable plane graphics */
-    WriteGr(0x04, 0x03);	/* read plane 3 */
-    WriteGr(0x05, 0x00);	/* write mode 0, read mode 0 */
-    WriteGr(0x06, 0x05);	/* set graphics */
-    slowbcopy_frombus(pVBox->VGAbase, pVBox->fonts + 8192, 8192);
-
-    scrn = ReadSeq(0x01) & ~0x20;
-    SeqReset(TRUE);
-    WriteSeq(0x01, scrn);
-    SeqReset(FALSE);
-
-    /* Restore clobbered registers */
-    WriteAttr(0x10, attr10);
-    WriteSeq(0x02, seq2);
-    WriteSeq(0x04, seq4);
-    WriteGr(0x04, gr4);
-    WriteGr(0x05, gr5);
-    WriteGr(0x06, gr6);
-    WriteMiscOut(miscOut);
-}
-
-static void
-RestoreFonts(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-    unsigned char miscOut, attr10, gr1, gr3, gr4, gr5, gr6, gr8, seq2, seq4, scrn;
-
-    if (pVBox->fonts == NULL)
-        return;
-
-    /* save the registers that are needed here */
-    miscOut = ReadMiscOut();
-    attr10 = ReadAttr(0x10);
-    gr1 = ReadGr(0x01);
-    gr3 = ReadGr(0x03);
-    gr4 = ReadGr(0x04);
-    gr5 = ReadGr(0x05);
-    gr6 = ReadGr(0x06);
-    gr8 = ReadGr(0x08);
-    seq2 = ReadSeq(0x02);
-    seq4 = ReadSeq(0x04);
-
-    /* Force into colour mode */
-    WriteMiscOut(miscOut | 0x01);
-
-    scrn = ReadSeq(0x01) | 0x20;
-    SeqReset(TRUE);
-    WriteSeq(0x01, scrn);
-    SeqReset(FALSE);
-
-    WriteAttr(0x10, 0x01);	/* graphics mode */
-    if (pScrn->depth == 4) {
-	/* GJA */
-	WriteGr(0x03, 0x00);	/* don't rotate, write unmodified */
-	WriteGr(0x08, 0xFF);	/* write all bits in a byte */
-	WriteGr(0x01, 0x00);	/* all planes come from CPU */
-    }
-
-    WriteSeq(0x02, 0x04);   /* write to plane 2 */
-    WriteSeq(0x04, 0x06);   /* enable plane graphics */
-    WriteGr(0x04, 0x02);    /* read plane 2 */
-    WriteGr(0x05, 0x00);    /* write mode 0, read mode 0 */
-    WriteGr(0x06, 0x05);    /* set graphics */
-    slowbcopy_tobus(pVBox->fonts, pVBox->VGAbase, 8192);
-
-    WriteSeq(0x02, 0x08);   /* write to plane 3 */
-    WriteSeq(0x04, 0x06);   /* enable plane graphics */
-    WriteGr(0x04, 0x03);    /* read plane 3 */
-    WriteGr(0x05, 0x00);    /* write mode 0, read mode 0 */
-    WriteGr(0x06, 0x05);    /* set graphics */
-    slowbcopy_tobus(pVBox->fonts + 8192, pVBox->VGAbase, 8192);
-
-    scrn = ReadSeq(0x01) & ~0x20;
-    SeqReset(TRUE);
-    WriteSeq(0x01, scrn);
-    SeqReset(FALSE);
-
-    /* restore the registers that were changed */
-    WriteMiscOut(miscOut);
-    WriteAttr(0x10, attr10);
-    WriteGr(0x01, gr1);
-    WriteGr(0x03, gr3);
-    WriteGr(0x04, gr4);
-    WriteGr(0x05, gr5);
-    WriteGr(0x06, gr6);
-    WriteGr(0x08, gr8);
-    WriteSeq(0x02, seq2);
-    WriteSeq(0x04, seq4);
-}
-
-static Bool
-VBOXSaveScreen(ScreenPtr pScreen, int mode)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    Bool on = xf86IsUnblank(mode);
-
-    if (on)
-	SetTimeSinceLastInputEvent();
-
-    if (pScrn->vtSema) {
-	unsigned char scrn = ReadSeq(0x01);
-
-	if (on)
-	    scrn &= ~0x20;
-	else
-	    scrn |= 0x20;
-	SeqReset(TRUE);
-	WriteSeq(0x01, scrn);
-	SeqReset(FALSE);
-    }
-
-    return (TRUE);
-}
-
-Bool
-VBOXSaveRestore(ScrnInfoPtr pScrn, vbeSaveRestoreFunction function)
-{
-    VBOXPtr pVBox;
-
-    if (MODE_QUERY < 0 || function > MODE_RESTORE)
-	return (FALSE);
-
-    pVBox = VBOXGetRec(pScrn);
-
-
-    /* Query amount of memory to save state */
-    if (function == MODE_QUERY ||
-	(function == MODE_SAVE && pVBox->state == NULL))
-    {
-
-	/* Make sure we save at least this information in case of failure */
-	(void)VBEGetVBEMode(pVBox->pVbe, &pVBox->stateMode);
-	SaveFonts(pScrn);
-
-        if (!VBESaveRestore(pVBox->pVbe,function,(pointer)&pVBox->state,
-                            &pVBox->stateSize,&pVBox->statePage))
-            return FALSE;
-    }
-
-    /* Save/Restore Super VGA state */
-    if (function != MODE_QUERY) {
-        Bool retval = TRUE;
-
-        if (function == MODE_RESTORE)
-            memcpy(pVBox->state, pVBox->pstate,
-                   (unsigned) pVBox->stateSize);
-
-        if ((retval = VBESaveRestore(pVBox->pVbe,function,
-                                     (pointer)&pVBox->state,
-                                     &pVBox->stateSize,&pVBox->statePage))
-             && function == MODE_SAVE)
-        {
-            /* don't rely on the memory not being touched */
-            if (pVBox->pstate == NULL)
-                pVBox->pstate = xalloc(pVBox->stateSize);
-            memcpy(pVBox->pstate, pVBox->state,
-                   (unsigned) pVBox->stateSize);
-        }
-
-        if (function == MODE_RESTORE)
-        {
-            VBESetVBEMode(pVBox->pVbe, pVBox->stateMode, NULL);
-            RestoreFonts(pScrn);
-        }
-
-	if (!retval)
-	    return (FALSE);
-
-    }
-
-    return (TRUE);
-}
-
-static void
-VBOXDisplayPowerManagementSet(ScrnInfoPtr pScrn, int mode,
-                int flags)
-{
-    /* VBox is always power efficient... */
-}
-
-
-
-
-/***********************************************************************
- * DGA stuff
- ***********************************************************************/
-static Bool VBOXDGAOpenFramebuffer(ScrnInfoPtr pScrn, char **DeviceName,
-				   unsigned char **ApertureBase,
-				   int *ApertureSize, int *ApertureOffset,
-				   int *flags);
-static Bool VBOXDGASetMode(ScrnInfoPtr pScrn, DGAModePtr pDGAMode);
-static void VBOXDGASetViewport(ScrnInfoPtr pScrn, int x, int y, int flags);
-
-static Bool
-VBOXDGAOpenFramebuffer(ScrnInfoPtr pScrn, char **DeviceName,
-		       unsigned char **ApertureBase, int *ApertureSize,
-		       int *ApertureOffset, int *flags)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    *DeviceName = NULL;		/* No special device */
-    *ApertureBase = (unsigned char *)(long)(pVBox->mapPhys);
-    *ApertureSize = pVBox->mapSize;
-    *ApertureOffset = pVBox->mapOff;
-    *flags = DGA_NEED_ROOT;
-
-    return (TRUE);
-}
-
-static Bool
-VBOXDGASetMode(ScrnInfoPtr pScrn, DGAModePtr pDGAMode)
-{
-    DisplayModePtr pMode;
-    int scrnIdx = pScrn->pScreen->myNum;
-    int frameX0, frameY0;
-
-    if (pDGAMode) {
-	pMode = pDGAMode->mode;
-	frameX0 = frameY0 = 0;
-    }
-    else {
-	if (!(pMode = pScrn->currentMode))
-	    return (TRUE);
-
-	frameX0 = pScrn->frameX0;
-	frameY0 = pScrn->frameY0;
-    }
-
-    if (!(*pScrn->SwitchMode)(scrnIdx, pMode, 0))
-	return (FALSE);
-    (*pScrn->AdjustFrame)(scrnIdx, frameX0, frameY0, 0);
-
-    return (TRUE);
-}
-
-static void
-VBOXDGASetViewport(ScrnInfoPtr pScrn, int x, int y, int flags)
-{
-    (*pScrn->AdjustFrame)(pScrn->pScreen->myNum, x, y, flags);
-}
-
-static int
-VBOXDGAGetViewport(ScrnInfoPtr pScrn)
-{
-    return (0);
-}
-
-static DGAFunctionRec VBOXDGAFunctions =
-{
-    VBOXDGAOpenFramebuffer,
-    NULL,       /* CloseFramebuffer */
-    VBOXDGASetMode,
-    VBOXDGASetViewport,
-    VBOXDGAGetViewport,
-    NULL,       /* Sync */
-    NULL,       /* FillRect */
-    NULL,       /* BlitRect */
-    NULL,       /* BlitTransRect */
-};
-
-static void
-VBOXDGAAddModes(ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-    DisplayModePtr pMode = pScrn->modes;
-    DGAModePtr pDGAMode;
-
-    do {
-	pDGAMode = xrealloc(pVBox->pDGAMode,
-			    (pVBox->nDGAMode + 1) * sizeof(DGAModeRec));
-	if (!pDGAMode)
-	    break;
-
-	pVBox->pDGAMode = pDGAMode;
-	pDGAMode += pVBox->nDGAMode;
-	(void)memset(pDGAMode, 0, sizeof(DGAModeRec));
-
-	++pVBox->nDGAMode;
-	pDGAMode->mode = pMode;
-	pDGAMode->flags = DGA_CONCURRENT_ACCESS | DGA_PIXMAP_AVAILABLE;
-	pDGAMode->byteOrder = pScrn->imageByteOrder;
-	pDGAMode->depth = pScrn->depth;
-	pDGAMode->bitsPerPixel = pScrn->bitsPerPixel;
-	pDGAMode->red_mask = pScrn->mask.red;
-	pDGAMode->green_mask = pScrn->mask.green;
-	pDGAMode->blue_mask = pScrn->mask.blue;
-        pDGAMode->visualClass = TrueColor;
-	pDGAMode->xViewportStep = 1;
-	pDGAMode->yViewportStep = 1;
-	pDGAMode->viewportWidth = pMode->HDisplay;
-	pDGAMode->viewportHeight = pMode->VDisplay;
-
-	pDGAMode->bytesPerScanline = pVBox->maxBytesPerScanline;
-	pDGAMode->imageWidth = pMode->HDisplay;
-	pDGAMode->imageHeight =  pMode->VDisplay;
-	pDGAMode->pixmapWidth = pDGAMode->imageWidth;
-	pDGAMode->pixmapHeight = pDGAMode->imageHeight;
-	pDGAMode->maxViewportX = pScrn->virtualX -
-				    pDGAMode->viewportWidth;
-	pDGAMode->maxViewportY = pScrn->virtualY -
-				    pDGAMode->viewportHeight;
-
-	pDGAMode->address = pVBox->base;
-
-	pMode = pMode->next;
-    } while (pMode != pScrn->modes);
-}
-
-static Bool
-VBOXDGAInit(ScrnInfoPtr pScrn, ScreenPtr pScreen)
-{
-    VBOXPtr pVBox = VBOXGetRec(pScrn);
-
-    if (!pVBox->nDGAMode)
-	VBOXDGAAddModes(pScrn);
-
-    return (DGAInit(pScreen, &VBOXDGAFunctions,
-	    pVBox->pDGAMode, pVBox->nDGAMode));
-}
Index: src/VBox/Additions/x11/vboxvideo/vboxvideo_68.h
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo_68.h
+++ /dev/null
@@ -1,178 +0,0 @@
-/** @file
- *
- * VirtualBox X11 Additions graphics driver
- */
-
-/*
- * Copyright (C) 2006-2007 Oracle Corporation
- *
- * This file is part of VirtualBox Open Source Edition (OSE), as
- * available from http://www.virtualbox.org. This file is free software;
- * you can redistribute it and/or modify it under the terms of the GNU
- * General Public License (GPL) as published by the Free Software
- * Foundation, in version 2 as it comes in the "COPYING" file of the
- * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
- * --------------------------------------------------------------------
- *
- * This code is based on:
- *
- * X11 VESA driver
- *
- * Copyright (c) 2000 by Conectiva S.A. (http://www.conectiva.com)
- *
- * Permission is hereby granted, free of charge, to any person obtaining a
- * copy of this software and associated documentation files (the "Software"),
- * to deal in the Software without restriction, including without limitation
- * the rights to use, copy, modify, merge, publish, distribute, sublicense,
- * and/or sell copies of the Software, and to permit persons to whom the
- * Software is furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in
- * all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
- * CONECTIVA LINUX BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
- * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
- * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- *
- * Except as contained in this notice, the name of Conectiva Linux shall
- * not be used in advertising or otherwise to promote the sale, use or other
- * dealings in this Software without prior written authorization from
- * Conectiva Linux.
- *
- * Authors: Paulo C�ar Pereira de Andrade <pcpa@conectiva.com.br>
- *
- * $XFree86: xc/programs/Xserver/hw/xfree86/drivers/vesa/vesa.h,v 1.9 2001/05/04 19:05:49 dawes Exp $
- */
-
-#ifndef _VBOXVIDEO_H_
-#define _VBOXVIDEO_H_
-
-#include <VBox/VMMDev.h>
-
-/* All drivers should typically include these */
-#include "xf86.h"
-#include "xf86_OSproc.h"
-#include "xf86Resources.h"
-
-/* All drivers need this */
-#include "xf86_ansic.h"
-
-#include "compiler.h"
-
-/* Drivers for PCI hardware need this */
-#include "xf86PciInfo.h"
-
-#include "vgaHW.h"
-
-/* Drivers that need to access the PCI config space directly need this */
-#include "xf86Pci.h"
-
-/* VBE/DDC support */
-#include "vbe.h"
-#include "xf86DDC.h"
-
-/* ShadowFB support */
-#include "shadow.h"
-
-#include "shadowfb.h"
-
-/* VBox video related defines */
-
-#define VBE_DISPI_IOPORT_INDEX          0x01CE
-#define VBE_DISPI_IOPORT_DATA           0x01CF
-#define VBE_DISPI_INDEX_ID              0x0
-#define VBE_DISPI_INDEX_XRES            0x1
-#define VBE_DISPI_INDEX_YRES            0x2
-#define VBE_DISPI_INDEX_BPP             0x3
-#define VBE_DISPI_INDEX_ENABLE          0x4
-#define VBE_DISPI_INDEX_VIRT_WIDTH      0x6
-#define VBE_DISPI_INDEX_VIRT_HEIGHT     0x7
-#define VBE_DISPI_ID2                   0xB0C2
-#define VBE_DISPI_DISABLED              0x00
-#define VBE_DISPI_ENABLED               0x01
-#define VBE_DISPI_LFB_ENABLED           0x40
-
-/* Int 10 support */
-#include "xf86int10.h"
-
-/* bank switching */
-#include "mibank.h"
-
-/* Dga definitions */
-#include "dgaproc.h"
-
-#include "xf86Resources.h"
-#include "xf86RAC.h"
-
-#include "xf1bpp.h"
-#include "xf4bpp.h"
-#include "fb.h"
-#include "afb.h"
-#include "mfb.h"
-
-#define VBOX_VERSION		4000
-#include "xf86Cursor.h"
-#define VBOX_NAME		"VBoxVideo"
-#define VBOX_DRIVER_NAME	"vboxvideo"
-
-/*XXX*/
-
-typedef struct _VBOXRec
-{
-    vbeInfoPtr pVbe;
-    EntityInfoPtr pEnt;
-    VbeInfoBlock *vbeInfo;
-    pciVideoPtr pciInfo;
-    PCITAG pciTag;
-    CARD16 maxBytesPerScanline;
-    unsigned long mapPhys, mapOff, mapSize;	/* video memory */
-    void *base, *VGAbase;
-    CARD8 *state, *pstate;	/* SVGA state */
-    int statePage, stateSize, stateMode;
-    CARD32 *savedPal;
-    CARD8 *fonts;
-    /* DGA info */
-    DGAModePtr pDGAMode;
-    int nDGAMode;
-    CloseScreenProcPtr CloseScreen;
-    OptionInfoPtr Options;
-    int vbox_fd;
-    VMMDevReqMousePointer *reqp;
-    xf86CursorInfoPtr pCurs;
-    size_t pointerHeaderSize;
-    size_t pointerSize;
-    Bool pointerOffscreen;
-    Bool useVbva;
-    int viewportX, viewportY;
-    Bool forceSWCursor;
-    VMMDevVideoAccelFlush *reqf;
-    VMMDevVideoAccelEnable *reqe;
-    VMMDevMemory *pVMMDevMemory;
-    VBVAMEMORY *pVbvaMemory;
-} VBOXRec, *VBOXPtr;
-
-typedef struct _ModeInfoData
-{
-    int mode;
-    VbeModeInfoBlock *data;
-    VbeCRTCInfoBlock *block;
-} ModeInfoData;
-
-Bool vbox_cursor_init (ScreenPtr pScreen);
-Bool vbox_open (ScrnInfoPtr pScrn, ScreenPtr pScreen, VBOXPtr pVBOX);
-void vbox_close (ScrnInfoPtr pScrn, VBOXPtr pVBOX);
-
-extern Bool vboxEnableVbva(ScrnInfoPtr pScrn);
-
-extern Bool vboxDisableVbva(ScrnInfoPtr pScrn);
-
-extern Bool vboxGetDisplayChangeRequest(ScrnInfoPtr pScrn, uint32_t *pcx,
-                                        uint32_t *pcy, uint32_t *pcBits,
-                                        uint32_t *piDisplay);
-
-#endif /* _VBOXVIDEO_H_ */
Index: src/VBox/Additions/x11/vboxvideo/vboxutils_68.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxutils_68.c
+++ /dev/null
@@ -1,979 +0,0 @@
-/** @file
- * Linux Additions X11 graphics driver helper module
- */
-
-/*
- * Copyright (C) 2006-2007 Oracle Corporation
- *
- * This file is part of VirtualBox Open Source Edition (OSE), as
- * available from http://www.virtualbox.org. This file is free software;
- * you can redistribute it and/or modify it under the terms of the GNU
- * General Public License (GPL) as published by the Free Software
- * Foundation, in version 2 as it comes in the "COPYING" file of the
- * VirtualBox OSE distribution. VirtualBox OSE is distributed in the
- * hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
- */
-
-#include <VBox/VBoxGuest.h>
-#include <VBox/VBoxGuestLib.h>
-
-#include <xf86Pci.h>
-#include <Pci.h>
-
-#include "xf86.h"
-#define NEED_XF86_TYPES
-#include "xf86_ansic.h"
-#include "compiler.h"
-#include "cursorstr.h"
-
-#include "vboxvideo_68.h"
-
-#define VBOX_MAX_CURSOR_WIDTH 64
-#define VBOX_MAX_CURSOR_HEIGHT 64
-
-#if 0
-#define DEBUG_X
-#endif
-#ifdef DEBUG_X
-#define TRACE_ENTRY() do \
-    { \
-        ErrorF ("%s\n", __FUNCTION__); \
-    } while(0)
-#define TRACE_LINE() do \
-    { \
-        ErrorF ("%s: line %d\n", __FUNCTION__, __LINE__); \
-    } while(0)
-#define PUT_PIXEL(c) ErrorF ("%c", c)
-#define dolog(...) ErrorF  (__VA_ARGS__)
-#else
-#define PUT_PIXEL(c) do { } while(0)
-#define TRACE_ENTRY() do { } while(0)
-#define TRACE_LINE() do { } while(0)
-#define dolog(...) do { } while(0)
-#endif
-
-/** Macro to printf an error message and return from a function */
-#define RETERROR(scrnIndex, RetVal, ...) \
-do \
-{ \
-    xf86DrvMsg(scrnIndex, X_ERROR, __VA_ARGS__); \
-    return RetVal; \
-} \
-while (0)
-
-#ifdef DEBUG_X
-static void vbox_show_shape (unsigned short w, unsigned short h,
-                             CARD32 bg, unsigned char *image)
-{
-    size_t x, y;
-    unsigned short pitch;
-    CARD32 *color;
-    unsigned char *mask;
-    size_t size_mask;
-
-    image    += offsetof (VMMDevReqMousePointer, pointerData);
-    mask      = image;
-    pitch     = (w + 7) / 8;
-    size_mask = (pitch * h + 3) & ~3;
-    color     = (CARD32 *) (image + size_mask);
-
-    TRACE_ENTRY ();
-    for (y = 0; y < h; ++y, mask += pitch, color += w)
-    {
-        for (x = 0; x < w; ++x)
-        {
-            if (mask[x / 8] & (1 << (7 - (x % 8))))
-                ErrorF (" ");
-
-            else
-            {
-                CARD32 c = color[x];
-                if (c == bg)
-                    ErrorF ("Y");
-                else
-                    ErrorF ("X");
-            }
-        }
-        ErrorF ("\n");
-    }
-}
-#endif
-
-static Bool vbox_vmmcall (ScrnInfoPtr pScrn, VBOXPtr pVBox,
-                          VMMDevRequestHeader *hdrp)
-{
-    int err;
-
-    TRACE_ENTRY ();
-#ifdef RT_OS_LINUX
-    err = ioctl (pVBox->vbox_fd, VBOXGUEST_IOCTL_VMMREQUEST(hdrp->size), hdrp);
-#else
-/**
- * @todo this should work fine on other platforms too, but it needs to be
- *       checked for each one.
- */
-# error port me!
-#endif
-    if (err < 0)
-        RETERROR(pScrn->scrnIndex, FALSE,
-                 "Ioctl call failed during a request to the virtual machine: %s\n",
-                 strerror (errno));
-    else
-        if (RT_FAILURE (hdrp->rc))
-            RETERROR(pScrn->scrnIndex, FALSE,
-                     "A request to the virtual machine returned %d\n",
-                     hdrp->rc);
-
-    /* success */
-    return TRUE;
-}
-
-static Bool
-vbox_host_uses_hwcursor(ScrnInfoPtr pScrn)
-{
-    Bool rc = FALSE;
-    VBOXPtr pVBox = pScrn->driverPrivate;
-    VMMDevReqMouseStatus req;
-
-    /* We may want to force the use of a software cursor.  Currently this is
-     * needed if the guest uses a large virtual resolution, as in this case
-     * the host and guest tend to disagree about the pointer location. */
-    if (pVBox->forceSWCursor)
-        rc = FALSE;
-    else
-    {
-        int vrc = vmmdevInitRequest ((VMMDevRequestHeader*)&req, VMMDevReq_GetMouseStatus);
-        if (RT_FAILURE (vrc))
-            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                "Unable to determine whether the virtual machine supports mouse pointer integration - request initialization failed with return code %d\n", rc);
-    #ifdef RT_OS_LINUX
-        if (   RT_SUCCESS(vrc)
-            && (ioctl(pVBox->vbox_fd, VBOXGUEST_IOCTL_VMMREQUEST(sizeof(req)), (void*)&req) < 0))
-    #else
-    # error port me!
-    #endif
-        {
-            vrc = VERR_FILE_IO_ERROR;
-            xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                "Unable to determine whether the virtual machine supports mouse pointer integration - request system call failed: %s.\n",
-                strerror(errno));
-        }
-        if (   RT_SUCCESS(rc)
-            && !(req.mouseFeatures & VMMDEV_MOUSE_HOST_CANNOT_HWPOINTER)
-            && (req.mouseFeatures & VMMDEV_MOUSE_GUEST_CAN_ABSOLUTE))
-                rc = TRUE;
-    }
-    return rc;
-}
-
-
-void
-vbox_close(ScrnInfoPtr pScrn, VBOXPtr pVBox)
-{
-    TRACE_ENTRY ();
-
-    xfree (pVBox->reqp);
-    pVBox->reqp = NULL;
-
-#ifdef RT_OS_SOLARIS
-    VbglR3Term();
-#else
-    if (close (pVBox->vbox_fd))
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-            "Unable to close the virtual machine device (file %d): %s\n",
-            pVBox->vbox_fd, strerror (errno));
-    pVBox->vbox_fd = -1;
-#endif
-}
-
-/**
- * Macro to disable VBVA extensions and return, for use when an
- * unexplained error occurs.
- */
-#define DISABLE_VBVA_AND_RETURN(pScrn, ...) \
-do \
-{ \
-    xf86DrvMsg(pScrn->scrnIndex, X_ERROR, __VA_ARGS__); \
-    vboxDisableVbva(pScrn); \
-    pVBox->useVbva = FALSE; \
-    return; \
-} \
-while (0)
-
-/**
- * Callback function called by the X server to tell us about dirty
- * rectangles in the video buffer.
- *
- * @param pScreen pointer to the information structure for the current
- *                screen
- * @param iRects  Number of dirty rectangles to update
- * @param aRects  Array of structures containing the coordinates of the
- *                rectangles
- */
-static void
-vboxHandleDirtyRect(ScrnInfoPtr pScrn, int iRects, BoxPtr aRects)
-{
-    VBVACMDHDR cmdHdr;
-    VBOXPtr pVBox;
-    VBVARECORD *pRecord;
-    VBVAMEMORY *pMem;
-    CARD32 indexRecordNext;
-    CARD32 off32Data;
-    CARD32 off32Free;
-    INT32 i32Diff;
-    CARD32 cbHwBufferAvail;
-    int scrnIndex;
-    int i;
-
-    pVBox = pScrn->driverPrivate;
-    if (pVBox->useVbva == FALSE)
-        return;
-    pMem = pVBox->pVbvaMemory;
-    /* Just return quietly if VBVA is not currently active. */
-    if ((pMem->fu32ModeFlags & VBVA_F_MODE_ENABLED) == 0)
-        return;
-    scrnIndex = pScrn->scrnIndex;
-
-    for (i = 0; i < iRects; i++)
-    {
-        cmdHdr.x = (int16_t)aRects[i].x1 - pVBox->viewportX;
-        cmdHdr.y = (int16_t)aRects[i].y1 - pVBox->viewportY;
-        cmdHdr.w = (uint16_t)(aRects[i].x2 - aRects[i].x1);
-        cmdHdr.h = (uint16_t)(aRects[i].y2 - aRects[i].y1);
-
-        /* Get the active record and move the pointer along */
-        indexRecordNext = (pMem->indexRecordFree + 1)
-                           % VBVA_MAX_RECORDS;
-        if (indexRecordNext == pMem->indexRecordFirst)
-        {
-            /* All slots in the records queue are used. */
-            if (vbox_vmmcall(pScrn, pVBox,
-                             (VMMDevRequestHeader *) pVBox->reqf) != TRUE)
-                DISABLE_VBVA_AND_RETURN(pScrn,
-                    "Unable to clear the VirtualBox graphics acceleration queue "
-                    "- the request to the virtual machine failed.  Switching to "
-                    "unaccelerated mode.\n");
-        }
-        if (indexRecordNext == pMem->indexRecordFirst)
-            DISABLE_VBVA_AND_RETURN(pScrn,
-                "Failed to clear the VirtualBox graphics acceleration queue.  "
-                "Switching to unaccelerated mode.\n");
-        pRecord = &pMem->aRecords[pMem->indexRecordFree];
-        /* Mark the record as being updated. */
-        pRecord->cbRecord = VBVA_F_RECORD_PARTIAL;
-        pMem->indexRecordFree = indexRecordNext;
-        /* Compute how many bytes we have in the ring buffer. */
-        off32Free = pMem->off32Free;
-        off32Data = pMem->off32Data;
-        /* Free is writing position. Data is reading position.
-         * Data == Free means buffer is free.
-         * There must be always gap between free and data when data
-         * are in the buffer.
-         * Guest only changes free, host only changes data.
-         */
-        i32Diff = off32Data - off32Free;
-        cbHwBufferAvail = i32Diff > 0? i32Diff: VBVA_RING_BUFFER_SIZE
-                                              + i32Diff;
-        if (cbHwBufferAvail <= VBVA_RING_BUFFER_THRESHOLD)
-        {
-            if (vbox_vmmcall(pScrn, pVBox,
-                            (VMMDevRequestHeader *) pVBox->reqf) != TRUE)
-                DISABLE_VBVA_AND_RETURN(pScrn,
-                    "Unable to clear the VirtualBox graphics acceleration queue "
-                    "- the request to the virtual machine failed.  Switching to "
-                    "unaccelerated mode.\n");
-            /* Calculate the free space again. */
-            off32Free = pMem->off32Free;
-            off32Data = pMem->off32Data;
-            i32Diff = off32Data - off32Free;
-            cbHwBufferAvail = i32Diff > 0? i32Diff:
-                                  VBVA_RING_BUFFER_SIZE + i32Diff;
-            if (cbHwBufferAvail <= VBVA_RING_BUFFER_THRESHOLD)
-                DISABLE_VBVA_AND_RETURN(pScrn,
-                    "No space left in the VirtualBox graphics acceleration command buffer, "
-                    "despite clearing the queue.  Switching to unaccelerated mode.\n");
-        }
-        /* Now copy the data into the buffer */
-        if (off32Free + sizeof(cmdHdr) < VBVA_RING_BUFFER_SIZE)
-        {
-            memcpy(&pMem->au8RingBuffer[off32Free], &cmdHdr,
-                   sizeof(cmdHdr));
-            pMem->off32Free = pMem->off32Free + sizeof(cmdHdr);
-        }
-        else
-        {
-            CARD32 u32First = VBVA_RING_BUFFER_SIZE - off32Free;
-            /* The following is impressively ugly! */
-            CARD8 *pu8Second = (CARD8 *)&cmdHdr + u32First;
-            CARD32 u32Second = sizeof(cmdHdr) - u32First;
-            memcpy(&pMem->au8RingBuffer[off32Free], &cmdHdr, u32First);
-            if (u32Second)
-                memcpy(&pMem->au8RingBuffer[0], (void *)pu8Second, u32Second);
-            pMem->off32Free = u32Second;
-        }
-        pRecord->cbRecord += sizeof(cmdHdr);
-        /* Mark the record completed. */
-        pRecord->cbRecord &= ~VBVA_F_RECORD_PARTIAL;
-    }
-}
-
-
-/**
- * Initialise VirtualBox's accelerated video extensions.
- * Note that we assume that the PCI memory is 32bit mapped,
- * as X doesn't seem to support mapping 64bit memory.
- *
- * @returns True on success, false on failure
- */
-static Bool
-vboxInitVbva(int scrnIndex, ScreenPtr pScreen, VBOXPtr pVBox)
-{
-    PCITAG pciTagDev;
-    ADDRESS pciAddrDev;
-    int rc;
-
-    /* Locate the device.  It should already have been enabled by
-       the kernel driver. */
-    pciTagDev = pciFindFirst((unsigned) VMMDEV_DEVICEID << 16 | VMMDEV_VENDORID,
-                             (CARD32) ~0);
-    if (pciTagDev == PCI_NOT_FOUND)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Could not find the VirtualBox base device on the PCI bus.\n");
-        return FALSE;
-    }
-    /* Read the address and size of the second I/O region. */
-    pciAddrDev = pciReadLong(pciTagDev, PCI_MAP_REG_START + 4);
-    if (pciAddrDev == 0 || pciAddrDev == (CARD32) ~0)
-        RETERROR(scrnIndex, FALSE,
-                 "The VirtualBox base device contains an invalid memory address.\n");
-    if (PCI_MAP_IS64BITMEM(pciAddrDev))
-        RETERROR(scrnIndex, FALSE,
-                 "The VirtualBox base device has a 64bit mapping address.  "
-                 "This is currently not supported.\n");
-    /* Map it.  We hardcode the size as X does not export the
-       function needed to determine it. */
-    pVBox->pVMMDevMemory = xf86MapPciMem(scrnIndex, 0, pciTagDev, pciAddrDev,
-                                         sizeof(VMMDevMemory));
-    if (pVBox->pVMMDevMemory == NULL)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Failed to map VirtualBox video extension memory.\n");
-        return FALSE;
-    }
-    pVBox->pVbvaMemory = &pVBox->pVMMDevMemory->vbvaMemory;
-    /* Initialise requests */
-    pVBox->reqf = xcalloc(1, vmmdevGetRequestSize(VMMDevReq_VideoAccelFlush));
-    if (!pVBox->reqf)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Could not allocate memory for VBVA flush request.\n");
-        return FALSE;
-    }
-    rc = vmmdevInitRequest ((VMMDevRequestHeader *) pVBox->reqf,
-                            VMMDevReq_VideoAccelFlush);
-    if (RT_FAILURE (rc))
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Could not initialise VBVA flush request: return value %d\n", rc);
-        xfree(pVBox->reqf);
-        return FALSE;
-    }
-    pVBox->reqe = xcalloc(1, vmmdevGetRequestSize(VMMDevReq_VideoAccelEnable));
-    if (!pVBox->reqe)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Could not allocate memory for VBVA enable request.\n");
-        xfree(pVBox->reqf);
-        return FALSE;
-    }
-    rc = vmmdevInitRequest ((VMMDevRequestHeader *) pVBox->reqe,
-                            VMMDevReq_VideoAccelEnable);
-    if (RT_FAILURE (rc))
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Could not initialise VBVA enable request: return value = %d\n",
-                   rc);
-        xfree(pVBox->reqf);
-        xfree(pVBox->reqe);
-        return FALSE;
-    }
-    /* Set up the dirty rectangle handler.  Since this seems to be a
-       delicate operation, and removing it doubly so, this will
-       remain in place whether it is needed or not, and will simply
-       return if VBVA is not active.  I assume that it will be active
-       most of the time. */
-    if (ShadowFBInit2(pScreen, NULL, vboxHandleDirtyRect) != TRUE)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Unable to install dirty rectangle handler for VirtualBox graphics acceleration.\n");
-        xfree(pVBox->reqf);
-        xfree(pVBox->reqe);
-        return FALSE;
-    }
-    return TRUE;
-}
-
-Bool
-vbox_open (ScrnInfoPtr pScrn, ScreenPtr pScreen, VBOXPtr pVBox)
-{
-    int fd, vrc;
-    void *p = NULL;
-    size_t size;
-    int scrnIndex = pScrn->scrnIndex;
-    Bool rc = TRUE;
-
-    TRACE_ENTRY ();
-
-    pVBox->useVbva = FALSE;
-
-#ifdef RT_OS_SOLARIS
-    NOREF(fd);
-    if (pVBox->reqp)
-    {
-        /* still open, just re-enable VBVA after CloseScreen was called */
-        pVBox->useVbva = vboxInitVbva(scrnIndex, pScreen, pVBox);
-        return TRUE;
-    }
-
-    vrc = VbglR3Init();
-    if (RT_FAILURE(vrc))
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR, "VbglR3Init failed vrc=%d.\n", vrc);
-        rc = FALSE;
-    }
-#else
-    if (pVBox->vbox_fd != -1 && pVBox->reqp)
-    {
-        /* still open, just re-enable VBVA after CloseScreen was called */
-        pVBox->useVbva = vboxInitVbva(scrnIndex, pScreen, pVBox);
-        return TRUE;
-    }
-
-    fd = open (VBOXGUEST_DEVICE_NAME, O_RDWR, 0);
-    if (fd < 0)
-    {
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Error opening kernel module: %s\n",
-                   strerror (errno));
-        rc = FALSE;
-    }
-#endif
-
-    if (rc) {
-        size = vmmdevGetRequestSize (VMMDevReq_SetPointerShape);
-
-        p = xcalloc (1, size);
-        if (NULL == p) {
-            xf86DrvMsg(scrnIndex, X_ERROR,
-                       "Could not allocate %lu bytes for VMM request\n",
-                       (unsigned long) size);
-            rc = FALSE;
-        }
-    }
-    if (rc) {
-        vrc = vmmdevInitRequest (p, VMMDevReq_SetPointerShape);
-        if (RT_FAILURE (vrc))
-        {
-            xf86DrvMsg(scrnIndex, X_ERROR,
-                       "Could not init VMM request: vrc = %d\n", vrc);
-            rc = FALSE;
-        }
-    }
-    if (rc) {
-#ifndef RT_OS_SOLARIS
-        pVBox->vbox_fd = fd;
-#endif
-        pVBox->reqp = p;
-        pVBox->pCurs = NULL;
-        pVBox->pointerHeaderSize = size;
-        pVBox->useVbva = vboxInitVbva(scrnIndex, pScreen, pVBox);
-    } else {
-        if (NULL != p) {
-            xfree (p);
-        }
-#ifdef RT_OS_SOLARIS
-        VbglR3Term();
-#else
-        if (close (fd)) {
-            xf86DrvMsg(scrnIndex, X_ERROR,
-                       "Error closing kernel module file descriptor(%d): %s\n",
-                       fd, strerror (errno));
-        }
-#endif
-    }
-    return rc;
-}
-
-static void vbox_vmm_hide_cursor (ScrnInfoPtr pScrn, VBOXPtr pVBox)
-{
-    pVBox->reqp->fFlags = 0;
-    if (vbox_vmmcall (pScrn, pVBox, &pVBox->reqp->header) != TRUE)
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Could not hide the virtual mouse pointer.\n");
-}
-
-static void vbox_vmm_show_cursor (ScrnInfoPtr pScrn, VBOXPtr pVBox)
-{
-    pVBox->reqp->fFlags = VBOX_MOUSE_POINTER_VISIBLE;
-    if (vbox_vmmcall (pScrn, pVBox, &pVBox->reqp->header) != TRUE)
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Could not unhide the virtual mouse pointer.\n");
-}
-
-static void vbox_vmm_load_cursor_image (ScrnInfoPtr pScrn, VBOXPtr pVBox,
-                                        unsigned char *image)
-{
-    VMMDevReqMousePointer *reqp;
-    reqp = (VMMDevReqMousePointer *) image;
-
-    dolog ("w=%d h=%d size=%d\n",
-           reqp->width,
-           reqp->height,
-           reqp->header.size);
-
-#ifdef DEBUG_X
-    vbox_show_shape (reqp->width, reqp->height, 0, image);
-#endif
-
-    if (vbox_vmmcall (pScrn, pVBox, &reqp->header) != TRUE)
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Unable to set the virtual mouse pointer image.\n");
-}
-
-static void vbox_set_cursor_colors (ScrnInfoPtr pScrn, int bg, int fg)
-{
-    TRACE_ENTRY ();
-
-    (void) pScrn;
-    (void) bg;
-    (void) fg;
-    /* ErrorF ("vbox_set_cursor_colors NOT IMPLEMENTED\n"); */
-}
-
-static void
-vbox_set_cursor_position (ScrnInfoPtr pScrn, int x, int y)
-{
-    (void) pScrn; (void) x; (void) y;
-}
-
-static void vbox_hide_cursor (ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    TRACE_ENTRY ();
-
-    vbox_vmm_hide_cursor (pScrn, pVBox);
-}
-
-static void vbox_show_cursor (ScrnInfoPtr pScrn)
-{
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    TRACE_ENTRY ();
-
-    vbox_vmm_show_cursor (pScrn, pVBox);
-}
-
-static void vbox_load_cursor_image (ScrnInfoPtr pScrn, unsigned char *image)
-{
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    TRACE_ENTRY ();
-
-    vbox_vmm_load_cursor_image (pScrn, pVBox, image);
-}
-
-static Bool
-vbox_use_hw_cursor (ScreenPtr pScreen, CursorPtr pCurs)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    return vbox_host_uses_hwcursor(pScrn);
-}
-
-static unsigned char color_to_byte (unsigned c)
-{
-    return (c >> 8) & 0xff;
-}
-
-static unsigned char *
-vbox_realize_cursor(xf86CursorInfoPtr infoPtr, CursorPtr pCurs)
-{
-    VBOXPtr pVBox;
-    CursorBitsPtr bitsp;
-    unsigned short w, h, x, y;
-    unsigned char *c, *p, *pm, *ps, *m;
-    size_t size, size_rgba, size_mask, src_pitch, dst_pitch;
-    CARD32 fc, bc, *cp;
-    int rc, scrnIndex = infoPtr->pScrn->scrnIndex;
-    VMMDevReqMousePointer *reqp;
-
-    pVBox = infoPtr->pScrn->driverPrivate;
-    bitsp = pCurs->bits;
-    w = bitsp->width;
-    h = bitsp->height;
-
-    if (!w || !h || w > VBOX_MAX_CURSOR_WIDTH || h > VBOX_MAX_CURSOR_HEIGHT)
-        RETERROR(scrnIndex, NULL,
-            "Error invalid cursor dimensions %dx%d\n", w, h);
-
-    if ((bitsp->xhot > w) || (bitsp->yhot > h))
-        RETERROR(scrnIndex, NULL,
-            "Error invalid cursor hotspot location %dx%d (max %dx%d)\n",
-            bitsp->xhot, bitsp->yhot, w, h);
-
-    src_pitch = PixmapBytePad (bitsp->width, 1);
-    dst_pitch = (w + 7) / 8;
-    size_mask = ((dst_pitch * h) + 3) & (size_t) ~3;
-    size_rgba = w * h * 4;
-    size      = size_mask + size_rgba + pVBox->pointerHeaderSize;
-
-    p = c = xcalloc (1, size);
-    if (!c)
-        RETERROR(scrnIndex, NULL,
-                 "Error failed to alloc %lu bytes for cursor\n",
-                 (unsigned long) size);
-
-    rc = vmmdevInitRequest ((VMMDevRequestHeader *) p,
-                            VMMDevReq_SetPointerShape);
-    if (RT_FAILURE (rc)) {
-        xfree(p);
-        RETERROR(scrnIndex, NULL,
-                 "Could not init VMM request: rc = %d\n", rc);
-    }
-
-    m = p + offsetof (VMMDevReqMousePointer, pointerData);
-    cp = (CARD32 *) (m + size_mask);
-
-    dolog ("w=%d h=%d sm=%d sr=%d p=%d\n",
-           w, h, (int) size_mask, (int) size_rgba, (int) dst_pitch);
-    dolog ("m=%p c=%p cp=%p\n", m, c, (void *) (void *)cp);
-
-    fc = color_to_byte (pCurs->foreBlue)
-      | (color_to_byte (pCurs->foreGreen) << 8)
-      | (color_to_byte (pCurs->foreRed)   << 16);
-
-    bc = color_to_byte (pCurs->backBlue)
-      | (color_to_byte (pCurs->backGreen) << 8)
-      | (color_to_byte (pCurs->backRed)   << 16);
-
-    /*
-     * Convert the Xorg source/mask bits to the and/xor bits VBox needs.
-     * Xorg:
-     *   The mask is a bitmap indicating which parts of the cursor are
-     *   transparent and which parts are drawn. The source is a bitmap
-     *   indicating which parts of the non-transparent portion of the
-     *   the cursor should be painted in the foreground color and which
-     *   should be painted in the background color. By default, set bits
-     *   indicate the opaque part of the mask bitmap and clear bits
-     *   indicate the transparent part.
-     * VBox:
-     *   The color data is the XOR mask. The AND mask bits determine
-     *   which pixels of the color data (XOR mask) will replace (overwrite)
-     *   the screen pixels (AND mask bit = 0) and which ones will be XORed
-     *   with existing screen pixels (AND mask bit = 1).
-     *   For example when you have the AND mask all 0, then you see the
-     *   correct mouse pointer image surrounded by black square.
-     */
-    for (pm = bitsp->mask, ps = bitsp->source, y = 0;
-         y < h;
-         ++y, pm += src_pitch, ps += src_pitch, m += dst_pitch)
-    {
-        for (x = 0; x < w; ++x)
-        {
-            if (pm[x / 8] & (1 << (x % 8)))
-            {
-                /* opaque, leave AND mask bit at 0 */
-                if (ps[x / 8] & (1 << (x % 8)))
-                {
-                    *cp++ = fc;
-                    PUT_PIXEL ('X');
-                }
-                else
-                {
-                    *cp++ = bc;
-                    PUT_PIXEL ('*');
-                }
-            }
-            else
-            {
-                /* transparent, set AND mask bit */
-                m[x / 8] |= 1 << (7 - (x % 8));
-                /* don't change the screen pixel */
-                *cp++ = 0;
-                PUT_PIXEL (' ');
-            }
-        }
-        PUT_PIXEL ('\n');
-    }
-
-    reqp = (VMMDevReqMousePointer *) p;
-    reqp->width  = w;
-    reqp->height = h;
-    reqp->xHot   = bitsp->xhot;
-    reqp->yHot   = bitsp->yhot;
-    reqp->fFlags = VBOX_MOUSE_POINTER_SHAPE;
-    reqp->header.size = size;
-
-#ifdef DEBUG_X
-    ErrorF ("shape = %p\n", p);
-    vbox_show_shape (w, h, bc, c);
-#endif
-
-    return p;
-}
-
-#ifdef ARGB_CURSOR
-static Bool vbox_use_hw_cursor_argb (ScreenPtr pScreen, CursorPtr pCurs)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    Bool rc = TRUE;
-
-    if (!vbox_host_uses_hwcursor(pScrn))
-        rc = FALSE;
-    if (   rc
-        && (   (pCurs->bits->height > VBOX_MAX_CURSOR_HEIGHT)
-            || (pCurs->bits->width > VBOX_MAX_CURSOR_WIDTH)
-            || (pScrn->bitsPerPixel <= 8)
-           )
-       )
-        rc = FALSE;
-    return rc;
-}
-
-static void vbox_load_cursor_argb (ScrnInfoPtr pScrn, CursorPtr pCurs)
-{
-    VBOXPtr pVBox;
-    VMMDevReqMousePointer *reqp;
-    CursorBitsPtr bitsp;
-    unsigned short w, h;
-    unsigned short cx, cy;
-    unsigned char *pm;
-    CARD32 *pc;
-    size_t size, mask_size;
-    CARD8 *p;
-    int scrnIndex;
-
-    pVBox = pScrn->driverPrivate;
-    bitsp = pCurs->bits;
-    w     = bitsp->width;
-    h     = bitsp->height;
-    scrnIndex = pScrn->scrnIndex;
-
-    /* Mask must be generated for alpha cursors, that is required by VBox. */
-    /* @note: (michael) the next struct must be 32bit aligned. */
-    mask_size  = ((w + 7) / 8 * h + 3) & ~3;
-
-    if (!w || !h || w > VBOX_MAX_CURSOR_WIDTH || h > VBOX_MAX_CURSOR_HEIGHT)
-        RETERROR(scrnIndex, ,
-                 "Error invalid cursor dimensions %dx%d\n", w, h);
-
-    if ((bitsp->xhot > w) || (bitsp->yhot > h))
-        RETERROR(scrnIndex, ,
-            "Error invalid cursor hotspot location %dx%d (max %dx%d)\n",
-            bitsp->xhot, bitsp->yhot, w, h);
-
-    size = w * h * 4 + pVBox->pointerHeaderSize + mask_size;
-    p = xcalloc (1, size);
-    if (!p)
-        RETERROR(scrnIndex, ,
-            "Error failed to alloc %lu bytes for cursor\n",
-            (unsigned long) size);
-
-    reqp = (VMMDevReqMousePointer *) p;
-    *reqp = *pVBox->reqp;
-    reqp->width  = w;
-    reqp->height = h;
-    reqp->xHot   = bitsp->xhot;
-    reqp->yHot   = bitsp->yhot;
-    reqp->fFlags = VBOX_MOUSE_POINTER_SHAPE | VBOX_MOUSE_POINTER_ALPHA;
-    reqp->header.size = size;
-
-    memcpy (p + offsetof (VMMDevReqMousePointer, pointerData) + mask_size,
-            bitsp->argb, w * h * 4);
-
-    /** @ */
-    /* Emulate the AND mask. */
-    pm = p + offsetof (VMMDevReqMousePointer, pointerData);
-    pc = bitsp->argb;
-
-    /* Init AND mask to 1 */
-    memset (pm, 0xFF, mask_size);
-
-    /**
-     * The additions driver must provide the AND mask for alpha cursors. The host frontend
-     * which can handle alpha channel, will ignore the AND mask and draw an alpha cursor.
-     * But if the host does not support ARGB, then it simply uses the AND mask and the color
-     * data to draw a normal color cursor.
-     */
-    for (cy = 0; cy < h; cy++)
-    {
-        unsigned char bitmask = 0x80;
-
-        for (cx = 0; cx < w; cx++, bitmask >>= 1)
-        {
-            if (bitmask == 0)
-                bitmask = 0x80;
-
-            if (pc[cx] >= 0xF0000000)
-                pm[cx / 8] &= ~bitmask;
-        }
-
-        /* Point to next source and dest scans */
-        pc += w;
-        pm += (w + 7) / 8;
-    }
-
-    if (vbox_vmmcall (pScrn, pVBox, &reqp->header) != TRUE)
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
-                   "Request to virtual machine failed "
-                   "- unable to set the virtual mouse pointer ARGB cursor image.\n");
-
-    xfree (p);
-}
-#endif
-
-Bool vbox_cursor_init (ScreenPtr pScreen)
-{
-    ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
-    VBOXPtr pVBox = pScrn->driverPrivate;
-    xf86CursorInfoPtr pCurs;
-    Bool rc;
-
-    pVBox->pCurs = pCurs = xf86CreateCursorInfoRec ();
-    if (!pCurs)
-        RETERROR(pScrn->scrnIndex, FALSE,
-                 "Failed to create X Window cursor information structures for virtual mouse.\n");
-
-    pCurs->MaxWidth = VBOX_MAX_CURSOR_WIDTH;
-    pCurs->MaxHeight = VBOX_MAX_CURSOR_HEIGHT;
-    pCurs->Flags = HARDWARE_CURSOR_TRUECOLOR_AT_8BPP
-                 | HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1
-                 | HARDWARE_CURSOR_BIT_ORDER_MSBFIRST;
-
-    pCurs->SetCursorColors   = vbox_set_cursor_colors;
-    pCurs->SetCursorPosition = vbox_set_cursor_position;
-    pCurs->LoadCursorImage   = vbox_load_cursor_image;
-    pCurs->HideCursor        = vbox_hide_cursor;
-    pCurs->ShowCursor        = vbox_show_cursor;
-    pCurs->UseHWCursor       = vbox_use_hw_cursor;
-    pCurs->RealizeCursor     = vbox_realize_cursor;
-
-#ifdef ARGB_CURSOR
-    pCurs->UseHWCursorARGB   = vbox_use_hw_cursor_argb;
-    pCurs->LoadCursorARGB    = vbox_load_cursor_argb;
-#endif
-
-    /* Hide the host cursor before we initialise if we wish to use a
-     * software cursor. */
-    if (pVBox->forceSWCursor)
-        vbox_vmm_hide_cursor(pScrn, pVBox);
-    rc = xf86InitCursor (pScreen, pCurs);
-    if (rc == TRUE)
-        return TRUE;
-    RETERROR(pScrn->scrnIndex, FALSE, "Failed to enable mouse pointer integration.\n");
-}
-
-/**
- * Inform VBox that we will supply it with dirty rectangle information
- * and install the dirty rectangle handler.
- *
- * @returns TRUE for success, FALSE for failure
- * @param   pScreen Pointer to a structure describing the X screen in use
- */
-Bool
-vboxEnableVbva(ScrnInfoPtr pScrn)
-{
-    int scrnIndex = pScrn->scrnIndex;
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    if (pVBox->useVbva != TRUE)
-        return FALSE;
-    pVBox->reqe->u32Enable = 1;
-    pVBox->reqe->cbRingBuffer = VBVA_RING_BUFFER_SIZE;
-    pVBox->reqe->fu32Status = 0;
-    if (vbox_vmmcall(pScrn, pVBox, (VMMDevRequestHeader *) pVBox->reqe)
-        != TRUE)
-    {
-        /* Request not accepted - disable for old hosts. */
-        xf86DrvMsg(scrnIndex, X_ERROR,
-                   "Unable to activate VirtualBox graphics acceleration "
-                   "- the request to the virtual machine failed.  "
-                   "You may be running an old version of VirtualBox.\n");
-        pVBox->useVbva = FALSE;
-        pVBox->reqe->u32Enable = 0;
-        pVBox->reqe->cbRingBuffer = VBVA_RING_BUFFER_SIZE;
-        pVBox->reqe->fu32Status = 0;
-        vbox_vmmcall(pScrn, pVBox, (VMMDevRequestHeader *) pVBox->reqe);
-        return FALSE;
-    }
-    return TRUE;
-}
-
-
-/**
- * Inform VBox that we will stop supplying it with dirty rectangle
- * information. This function is intended to be called when an X
- * virtual terminal is disabled, or the X server is terminated.
- *
- * @returns TRUE for success, FALSE for failure
- * @param   pScreen Pointer to a structure describing the X screen in use
- */
-Bool
-vboxDisableVbva(ScrnInfoPtr pScrn)
-{
-    int scrnIndex = pScrn->scrnIndex;
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    if (pVBox->useVbva != TRUE)  /* Ths function should not have been called */
-        return FALSE;
-    pVBox->reqe->u32Enable = 0;
-    pVBox->reqe->cbRingBuffer = VBVA_RING_BUFFER_SIZE;
-    pVBox->reqe->fu32Status = 0;
-    if (vbox_vmmcall(pScrn, pVBox, (VMMDevRequestHeader *) pVBox->reqe)
-        != TRUE)
-        xf86DrvMsg(scrnIndex, X_ERROR,
-            "Unable to disable VirtualBox graphics acceleration "
-            "- the request to the virtual machine failed.\n");
-    else
-        memset(pVBox->pVbvaMemory, 0, sizeof(VBVAMEMORY));
-    return TRUE;
-}
-
-
-/**
- * Query the last display change request.
- *
- * @returns iprt status value
- * @param xres     where to store the horizontal pixel resolution requested
- *                 (0 = do not change)
- * @param yres     where to store the vertical pixel resolution requested
- *                 (0 = do not change)
- * @param bpp      where to store the bits per pixel requeste
- *                 (0 = do not change)
- * @param  display Where to store the display number the request was for -
- *                 0 for the primary display, 1 for the first secondary, etc.
- */
-Bool
-vboxGetDisplayChangeRequest(ScrnInfoPtr pScrn, uint32_t *pX, uint32_t *pY,
-                            uint32_t *pBpp, uint32_t *pDisplay)
-{
-    int rc, scrnIndex = pScrn->scrnIndex;
-    VBOXPtr pVBox = pScrn->driverPrivate;
-
-    VMMDevDisplayChangeRequest2 Req = { { 0 } };
-    vmmdevInitRequest(&Req.header, VMMDevReq_GetDisplayChangeRequest2);
-    rc = vbox_vmmcall(pScrn, pVBox, &Req.header);
-    if (RT_SUCCESS(rc))
-    {
-        *pX = Req.xres;
-        *pY = Req.yres;
-        *pBpp = Req.bpp;
-        *pDisplay = Req.display;
-        return TRUE;
-    }
-    xf86DrvMsg(scrnIndex, X_ERROR,
-               "Failed to request the last resolution requested from the guest, rc=%d.\n",
-               rc);
-    return FALSE;
-}
Index: src/VBox/Additions/x11/vboxvideo/vboxutils.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxutils.c.orig
+++ src/VBox/Additions/x11/vboxvideo/vboxutils.c
@@ -172,8 +172,8 @@ vbox_close(ScrnInfoPtr pScrn, VBOXPtr pV
 {
     TRACE_ENTRY();
 
-    xfree (pVBox->reqp);
-    pVBox->reqp = NULL;
+    xf86DestroyCursorInfoRec(pVBox->pCurs);
+    pVBox->pCurs = NULL;
     TRACE_EXIT();
 }
 
@@ -418,41 +418,12 @@ vbox_init(int scrnIndex, VBOXPtr pVBox)
 Bool
 vbox_open(ScrnInfoPtr pScrn, ScreenPtr pScreen, VBOXPtr pVBox)
 {
-    int rc;
-    void *p;
-    size_t size;
-    int scrnIndex = pScrn->scrnIndex;
-
     TRACE_ENTRY();
 
     if (!pVBox->useDevice)
         return FALSE;
-
-    if (pVBox->reqp)
-    {
-        /* still open, just re-enable VBVA after CloseScreen was called */
-        pVBox->useVbva = vboxInitVbva(scrnIndex, pScreen, pVBox);
-        return TRUE;
-    }
-
-    size = vmmdevGetRequestSize(VMMDevReq_SetPointerShape);
-    p = xcalloc(1, size);
-    if (p)
-    {
-        rc = vmmdevInitRequest(p, VMMDevReq_SetPointerShape);
-        if (RT_SUCCESS(rc))
-        {
-            pVBox->reqp = p;
-            pVBox->pCurs = NULL;
-            pVBox->pointerHeaderSize = size;
-            pVBox->useVbva = vboxInitVbva(scrnIndex, pScreen, pVBox);
-            return TRUE;
-        }
-        xf86DrvMsg(scrnIndex, X_ERROR, "Could not init VMM request: rc = %d\n", rc);
-        xfree(p);
-    }
-    xf86DrvMsg(scrnIndex, X_ERROR, "Could not allocate %lu bytes for VMM request\n", (unsigned long)size);
-    return FALSE;
+    pVBox->useVbva = vboxInitVbva(pScrn->scrnIndex, pScreen, pVBox);
+    return TRUE;
 }
 
 Bool
@@ -466,11 +437,10 @@ vbox_vmm_hide_cursor(ScrnInfoPtr pScrn,
 {
     int rc;
 
-    pVBox->reqp->fFlags = 0;
-    rc = VbglR3SetPointerShapeReq(pVBox->reqp);
+    rc = VbglR3SetPointerShape(0, 0, 0, 0, 0, NULL, 0);
     if (RT_FAILURE(rc))
     {
-        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not hide the virtual mouse pointer.\n");
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not hide the virtual mouse pointer, VBox error %d.\n", rc);
         /* Play safe, and disable the hardware cursor until the next mode
          * switch, since obviously something happened that we didn't
          * anticipate. */
@@ -483,16 +453,15 @@ vbox_vmm_show_cursor(ScrnInfoPtr pScrn,
 {
     int rc;
 
-    if (vbox_host_uses_hwcursor(pScrn)) {
-        pVBox->reqp->fFlags = VBOX_MOUSE_POINTER_VISIBLE;
-        rc = VbglR3SetPointerShapeReq(pVBox->reqp);
-        if (RT_FAILURE(rc)) {
-            xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not unhide the virtual mouse pointer.\n");
-            /* Play safe, and disable the hardware cursor until the next mode
-             * switch, since obviously something happened that we didn't
-             * anticipate. */
-            pVBox->forceSWCursor = TRUE;
-        }
+    if (!vbox_host_uses_hwcursor(pScrn))
+        return;
+    rc = VbglR3SetPointerShape(VBOX_MOUSE_POINTER_VISIBLE, 0, 0, 0, 0, NULL, 0);
+    if (RT_FAILURE(rc)) {
+        xf86DrvMsg(pScrn->scrnIndex, X_ERROR, "Could not unhide the virtual mouse pointer.\n");
+        /* Play safe, and disable the hardware cursor until the next mode
+         * switch, since obviously something happened that we didn't
+         * anticipate. */
+        pVBox->forceSWCursor = TRUE;
     }
 }
 
@@ -605,10 +574,9 @@ vbox_realize_cursor(xf86CursorInfoPtr in
     dstPitch = (w + 7) / 8;
     sizeMask = ((dstPitch * h) + 3) & (size_t) ~3;
     sizeRgba = w * h * 4;
-    pVBox->pointerSize = sizeMask + sizeRgba;
-    sizeRequest = pVBox->pointerSize + pVBox->pointerHeaderSize;
+    sizeRequest = sizeMask + sizeRgba + sizeof(VMMDevReqMousePointer);
 
-    p = c = xcalloc (1, sizeRequest);
+    p = c = calloc (1, sizeRequest);
     if (!c)
         RETERROR(scrnIndex, NULL,
                  "Error failed to alloc %lu bytes for cursor\n",
@@ -618,7 +586,7 @@ vbox_realize_cursor(xf86CursorInfoPtr in
     if (RT_FAILURE(rc))
     {
         xf86DrvMsg(scrnIndex, X_ERROR, "Could not init VMM request: rc = %d\n", rc);
-        xfree(p);
+        free(p);
         return NULL;
     }
 
@@ -739,9 +707,12 @@ vbox_load_cursor_argb(ScrnInfoPtr pScrn,
     unsigned short cx, cy;
     unsigned char *pm;
     CARD32 *pc;
-    size_t sizeRequest, sizeMask;
+    size_t sizeData, sizeMask;
     CARD8 *p;
     int scrnIndex;
+    uint32_t fFlags =   VBOX_MOUSE_POINTER_VISIBLE | VBOX_MOUSE_POINTER_SHAPE
+                      | VBOX_MOUSE_POINTER_ALPHA;
+    int rc;
 
     TRACE_ENTRY();
     pVBox = pScrn->driverPrivate;
@@ -763,28 +734,17 @@ vbox_load_cursor_argb(ScrnInfoPtr pScrn,
                  "Error invalid cursor hotspot location %dx%d (max %dx%d)\n",
                  bitsp->xhot, bitsp->yhot, w, h);
 
-    pVBox->pointerSize = w * h * 4 + sizeMask;
-    sizeRequest = pVBox->pointerSize + pVBox->pointerHeaderSize;
-    p = xcalloc(1, sizeRequest);
+    sizeData = w * h * 4 + sizeMask;
+    p = calloc(1, sizeData);
     if (!p)
         RETERROR(scrnIndex, ,
                  "Error failed to alloc %lu bytes for cursor\n",
-                 (unsigned long)sizeRequest);
-
-    reqp = (VMMDevReqMousePointer *)p;
-    *reqp = *pVBox->reqp;
-    reqp->width  = w;
-    reqp->height = h;
-    reqp->xHot   = bitsp->xhot;
-    reqp->yHot   = bitsp->yhot;
-    reqp->fFlags =   VBOX_MOUSE_POINTER_VISIBLE | VBOX_MOUSE_POINTER_SHAPE
-                   | VBOX_MOUSE_POINTER_ALPHA;
-    reqp->header.size = sizeRequest;
+                 (unsigned long)sizeData);
 
-    memcpy(p + offsetof(VMMDevReqMousePointer, pointerData) + sizeMask, bitsp->argb, w * h * 4);
+    memcpy(p + sizeMask, bitsp->argb, w * h * 4);
 
     /* Emulate the AND mask. */
-    pm = p + offsetof(VMMDevReqMousePointer, pointerData);
+    pm = p;
     pc = bitsp->argb;
 
     /* Init AND mask to 1 */
@@ -814,8 +774,9 @@ vbox_load_cursor_argb(ScrnInfoPtr pScrn,
         pm += (w + 7) / 8;
     }
 
-    VbglR3SetPointerShapeReq(reqp);
-    xfree(p);
+    rc = VbglR3SetPointerShape(fFlags, bitsp->xhot, bitsp->yhot, w, h, p, sizeData);
+    TRACE_LOG(": leaving, returning %d\n", rc);
+    free(p);
 }
 #endif
 
@@ -1091,7 +1052,7 @@ static void vboxFillDisplayMode(DisplayM
     if (pszName)
     {
         if (m->name)
-            xfree(m->name);
+            free(m->name);
         m->name      = xnfstrdup(pszName);
     }
 }
Index: src/VBox/Additions/x11/vboxvideo/undefined_13
===================================================================
--- src/VBox/Additions/x11/vboxvideo/undefined_13.orig
+++ src/VBox/Additions/x11/vboxvideo/undefined_13
@@ -1,181 +1,190 @@
-XNFstrdup
-chdir
-LoaderRefSymLists
-xf86PrintDepthBpp
-xf86ShowUnusedOptions
-pci_device_probe
-memset
+DRICloseScreen
+DRICreateInfoRec
 DRICreatePCIBusID
-miDCInitialize
-close
-ioctl
-memchr
-xf86SetDpi
-xf86HandleColormaps
-utimes
-pci_id_match_iterator_create
-__gmon_start__
-_Jv_RegisterClasses
-VBEGetVBEMode
-VBESaveRestore
-__isoc99_sscanf
-sscanf
-xf86LoaderReqSymLists
-ErrorF
+DRIDestroyInfoRec
+DRIFinishScreenInit
+DRILock
+DRIQueryVersion
 DRIScreenInit
-xf86InitCursor
-xf86SetGamma
-Xalloc
-xf86SlowBcopy
-xf86GetEntityInfo
-read
-strncmp
-malloc
-xf86ConfigPciEntity
-drmFreeVersion
-xf86SetSingleMode
-unlink
-xf86MapDomainMemory
-miClearVisualTypes
-VBESetGetPaletteData
-xf86DrvMsg
-VBESetDisplayStart
-xf86Screens
-miInitializeBackingStore
-__fxstat64
-xf86GetPointerScreenFuncs
-iconv_open
-geteuid
-pci_iterator_destroy
-xf86UnMapVidMem
-xf86LoadSubModule
-free
-strlen
-xf86DiDGAInit
-xf86SetDepthBpp
-miSetVisualTypes
-miSetPixmapDepths
-__cxa_finalize
-DRICreateInfoRec
-realpath
-xf86DPMSSet
-xf86CollectOptions
-pci_device_unmap_range
-xf86ProcessOptions
-fsync
-xf86SetModeDefaultName
-iconv
-pci_device_next
-futimes
 DRIUnlock
-xf86DestroyCursorInfoRec
-XNFcalloc
-open64
-strstr
-xf86SetBlackWhitePixels
-xf86PrintChipsets
-xf86SetDesiredModes
-resVgaShared
-xf86DPMSInit
-fputs
-Xcalloc
-ftruncate64
-DRILock
-Xfree
-xf86CrtcSetSizeRange
-fchmod
-memcpy
-memmove
-strchr
-VBEExtendedInit
+ErrorF
+FatalError
 GlxSetVisualConfigs
+LoaderRefSymLists
+PixmapWidthPaddingInfo
+ShadowFBInit2
+VBEExtendedInit
+VBEGetVBEMode
+VBESaveRestore
+VBESetDisplayStart
+VBESetGetPaletteData
 VBESetVBEMode
-xf86OutputUseScreenMonitor
+XNFcalloc
+XNFstrdup
+_Jv_RegisterClasses
+___errno
+__cxa_finalize
+__deregister_frame_info_bases
+__divdi3
 __errno_location
-xf86CreateCursorInfoRec
-serverGeneration
-xf86LoaderCheckSymbol
-fbPictureInit
+__fxstat64
+__gmon_start__
+__iob
+__isoc99_sscanf
+__moddi3
+__register_frame_info_bases
 __stack_chk_fail
-ShadowFBInit2
-DRIQueryVersion
-strcmp
-tolower
-getcwd
-xf86CrtcConfigInit
-miCreateDefColormap
-strcpy
-fbScreenInit
-xf86SetWeight
-xf86ModesAdd
-memcmp
+__udivdi3
+__umoddi3
+__xstat64
 calloc
-xf86SetBackingStore
-xf86OutputCreate
+chdir
+chmod
+chown
+close
+drmFreeVersion
 drmGetVersion
-__xstat64
-lseek64
-stderr
-xf86InitialConfiguration
-xf86CheckModeForMonitor
-DRIDestroyInfoRec
-DRICloseScreen
-xf86Msg
-xf86CVTMode
-xf86SaveScreen
-realloc
-getpwuid_r
-xf86CrtcScreenInit
-xf86SetDefaultVisual
-fprintf
-PixmapWidthPaddingInfo
-write
-pci_device_map_range
-xf86CrtcCreate
+fbPictureInit
+fbScreenInit
+fchmod
 fcntl
-screenInfo
-iconv_close
-rename
-DRIFinishScreenInit
-xf86AddDriver
 fflush
-putenv
-setenv
-getenv
-unsetenv
-lseek
-__deregister_frame_info_bases
+flock
+fprintf
+fputs
+free
 fstat
-__register_frame_info_bases
-___errno
-open
+fsync
 ftruncate
-stat
+ftruncate64
+futimes
+getcwd
+getenv
+geteuid
+getpwuid_r
+iconv
+iconv_close
+iconv_open
+ioctl
+lchown
+lseek
+lseek64
+malloc
+memalign
+memchr
+memcmp
+memcpy
+memmove
+memset
+miClearVisualTypes
+miCreateDefColormap
+miDCInitialize
+miInitializeBackingStore
+miSetPixmapDepths
+miSetVisualTypes
+mmap64
+mprotect
+munmap
 nl_langinfo
+open
+open64
+pciFindFirst
+pciReadLong
+pciTag
+pci_device_map_range
+pci_device_next
+pci_device_probe
+pci_device_unmap_range
+pci_id_match_iterator_create
+pci_iterator_destroy
+posix_memalign
+pthread_sigmask
+putenv
+read
+realloc
+realpath
+rename
+resVgaShared
+screenInfo
+serverGeneration
+setenv
+sigdelset
+sigfillset
+sprintf
 sscanf
+sscanf
+stat
+stderr
+strchr
+strcmp
+strcpy
+strlen
+strncmp
 strpbrk
-__iob
-__divdi3
-__umoddi3
-__moddi3
-__udivdi3
-vgaHWRestoreFonts
+strstr
+tolower
+unlink
+unsetenv
+utimes
+vgaHWFreeHWRec
+vgaHWGetHWRec
 vgaHWGetIndex
-vgaHWSaveFonts
-vgaHWUnmapMem
 vgaHWHandleColormaps
-vgaHWGetHWRec
 vgaHWMapMem
-vgaHWFreeHWRec
-pciReadLong
+vgaHWRestoreFonts
+vgaHWSaveFonts
+vgaHWUnmapMem
+write
+xf86AddDriver
+xf86CVTMode
+xf86CheckModeForMonitor
+xf86CollectOptions
+xf86ConfigPciEntity
+xf86CreateCursorInfoRec
+xf86CrtcConfigInit
+xf86CrtcConfigPrivateIndex
+xf86CrtcCreate
+xf86CrtcScreenInit
+xf86CrtcSetSizeRange
+xf86DPMSInit
+xf86DPMSSet
+xf86DestroyCursorInfoRec
+xf86DiDGAInit
+xf86DrvMsg
+xf86GetEntityInfo
 xf86GetPciInfoForEntity
+xf86GetPciVideoInfo
+xf86GetPointerScreenFuncs
+xf86HandleColormaps
+xf86InitCursor
+xf86InitialConfiguration
+xf86LoadSubModule
+xf86LoaderCheckSymbol
+xf86LoaderReqSymLists
+xf86MapDomainMemory
+xf86MapPciMem
 xf86MatchDevice
 xf86MatchPciInstances
-xf86MapPciMem
-xf86GetPciVideoInfo
-pciFindFirst
-pciTag
+xf86ModesAdd
+xf86Msg
+xf86OutputCreate
+xf86OutputUseScreenMonitor
+xf86PrintChipsets
+xf86PrintDepthBpp
+xf86ProcessOptions
+xf86SaveScreen
+xf86Screens
+xf86SetBackingStore
+xf86SetBlackWhitePixels
+xf86SetDefaultVisual
+xf86SetDepthBpp
+xf86SetDesiredModes
+xf86SetDpi
+xf86SetGamma
+xf86SetModeDefaultName
+xf86SetSingleMode
+xf86SetWeight
+xf86ShowUnusedOptions
+xf86SlowBcopy
+xf86UnMapVidMem
 xf86sprintf
-sprintf
-FatalError
-xf86CrtcConfigPrivateIndex
Index: src/VBox/Additions/x11/vboxvideo/vboxvideo_dri.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo_dri.c.orig
+++ src/VBox/Additions/x11/vboxvideo/vboxvideo_dri.c
@@ -83,8 +83,8 @@ VBOXInitVisualConfigs(ScrnInfoPtr pScrn,
     TRACE_ENTRY();
     int cConfigs = 2;  /* With and without double buffering */
     __GLXvisualConfig *pConfigs = NULL;
-    pConfigs = (__GLXvisualConfig*) xcalloc(sizeof(__GLXvisualConfig),
-                                            cConfigs);
+    pConfigs = (__GLXvisualConfig*) calloc(sizeof(__GLXvisualConfig),
+                                           cConfigs);
     if (!pConfigs)
     {
         rc = FALSE;
@@ -132,7 +132,7 @@ VBOXInitVisualConfigs(ScrnInfoPtr pScrn,
         GlxSetVisualConfigs(cConfigs, pConfigs, NULL);
     }
     if (!rc && pConfigs)
-        xfree(pConfigs);
+        free(pConfigs);
     TRACE_LOG("returning %s\n", BOOL_STR(rc));
     return rc;
 }
@@ -243,7 +243,7 @@ Bool VBOXDRIScreenInit(int scrnIndex, Sc
 #ifdef PCIACCESS
         pDRIInfo->busIdString = DRICreatePCIBusID(pVBox->pciInfo);
 #else
-        pDRIInfo->busIdString = xalloc(64);
+        pDRIInfo->busIdString = alloc(64);
         sprintf(pDRIInfo->busIdString, "PCI:%d:%d:%d",
             ((pciConfigPtr)pVBox->pciInfo->thisCard)->busnum,
 	        ((pciConfigPtr)pVBox->pciInfo->thisCard)->devnum,
@@ -254,7 +254,7 @@ Bool VBOXDRIScreenInit(int scrnIndex, Sc
         pDRIInfo->ddxDriverPatchVersion = 0;
         pDRIInfo->ddxDrawableTableEntry = VBOX_MAX_DRAWABLES;
         pDRIInfo->maxDrawableTableEntry = VBOX_MAX_DRAWABLES;
-        pDRIInfo->frameBufferPhysicalAddress = (pointer)pVBox->mapPhys;
+        pDRIInfo->frameBufferPhysicalAddress = (pointer)pScrn->memPhysBase;
         pDRIInfo->frameBufferSize = pVBox->mapSize;
         pDRIInfo->frameBufferStride =   pScrn->displayWidth
                                       * pScrn->bitsPerPixel / 8;
@@ -325,7 +325,7 @@ VBOXDRICloseScreen(ScreenPtr pScreen, VB
     DRIDestroyInfoRec(pVBox->pDRIInfo);
     pVBox->pDRIInfo=0;
     if (pVBox->pVisualConfigs)
-        xfree(pVBox->pVisualConfigs);
+        free(pVBox->pVisualConfigs);
     pVBox->cVisualConfigs = 0;
     pVBox->pVisualConfigs = NULL;
 }
Index: src/VBox/Additions/x11/vboxvideo/undefined_70
===================================================================
--- src/VBox/Additions/x11/vboxvideo/undefined_70.orig
+++ src/VBox/Additions/x11/vboxvideo/undefined_70
@@ -1,181 +1,196 @@
-xf86sscanf
-chdir
+DGAInit
+DRICloseScreen
+DRICreateInfoRec
+DRICreateInfoRec sprintf
+DRICreatePCIBusID
+DRIDestroyInfoRec
+DRIFinishScreenInit
+DRILock
+DRIQueryVersion
+DRIScreenInit
+DRIUnlock
+ErrorF
+FatalError
+GlxSetVisualConfigs
 LoaderRefSymLists
-xf86PrintDepthBpp
-xf86ShowUnusedOptions
-Xrealloc
-memset
-miDCInitialize
-close
-ioctl
-memchr
-xf86SetDpi
-xf86HandleColormaps
-utimes
-__gmon_start__
-_Jv_RegisterClasses
+PixmapWidthPaddingInfo
+SetTimeSinceLastInputEvent
+ShadowFBInit2
+VBEExtendedInit
 VBEGetVBEMode
-pciReadLong
 VBESaveRestore
-xf86LoaderReqSymLists
-ErrorF
-XNFprintf
-xf86InitCursor
-xf86SetGamma
-xf86PruneDriverModes
-Xalloc
-xf86SlowBcopy
-xf86GetEntityInfo
-read
-xf86GetPciInfoForEntity
-strncmp
-malloc
-xf86ConfigPciEntity
-xf86MatchDevice
-unlink
-xf86MapDomainMemory
-miClearVisualTypes
-VBESetGetPaletteData
-xf86MatchPciInstances
-xf86DrvMsg
 VBESetDisplayStart
-xf86Screens
-miInitializeBackingStore
-xf86memset
-__fxstat64
-xf86GetPointerScreenFuncs
-iconv_open
-geteuid
-xf86UnMapVidMem
-xf86LoadSubModule
-free
-strlen
-xf86ValidateModes
-xf86SetDepthBpp
-miSetVisualTypes
-miSetPixmapDepths
-__cxa_finalize
-realpath
-xf86CollectOptions
-xf86ProcessOptions
-fsync
-iconv
-futimes
-xf86DestroyCursorInfoRec
+VBESetGetPaletteData
+VBESetVBEMode
+XNFalloc
 XNFcalloc
-open64
-xf86MapPciMem
-strstr
-xf86SetBlackWhitePixels
-xf86PrintChipsets
-resVgaShared
-xf86DPMSInit
-fputs
+XNFprintf
+XNFrealloc
+XNFstrdup
+Xalloc
 Xcalloc
-ftruncate64
 Xfree
-fchmod
-memcpy
-memmove
-xf86strdup
-strchr
-xf86GetPciVideoInfo
-SetTimeSinceLastInputEvent
-VBEExtendedInit
-VBESetVBEMode
+Xrealloc
+_GLOBAL_OFFSET_TABLE_
+_Jv_RegisterClasses
+___errno
+__cxa_finalize
+__deregister_frame_info_bases
+__divdi3
 __errno_location
-xf86CreateCursorInfoRec
-serverGeneration
-fbPictureInit
+__fxstat64
+__gmon_start__
+__iob
+__isoc99_sscanf
+__moddi3
+__register_frame_info_bases
 __stack_chk_fail
-ShadowFBInit2
-strcmp
-tolower
-getcwd
-miCreateDefColormap
-strcpy
-fbScreenInit
-xf86SetWeight
-xf86memcpy
-memcmp
-calloc
-xf86SetBackingStore
-pciFindFirst
-XNFalloc
+__udivdi3
+__umoddi3
 __xstat64
-lseek64
-xf86PrintModes
-stderr
-xf86Msg
-pciTag
-realloc
-getpwuid_r
-xf86SetDefaultVisual
-fprintf
-PixmapWidthPaddingInfo
-write
-XNFrealloc
+calloc
+chdir
+chmod
+chown
+close
+drmFreeVersion
+drmGetVersion
+fbPictureInit
+fbScreenInit
+fchmod
 fcntl
-DGAInit
-iconv_close
-rename
-xf86IsUnblank
-xf86AddDriver
 fflush
-putenv
-setenv
-getenv
-unsetenv
-__register_frame_info_bases
-___errno
-nl_langinfo
-__deregister_frame_info_bases
+flock
+fprintf
+fputs
+free
 fstat
-lseek
+fsync
 ftruncate
+ftruncate64
+futimes
+getcwd
+getenv
+geteuid
+getpwuid_r
+iconv
+iconv_close
+iconv_open
+ioctl
+lchown
+lseek
+lseek64
+malloc
+memalign
+memchr
+memcmp
+memcpy
+memmove
+memset
+miClearVisualTypes
+miCreateDefColormap
+miDCInitialize
+miInitializeBackingStore
+miSetPixmapDepths
+miSetVisualTypes
+mmap64
+mprotect
+munmap
+nl_langinfo
 open
-stat
-strpbrk
-__iob
-__umoddi3
-__udivdi3
-__moddi3
-__divdi3
-xf86sprintf
-_GLOBAL_OFFSET_TABLE_
-XNFstrdup
-FatalError
-xf86vsnprintf
-xf86strtoul
-xf86errno
-xf86isspace
+open64
+pciFindFirst
+pciReadLong
+pciTag
+pci_device_map_range
+pci_device_next
 pci_device_probe
-DRICreatePCIBusID
+pci_device_unmap_range
 pci_id_match_iterator_create
-__isoc99_sscanf
-DRIScreenInit
-drmFreeVersion
 pci_iterator_destroy
-DRICreateInfoRec sprintf
-pci_device_unmap_range
-pci_device_next
-GlxSetVisualConfigs
-xf86LoaderCheckSymbol
-DRIQueryVersion
-drmGetVersion
-DRIDestroyInfoRec
-DRICloseScreen
-pci_device_map_range
-DRIFinishScreenInit
-DRICreateInfoRec
+posix_memalign
+pthread_sigmask
+putenv
+read
+realloc
+realpath
+rename
+resVgaShared
+screenInfo
+serverGeneration
+setenv
+sigdelset
+sigfillset
 sprintf
-vgaHWRestoreFonts
+stat
+stderr
+strchr
+strcmp
+strcpy
+strlen
+strncmp
+strpbrk
+strstr
+tolower
+unlink
+unsetenv
+utimes
+vgaHWDPMSSet
+vgaHWFreeHWRec
+vgaHWGetHWRec
 vgaHWGetIndex
-vgaHWSaveFonts
-vgaHWUnmapMem
 vgaHWHandleColormaps
-vgaHWGetHWRec
 vgaHWMapMem
-vgaHWFreeHWRec
+vgaHWRestoreFonts
+vgaHWSaveFonts
 vgaHWSaveScreen
-vgaHWDPMSSet
+vgaHWUnmapMem
+write
+xf86AddDriver
+xf86CollectOptions
+xf86ConfigPciEntity
+xf86CreateCursorInfoRec
+xf86DPMSInit
+xf86DestroyCursorInfoRec
+xf86DrvMsg
+xf86GetEntityInfo
+xf86GetPciInfoForEntity
+xf86GetPciVideoInfo
+xf86GetPointerScreenFuncs
+xf86HandleColormaps
+xf86InitCursor
+xf86IsUnblank
+xf86LoadSubModule
+xf86LoaderCheckSymbol
+xf86LoaderReqSymLists
+xf86MapDomainMemory
+xf86MapPciMem
+xf86MatchDevice
+xf86MatchPciInstances
+xf86Msg
+xf86PrintChipsets
+xf86PrintDepthBpp
+xf86PrintModes
+xf86ProcessOptions
+xf86PruneDriverModes
+xf86Screens
+xf86SetBackingStore
+xf86SetBlackWhitePixels
+xf86SetDefaultVisual
+xf86SetDepthBpp
+xf86SetDpi
+xf86SetGamma
+xf86SetWeight
+xf86ShowUnusedOptions
+xf86SlowBcopy
+xf86UnMapVidMem
+xf86ValidateModes
+xf86errno
+xf86isspace
+xf86memcpy
+xf86memset
+xf86sprintf
+xf86sscanf
+xf86strdup
+xf86strtoul
+xf86vsnprintf
Index: src/VBox/Additions/x11/vboxvideo/vboxvideo_13.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo_13.c.orig
+++ src/VBox/Additions/x11/vboxvideo/vboxvideo_13.c
@@ -169,7 +169,7 @@ static VBOXPtr
 VBOXGetRec(ScrnInfoPtr pScrn)
 {
     if (!pScrn->driverPrivate) {
-        pScrn->driverPrivate = xcalloc(sizeof(VBOXRec), 1);
+        pScrn->driverPrivate = calloc(sizeof(VBOXRec), 1);
     }
 
     return ((VBOXPtr)pScrn->driverPrivate);
@@ -179,9 +179,9 @@ static void
 VBOXFreeRec(ScrnInfoPtr pScrn)
 {
     VBOXPtr pVBox = VBOXGetRec(pScrn);
-    xfree(pVBox->savedPal);
-    xfree(pVBox->fonts);
-    xfree(pScrn->driverPrivate);
+    free(pVBox->savedPal);
+    free(pVBox->fonts);
+    free(pScrn->driverPrivate);
     pScrn->driverPrivate = NULL;
 }
 
@@ -625,11 +625,11 @@ VBOXProbe(DriverPtr drv, int flags)
 		    }
 		}
 	    }
-	    xfree(usedChips);
+	    free(usedChips);
 	}
     }
 
-    xfree(devSections);
+    free(devSections);
 
     return (foundScreen);
 }
@@ -759,7 +759,7 @@ VBOXPreInit(ScrnInfoPtr pScrn, int flags
 
     /* options */
     xf86CollectOptions(pScrn, NULL);
-    if (!(pVBox->Options = xalloc(sizeof(VBOXOptions))))
+    if (!(pVBox->Options = malloc(sizeof(VBOXOptions))))
         return FALSE;
     memcpy(pVBox->Options, VBOXOptions, sizeof(VBOXOptions));
     xf86ProcessOptions(pScrn->scrnIndex, pScrn->options, pVBox->Options);
@@ -865,17 +865,17 @@ VBOXScreenInit(int scrnIndex, ScreenPtr
     VisualPtr visual;
     unsigned flags;
 
-    if (pVBox->mapPhys == 0) {
+    if (pScrn->memPhysBase == 0) {
 #ifdef PCIACCESS
-        pVBox->mapPhys = pVBox->pciInfo->regions[0].base_addr;
+        pScrn->memPhysBase = pVBox->pciInfo->regions[0].base_addr;
 #else
-        pVBox->mapPhys = pVBox->pciInfo->memBase[0];
+        pScrn->memPhysBase = pVBox->pciInfo->memBase[0];
 #endif
 /*        pVBox->mapSize = 1 << pVBox->pciInfo->size[0]; */
         /* Using the PCI information caused problems with
            non-powers-of-two sized video RAM configurations */
         pVBox->mapSize = inl(VBE_DISPI_IOPORT_DATA);
-        pVBox->mapOff = 0;
+        pScrn->fbOffset = 0;
     }
 
     if (!VBOXMapVidMem(pScrn))
@@ -1067,6 +1067,9 @@ VBOXCloseScreen(int scrnIndex, ScreenPtr
     /* Destroy the VGA hardware record */
     vgaHWFreeHWRec(pScrn);
 
+    /* And do additional bits which are separate for historical reasons */
+    vbox_close(pScrn, pVBox);
+
     /* Remove our observer functions from the X server call chains. */
     pScrn->EnableDisableFBAccess = pVBox->EnableDisableFBAccess;
     pScreen->CloseScreen = pVBox->CloseScreen;
@@ -1122,7 +1125,7 @@ VBOXValidMode(int scrn, DisplayModePtr p
     for (v = mon->vrefresh[0].lo; v <= mon->vrefresh[0].hi; v++) {
         mode = xf86CVTMode(p->HDisplay, p->VDisplay, v, 0, 0);
         ret = xf86CheckModeForMonitor(mode, mon);
-        xfree(mode);
+        free(mode);
         if (ret == MODE_OK)
             break;
     }
@@ -1252,9 +1255,6 @@ VBOXMapVidMem(ScrnInfoPtr pScrn)
     TRACE_ENTRY();
     if (!pVBox->base)
     {
-        pScrn->memPhysBase = pVBox->mapPhys;
-        pScrn->fbOffset = pVBox->mapOff;
-
 #ifdef PCIACCESS
         (void) pci_device_map_range(pVBox->pciInfo,
                                     pScrn->memPhysBase,
@@ -1264,7 +1264,7 @@ VBOXMapVidMem(ScrnInfoPtr pScrn)
 #else
         pVBox->base = xf86MapPciMem(pScrn->scrnIndex,
                                     VIDMEM_FRAMEBUFFER,
-                                    pVBox->pciTag, pVBox->mapPhys,
+                                    pVBox->pciTag, pScrn->memPhysBase,
                                     (unsigned) pVBox->mapSize);
 #endif
         if (pVBox->base)
@@ -1350,7 +1350,7 @@ VBOXSaveRestore(ScrnInfoPtr pScrn, vbeSa
             {
                 /* don't rely on the memory not being touched */
                 if (pVBox->pstate == NULL)
-                    pVBox->pstate = xalloc(pVBox->stateSize);
+                    pVBox->pstate = malloc(pVBox->stateSize);
                 memcpy(pVBox->pstate, pVBox->state,
                        (unsigned) pVBox->stateSize);
             }
Index: src/VBox/Additions/x11/vboxvideo/vboxvideo.h
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo.h.orig
+++ src/VBox/Additions/x11/vboxvideo/vboxvideo.h
@@ -184,9 +184,8 @@ extern void GlxSetVisualConfigs(int ncon
 
 typedef struct _VBOXRec
 {
-    vbeInfoPtr pVbe;
+    vbeInfoPtr pVbe;  /** @todo do the VBE bits ourselves? */
     EntityInfoPtr pEnt;
-    VbeInfoBlock *vbeInfo;
 #ifdef PCIACCESS
     struct pci_device *pciInfo;
     struct pci_device *vmmDevInfo;
@@ -194,9 +193,8 @@ typedef struct _VBOXRec
     pciVideoPtr pciInfo;
     PCITAG pciTag;
 #endif
-    CARD16 maxBytesPerScanline;
-    unsigned long mapPhys, mapOff, mapSize;	/* video memory */
-    void *base, *VGAbase;
+    unsigned long mapSize;	/* video memory */
+    void *base;
     CARD8 *state, *pstate;	/* SVGA state */
     int statePage, stateSize, stateMode;
     CARD32 *savedPal;
@@ -208,15 +206,8 @@ typedef struct _VBOXRec
     /** Is access to the framebuffer currently allowed? */
     Bool accessEnabled;
     OptionInfoPtr Options;
-    IOADDRESS ioBase;
-    /** The width of the last resolution set, used to avoid resetting modes */
-    int cLastWidth;
-    /** The height of the last resolution set */
-    int cLastHeight;
-    VMMDevReqMousePointer *reqp;
+    /** @todo we never actually free this */
     xf86CursorInfoPtr pCurs;
-    size_t pointerHeaderSize;
-    size_t pointerSize;
     Bool useDevice;
     Bool forceSWCursor;
     /** Do we know that the guest can handle absolute co-ordinates? */
Index: src/VBox/Additions/x11/vboxvideo/vboxvideo_70.c
===================================================================
--- src/VBox/Additions/x11/vboxvideo/vboxvideo_70.c.orig
+++ src/VBox/Additions/x11/vboxvideo/vboxvideo_70.c
@@ -332,9 +332,6 @@ static void
 VBOXFreeRec(ScrnInfoPtr pScrn)
 {
     VBOXPtr pVBox = VBOXGetRec(pScrn);
-#if 0
-    xfree(pVBox->vbeInfo);
-#endif
     xfree(pVBox->savedPal);
     xfree(pVBox->fonts);
     xfree(pScrn->driverPrivate);
@@ -526,6 +523,12 @@ VBOXPreInit(ScrnInfoPtr pScrn, int flags
     if (!xf86LoadSubModule(pScrn, "vgahw"))
         return FALSE;
 
+#ifdef VBOX_DRI
+    /* Load the dri module. */
+    if (!xf86LoadSubModule(pScrn, "dri"))
+        return FALSE;
+#endif
+
 #ifndef PCIACCESS
     if (pVBox->pEnt->location.type != BUS_PCI)
         return FALSE;
@@ -665,17 +668,17 @@ VBOXScreenInit(int scrnIndex, ScreenPtr
                                        | RESTORE_BIOS_SCRATCH)) == NULL)
         return (FALSE);
 
-    if (pVBox->mapPhys == 0) {
+    if (pScrn->memPhysBase == 0) {
 #ifdef PCIACCESS
-        pVBox->mapPhys = pVBox->pciInfo->regions[0].base_addr;
+        pScrn->memPhysBase = pVBox->pciInfo->regions[0].base_addr;
 #else
-        pVBox->mapPhys = pVBox->pciInfo->memBase[0];
+        pScrn->memPhysBase = pVBox->pciInfo->memBase[0];
 #endif
 /*        pVBox->mapSize = 1 << pVBox->pciInfo->size[0]; */
         /* Using the PCI information caused problems with
            non-powers-of-two sized video RAM configurations */
         pVBox->mapSize = inl(VBE_DISPI_IOPORT_DATA);
-        pVBox->mapOff = 0;
+        pScrn->fbOffset = 0;
     }
 
     if (!VBOXMapVidMem(pScrn))
@@ -702,6 +705,14 @@ VBOXScreenInit(int scrnIndex, ScreenPtr
     if (!miSetPixmapDepths())
         return (FALSE);
 
+    /* Needed before we initialise DRI. */
+    pScrn->virtualX = (pScrn->virtualX + 7) & ~7;
+    pScrn->displayWidth = pScrn->virtualX;
+
+#ifdef VBOX_DRI
+    pVBox->useDRI = VBOXDRIScreenInit(scrnIndex, pScreen, pVBox);
+#endif
+
     /* I checked in the sources, and XFree86 4.2 does seem to support
        this function for 32bpp. */
     if (!fbScreenInit(pScreen, pVBox->base,
@@ -779,6 +790,11 @@ VBOXScreenInit(int scrnIndex, ScreenPtr
                       "The VBox video extensions are now enabled.\n");
         vboxEnableGraphicsCap(pVBox);
     }
+
+#ifdef VBOX_DRI
+    if (pVBox->useDRI)
+        pVBox->useDRI = VBOXDRIFinishScreenInit(pScreen);
+#endif
     TRACE_EXIT();
     return (TRUE);
 }
@@ -791,6 +807,10 @@ VBOXEnterVT(int scrnIndex, int flags)
 
     TRACE_ENTRY();
     pVBox->vtSwitch = FALSE;
+#ifdef VBOX_DRI
+    if (pVBox->useDRI)
+        DRIUnlock(screenInfo.screens[scrnIndex]);
+#endif
     if (!VBOXSetMode(pScrn, pScrn->currentMode))
         return FALSE;
     VBOXAdjustFrame(scrnIndex, pScrn->frameX0, pScrn->frameY0, 0);
@@ -811,6 +831,10 @@ VBOXLeaveVT(int scrnIndex, int flags)
         vboxDisableVbva(pScrn);
     vboxDisableGraphicsCap(pVBox);
     pVBox->vtSwitch = TRUE;
+#ifdef VBOX_DRI
+    if (pVBox->useDRI)
+        DRILock(screenInfo.screens[scrnIndex], 0);
+#endif
 }
 
 static Bool
@@ -819,6 +843,12 @@ VBOXCloseScreen(int scrnIndex, ScreenPtr
     ScrnInfoPtr pScrn = xf86Screens[scrnIndex];
     VBOXPtr pVBox = VBOXGetRec(pScrn);
 
+#ifdef VBOX_DRI
+    if (pVBox->useDRI)
+        VBOXDRICloseScreen(pScreen, pVBox);
+    pVBox->useDRI = false;
+#endif
+
     if (pVBox->useVbva == TRUE)
         vboxDisableVbva(pScrn);
     vboxDisableGraphicsCap(pVBox);
@@ -834,6 +864,9 @@ VBOXCloseScreen(int scrnIndex, ScreenPtr
     /* Destroy the VGA hardware record */
     vgaHWFreeHWRec(pScrn);
 
+    /* And do additional bits which are separate for historical reasons */
+    vbox_close(pScrn, pVBox);
+
     pScreen->CloseScreen = pVBox->CloseScreen;
     return pScreen->CloseScreen(scrnIndex, pScreen);
 }
@@ -918,8 +951,6 @@ VBOXSetMode(ScrnInfoPtr pScrn, DisplayMo
        the virtual offset. */
     outw(VBE_DISPI_IOPORT_INDEX, VBE_DISPI_INDEX_VIRT_WIDTH);
     outw(VBE_DISPI_IOPORT_DATA, pMode->HDisplay);
-    pVBox->cLastWidth = pMode->HDisplay;
-    pVBox->cLastHeight = pMode->VDisplay;
     vboxEnableGraphicsCap(pVBox);
     TRACE_EXIT();
     return (TRUE);
@@ -939,6 +970,10 @@ static bool VBOXAdjustScreenPixmap(ScrnI
     pScreen->ModifyPixmapHeader(pPixmap, pMode->HDisplay, pMode->VDisplay,
                                 pScrn->depth, bpp, pMode->HDisplay * bpp / 8,
                                 pVBox->base);
+#ifdef VBOX_DRI
+    if (pVBox->useDRI)
+        VBOXDRIUpdateStride(pScrn, pVBox);
+#endif
     pScrn->EnableDisableFBAccess(pScrn->scrnIndex, FALSE);
     pScrn->EnableDisableFBAccess(pScrn->scrnIndex, TRUE);
     return TRUE;
@@ -978,9 +1013,6 @@ VBOXMapVidMem(ScrnInfoPtr pScrn)
     if (pVBox->base != NULL)
         return (TRUE);
 
-    pScrn->memPhysBase = pVBox->mapPhys;
-    pScrn->fbOffset = pVBox->mapOff;
-
 #ifdef PCIACCESS
     (void) pci_device_map_range(pVBox->pciInfo,
                                 pScrn->memPhysBase,
@@ -990,7 +1022,7 @@ VBOXMapVidMem(ScrnInfoPtr pScrn)
 #else
     pVBox->base = xf86MapPciMem(pScrn->scrnIndex,
                                 VIDMEM_FRAMEBUFFER,
-                                pVBox->pciTag, pVBox->mapPhys,
+                                pVBox->pciTag, pScrn->memPhysBase,
                                 (unsigned) pVBox->mapSize);
 #endif
     if (pVBox->base)
Index: src/VBox/Additions/x11/vboxvideo/Makefile.kmk
===================================================================
--- src/VBox/Additions/x11/vboxvideo/Makefile.kmk.orig
+++ src/VBox/Additions/x11/vboxvideo/Makefile.kmk
@@ -37,8 +37,6 @@ if1of ($(KBUILD_TARGET), linux)
  	XFree86LOADER XFree86Server XF86VIDMODE XvMCExtension SMART_SCHEDULE \
  	BUILDDEBUG X_BYTE_ORDER=X_LITTLE_ENDIAN DNDEBUG FUNCPROTO=15 NARROWPROTO \
  	IN_MODULE XFree86Module
- vboxvideo_drv_CFLAGS.linux := \
- 	-Wno-conversion -Wno-unused-parameter $(VBOX_GCC_Wno-variadic-macros)
  vboxvideo_drv_INCS = \
 	$(VBOX_PATH_X11_XFREE_4_3)/include \
 	$(VBOX_PATH_X11_XFREE_4_3)/include/X11 \
@@ -98,9 +96,7 @@ vboxvideo_drv_70_INCS = \
 	$(VBOX_PATH_X11_XORG_7_0) \
 	$(VBOX_PATH_X11_XORG_7_0)/X11 \
 	$(VBOX_PATH_X11_XORG_7_0)/xorg
-vboxvideo_drv_70_SOURCES  = \
-	vboxvideo_70.c \
-	vboxutils.c
+vboxvideo_drv_70_SOURCES  = $(vboxvideo_drv_SOURCES)
 
 
 #
@@ -114,9 +110,7 @@ vboxvideo_drv_71_INCS = \
 	$(VBOX_PATH_X11_XORG_7_1) \
 	$(VBOX_PATH_X11_XORG_7_1)/X11 \
 	$(VBOX_PATH_X11_XORG_7_1)/xorg
-vboxvideo_drv_71_SOURCES  = \
-	vboxvideo_70.c \
-	vboxutils.c
+vboxvideo_drv_71_SOURCES  = $(vboxvideo_drv_SOURCES)
 
 
 #
@@ -157,9 +151,7 @@ vboxvideo_drv_14_INCS = \
 	$(VBOX_PATH_X11_ROOT)/mesa-7.2/include \
 	$(VBOX_PATH_X11_ROOT)/libdrm-2.4.13 \
 	$(VBOX_PATH_X11_ROOT)/xf86driproto-2.1.0
-vboxvideo_drv_14_SOURCES  = \
-	vboxvideo_13.c \
-	vboxutils.c
+vboxvideo_drv_14_SOURCES  = $(vboxvideo_drv_13_SOURCES)
 
 
 #
@@ -181,9 +173,7 @@ vboxvideo_drv_15_INCS = \
 	$(VBOX_PATH_X11_ROOT)/libdrm-2.4.13 \
 	$(VBOX_PATH_X11_ROOT)/xf86driproto-2.1.0 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.5.3
-vboxvideo_drv_15_SOURCES  = \
-	vboxvideo_13.c \
-	vboxutils.c
+vboxvideo_drv_15_SOURCES  = $(vboxvideo_drv_13_SOURCES)
 if1of ($(KBUILD_TARGET), linux solaris)
  vboxvideo_drv_15_SOURCES += \
 	vboxvideo_dri.c
@@ -231,7 +221,7 @@ vboxvideo_drv_17_INCS = \
 	$(VBOX_PATH_X11_ROOT)/xf86driproto-2.1.0 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.99-20090831 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
-	$(VBOX_PATH_X11_ROOT)/xproto-7.0.15
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18
 vboxvideo_drv_17_SOURCES := $(vboxvideo_drv_15_SOURCES)
 
 
@@ -257,10 +247,36 @@ vboxvideo_drv_18_INCS = \
 	$(VBOX_PATH_X11_ROOT)/xf86driproto-2.1.0 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.8.0 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
-	$(VBOX_PATH_X11_ROOT)/xproto-7.0.15
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18
 vboxvideo_drv_18_SOURCES := $(vboxvideo_drv_15_SOURCES)
 
 
+#
+# vboxvideo_drv_19
+#
+DLLS += vboxvideo_drv_19
+vboxvideo_drv_19_TEMPLATE = VBOXGUESTR3XORGMOD
+vboxvideo_drv_19_CFLAGS := $(vboxvideo_drv_70_CFLAGS)
+vboxvideo_drv_19_DEFS := $(vboxvideo_drv_15_DEFS)
+## @todo replace $(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local
+vboxvideo_drv_19_INCS = \
+	$(VBOX_PATH_X11_ROOT)/fontsproto-2.1.0 \
+	$(VBOX_PATH_X11_ROOT)/glproto-1.4.10 \
+	$(VBOX_PATH_X11_ROOT)/mesa-7.2/include \
+	$(VBOX_PATH_X11_ROOT)/inputproto-1.9.99.902 \
+	$(VBOX_PATH_X11_ROOT)/libdrm-2.4.13 \
+	$(VBOX_PATH_X11_ROOT)/libpciaccess-0.10.8 \
+	$(VBOX_PATH_X11_ROOT)/pixman-0.16.0 \
+	$(VBOX_PATH_X11_ROOT)/randrproto-1.3.0 \
+	$(VBOX_PATH_X11_ROOT)/renderproto-0.11 \
+	$(VBOX_PATH_X11_ROOT)/xextproto-7.1.1 \
+	$(VBOX_PATH_X11_ROOT)/xf86driproto-2.1.0 \
+	$(VBOX_PATH_X11_ROOT)/xorg-server-1.9.0 \
+	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18
+vboxvideo_drv_19_SOURCES := $(vboxvideo_drv_15_SOURCES)
+
+
 # Check the undefined symbols in the X.Org modules against lists of allowed
 # symbols.  Not very elegant, but it will catch problems early.
 ifdef VBOX_WITH_TESTCASES
@@ -274,6 +290,7 @@ ifdef VBOX_WITH_TESTCASES
      TESTING  += $(PATH_vboxvideo_drv)/tstvboxvideo68.run
      OTHERS += $(PATH_vboxvideo_drv)/tstvboxvideo68.run
 $$(PATH_vboxvideo_drv)/tstvboxvideo68.run: $$(INSTARGET_vboxvideo_drv)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv) $(OUR_PATH_VBOXVIDEO)/undefined_68 --static
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -282,6 +299,7 @@ $$(PATH_vboxvideo_drv)/tstvboxvideo68.ru
      TESTING  += $(PATH_vboxvideo_drv_70)/tstvboxvideo70.run
      OTHERS += $(PATH_vboxvideo_drv_70)/tstvboxvideo70.run
 $$(PATH_vboxvideo_drv_70)/tstvboxvideo70.run: $$(INSTARGET_vboxvideo_drv_70)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_70) $(OUR_PATH_VBOXVIDEO)/undefined_70
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -289,6 +307,7 @@ $$(PATH_vboxvideo_drv_70)/tstvboxvideo70
      TESTING  += $(PATH_vboxvideo_drv_71)/tstvboxvideo71.run
      OTHERS += $(PATH_vboxvideo_drv_71)/tstvboxvideo71.run
 $$(PATH_vboxvideo_drv_71)/tstvboxvideo71.run: $$(INSTARGET_vboxvideo_drv_71)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_71) $(OUR_PATH_VBOXVIDEO)/undefined_70
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -296,6 +315,7 @@ $$(PATH_vboxvideo_drv_71)/tstvboxvideo71
      TESTING  += $(PATH_vboxvideo_drv_13)/tstvboxvideo13.run
      OTHERS += $(PATH_vboxvideo_drv_13)/tstvboxvideo13.run
 $$(PATH_vboxvideo_drv_13)/tstvboxvideo13.run: $$(INSTARGET_vboxvideo_drv_13)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_13) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -303,6 +323,7 @@ $$(PATH_vboxvideo_drv_13)/tstvboxvideo13
      TESTING  += $(PATH_vboxvideo_drv_14)/tstvboxvideo14.run
      OTHERS += $(PATH_vboxvideo_drv_14)/tstvboxvideo14.run
 $$(PATH_vboxvideo_drv_14)/tstvboxvideo14.run: $$(INSTARGET_vboxvideo_drv_14)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_14) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -310,6 +331,7 @@ $$(PATH_vboxvideo_drv_14)/tstvboxvideo14
      TESTING  += $(PATH_vboxvideo_drv_15)/tstvboxvideo15.run
      OTHERS += $(PATH_vboxvideo_drv_15)/tstvboxvideo15.run
 $$(PATH_vboxvideo_drv_15)/tstvboxvideo15.run: $$(INSTARGET_vboxvideo_drv_15)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_15) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -317,6 +339,7 @@ $$(PATH_vboxvideo_drv_15)/tstvboxvideo15
      TESTING  += $(PATH_vboxvideo_drv_16)/tstvboxvideo16.run
      OTHERS += $(PATH_vboxvideo_drv_16)/tstvboxvideo16.run
 $$(PATH_vboxvideo_drv_16)/tstvboxvideo16.run: $$(INSTARGET_vboxvideo_drv_16)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_16) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -324,6 +347,7 @@ $$(PATH_vboxvideo_drv_16)/tstvboxvideo16
      TESTING  += $(PATH_vboxvideo_drv_17)/tstvboxvideo17.run
      OTHERS += $(PATH_vboxvideo_drv_17)/tstvboxvideo17.run
 $$(PATH_vboxvideo_drv_17)/tstvboxvideo17.run: $$(INSTARGET_vboxvideo_drv_17)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_17) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -331,10 +355,19 @@ $$(PATH_vboxvideo_drv_17)/tstvboxvideo17
      TESTING  += $(PATH_vboxvideo_drv_18)/tstvboxvideo18.run
      OTHERS += $(PATH_vboxvideo_drv_18)/tstvboxvideo18.run
 $$(PATH_vboxvideo_drv_18)/tstvboxvideo18.run: $$(INSTARGET_vboxvideo_drv_18)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxvideo_drv_18) $(OUR_PATH_VBOXVIDEO)/undefined_13
 	$(QUIET)$(APPEND) -t "$@" "done"
 
+     TESTING  += $(PATH_vboxvideo_drv_19)/tstvboxvideo19.run
+     OTHERS += $(PATH_vboxvideo_drv_19)/tstvboxvideo19.run
+$$(PATH_vboxvideo_drv_19)/tstvboxvideo19.run: $$(INSTARGET_vboxvideo_drv_19)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
+	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
+	    $(INSTARGET_vboxvideo_drv_19) $(OUR_PATH_VBOXVIDEO)/undefined_13
+	$(QUIET)$(APPEND) -t "$@" "done"
+
     endif # ! VBOX_ONLY_SDK
    endif # eq ($(KBUILD_HOST_ARCH),$(KBUILD_TARGET_ARCH))
   endif # eq ($(KBUILD_TARGET),linux)
Index: src/VBox/Additions/x11/vboxvideo/undefined_68
===================================================================
--- src/VBox/Additions/x11/vboxvideo/undefined_68.orig
+++ src/VBox/Additions/x11/vboxvideo/undefined_68
@@ -1,5 +1,6 @@
 DGAInit
 ErrorF
+FatalError
 LoaderRefSymLists
 PixmapWidthPaddingInfo
 SetTimeSinceLastInputEvent
Index: src/VBox/Additions/x11/vboxmouse/undefined_14
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_14
+++ /dev/null
@@ -1,141 +0,0 @@
-xf86ReadSerial
-Xstrdup
-chdir
-RegisterBlockAndWakeupHandlers
-xf86ReplaceIntOption
-XisbRead
-xf86PostMotionEvent
-xf86WaitForInput
-memset
-xf86AddEnabledDevice
-close
-ioctl
-memchr
-xf86UnblockSIGIO
-utimes
-XisbFree
-__gmon_start__
-_Jv_RegisterClasses
-xf86AddInputDriver
-ErrorF
-Xalloc
-xf86FindOptionValue
-read
-strncmp
-malloc
-xf86RemoveEnabledDevice
-unlink
-AdjustWaitForDelay
-xf86PostButtonEvent
-xf86FlushInput
-__fxstat64
-iconv_open
-geteuid
-currentTime
-xf86NameCmp
-xf86ProcessCommonOptions
-xf86OptionListMerge
-free
-strlen
-xf86CheckStrOption
-xf86OptionListCreate
-__cxa_finalize
-xf86OSMouseInit
-realpath
-sprintf
-sscanf
-fsync
-iconv
-futimes
-usleep
-strerror
-open64
-strstr
-xf86OpenSerial
-RemoveBlockAndWakeupHandlers
-fputs
-strtol
-Xcalloc
-ftruncate64
-xf86SetIntOption
-xf86GetAllowMouseOpenFail
-xf86SetStrOption
-Xfree
-fchmod
-memcpy
-putenv
-ffs
-xf86SetBoolOption
-GetTimeInMillis
-memmove
-strchr
-setenv
-getenv
-xf86SerialModemSetBits
-xf86InitValuatorAxisStruct
-__errno_location
-xf86CollectInputOptions
-xf86LoaderCheckSymbol
-__stack_chk_fail
-XisbNew
-strcmp
-tolower
-xf86GetSerialModemState
-getcwd
-xf86SetSerial
-InitPointerDeviceStruct
-xf86SetSerialModemState
-strcpy
-xf86MsgVerb
-sin
-memcmp
-xf86MotionHistoryAllocate
-calloc
-XNFalloc
-__xstat64
-xf86GetOS
-xf86MarkOptionUsedByName
-xf86ErrorF
-lseek64
-xf86GetBuiltinInterfaceVersion
-unsetenv
-xf86AllocateInput
-stderr
-xf86Msg
-xf86CloseSerial
-xf86InitValuatorDefaults
-realloc
-getpwuid_r
-cos
-xf86WriteSerial
-fprintf
-xf86OptionListFree
-write
-xf86AddModuleInfo
-XNFrealloc
-xf86BlockSIGIO
-XisbBlockDuration
-fcntl
-screenInfo
-iconv_close
-rename
-GetMotionHistory
-GetMotionHistorySize
-xf86SetSerialSpeed
-fflush
-abs
-stat
-ftruncate
-__deregister_frame_info_bases
-fstat
-open
-nl_langinfo
-lseek
-__register_frame_info_bases
-___errno
-strpbrk
-__iob
-__moddi3
-__umoddi3
-__udivdi3
-__divdi3
Index: src/VBox/Additions/x11/vboxmouse/undefined_16
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_16
+++ /dev/null
@@ -1,87 +0,0 @@
-chdir
-xf86PostMotionEvent
-memset
-xf86AddEnabledDevice
-close
-ioctl
-memchr
-utimes
-__gmon_start__
-_Jv_RegisterClasses
-xf86AddInputDriver
-read
-strncmp
-malloc
-xf86RemoveEnabledDevice
-unlink
-__fxstat64
-iconv_open
-geteuid
-xf86ProcessCommonOptions
-free
-strlen
-xf86CheckStrOption
-__cxa_finalize
-xf86DeleteInput
-realpath
-InitButtonClassDeviceStruct
-fsync
-iconv
-futimes
-open64
-strstr
-fputs
-ftruncate64
-xf86SetIntOption
-fchmod
-memcpy
-putenv
-memmove
-strchr
-setenv
-getenv
-xf86InitValuatorAxisStruct
-__errno_location
-xf86CollectInputOptions
-__stack_chk_fail
-strcmp
-tolower
-getcwd
-strcpy
-miPointerGetScreen
-memcmp
-xf86MotionHistoryAllocate
-calloc
-__xstat64
-lseek64
-unsetenv
-xf86AllocateInput
-stderr
-xf86Msg
-xf86InitValuatorDefaults
-realloc
-getpwuid_r
-InitValuatorClassDeviceStruct
-fprintf
-write
-fcntl
-iconv_close
-rename
-GetMotionHistorySize
-fflush
-nl_langinfo
-lseek
-open
-__register_frame_info_bases
-__deregister_frame_info_bases
-stat
-fstat
-___errno
-ftruncate
-strpbrk
-__iob
-__divdi3
-__umoddi3
-__moddi3
-__udivdi3
-InitPtrFeedbackClassDeviceStruct
Index: src/VBox/Additions/x11/vboxmouse/undefined_15
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_15.orig
+++ src/VBox/Additions/x11/vboxmouse/undefined_15
@@ -1,94 +1,106 @@
-chdir
-xf86PostMotionEvent
-memset
-xf86AddEnabledDevice
-close
-ioctl
-memchr
-utimes
-__gmon_start__
+GetMotionHistory
+GetMotionHistorySize
+InitButtonClassDeviceStruct
+InitPointerDeviceStruct
+InitPtrFeedbackClassDeviceStruct
+InitValuatorClassDeviceStruct
 _Jv_RegisterClasses
-xf86AddInputDriver
-read
-strncmp
-malloc
-xf86RemoveEnabledDevice
-unlink
+___errno
+__cxa_finalize
+__deregister_frame_info_bases
+__divdi3
+__errno_location
 __fxstat64
-iconv_open
-geteuid
-xf86ProcessCommonOptions
+__gmon_start__
+__iob
+__moddi3
+__register_frame_info_bases
+__stack_chk_fail
+__udivdi3
+__umoddi3
+__xstat64
+calloc
+chdir
+chmod
+chown
+close
+fchmod
+fcntl
+fflush
+flock
+fprintf
+fputs
 free
-strlen
-xf86CheckStrOption
-__cxa_finalize
-xf86DeleteInput
-realpath
-InitButtonClassDeviceStruct
+fstat
 fsync
-iconv
-futimes
-open64
-strstr
-fputs
+ftruncate
 ftruncate64
-xf86SetIntOption
-fchmod
+futimes
+getcwd
+getenv
+geteuid
+getpwuid_r
+iconv
+iconv_close
+iconv_open
+ioctl
+lchown
+lseek
+lseek64
+malloc
+memalign
+memchr
+memcmp
 memcpy
-putenv
 memmove
-strchr
+memset
+miPointerCurrentScreen
+miPointerGetMotionBufferSize
+miPointerGetMotionEvents
+miPointerGetScreen
+mmap64
+mprotect
+munmap
+nl_langinfo
+open
+open64
+posix_memalign
+pthread_sigmask
+putenv
+read
+realloc
+realpath
+rename
+screenInfo
 setenv
-getenv
-xf86InitValuatorAxisStruct
-__errno_location
-xf86CollectInputOptions
-__stack_chk_fail
+sigdelset
+sigfillset
+stat
+stderr
+strchr
 strcmp
-tolower
-getcwd
 strcpy
-miPointerGetScreen
-memcmp
-xf86MotionHistoryAllocate
-calloc
-__xstat64
-lseek64
+strlen
+strncmp
+strpbrk
+strstr
+tolower
+unlink
 unsetenv
+utimes
+write
+xf86AddEnabledDevice
+xf86AddInputDriver
 xf86AllocateInput
-stderr
-xf86Msg
+xf86CheckStrOption
+xf86CollectInputOptions
+xf86DeleteInput
+xf86InitValuatorAxisStruct
 xf86InitValuatorDefaults
-realloc
-getpwuid_r
-InitValuatorClassDeviceStruct
-fprintf
-write
-fcntl
-iconv_close
-rename
-GetMotionHistory
-GetMotionHistorySize
-fflush
-nl_langinfo
-lseek
-open
-__register_frame_info_bases
-__deregister_frame_info_bases
-stat
-fstat
-___errno
-ftruncate
-strpbrk
-__iob
-__udivdi3
-__umoddi3
-__divdi3
-__moddi3
-InitPtrFeedbackClassDeviceStruct
+xf86MotionHistoryAllocate
+xf86Msg
+xf86PostMotionEvent
+xf86ProcessCommonOptions
+xf86RemoveEnabledDevice
 xf86ScaleAxis
-miPointerGetMotionEvents
-miPointerGetMotionBufferSize
-miPointerCurrentScreen
-screenInfo
-InitPointerDeviceStruct
+xf86SetIntOption
Index: src/VBox/Additions/x11/vboxmouse/xorg70/mouse.c
===================================================================
--- src/VBox/Additions/x11/vboxmouse/xorg70/mouse.c.orig
+++ src/VBox/Additions/x11/vboxmouse/xorg70/mouse.c
@@ -473,7 +473,7 @@ MouseCommonOptions(InputInfoPtr pInfo)
 	int lock;             /* lock button */
 	int target;           /* target button */
 	int lockM,targetM;    /* bitmasks for drag lock, target */
-	int i, j;             /* indexes */
+	int k, j;             /* indexes */
 	char *s1;             /* parse input string */
 	DragLockPtr pLock;
 
@@ -537,7 +537,7 @@ MouseCommonOptions(InputInfoPtr pInfo)
 	 */
 
 	/* for each nibble */
-	for (i = 0; i < NIB_COUNT; i++) {
+	for (k = 0; k < NIB_COUNT; k++) {
 	    /* for each possible set of bits for that nibble */
 	    for (j = 0; j < NIB_SIZE; j++) {
 		int ff, fM, otherbits;
@@ -553,17 +553,17 @@ MouseCommonOptions(InputInfoPtr pInfo)
 		    /*
 		     * if otherbits =0 then only 1 bit set
 		     * so j=fM
-		     * nib_table[i][fM] already calculated if fM has
+		     * nib_table[k][fM] already calculated if fM has
 		     * only 1 bit set.
-		     * nib_table[i][j] has already been filled in
+		     * nib_table[k][j] has already been filled in
 		     * by previous loop. otherwise
-		     * otherbits < j so nibtable[i][otherbits]
+		     * otherbits < j so nibtable[k][otherbits]
 		     * has already been calculated.
 		     */
 		    if (otherbits)
-			pLock->nib_table[i][j] =
-				     pLock->nib_table[i][fM] |
-				     pLock->nib_table[i][otherbits];
+			pLock->nib_table[k][j] =
+				     pLock->nib_table[k][fM] |
+				     pLock->nib_table[k][otherbits];
 
 		}
 	    }
@@ -3653,21 +3653,21 @@ autoProbeMouse(InputInfoPtr pInfo, Bool
 	}
 	case AUTOPROBE_SWITCH_PROTOCOL:
 	{
-	    MouseProtocolID proto;
+	    MouseProtocolID prot;
 	    void *defaults;
 	    AP_DBG(("State SWITCH_PROTOCOL\n"));
-	    proto = mPriv->protoList[mPriv->protocolID++];
-	    if (proto == PROT_UNKNOWN)
+	    prot = mPriv->protoList[mPriv->protocolID++];
+	    if (prot == PROT_UNKNOWN)
 		mPriv->autoState = AUTOPROBE_SWITCHSERIAL;
-	    else if (!(defaults = GetProtocol(proto)->defaults)
+	    else if (!(defaults = GetProtocol(prot)->defaults)
 		       || (mPriv->serialDefaultsNum == -1
 			   && (defaults == msDefaults))
 		       || (mPriv->serialDefaultsNum != -1
 			   && serialDefaultsList[mPriv->serialDefaultsNum]
 			   == defaults)) {
 		AP_DBG(("Changing Protocol to %s\n",
-			ProtocolIDToName(proto)));
-		SetMouseProto(pMse,proto);
+			ProtocolIDToName(prot)));
+		SetMouseProto(pMse,prot);
 		FlushButtons(pMse);
 		RESET_VALIDATION;
 		mPriv->autoState = AUTOPROBE_VALIDATE2;
Index: src/VBox/Additions/x11/vboxmouse/xorg70/pnp.c
===================================================================
--- src/VBox/Additions/x11/vboxmouse/xorg70/pnp.c.orig
+++ src/VBox/Additions/x11/vboxmouse/xorg70/pnp.c
@@ -713,8 +713,8 @@ probePs2ProtocolPnP(InputInfoPtr pInfo)
 	    u = ps2GetDeviceID(pInfo);
 	    if (u == 0x03) {
 		/* found IntelliMouse now try IntelliExplorer */
-		unsigned char seq[] = { 243, 200, 243, 200, 243, 80 };
-		if (ps2SendPacket(pInfo,seq,sizeof(seq))) {
+		unsigned char seq2[] = { 243, 200, 243, 200, 243, 80 };
+		if (ps2SendPacket(pInfo,seq2,sizeof(seq2))) {
 		    u = ps2GetDeviceID(pInfo);
 		    if (u == 0x04)
 			ret =  PROT_EXPPS2;
Index: src/VBox/Additions/x11/vboxmouse/undefined_70
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_70.orig
+++ src/VBox/Additions/x11/vboxmouse/undefined_70
@@ -1,145 +1,157 @@
-xf86ReadSerial
-xf86sscanf
-Xstrdup
-chdir
+AdjustWaitForDelay
+ErrorF
+GetTimeInMillis
+InitPointerDeviceStruct
 RegisterBlockAndWakeupHandlers
-xf86ReplaceIntOption
-XisbRead
-xf86PostMotionEvent
-xf86WaitForInput
-memset
-xf86AddEnabledDevice
-close
-xf86strtol
-ioctl
-memchr
-xf86UnblockSIGIO
-utimes
-xf86sprintf
+RemoveBlockAndWakeupHandlers
+XNFalloc
+XNFrealloc
+Xalloc
+Xcalloc
+Xfree
+XisbBlockDuration
 XisbFree
-__gmon_start__
+XisbNew
+XisbRead
+Xstrdup
 _Jv_RegisterClasses
-xf86AddInputDriver
-ErrorF
-Xalloc
-xf86FindOptionValue
-read
-strncmp
-malloc
-xf86RemoveEnabledDevice
-unlink
-xf86sin
-xf86GetMotionEvents
-AdjustWaitForDelay
-xf86PostButtonEvent
-xf86FlushInput
+___errno
+__cxa_finalize
+__deregister_frame_info_bases
+__divdi3
+__errno_location
 __fxstat64
-iconv_open
-xf86cos
-geteuid
-xf86errno
+__gmon_start__
+__iob
+__moddi3
+__register_frame_info_bases
+__stack_chk_fail
+__udivdi3
+__umoddi3
+__xstat64
+calloc
+chdir
+chmod
+chown
+close
 currentTime
-xf86NameCmp
-xf86ProcessCommonOptions
-xf86OptionListMerge
+fchmod
+fcntl
+fflush
+flock
+fprintf
+fputs
 free
-strlen
-xf86CheckStrOption
-xf86OptionListCreate
-__cxa_finalize
-xf86OSMouseInit
-miPointerGetMotionEvents
-realpath
-miPointerGetMotionBufferSize
-xf86usleep
+fstat
 fsync
-iconv
-futimes
-open64
-strstr
-xf86OpenSerial
-RemoveBlockAndWakeupHandlers
-fputs
-Xcalloc
+ftruncate
 ftruncate64
-xf86SetIntOption
-xf86GetAllowMouseOpenFail
-xf86SetStrOption
-Xfree
-fchmod
+futimes
+getcwd
+getenv
+geteuid
+getpwuid_r
+iconv
+iconv_close
+iconv_open
+ioctl
+lchown
+lseek
+lseek64
+malloc
+memalign
+memchr
+memcmp
 memcpy
-putenv
-xf86SetBoolOption
-GetTimeInMillis
 memmove
-strchr
+memset
+miPointerGetMotionBufferSize
+miPointerGetMotionEvents
+mmap64
+mprotect
+munmap
+nl_langinfo
+open
+open64
+posix_memalign
+pthread_sigmask
+putenv
+read
+realloc
+realpath
+rename
+screenInfo
 setenv
-getenv
-xf86ffs
-xf86SerialModemSetBits
-xf86InitValuatorAxisStruct
-__errno_location
-xf86CollectInputOptions
-xf86LoaderCheckSymbol
-__stack_chk_fail
-XisbNew
+sigdelset
+sigfillset
+stat
+stderr
+strchr
 strcmp
-tolower
-xf86GetSerialModemState
-getcwd
-xf86SetSerial
-InitPointerDeviceStruct
-xf86SetSerialModemState
 strcpy
-xf86strerror
-xf86MsgVerb
-xf86memcpy
-memcmp
-xf86MotionHistoryAllocate
-calloc
-XNFalloc
-__xstat64
-xf86GetOS
-xf86MarkOptionUsedByName
-xf86ErrorF
-lseek64
-xf86strncmp
-xf86GetBuiltinInterfaceVersion
+strlen
+strncmp
+strpbrk
+strstr
+tolower
+unlink
 unsetenv
+utimes
+write
+xf86AddEnabledDevice
+xf86AddInputDriver
+xf86AddModuleInfo
 xf86AllocateInput
-stderr
-xf86Msg
+xf86BlockSIGIO
+xf86CheckStrOption
 xf86CloseSerial
+xf86CollectInputOptions
+xf86ErrorF
+xf86FindOptionValue
+xf86FlushInput
+xf86GetAllowMouseOpenFail
+xf86GetBuiltinInterfaceVersion
+xf86GetMotionEvents
+xf86GetOS
+xf86GetSerialModemState
+xf86InitValuatorAxisStruct
 xf86InitValuatorDefaults
-realloc
-getpwuid_r
-xf86WriteSerial
-fprintf
+xf86LoaderCheckSymbol
+xf86MarkOptionUsedByName
+xf86MotionHistoryAllocate
+xf86Msg
+xf86MsgVerb
+xf86NameCmp
+xf86OSMouseInit
+xf86OpenSerial
+xf86OptionListCreate
 xf86OptionListFree
-write
-xf86AddModuleInfo
-XNFrealloc
-xf86BlockSIGIO
-XisbBlockDuration
-fcntl
-screenInfo
-iconv_close
-rename
+xf86OptionListMerge
+xf86PostButtonEvent
+xf86PostMotionEvent
+xf86ProcessCommonOptions
+xf86ReadSerial
+xf86RemoveEnabledDevice
+xf86ReplaceIntOption
+xf86SerialModemSetBits
+xf86SetBoolOption
+xf86SetIntOption
+xf86SetSerial
+xf86SetSerialModemState
 xf86SetSerialSpeed
-fflush
+xf86SetStrOption
+xf86UnblockSIGIO
+xf86WaitForInput
+xf86WriteSerial
 xf86abs
-open
-fstat
-___errno
-ftruncate
-nl_langinfo
-__deregister_frame_info_bases
-__register_frame_info_bases
-lseek
-stat
-strpbrk
-__iob
-__divdi3
-__umoddi3
-__udivdi3
-__moddi3
+xf86cos
+xf86errno
+xf86ffs
+xf86memcpy
+xf86sin
+xf86sprintf
+xf86sscanf
+xf86strerror
+xf86strncmp
+xf86strtol
+xf86usleep
Index: src/VBox/Additions/x11/vboxmouse/xorg71/mouse.c
===================================================================
--- src/VBox/Additions/x11/vboxmouse/xorg71/mouse.c.orig
+++ src/VBox/Additions/x11/vboxmouse/xorg71/mouse.c
@@ -488,7 +488,7 @@ MouseCommonOptions(InputInfoPtr pInfo)
 	int lock;             /* lock button */
 	int target;           /* target button */
 	int lockM,targetM;    /* bitmasks for drag lock, target */
-	int i, j;             /* indexes */
+	int k, j;             /* indexes */
 	char *s1;             /* parse input string */
 	DragLockPtr pLock;
 
@@ -552,7 +552,7 @@ MouseCommonOptions(InputInfoPtr pInfo)
 	 */
 
 	/* for each nibble */
-	for (i = 0; i < NIB_COUNT; i++) {
+	for (k = 0; k < NIB_COUNT; k++) {
 	    /* for each possible set of bits for that nibble */
 	    for (j = 0; j < NIB_SIZE; j++) {
 		int ff, fM, otherbits;
@@ -568,17 +568,17 @@ MouseCommonOptions(InputInfoPtr pInfo)
 		    /*
 		     * if otherbits =0 then only 1 bit set
 		     * so j=fM
-		     * nib_table[i][fM] already calculated if fM has
+		     * nib_table[k][fM] already calculated if fM has
 		     * only 1 bit set.
-		     * nib_table[i][j] has already been filled in
+		     * nib_table[k][j] has already been filled in
 		     * by previous loop. otherwise
-		     * otherbits < j so nibtable[i][otherbits]
+		     * otherbits < j so nibtable[k][otherbits]
 		     * has already been calculated.
 		     */
 		    if (otherbits)
-			pLock->nib_table[i][j] =
-				     pLock->nib_table[i][fM] |
-				     pLock->nib_table[i][otherbits];
+			pLock->nib_table[k][j] =
+				     pLock->nib_table[k][fM] |
+				     pLock->nib_table[k][otherbits];
 
 		}
 	    }
@@ -3668,21 +3668,21 @@ autoProbeMouse(InputInfoPtr pInfo, Bool
 	}
 	case AUTOPROBE_SWITCH_PROTOCOL:
 	{
-	    MouseProtocolID proto;
+	    MouseProtocolID prot;
 	    void *defaults;
 	    AP_DBG(("State SWITCH_PROTOCOL\n"));
-	    proto = mPriv->protoList[mPriv->protocolID++];
-	    if (proto == PROT_UNKNOWN)
+	    prot = mPriv->protoList[mPriv->protocolID++];
+	    if (prot == PROT_UNKNOWN)
 		mPriv->autoState = AUTOPROBE_SWITCHSERIAL;
-	    else if (!(defaults = GetProtocol(proto)->defaults)
+	    else if (!(defaults = GetProtocol(prot)->defaults)
 		       || (mPriv->serialDefaultsNum == -1
 			   && (defaults == msDefaults))
 		       || (mPriv->serialDefaultsNum != -1
 			   && serialDefaultsList[mPriv->serialDefaultsNum]
 			   == defaults)) {
 		AP_DBG(("Changing Protocol to %s\n",
-			ProtocolIDToName(proto)));
-		SetMouseProto(pMse,proto);
+			ProtocolIDToName(prot)));
+		SetMouseProto(pMse,prot);
 		FlushButtons(pMse);
 		RESET_VALIDATION;
 		mPriv->autoState = AUTOPROBE_VALIDATE2;
Index: src/VBox/Additions/x11/vboxmouse/xorg71/pnp.c
===================================================================
--- src/VBox/Additions/x11/vboxmouse/xorg71/pnp.c.orig
+++ src/VBox/Additions/x11/vboxmouse/xorg71/pnp.c
@@ -720,8 +720,8 @@ probePs2ProtocolPnP(InputInfoPtr pInfo)
 	    u = ps2GetDeviceID(pInfo);
 	    if (u == 0x03) {
 		/* found IntelliMouse now try IntelliExplorer */
-		unsigned char seq[] = { 243, 200, 243, 200, 243, 80 };
-		if (ps2SendPacket(pInfo,seq,sizeof(seq))) {
+		unsigned char seq2[] = { 243, 200, 243, 200, 243, 80 };
+		if (ps2SendPacket(pInfo,seq2,sizeof(seq2))) {
 		    u = ps2GetDeviceID(pInfo);
 		    if (u == 0x04)
 			ret =  PROT_EXPPS2;
Index: src/VBox/Additions/x11/vboxmouse/undefined_71
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_71.orig
+++ src/VBox/Additions/x11/vboxmouse/undefined_71
@@ -1,143 +1,155 @@
-xf86ReadSerial
-Xstrdup
-chdir
+AdjustWaitForDelay
+ErrorF
+GetTimeInMillis
+InitPointerDeviceStruct
 RegisterBlockAndWakeupHandlers
-xf86ReplaceIntOption
-XisbRead
-xf86PostMotionEvent
-xf86WaitForInput
-memset
-xf86AddEnabledDevice
-close
-ioctl
-memchr
-xf86UnblockSIGIO
-utimes
+RemoveBlockAndWakeupHandlers
+XNFalloc
+XNFrealloc
+Xalloc
+Xcalloc
+Xfree
+XisbBlockDuration
 XisbFree
-__gmon_start__
+XisbNew
+XisbRead
+Xstrdup
 _Jv_RegisterClasses
-xf86AddInputDriver
-ErrorF
-Xalloc
-xf86FindOptionValue
-read
-strncmp
-malloc
-xf86RemoveEnabledDevice
-unlink
-xf86GetMotionEvents
-AdjustWaitForDelay
-xf86PostButtonEvent
-xf86FlushInput
+___errno
+__cxa_finalize
+__deregister_frame_info_bases
+__divdi3
+__errno_location
 __fxstat64
-iconv_open
-geteuid
-xf86errno
+__gmon_start__
+__iob
+__moddi3
+__register_frame_info_bases
+__stack_chk_fail
+__udivdi3
+__umoddi3
+__xstat64
+abs
+calloc
+chdir
+chmod
+chown
+close
+cos
 currentTime
-xf86NameCmp
-xf86ProcessCommonOptions
-xf86OptionListMerge
+fchmod
+fcntl
+fflush
+ffs
+flock
+fprintf
+fputs
 free
-strlen
-xf86CheckStrOption
-xf86OptionListCreate
-__cxa_finalize
-xf86OSMouseInit
-miPointerGetMotionEvents
-realpath
-miPointerGetMotionBufferSize
-sprintf
-sscanf
+fstat
 fsync
-iconv
-futimes
-usleep
-open64
-strstr
-xf86OpenSerial
-RemoveBlockAndWakeupHandlers
-fputs
-strtol
-Xcalloc
+ftruncate
 ftruncate64
-xf86SetIntOption
-xf86GetAllowMouseOpenFail
-xf86SetStrOption
-Xfree
-fchmod
+futimes
+getcwd
+getenv
+geteuid
+getpwuid_r
+iconv
+iconv_close
+iconv_open
+ioctl
+lchown
+lseek
+lseek64
+malloc
+memalign
+memchr
+memcmp
 memcpy
-putenv
-ffs
-xf86SetBoolOption
-GetTimeInMillis
 memmove
-strchr
+memset
+miPointerGetMotionBufferSize
+miPointerGetMotionEvents
+mmap64
+mprotect
+munmap
+nl_langinfo
+open
+open64
+posix_memalign
+pthread_sigmask
+putenv
+read
+realloc
+realpath
+rename
+screenInfo
 setenv
-getenv
-xf86SerialModemSetBits
-xf86InitValuatorAxisStruct
-__errno_location
-xf86CollectInputOptions
-xf86LoaderCheckSymbol
-__stack_chk_fail
-XisbNew
+sigdelset
+sigfillset
+sin
+sprintf
+sscanf
+stat
+stderr
+strchr
 strcmp
-tolower
-xf86GetSerialModemState
-getcwd
-xf86SetSerial
-InitPointerDeviceStruct
-xf86SetSerialModemState
 strcpy
-xf86strerror
-xf86MsgVerb
-sin
-memcmp
-xf86MotionHistoryAllocate
-calloc
-XNFalloc
-__xstat64
-xf86GetOS
-xf86MarkOptionUsedByName
-xf86ErrorF
-lseek64
-xf86GetBuiltinInterfaceVersion
+strlen
+strncmp
+strpbrk
+strstr
+strtol
+tolower
+unlink
 unsetenv
+usleep
+utimes
+write
+xf86AddEnabledDevice
+xf86AddInputDriver
+xf86AddModuleInfo
 xf86AllocateInput
-stderr
-xf86Msg
+xf86BlockSIGIO
+xf86CheckStrOption
 xf86CloseSerial
+xf86CollectInputOptions
+xf86ErrorF
+xf86FindOptionValue
+xf86FlushInput
+xf86GetAllowMouseOpenFail
+xf86GetBuiltinInterfaceVersion
+xf86GetMotionEvents
+xf86GetOS
+xf86GetSerialModemState
+xf86InitValuatorAxisStruct
 xf86InitValuatorDefaults
-realloc
-getpwuid_r
-cos
-xf86WriteSerial
-fprintf
+xf86LoaderCheckSymbol
+xf86MarkOptionUsedByName
+xf86MotionHistoryAllocate
+xf86Msg
+xf86MsgVerb
+xf86NameCmp
+xf86OSMouseInit
+xf86OpenSerial
+xf86OptionListCreate
 xf86OptionListFree
-write
-xf86AddModuleInfo
-XNFrealloc
-xf86BlockSIGIO
-XisbBlockDuration
-fcntl
-screenInfo
-iconv_close
-rename
+xf86OptionListMerge
+xf86PostButtonEvent
+xf86PostMotionEvent
+xf86ProcessCommonOptions
+xf86ReadSerial
+xf86RemoveEnabledDevice
+xf86ReplaceIntOption
+xf86SerialModemSetBits
+xf86SetBoolOption
+xf86SetIntOption
+xf86SetSerial
+xf86SetSerialModemState
 xf86SetSerialSpeed
-fflush
-abs
-lseek
-stat
-__deregister_frame_info_bases
-nl_langinfo
-__register_frame_info_bases
-open
-___errno
-fstat
-ftruncate
-strpbrk
-__iob
-__moddi3
-__umoddi3
-__udivdi3
-__divdi3
+xf86SetStrOption
+xf86UnblockSIGIO
+xf86WaitForInput
+xf86WriteSerial
+xf86errno
+xf86strerror
Index: src/VBox/Additions/x11/vboxmouse/mouse.c
===================================================================
--- src/VBox/Additions/x11/vboxmouse/mouse.c.orig
+++ src/VBox/Additions/x11/vboxmouse/mouse.c
@@ -44,8 +44,6 @@
 #ifdef XINPUT
 #include "XI.h"
 #include "XIproto.h"
-#include "extnsionst.h"
-#include "extinit.h"
 #else
 #include "inputstr.h"
 #endif
Index: src/VBox/Additions/x11/vboxmouse/Makefile.kmk
===================================================================
--- src/VBox/Additions/x11/vboxmouse/Makefile.kmk.orig
+++ src/VBox/Additions/x11/vboxmouse/Makefile.kmk
@@ -119,15 +119,8 @@ vboxmouse_drv_14_INCS := \
 	$(VBOX_PATH_X11_XORG_1_4) \
 	$(VBOX_PATH_X11_XORG_1_4)/xorg \
 	$(PATH_SUB_CURRENT)
-ifeq ($(KBUILD_TARGET),linux)
 vboxmouse_drv_14_SOURCES = \
 	vboxmouse_15.c
-else  # Don't enable this for other platforms yet
-vboxmouse_drv_14_SOURCES = \
-	xorg14/mouse.c \
-	xorg14/pnp.c \
-	VBoxUtils.c
-endif
 
 
 #
@@ -175,7 +168,7 @@ vboxmouse_drv_17_INCS := \
 	$(VBOX_PATH_X11_ROOT)/xextproto-7.1.1 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.99-20090831 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
-	$(VBOX_PATH_X11_ROOT)/xproto-7.0.15 \
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18 \
 	$(PATH_SUB_CURRENT)
 vboxmouse_drv_17_SOURCES = \
 	vboxmouse_15.c
@@ -195,12 +188,32 @@ vboxmouse_drv_18_INCS := \
 	$(VBOX_PATH_X11_ROOT)/xextproto-7.1.1 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.8.0 \
 	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
-	$(VBOX_PATH_X11_ROOT)/xproto-7.0.15 \
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18 \
 	$(PATH_SUB_CURRENT)
 vboxmouse_drv_18_SOURCES = \
 	vboxmouse_15.c
 
 
+#
+# vboxmouse_drv_19
+#
+DLLS += vboxmouse_drv_19
+vboxmouse_drv_19_TEMPLATE = VBOXGUESTR3XORGMOD
+vboxmouse_drv_19_DEFS := $(vboxmouse_drv_70_DEFS) NO_ANSIC
+## @todo replace $(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local
+vboxmouse_drv_19_INCS := \
+	$(VBOX_PATH_X11_ROOT)/inputproto-1.9.99.902 \
+	$(VBOX_PATH_X11_ROOT)/libpciaccess-0.10.8 \
+	$(VBOX_PATH_X11_ROOT)/pixman-0.16.0 \
+	$(VBOX_PATH_X11_ROOT)/xextproto-7.1.1 \
+	$(VBOX_PATH_X11_ROOT)/xorg-server-1.9.0 \
+	$(VBOX_PATH_X11_ROOT)/xorg-server-1.6.0-local \
+	$(VBOX_PATH_X11_ROOT)/xproto-7.0.18 \
+	$(PATH_SUB_CURRENT)
+vboxmouse_drv_19_SOURCES = \
+	vboxmouse_15.c
+
+
 # Check the undefined symbols in the X.Org modules against lists of allowed
 # symbols.  Not very elegant, but it will catch problems early.
 ifdef VBOX_WITH_TESTCASES
@@ -214,6 +227,7 @@ ifdef VBOX_WITH_TESTCASES
       TESTING  += $(PATH_vboxmouse_drv)/tstvboxmouse68.run
       OTHERS += $(PATH_vboxmouse_drv)/tstvboxmouse68.run
 $$(PATH_vboxmouse_drv)/tstvboxmouse68.run: $$(INSTARGET_vboxmouse_drv)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET) \
 	    "$(INSTARGET_vboxmouse_drv)" "$(OUR_PATH_VBOXMOUSE)/undefined_68" --static
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -222,6 +236,7 @@ $$(PATH_vboxmouse_drv)/tstvboxmouse68.ru
      TESTING  += $(PATH_vboxmouse_drv_70)/tstvboxmouse70.run
      OTHERS += $(PATH_vboxmouse_drv_70)/tstvboxmouse70.run
 $$(PATH_vboxmouse_drv_70)/tstvboxmouse70.run: $$(INSTARGET_vboxmouse_drv_70)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh  $(KBUILD_TARGET) \
 	    $(INSTARGET_vboxmouse_drv_70) $(OUR_PATH_VBOXMOUSE)/undefined_70
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -229,6 +244,7 @@ $$(PATH_vboxmouse_drv_70)/tstvboxmouse70
      TESTING  += $(PATH_vboxmouse_drv_71)/tstvboxmouse71.run
      OTHERS += $(PATH_vboxmouse_drv_71)/tstvboxmouse71.run
 $$(PATH_vboxmouse_drv_71)/tstvboxmouse71.run: $$(INSTARGET_vboxmouse_drv_71)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxmouse_drv_71) $(OUR_PATH_VBOXMOUSE)/undefined_71
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -236,22 +252,23 @@ $$(PATH_vboxmouse_drv_71)/tstvboxmouse71
      TESTING  += $(PATH_vboxmouse_drv_13)/tstvboxmouse13.run
      OTHERS += $(PATH_vboxmouse_drv_13)/tstvboxmouse13.run
 $$(PATH_vboxmouse_drv_13)/tstvboxmouse13.run: $$(INSTARGET_vboxmouse_drv_13)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET) \
 	    $(INSTARGET_vboxmouse_drv_13) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
 
-ifeq ($(KBUILD_TARGET),linux)
      TESTING  += $(PATH_vboxmouse_drv_14)/tstvboxmouse14.run
      OTHERS += $(PATH_vboxmouse_drv_14)/tstvboxmouse14.run
 $$(PATH_vboxmouse_drv_14)/tstvboxmouse14.run: $$(INSTARGET_vboxmouse_drv_14)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET) \
 	    $(INSTARGET_vboxmouse_drv_14) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
-endif
 
      TESTING  += $(PATH_vboxmouse_drv_15)/tstvboxmouse15.run
      OTHERS += $(PATH_vboxmouse_drv_15)/tstvboxmouse15.run
 $$(PATH_vboxmouse_drv_15)/tstvboxmouse15.run: $$(INSTARGET_vboxmouse_drv_15)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxmouse_drv_15) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -259,6 +276,7 @@ $$(PATH_vboxmouse_drv_15)/tstvboxmouse15
      TESTING  += $(PATH_vboxmouse_drv_16)/tstvboxmouse16.run
      OTHERS += $(PATH_vboxmouse_drv_16)/tstvboxmouse16.run
 $$(PATH_vboxmouse_drv_16)/tstvboxmouse16.run: $$(INSTARGET_vboxmouse_drv_16)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxmouse_drv_16) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -266,6 +284,7 @@ $$(PATH_vboxmouse_drv_16)/tstvboxmouse16
      TESTING  += $(PATH_vboxmouse_drv_17)/tstvboxmouse17.run
      OTHERS += $(PATH_vboxmouse_drv_17)/tstvboxmouse17.run
 $$(PATH_vboxmouse_drv_17)/tstvboxmouse17.run: $$(INSTARGET_vboxmouse_drv_17)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxmouse_drv_17) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
@@ -273,10 +292,19 @@ $$(PATH_vboxmouse_drv_17)/tstvboxmouse17
      TESTING  += $(PATH_vboxmouse_drv_18)/tstvboxmouse18.run
      OTHERS += $(PATH_vboxmouse_drv_18)/tstvboxmouse18.run
 $$(PATH_vboxmouse_drv_18)/tstvboxmouse18.run: $$(INSTARGET_vboxmouse_drv_18)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
 	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
 	    $(INSTARGET_vboxmouse_drv_18) $(OUR_PATH_VBOXMOUSE)/undefined_15
 	$(QUIET)$(APPEND) -t "$@" "done"
 
+     TESTING  += $(PATH_vboxmouse_drv_19)/tstvboxmouse19.run
+     OTHERS += $(PATH_vboxmouse_drv_19)/tstvboxmouse19.run
+$$(PATH_vboxmouse_drv_19)/tstvboxmouse19.run: $$(INSTARGET_vboxmouse_drv_19)
+	$(QUIET)$(call MSG_L1,Checking for unresolved symbols in $<)
+	$(QUIET)/bin/sh $(PATH_ROOT)/src/bldprogs/checkUndefined.sh $(KBUILD_TARGET)  \
+	    $(INSTARGET_vboxmouse_drv_19) $(OUR_PATH_VBOXMOUSE)/undefined_15
+	$(QUIET)$(APPEND) -t "$@" "done"
+
     endif # ! VBOX_ONLY_SDK
    endif # eq ($(KBUILD_HOST_ARCH),$(KBUILD_TARGET_ARCH))
   endif # eq ($(KBUILD_TARGET),linux)
Index: src/VBox/Additions/x11/vboxmouse/undefined_68
===================================================================
--- src/VBox/Additions/x11/vboxmouse/undefined_68.orig
+++ src/VBox/Additions/x11/vboxmouse/undefined_68
@@ -1,71 +1,75 @@
-xf86GetMotionEvents
-xf86ReadSerial
-xf86FlushInput
-xf86WaitForInput
-xf86LoaderCheckSymbol
-xf86OptionListCreate
 AdjustWaitForDelay
-xf86GetSerialModemState
-xf86free
-xf86usleep
-xf86AddInputDriver
-xf86UnblockSIGIO
-xf86SetSerial
-xf86ReplaceIntOption
-xf86InitValuatorDefaults
-xf86open
+ErrorF
+GetTimeInMillis
+InitPointerDeviceStruct
+RegisterBlockAndWakeupHandlers
+RemoveBlockAndWakeupHandlers
+Xcalloc
+Xfree
+XisbBlockDuration
 XisbFree
+XisbNew
+XisbRead
+Xstrdup
+__stack_chk_fail
+flock
+miPointerGetMotionBufferSize
+miPointerGetMotionEvents
+pthread_sigmask
+screenInfo
+sigdelset
+sigfillset
+xf86AddEnabledDevice
+xf86AddInputDriver
 xf86AddModuleInfo
-Xfree
-xf86ErrorF
-GetTimeInMillis
-xf86ProcessCommonOptions
 xf86AllocateInput
+xf86BlockSIGIO
+xf86CloseSerial
+xf86CollectInputOptions
+xf86ErrorF
+xf86FlushInput
 xf86GetAllowMouseOpenFail
+xf86GetMotionEvents
 xf86GetOS
-xf86AddEnabledDevice
-xf86malloc
-xf86strerror
-xf86ffs
-__stack_chk_fail
-xf86OptionListMerge
-xf86PostButtonEvent
-XisbBlockDuration
+xf86GetSerialModemState
+xf86InitValuatorAxisStruct
+xf86InitValuatorDefaults
+xf86LoaderCheckSymbol
 xf86MotionHistoryAllocate
-xf86MsgVerb
-xf86CollectInputOptions
-RegisterBlockAndWakeupHandlers
-xf86sprintf
-xf86SerialModemSetBits
 xf86Msg
-XisbNew
-xf86OSMouseInit
-xf86close
-xf86ioctl
-xf86SetSerialModemState
-XisbRead
-Xcalloc
-xf86CloseSerial
-xf86BlockSIGIO
-ErrorF
-xf86strncmp
-xf86RemoveEnabledDevice
+xf86MsgVerb
 xf86NameCmp
-xf86InitValuatorAxisStruct
-InitPointerDeviceStruct
-RemoveBlockAndWakeupHandlers
-xf86memcpy
-xf86SetIntOption
-Xstrdup
-miPointerGetMotionBufferSize
+xf86OSMouseInit
 xf86OpenSerial
-screenInfo
-xf86abs
-miPointerGetMotionEvents
-xf86sscanf
-xf86SetBoolOption
+xf86OptionListCreate
+xf86OptionListMerge
+xf86PostButtonEvent
 xf86PostMotionEvent
+xf86ProcessCommonOptions
+xf86ReadSerial
+xf86RemoveEnabledDevice
+xf86ReplaceIntOption
+xf86SerialModemSetBits
+xf86SetBoolOption
+xf86SetIntOption
+xf86SetSerial
+xf86SetSerialModemState
 xf86SetSerialSpeed
+xf86SetStrOption
+xf86UnblockSIGIO
+xf86WaitForInput
 xf86WriteSerial
+xf86abs
+xf86close
 xf86errno
-xf86SetStrOption
+xf86ffs
+xf86free
+xf86ioctl
+xf86malloc
+xf86memcpy
+xf86open
+xf86sprintf
+xf86sscanf
+xf86strerror
+xf86strncmp
+xf86usleep
Index: src/VBox/Additions/x11/Installer/x11config15.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11config15.pl.orig
+++ src/VBox/Additions/x11/Installer/x11config15.pl
@@ -1,10 +1,8 @@
 #!/usr/bin/perl -w
 #
-# Sun VirtualBox
-#
 # Guest Additions X11 config update script for X.org 1.5
 #
-# Copyright (C) 2006-2009 Oracle Corporation
+# Copyright (C) 2006-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
Index: src/VBox/Additions/x11/Installer/x11config15suse.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11config15suse.pl.orig
+++ src/VBox/Additions/x11/Installer/x11config15suse.pl
@@ -1,10 +1,8 @@
 #!/usr/bin/perl -w
 #
-# Sun VirtualBox
-#
 # Guest Additions X11 config update script
 #
-# Copyright (C) 2006-2009 Oracle Corporation
+# Copyright (C) 2006-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
Index: src/VBox/Additions/x11/Installer/x11config-new.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11config-new.pl.orig
+++ src/VBox/Additions/x11/Installer/x11config-new.pl
@@ -1,10 +1,8 @@
 #!/usr/bin/perl -w
 #
-# Sun VirtualBox
-#
 # Guest Additions X11 config update script
 #
-# Copyright (C) 2006-2009 Oracle Corporation
+# Copyright (C) 2006-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
@@ -118,7 +116,7 @@ Section "InputDevice"
   Option      "Device" "$old_mouse_dev"
   Option      "Name" "VirtualBox Mouse"
   Option      "Protocol" "explorerps/2"
-  Option      "Vendor" "Sun Microsystems Inc"
+  Option      "Vendor" "Oracle Corporation"
   Option      "ZAxisMapping" "4 5"
   Option      "CorePointer"
 EndSection
@@ -143,7 +141,7 @@ Section "InputDevice"
   Option       "Device" "/dev/input/mice"
   Option       "Name" "VirtualBox Mouse Buttons"
   Option       "Protocol" "explorerps/2"
-  Option       "Vendor" "Sun Microsystems Inc"
+  Option       "Vendor" "Oracle Corporation"
   Option       "ZAxisMapping" "4 5"
   Option       "CorePointer"
 EndSection
@@ -153,7 +151,7 @@ Section "InputDevice"
   Identifier   "Mouse[2]"
   Option       "Device" "/dev/vboxguest"
   Option       "Name" "VirtualBox Mouse"
-  Option       "Vendor" "Sun Microsystems Inc"
+  Option       "Vendor" "Oracle Corporation"
   Option       "SendCoreEvents"
 EndSection
 
@@ -174,14 +172,14 @@ EOF
 Section "Monitor"
   Identifier   "Monitor[0]"
   ModelName    "VirtualBox Virtual Output"
-  VendorName   "Sun Microsystems Inc"
+  VendorName   "Oracle Corporation"
 EndSection
 
 Section "Device"
   BoardName    "VirtualBox Graphics"
   Driver       "vboxvideo"
   Identifier   "Device[0]"
-  VendorName   "Sun Microsystems Inc"
+  VendorName   "Oracle Corporation"
 EndSection
 
 Section "Screen"
Index: src/VBox/Additions/x11/Installer/linux_xorg_suse11.conf
===================================================================
--- src/VBox/Additions/x11/Installer/linux_xorg_suse11.conf.orig
+++ src/VBox/Additions/x11/Installer/linux_xorg_suse11.conf
@@ -69,7 +69,7 @@ Section "InputDevice"
   Option       "Device" "/dev/input/mice"
   Option       "Name" "VirtualBox Mouse Buttons"
   Option       "Protocol" "explorerps/2"
-  Option       "Vendor" "Sun Microsystems Inc"
+  Option       "Vendor" "Oracle Corporation"
   Option       "ZAxisMapping" "4 5"
 EndSection
 
@@ -79,14 +79,14 @@ Section "InputDevice"
   Identifier   "Mouse[2]"
   Option       "Device" "/dev/vboxguest"
   Option       "Name" "VirtualBox Mouse"
-  Option       "Vendor" "Sun Microsystems Inc"
+  Option       "Vendor" "Oracle Corporation"
 EndSection
 
 
 Section "Monitor"
   Identifier   "Monitor[0]"
   ModelName    "VirtualBox Virtual Output"
-  VendorName   "Sun Microsystems Inc"
+  VendorName   "Oracle Corporation"
 EndSection
 
 
@@ -104,7 +104,7 @@ Section "Device"
   BoardName    "VirtualBox Graphics"
   Driver       "vboxvideo"
   Identifier   "Device[0]"
-  VendorName   "Sun Microsystems Inc"
+  VendorName   "Oracle Corporation"
 EndSection
 
 
Index: src/VBox/Additions/x11/Installer/x11restore.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11restore.pl.orig
+++ src/VBox/Additions/x11/Installer/x11restore.pl
@@ -1,11 +1,9 @@
 #!/usr/bin/perl -w
 # $Revision: 60692 $
 #
-# Sun VirtualBox
-#
 # Restore xorg.conf while removing Guest Additions.
 #
-# Copyright (C) 2008-2009 Oracle Corporation
+# Copyright (C) 2008-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
Index: src/VBox/Additions/x11/Installer/x11config.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11config.pl.orig
+++ src/VBox/Additions/x11/Installer/x11config.pl
@@ -1,10 +1,8 @@
 #!/usr/bin/perl -w
 #
-# Sun VirtualBox
-#
 # Guest Additions X11 config update script
 #
-# Copyright (C) 2006-2009 Oracle Corporation
+# Copyright (C) 2006-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
Index: src/VBox/Additions/x11/Installer/98vboxadd-xclient
===================================================================
--- src/VBox/Additions/x11/Installer/98vboxadd-xclient.orig
+++ src/VBox/Additions/x11/Installer/98vboxadd-xclient
@@ -1,8 +1,8 @@
 #!/bin/sh
-# Sun VirtualBox
+#
 # Start the Guest Additions X11 Client
 #
-# Copyright (C) 2007-2009 Sun Microsystems, Inc.
+# Copyright (C) 2007-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
@@ -12,10 +12,6 @@
 # VirtualBox OSE distribution. VirtualBox OSE is distributed in the
 # hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
 #
-# Please contact Sun Microsystems, Inc., 4150 Network Circle, Santa
-# Clara, CA 95054 USA or visit http://www.sun.com if you need
-# additional information or have any questions.
-#
 
 # It can happen that pidfiles from a sudo session can land in the user's
 # home directory and prevent new ones from being created.  This is not really
Index: src/VBox/Additions/x11/Installer/x11config15sol.pl
===================================================================
--- src/VBox/Additions/x11/Installer/x11config15sol.pl.orig
+++ src/VBox/Additions/x11/Installer/x11config15sol.pl
@@ -1,10 +1,8 @@
 #!/usr/bin/perl -w
 #
-# Sun VirtualBox
-#
 # Guest Additions X11 config update script
 #
-# Copyright (C) 2006-2009 Oracle Corporation
+# Copyright (C) 2006-2010 Oracle Corporation
 #
 # This file is part of VirtualBox Open Source Edition (OSE), as
 # available from http://www.virtualbox.org. This file is free software;
Index: src/VBox/Additions/x11/VBoxClient/VBoxClient.h
===================================================================
--- src/VBox/Additions/x11/VBoxClient/VBoxClient.h.orig
+++ src/VBox/Additions/x11/VBoxClient/VBoxClient.h
@@ -25,7 +25,7 @@ namespace VBoxClient {
 
 /** A simple class describing a service.  VBoxClient will run exactly one
  * service per invocation. */
-class Service : public stdx::non_copyable
+class Service : public stdx::non_copyable
 {
 public:
     /** Get the services default path to pidfile, relative to $HOME */
Index: src/VBox/Additions/x11/VBoxClient/main.cpp
===================================================================
--- src/VBox/Additions/x11/VBoxClient/main.cpp.orig
+++ src/VBox/Additions/x11/VBoxClient/main.cpp
@@ -26,6 +26,7 @@
 
 #include <X11/Xlib.h>
 
+#include <iprt/critsect.h>
 #include <iprt/env.h>
 #include <iprt/initterm.h>
 #include <iprt/path.h>
@@ -50,16 +51,26 @@ static char g_szPidFile[RTPATH_MAX];
 /** The file handle of our pidfile.  It is global for the benefit of the
  * cleanup routine. */
 static RTFILE g_hPidFile;
+/** Global critical section used to protect the clean-up routine, which can be
+ * called from different threads.
+ */
+RTCRITSECT g_critSect;
 
 /** Clean up if we get a signal or something.  This is extern so that we
  * can call it from other compilation units. */
 void VBoxClient::CleanUp()
 {
-    if (g_pService)
+    /* We never release this, as we end up with a call to exit(3) which is not
+     * async-safe.  Until we fix this application properly, we should be sure
+     * never to exit from anywhere except from this method. */
+    int rc = RTCritSectEnter(&g_critSect);
+    if (RT_FAILURE(rc))
     {
-        g_pService->cleanup();
-        delete g_pService;
+        RTPrintf("VBoxClient: Failure while acquiring the global critical section, rc=%Rrc\n", rc);
+        abort();
     }
+    if (g_pService)
+        g_pService->cleanup();
     if (g_szPidFile[0] && g_hPidFile)
         VbglR3ClosePidFile(g_szPidFile, g_hPidFile);
     VbglR3Term();
@@ -115,7 +126,6 @@ void vboxClientSetSignalHandlers(void)
     sigaction(SIGHUP, &sigAction, NULL);
     sigaction(SIGINT, &sigAction, NULL);
     sigaction(SIGQUIT, &sigAction, NULL);
-    sigaction(SIGABRT, &sigAction, NULL);
     sigaction(SIGPIPE, &sigAction, NULL);
     sigaction(SIGALRM, &sigAction, NULL);
     sigaction(SIGTERM, &sigAction, NULL);
@@ -148,7 +158,7 @@ void vboxClientUsage(const char *pcszFil
  */
 int main(int argc, char *argv[])
 {
-    int rcClipboard, rc = VINF_SUCCESS;
+    int rcClipboard, rc;
     const char *pszFileName = RTPathFilename(argv[0]);
     bool fDaemonise = true;
     /* Have any fatal errors occurred yet? */
@@ -160,7 +170,22 @@ int main(int argc, char *argv[])
         pszFileName = "VBoxClient";
 
     /* Initialise our runtime before all else. */
-    RTR3Init();
+    rc = RTR3Init();
+    if (RT_FAILURE(rc))
+    {
+        /* Of course, this should never happen. */
+        RTPrintf("%s: Failed to initialise the run-time library, rc=%Rrc\n", pszFileName, rc);
+        exit(1);
+    }
+
+    /* Initialise our global clean-up critical section */
+    rc = RTCritSectInit(&g_critSect);
+    if (RT_FAILURE(rc))
+    {
+        /* Of course, this should never happen. */
+        RTPrintf("%s: Failed to initialise the global critical section, rc=%Rrc\n", pszFileName, rc);
+        exit(1);
+    }
 
     /* Parse our option(s) */
     /** @todo Use RTGetOpt() if the arguments become more complex. */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xos_r.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xos_r.h
@@ -0,0 +1,1095 @@
+/*
+Copyright 1996, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+/*
+ * Various and sundry Thread-Safe functions used by X11, Motif, and CDE.
+ *
+ * Use this file in MT-safe code where you would have included
+ *	<dirent.h>	for readdir()
+ *	<grp.h>		for getgrgid() or getgrnam()
+ *	<netdb.h>	for gethostbyname(), gethostbyaddr(), or getservbyname()
+ *	<pwd.h>		for getpwnam() or getpwuid()
+ *	<string.h>	for strtok()
+ *	<time.h>	for asctime(), ctime(), localtime(), or gmtime()
+ *	<unistd.h>	for getlogin() or ttyname()
+ * or their thread-safe analogs.
+ *
+ * If you are on a platform that defines XTHREADS but does not have
+ * MT-safe system API (e.g. UnixWare) you must define _Xos_processLock
+ * and _Xos_processUnlock macros before including this header.
+ *
+ * For convenience XOS_USE_XLIB_LOCKING or XOS_USE_XT_LOCKING may be defined
+ * to obtain either Xlib-only or Xt-based versions of these macros.  These
+ * macros won't result in truly thread-safe calls, but they are better than
+ * nothing.  If you do not want locking in this situation define
+ * XOS_USE_NO_LOCKING.
+ *
+ * NOTE: On systems lacking appropriate _r functions Gethostbyname(),
+ *	Gethostbyaddr(), and Getservbyname() do NOT copy the host or
+ *	protocol lists!
+ *
+ * NOTE: On systems lacking appropriate _r functions Getgrgid() and
+ *	Getgrnam() do NOT copy the list of group members!
+ *
+ * This header is nominally intended to simplify porting X11, Motif, and
+ * CDE; it may be useful to other people too.  The structure below is
+ * complicated, mostly because P1003.1c (the IEEE POSIX Threads spec)
+ * went through lots of drafts, and some vendors shipped systems based
+ * on draft API that were changed later.  Unfortunately POSIX did not
+ * provide a feature-test macro for distinguishing each of the drafts.
+ */
+
+/*
+ * This header has several parts.  Search for "Effective prototypes"
+ * to locate the beginning of a section.
+ */
+
+/* This header can be included multiple times with different defines! */
+#ifndef _XOS_R_H_
+# define _XOS_R_H_
+
+# include <X11/Xos.h>
+# include <X11/Xfuncs.h>
+
+# ifndef X_NOT_POSIX
+#  ifdef _POSIX_SOURCE
+#   include <limits.h>
+#  else
+#   define _POSIX_SOURCE
+#   include <limits.h>
+#   undef _POSIX_SOURCE
+#  endif
+#  ifndef LINE_MAX
+#   define X_LINE_MAX 2048
+#  else
+#   define X_LINE_MAX LINE_MAX
+#  endif
+# endif
+#endif /* _XOS_R_H */
+
+#ifndef WIN32
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+# if defined(XOS_USE_XLIB_LOCKING)
+#  ifndef XAllocIDs /* Xlibint.h does not have multiple include protection */
+typedef struct _LockInfoRec *LockInfoPtr;
+extern LockInfoPtr _Xglobal_lock;
+#  endif
+#  ifndef _Xos_isThreadInitialized
+#   define _Xos_isThreadInitialized	(_Xglobal_lock)
+#  endif
+#  if defined(XTHREADS_WARN) || defined(XTHREADS_FILE_LINE)
+#   ifndef XAllocIDs /* Xlibint.h does not have multiple include protection */
+#    include <X11/Xfuncproto.h>	/* for NeedFunctionPrototypes */
+extern void (*_XLockMutex_fn)(
+#    if NeedFunctionPrototypes
+    LockInfoPtr	/* lock */, char * /* file */, int /* line */
+#    endif
+);
+extern void (*_XUnlockMutex_fn)(
+#    if NeedFunctionPrototypes
+    LockInfoPtr	/* lock */, char * /* file */, int /* line */
+#    endif
+);
+#   endif
+#   ifndef _Xos_processLock
+#    define _Xos_processLock	\
+  (_XLockMutex_fn ? (*_XLockMutex_fn)(_Xglobal_lock,__FILE__,__LINE__) : 0)
+#   endif
+#   ifndef _Xos_processUnlock
+#    define _Xos_processUnlock	\
+  (_XUnlockMutex_fn ? (*_XUnlockMutex_fn)(_Xglobal_lock,__FILE__,__LINE__) : 0)
+#   endif
+#  else
+#   ifndef XAllocIDs /* Xlibint.h does not have multiple include protection */
+#    include <X11/Xfuncproto.h>	/* for NeedFunctionPrototypes */
+extern void (*_XLockMutex_fn)(
+#    if NeedFunctionPrototypes
+    LockInfoPtr	/* lock */
+#    endif
+);
+extern void (*_XUnlockMutex_fn)(
+#    if NeedFunctionPrototypes
+    LockInfoPtr	/* lock */
+#    endif
+);
+#   endif
+#   ifndef _Xos_processLock
+#    define _Xos_processLock	\
+  (_XLockMutex_fn ? ((*_XLockMutex_fn)(_Xglobal_lock), 0) : 0)
+#   endif
+#   ifndef _Xos_processUnlock
+#    define _Xos_processUnlock	\
+  (_XUnlockMutex_fn ? ((*_XUnlockMutex_fn)(_Xglobal_lock), 0) : 0)
+#   endif
+#  endif
+# elif defined(XOS_USE_XT_LOCKING)
+#  ifndef _XtThreadsI_h
+extern void (*_XtProcessLock)(void);
+#  endif
+#  ifndef _XtintrinsicP_h
+#   include <X11/Xfuncproto.h>	/* for NeedFunctionPrototypes */
+extern void XtProcessLock(
+#   if NeedFunctionPrototypes
+    void
+#   endif
+);
+extern void XtProcessUnlock(
+#   if NeedFunctionPrototypes
+    void
+#   endif
+);
+#  endif
+#  ifndef _Xos_isThreadInitialized
+#   define _Xos_isThreadInitialized	_XtProcessLock
+#  endif
+#  ifndef _Xos_processLock
+#   define _Xos_processLock		XtProcessLock()
+#  endif
+#  ifndef _Xos_processUnlock
+#   define _Xos_processUnlock		XtProcessUnlock()
+#  endif
+# elif defined(XOS_USE_NO_LOCKING)
+#  ifndef _Xos_isThreadInitialized
+#   define _Xos_isThreadInitialized	0
+#  endif
+#  ifndef _Xos_processLock
+#   define _Xos_processLock		0
+#  endif
+#  ifndef _Xos_processUnlock
+#   define _Xos_processUnlock		0
+#  endif
+# endif
+
+#endif /* !defined WIN32 */
+
+/*
+ * Solaris defines the POSIX thread-safe feature test macro, but
+ * uses the older SVR4 thread-safe functions unless the POSIX ones
+ * are specifically requested.  Fix the feature test macro.
+ */
+#if defined(__sun) && defined(_POSIX_THREAD_SAFE_FUNCTIONS) && \
+	(_POSIX_C_SOURCE - 0 < 199506L) && !defined(_POSIX_PTHREAD_SEMANTICS)
+# undef _POSIX_THREAD_SAFE_FUNCTIONS
+#endif
+
+/***** <pwd.h> wrappers *****/
+
+/*
+ * Effective prototypes for <pwd.h> wrappers:
+ *
+ * #define X_INCLUDE_PWD_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xgetpwparams;
+ *
+ * struct passwd* _XGetpwnam(const char *name, _Xgetpwparams);
+ * struct passwd* _XGetpwuid(uid_t uid, _Xgetpwparams);
+ */
+
+#if defined(X_INCLUDE_PWD_H) && !defined(_XOS_INCLUDED_PWD_H)
+# include <pwd.h>
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_PWDAPI)
+#  define XOS_USE_MTSAFE_PWDAPI 1
+# endif
+#endif
+
+#undef X_NEEDS_PWPARAMS
+#if !defined(X_INCLUDE_PWD_H) || defined(_XOS_INCLUDED_PWD_H)
+/* Do nothing */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+# if defined(X_NOT_POSIX) && !defined(__i386__) && !defined(SYSV)
+extern struct passwd *getpwuid(), *getpwnam();
+# endif
+typedef int _Xgetpwparams;	/* dummy */
+# define _XGetpwuid(u,p)	getpwuid((u))
+# define _XGetpwnam(u,p)	getpwnam((u))
+
+#elif !defined(XOS_USE_MTSAFE_PWDAPI) || defined(XNO_MTSAFE_PWDAPI)
+/* UnixWare 2.0, or other systems with thread support but no _r API. */
+# define X_NEEDS_PWPARAMS
+typedef struct {
+  struct passwd pws;
+  char   pwbuf[1024];
+  struct passwd* pwp;
+  size_t len;
+} _Xgetpwparams;
+
+/*
+ * NetBSD and FreeBSD, at least, are missing several of the unixware passwd
+ * fields.
+ */
+
+#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__OpenBSD__) || \
+    defined(__APPLE__) || defined(__DragonFly__)
+static __inline__ void _Xpw_copyPasswd(_Xgetpwparams p)
+{
+   memcpy(&(p).pws, (p).pwp, sizeof(struct passwd));
+
+   (p).pws.pw_name = (p).pwbuf;
+   (p).len = strlen((p).pwp->pw_name);
+   strcpy((p).pws.pw_name, (p).pwp->pw_name);
+
+   (p).pws.pw_passwd = (p).pws.pw_name + (p).len + 1;
+   (p).len = strlen((p).pwp->pw_passwd);
+   strcpy((p).pws.pw_passwd,(p).pwp->pw_passwd);
+
+   (p).pws.pw_class = (p).pws.pw_passwd + (p).len + 1;
+   (p).len = strlen((p).pwp->pw_class);
+   strcpy((p).pws.pw_class, (p).pwp->pw_class);
+
+   (p).pws.pw_gecos = (p).pws.pw_class + (p).len + 1;
+   (p).len = strlen((p).pwp->pw_gecos);
+   strcpy((p).pws.pw_gecos, (p).pwp->pw_gecos);
+
+   (p).pws.pw_dir = (p).pws.pw_gecos + (p).len + 1;
+   (p).len = strlen((p).pwp->pw_dir);
+   strcpy((p).pws.pw_dir, (p).pwp->pw_dir);
+
+   (p).pws.pw_shell = (p).pws.pw_dir + (p).len + 1;
+   (p).len = strlen((p).pwp->pw_shell);
+   strcpy((p).pws.pw_shell, (p).pwp->pw_shell);
+
+   (p).pwp = &(p).pws;
+}
+
+#else
+# define _Xpw_copyPasswd(p) \
+   (memcpy(&(p).pws, (p).pwp, sizeof(struct passwd)), \
+    ((p).pws.pw_name = (p).pwbuf), \
+    ((p).len = strlen((p).pwp->pw_name)), \
+    strcpy((p).pws.pw_name, (p).pwp->pw_name), \
+    ((p).pws.pw_passwd = (p).pws.pw_name + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_passwd)), \
+    strcpy((p).pws.pw_passwd,(p).pwp->pw_passwd), \
+    ((p).pws.pw_age = (p).pws.pw_passwd + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_age)), \
+    strcpy((p).pws.pw_age, (p).pwp->pw_age), \
+    ((p).pws.pw_comment = (p).pws.pw_age + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_comment)), \
+    strcpy((p).pws.pw_comment, (p).pwp->pw_comment), \
+    ((p).pws.pw_gecos = (p).pws.pw_comment + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_gecos)), \
+    strcpy((p).pws.pw_gecos, (p).pwp->pw_gecos), \
+    ((p).pws.pw_dir = (p).pws.pw_comment + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_dir)), \
+    strcpy((p).pws.pw_dir, (p).pwp->pw_dir), \
+    ((p).pws.pw_shell = (p).pws.pw_dir + (p).len + 1), \
+    ((p).len = strlen((p).pwp->pw_shell)), \
+    strcpy((p).pws.pw_shell, (p).pwp->pw_shell), \
+    ((p).pwp = &(p).pws), \
+    0 )
+#endif
+# define _XGetpwuid(u,p) \
+( (_Xos_processLock), \
+  (((p).pwp = getpwuid((u))) ? _Xpw_copyPasswd(p), 0 : 0), \
+  (_Xos_processUnlock), \
+  (p).pwp )
+# define _XGetpwnam(u,p) \
+( (_Xos_processLock), \
+  (((p).pwp = getpwnam((u))) ? _Xpw_copyPasswd(p), 0 : 0), \
+  (_Xos_processUnlock), \
+  (p).pwp )
+
+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && !defined(__APPLE__)
+# define X_NEEDS_PWPARAMS
+typedef struct {
+  struct passwd pws;
+  char pwbuf[X_LINE_MAX];
+} _Xgetpwparams;
+# if defined(_POSIX_REENTRANT_FUNCTIONS) || !defined(SVR4)
+#   define _XGetpwuid(u,p) \
+((getpwuid_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf)) == -1) ? NULL : &(p).pws)
+#   define _XGetpwnam(u,p) \
+((getpwnam_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf)) == -1) ? NULL : &(p).pws)
+# else /* SVR4 */
+#  define _XGetpwuid(u,p) \
+((getpwuid_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf)) == NULL) ? NULL : &(p).pws)
+#  define _XGetpwnam(u,p) \
+((getpwnam_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf)) == NULL) ? NULL : &(p).pws)
+# endif /* SVR4 */
+
+#else /* _POSIX_THREAD_SAFE_FUNCTIONS */
+# define X_NEEDS_PWPARAMS
+typedef struct {
+  struct passwd pws;
+  char pwbuf[X_LINE_MAX];
+  struct passwd* pwp;
+} _Xgetpwparams;
+typedef int _Xgetpwret;
+# define _XGetpwuid(u,p) \
+((getpwuid_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf),&(p).pwp) == 0) ? \
+ (p).pwp : NULL)
+# define _XGetpwnam(u,p) \
+((getpwnam_r((u),&(p).pws,(p).pwbuf,sizeof((p).pwbuf),&(p).pwp) == 0) ? \
+ (p).pwp : NULL)
+#endif /* X_INCLUDE_PWD_H */
+
+#if defined(X_INCLUDE_PWD_H) && !defined(_XOS_INCLUDED_PWD_H)
+# define _XOS_INCLUDED_PWD_H
+#endif
+
+
+/***** <netdb.h> wrappers *****/
+
+/*
+ * Effective prototypes for <netdb.h> wrappers:
+ *
+ * NOTE: On systems lacking the appropriate _r functions Gethostbyname(),
+ *	Gethostbyaddr(), and Getservbyname() do NOT copy the host or
+ *	protocol lists!
+ *
+ * #define X_INCLUDE_NETDB_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xgethostbynameparams;
+ * typedef ... _Xgetservbynameparams;
+ *
+ * struct hostent* _XGethostbyname(const char* name,_Xgethostbynameparams);
+ * struct hostent* _XGethostbyaddr(const char* addr, int len, int type,
+ *				   _Xgethostbynameparams);
+ * struct servent* _XGetservbyname(const char* name, const char* proto,
+ *				 _Xgetservbynameparams);
+ */
+
+#undef XTHREADS_NEEDS_BYNAMEPARAMS
+#if defined(X_INCLUDE_NETDB_H) && !defined(_XOS_INCLUDED_NETDB_H) \
+    && !defined(WIN32)
+# include <netdb.h>
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_NETDBAPI)
+#  define XOS_USE_MTSAFE_NETDBAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_NETDB_H) || defined(_XOS_INCLUDED_NETDB_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xgethostbynameparams; /* dummy */
+typedef int _Xgetservbynameparams; /* dummy */
+# define _XGethostbyname(h,hp)		gethostbyname((h))
+# define _XGethostbyaddr(a,al,t,hp)	gethostbyaddr((a),(al),(t))
+# define _XGetservbyname(s,p,sp)	getservbyname((s),(p))
+
+#elif !defined(XOS_USE_MTSAFE_NETDBAPI) || defined(XNO_MTSAFE_NETDBAPI)
+/* WARNING:  The h_addr_list and s_aliases values are *not* copied! */
+
+#if defined(__NetBSD__) || defined(__FreeBSD__) || defined(__DragonFly__)
+#include <sys/param.h>
+#endif
+
+typedef struct {
+  struct hostent hent;
+  char           h_name[MAXHOSTNAMELEN];
+  struct hostent *hptr;
+} _Xgethostbynameparams;
+typedef struct {
+  struct servent sent;
+  char           s_name[255];
+  char		 s_proto[255];
+  struct servent *sptr;
+} _Xgetservbynameparams;
+
+# define XTHREADS_NEEDS_BYNAMEPARAMS
+
+# define _Xg_copyHostent(hp) \
+   (memcpy(&(hp).hent, (hp).hptr, sizeof(struct hostent)), \
+    strcpy((hp).h_name, (hp).hptr->h_name), \
+    ((hp).hent.h_name = (hp).h_name), \
+    ((hp).hptr = &(hp).hent), \
+     0 )
+# define _Xg_copyServent(sp) \
+   (memcpy(&(sp).sent, (sp).sptr, sizeof(struct servent)), \
+    strcpy((sp).s_name, (sp).sptr->s_name), \
+    ((sp).sent.s_name = (sp).s_name), \
+    strcpy((sp).s_proto, (sp).sptr->s_proto), \
+    ((sp).sent.s_proto = (sp).s_proto), \
+    ((sp).sptr = &(sp).sent), \
+    0 )
+# define _XGethostbyname(h,hp) \
+   ((_Xos_processLock), \
+    (((hp).hptr = gethostbyname((h))) ? _Xg_copyHostent(hp) : 0), \
+    (_Xos_processUnlock), \
+    (hp).hptr )
+# define _XGethostbyaddr(a,al,t,hp) \
+   ((_Xos_processLock), \
+    (((hp).hptr = gethostbyaddr((a),(al),(t))) ? _Xg_copyHostent(hp) : 0), \
+    (_Xos_processUnlock), \
+    (hp).hptr )
+# define _XGetservbyname(s,p,sp) \
+   ((_Xos_processLock), \
+    (((sp).sptr = getservbyname((s),(p))) ? _Xg_copyServent(sp) : 0), \
+    (_Xos_processUnlock), \
+    (sp).sptr )
+
+#elif defined(XUSE_NETDB_R_API)
+/*
+ * POSIX does not specify _r equivalents for <netdb.h> API, but some
+ * vendors provide them anyway.  Use them only when explicitly asked.
+ */
+# ifdef _POSIX_REENTRANT_FUNCTIONS
+#  ifndef _POSIX_THREAD_SAFE_FUNCTIONS
+#  endif
+# endif
+# ifdef _POSIX_THREAD_SAFE_FUNCTIONS
+#  define X_POSIX_THREAD_SAFE_FUNCTIONS 1
+# endif
+
+# define XTHREADS_NEEDS_BYNAMEPARAMS
+
+# ifndef X_POSIX_THREAD_SAFE_FUNCTIONS
+typedef struct {
+    struct hostent      hent;
+    char                hbuf[X_LINE_MAX];
+    int                 herr;
+} _Xgethostbynameparams;
+typedef struct {
+    struct servent      sent;
+    char                sbuf[X_LINE_MAX];
+} _Xgetservbynameparams;
+#  define _XGethostbyname(h,hp) \
+  gethostbyname_r((h),&(hp).hent,(hp).hbuf,sizeof((hp).hbuf),&(hp).herr)
+#  define _XGethostbyaddr(a,al,t,hp) \
+  gethostbyaddr_r((a),(al),(t),&(hp).hent,(hp).hbuf,sizeof((hp).hbuf),&(hp).herr)
+#  define _XGetservbyname(s,p,sp) \
+  getservbyname_r((s),(p),&(sp).sent,(sp).sbuf,sizeof((sp).sbuf))
+# else
+typedef struct {
+  struct hostent      hent;
+  struct hostent_data hdata;
+} _Xgethostbynameparams;
+typedef struct {
+  struct servent      sent;
+  struct servent_data sdata;
+} _Xgetservbynameparams;
+#  define _XGethostbyname(h,hp) \
+  (bzero((char*)&(hp).hdata,sizeof((hp).hdata)),	\
+   ((gethostbyname_r((h),&(hp).hent,&(hp).hdata) == -1) ? NULL : &(hp).hent))
+#  define _XGethostbyaddr(a,al,t,hp) \
+  (bzero((char*)&(hp).hdata,sizeof((hp).hdata)),	\
+   ((gethostbyaddr_r((a),(al),(t),&(hp).hent,&(hp).hdata) == -1) ? NULL : &(hp).hent))
+#  define _XGetservbyname(s,p,sp) \
+  (bzero((char*)&(sp).sdata,sizeof((sp).sdata)),	\
+   ((getservbyname_r((s),(p),&(sp).sent,&(sp).sdata) == -1) ? NULL : &(sp).sent) )
+# endif
+# ifdef X_POSIX_THREAD_SAFE_FUNCTIONS
+#  undef X_POSIX_THREAD_SAFE_FUNCTIONS
+# endif
+
+#else
+/* The regular API is assumed to be MT-safe under POSIX. */
+typedef int _Xgethostbynameparams; /* dummy */
+typedef int _Xgetservbynameparams; /* dummy */
+# define _XGethostbyname(h,hp)		gethostbyname((h))
+# define _XGethostbyaddr(a,al,t,hp)	gethostbyaddr((a),(al),(t))
+# define _XGetservbyname(s,p,sp)	getservbyname((s),(p))
+#endif /* X_INCLUDE_NETDB_H */
+
+#if defined(X_INCLUDE_NETDB_H) && !defined(_XOS_INCLUDED_NETDB_H)
+# define _XOS_INCLUDED_NETDB_H
+#endif
+
+
+/***** <dirent.h> wrappers *****/
+
+/*
+ * Effective prototypes for <dirent.h> wrappers:
+ *
+ * #define X_INCLUDE_DIRENT_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xreaddirparams;
+ *
+ * struct dirent *_XReaddir(DIR *dir_pointer, _Xreaddirparams);
+ */
+
+#if defined(X_INCLUDE_DIRENT_H) && !defined(_XOS_INCLUDED_DIRENT_H)
+# include <sys/types.h>
+# if !defined(X_NOT_POSIX) || defined(SYSV)
+#  include <dirent.h>
+# else
+#  include <sys/dir.h>
+#  ifndef dirent
+#   define dirent direct
+#  endif
+# endif
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_DIRENTAPI)
+#  define XOS_USE_MTSAFE_DIRENTAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_DIRENT_H) || defined(_XOS_INCLUDED_DIRENT_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xreaddirparams;	/* dummy */
+# define _XReaddir(d,p)	readdir(d)
+
+#elif !defined(XOS_USE_MTSAFE_DIRENTAPI) || defined(XNO_MTSAFE_DIRENTAPI)
+/* Systems with thread support but no _r API. */
+typedef struct {
+  struct dirent *result;
+  struct dirent dir_entry;
+# ifdef _POSIX_PATH_MAX
+  char buf[_POSIX_PATH_MAX];
+# elif defined(NAME_MAX)
+  char buf[NAME_MAX];
+# else
+  char buf[255];
+# endif
+} _Xreaddirparams;
+
+# define _XReaddir(d,p)	\
+ ( (_Xos_processLock),						 \
+   (((p).result = readdir((d))) ?				 \
+    (memcpy(&((p).dir_entry), (p).result, (p).result->d_reclen), \
+     ((p).result = &(p).dir_entry), 0) :			 \
+    0),								 \
+   (_Xos_processUnlock),					 \
+   (p).result )
+
+#else
+typedef struct {
+  struct dirent *result;
+  struct dirent dir_entry;
+# ifdef _POSIX_PATH_MAX
+  char buf[_POSIX_PATH_MAX];
+# elif defined(NAME_MAX)
+  char buf[NAME_MAX];
+# else
+  char buf[255];
+# endif
+} _Xreaddirparams;
+
+# if defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(__APPLE__)
+/* POSIX final API, returns (int)0 on success. */
+#  define _XReaddir(d,p)						\
+    (readdir_r((d), &((p).dir_entry), &((p).result)) ? NULL : (p).result)
+# elif defined(_POSIX_REENTRANT_FUNCTIONS)
+/* POSIX draft API, returns (int)0 on success. */
+#  define _XReaddir(d,p)	\
+    (readdir_r((d),&((p).dir_entry)) ? NULL : &((p).dir_entry))
+# elif defined(SVR4)
+/* Pre-POSIX API, returns non-NULL on success. */
+#  define _XReaddir(d,p)	(readdir_r((d), &(p).dir_entry))
+# else
+/* We have no idea what is going on.  Fake it all using process locks. */
+#  define _XReaddir(d,p)	\
+    ( (_Xos_processLock),						\
+      (((p).result = readdir((d))) ?					\
+       (memcpy(&((p).dir_entry), (p).result, (p).result->d_reclen),	\
+	((p).result = &(p).dir_entry), 0) :				\
+       0),								\
+      (_Xos_processUnlock),						\
+      (p).result )
+# endif
+#endif /* X_INCLUDE_DIRENT_H */
+
+#if defined(X_INCLUDE_DIRENT_H) && !defined(_XOS_INCLUDED_DIRENT_H)
+# define _XOS_INCLUDED_DIRENT_H
+#endif
+
+
+/***** <unistd.h> wrappers *****/
+
+/*
+ * Effective prototypes for <unistd.h> wrappers:
+ *
+ * #define X_INCLUDE_UNISTD_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xgetloginparams;
+ * typedef ... _Xttynameparams;
+ *
+ * char *_XGetlogin(_Xgetloginparams);
+ * char *_XTtyname(int, _Xttynameparams);
+ */
+
+#if defined(X_INCLUDE_UNISTD_H) && !defined(_XOS_INCLUDED_UNISTD_H)
+/* <unistd.h> already included by <X11/Xos.h> */
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_UNISTDAPI)
+#  define XOS_USE_MTSAFE_UNISTDAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_UNISTD_H) || defined(_XOS_INCLUDED_UNISTD_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xgetloginparams;	/* dummy */
+typedef int _Xttynameparams;	/* dummy */
+# define _XGetlogin(p)	getlogin()
+# define _XTtyname(f)	ttyname((f))
+
+#elif !defined(XOS_USE_MTSAFE_UNISTDAPI) || defined(XNO_MTSAFE_UNISTDAPI)
+/* Systems with thread support but no _r API. */
+typedef struct {
+  char *result;
+# if defined(MAXLOGNAME)
+  char buf[MAXLOGNAME];
+# elif defined(LOGIN_NAME_MAX)
+  char buf[LOGIN_NAME_MAX];
+# else
+  char buf[64];
+# endif
+} _Xgetloginparams;
+typedef struct {
+  char *result;
+# ifdef TTY_NAME_MAX
+  char buf[TTY_NAME_MAX];
+# elif defined(_POSIX_TTY_NAME_MAX)
+  char buf[_POSIX_TTY_NAME_MAX];
+# elif defined(_POSIX_PATH_MAX)
+  char buf[_POSIX_PATH_MAX];
+# else
+  char buf[256];
+# endif
+} _Xttynameparams;
+
+# define _XGetlogin(p) \
+ ( (_Xos_processLock), \
+   (((p).result = getlogin()) ? \
+    (strncpy((p).buf, (p).result, sizeof((p).buf)), \
+     ((p).buf[sizeof((p).buf)-1] = '\0'), \
+     ((p).result = (p).buf), 0) : 0), \
+   (_Xos_processUnlock), \
+   (p).result )
+#define _XTtyname(f,p) \
+ ( (_Xos_processLock), \
+   (((p).result = ttyname(f)) ? \
+    (strncpy((p).buf, (p).result, sizeof((p).buf)), \
+     ((p).buf[sizeof((p).buf)-1] = '\0'), \
+     ((p).result = (p).buf), 0) : 0), \
+   (_Xos_processUnlock), \
+   (p).result )
+
+#elif defined(_POSIX_THREAD_SAFE_FUNCTIONS) || defined(_POSIX_REENTRANT_FUNCTIONS)
+/* POSIX API.
+ *
+ * extern int getlogin_r(char *, size_t);
+ * extern int ttyname_r(int, char *, size_t);
+ */
+typedef struct {
+# if defined(MAXLOGNAME)
+  char buf[MAXLOGNAME];
+# elif defined(LOGIN_NAME_MAX)
+  char buf[LOGIN_NAME_MAX];
+# else
+  char buf[64];
+# endif
+} _Xgetloginparams;
+typedef struct {
+# ifdef TTY_NAME_MAX
+  char buf[TTY_NAME_MAX];
+# elif defined(_POSIX_TTY_NAME_MAX)
+  char buf[_POSIX_TTY_NAME_MAX];
+# elif defined(_POSIX_PATH_MAX)
+  char buf[_POSIX_PATH_MAX];
+# else
+  char buf[256];
+# endif
+} _Xttynameparams;
+
+# define _XGetlogin(p)	(getlogin_r((p).buf, sizeof((p).buf)) ? NULL : (p).buf)
+# define _XTtyname(f,p)	\
+	(ttyname_r((f), (p).buf, sizeof((p).buf)) ? NULL : (p).buf)
+
+#else
+/* Pre-POSIX API.
+ *
+ * extern char *getlogin_r(char *, size_t);
+ * extern char *ttyname_r(int, char *, size_t);
+ */
+typedef struct {
+# if defined(MAXLOGNAME)
+  char buf[MAXLOGNAME];
+# elif defined(LOGIN_NAME_MAX)
+  char buf[LOGIN_NAME_MAX];
+# else
+  char buf[64];
+# endif
+} _Xgetloginparams;
+typedef struct {
+# ifdef TTY_NAME_MAX
+  char buf[TTY_NAME_MAX];
+# elif defined(_POSIX_TTY_NAME_MAX)
+  char buf[_POSIX_TTY_NAME_MAX];
+# elif defined(_POSIX_PATH_MAX)
+  char buf[_POSIX_PATH_MAX];
+# else
+  char buf[256];
+# endif
+} _Xttynameparams;
+
+# define _XGetlogin(p)	getlogin_r((p).buf, sizeof((p).buf))
+# define _XTtyname(f,p)	ttyname_r((f), (p).buf, sizeof((p).buf))
+#endif /* X_INCLUDE_UNISTD_H */
+
+#if defined(X_INCLUDE_UNISTD_H) && !defined(_XOS_INCLUDED_UNISTD_H)
+# define _XOS_INCLUDED_UNISTD_H
+#endif
+
+
+/***** <string.h> wrappers *****/
+
+/*
+ * Effective prototypes for <string.h> wrappers:
+ *
+ * #define X_INCLUDE_STRING_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xstrtokparams;
+ *
+ * char *_XStrtok(char *, const char*, _Xstrtokparams);
+ */
+
+#if defined(X_INCLUDE_STRING_H) && !defined(_XOS_INCLUDED_STRING_H)
+/* <string.h> has already been included by <X11/Xos.h> */
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_STRINGAPI)
+#  define XOS_USE_MTSAFE_STRINGAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_STRING_H) || defined(_XOS_INCLUDED_STRING_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xstrtokparams;	/* dummy */
+# define _XStrtok(s1,s2,p) \
+ ( p = 0, (void)p, strtok((s1),(s2)) )
+
+#elif !defined(XOS_USE_MTSAFE_STRINGAPI) || defined(XNO_MTSAFE_STRINGAPI)
+/* Systems with thread support but no _r API. */
+typedef char *_Xstrtokparams;
+# define _XStrtok(s1,s2,p) \
+ ( (_Xos_processLock), \
+   ((p) = strtok((s1),(s2))), \
+   (_Xos_processUnlock), \
+   (p) )
+
+#else
+/* POSIX or pre-POSIX API. */
+typedef char * _Xstrtokparams;
+# define _XStrtok(s1,s2,p)	strtok_r((s1),(s2),&(p))
+#endif /* X_INCLUDE_STRING_H */
+
+
+/***** <time.h> wrappers *****/
+
+/*
+ * Effective prototypes for <time.h> wrappers:
+ *
+ * #define X_INCLUDE_TIME_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xatimeparams;
+ * typedef ... _Xctimeparams;
+ * typedef ... _Xgtimeparams;
+ * typedef ... _Xltimeparams;
+ *
+ * char *_XAsctime(const struct tm *, _Xatimeparams);
+ * char *_XCtime(const time_t *, _Xctimeparams);
+ * struct tm *_XGmtime(const time_t *, _Xgtimeparams);
+ * struct tm *_XLocaltime(const time_t *, _Xltimeparams);
+ */
+
+#if defined(X_INCLUDE_TIME_H) && !defined(_XOS_INCLUDED_TIME_H)
+# include <time.h>
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_TIMEAPI)
+#  define XOS_USE_MTSAFE_TIMEAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_TIME_H) || defined(_XOS_INCLUDED_TIME_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xatimeparams;	/* dummy */
+# define _XAsctime(t,p)		asctime((t))
+typedef int _Xctimeparams;	/* dummy */
+# define _XCtime(t,p)		ctime((t))
+typedef int _Xgtimeparams;	/* dummy */
+# define _XGmtime(t,p)		gmtime((t))
+typedef int _Xltimeparams;	/* dummy */
+# define _XLocaltime(t,p)	localtime((t))
+
+#elif !defined(XOS_USE_MTSAFE_TIMEAPI) || defined(XNO_MTSAFE_TIMEAPI)
+/* Systems with thread support but no _r API. */
+typedef struct {
+# ifdef TIMELEN
+  char buf[TIMELEN];
+# else
+  char buf[26];
+# endif
+  char *result;
+} _Xctimeparams, _Xatimeparams;
+typedef struct {
+  struct tm buf;
+  struct tm *result;
+} _Xgtimeparams, _Xltimeparams;
+# define _XAsctime(t,p) \
+ ( (_Xos_processLock), \
+   (((p).result = asctime((t))) ? \
+    (strncpy((p).buf, (p).result, sizeof((p).buf)), (p).result = &(p).buf) : \
+    0), \
+   (_Xos_processUnlock), \
+   (p).result )
+# define _XCtime(t,p) \
+ ( (_Xos_processLock), \
+   (((p).result = ctime((t))) ? \
+    (strncpy((p).buf, (p).result, sizeof((p).buf)), (p).result = &(p).buf) : \
+    0), \
+   (_Xos_processUnlock), \
+   (p).result )
+# define _XGmtime(t,p) \
+ ( (_Xos_processLock), \
+   (((p).result = gmtime(t)) ? \
+    (memcpy(&(p).buf, (p).result, sizeof((p).buf)), (p).result = &(p).buf) : \
+    0), \
+   (_Xos_processUnlock), \
+   (p).result )
+# define _XLocaltime(t,p) \
+ ( (_Xos_processLock), \
+   (((p).result = localtime(t)) ? \
+    (memcpy(&(p).buf, (p).result, sizeof((p).buf)), (p).result = &(p).buf) : \
+    0), \
+   (_Xos_processUnlock), \
+   (p).result )
+
+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) &&  defined(hpV4)
+/* Returns (int)0 on success.
+ *
+ * extern int asctime_r(const struct tm *timeptr, char *buffer, int buflen);
+ * extern int ctime_r(const time_t *timer, char *buffer, int buflen);
+ * extern int gmtime_r(const time_t *timer, struct tm *result);
+ * extern int localtime_r(const time_t *timer, struct tm *result);
+ */
+# ifdef TIMELEN
+typedef char _Xatimeparams[TIMELEN];
+typedef char _Xctimeparams[TIMELEN];
+# else
+typedef char _Xatimeparams[26];
+typedef char _Xctimeparams[26];
+# endif
+typedef struct tm _Xgtimeparams;
+typedef struct tm _Xltimeparams;
+# define _XAsctime(t,p)		(asctime_r((t),(p),sizeof((p))) ? NULL : (p))
+# define _XCtime(t,p)		(ctime_r((t),(p),sizeof((p))) ? NULL : (p))
+# define _XGmtime(t,p)		(gmtime_r((t),&(p)) ? NULL : &(p))
+# define _XLocaltime(t,p)	(localtime_r((t),&(p)) ? NULL : &(p))
+
+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && defined(__sun)
+/* Returns NULL on failure.  Solaris 2.5
+ *
+ * extern char *asctime_r(const struct tm *tm,char *buf, int buflen);
+ * extern char *ctime_r(const time_t *clock, char *buf, int buflen);
+ * extern struct tm *gmtime_r(const time_t *clock, struct tm *res);
+ * extern struct tm *localtime_r(const time_t *clock, struct tm *res);
+ */
+# ifdef TIMELEN
+typedef char _Xatimeparams[TIMELEN];
+typedef char _Xctimeparams[TIMELEN];
+# else
+typedef char _Xatimeparams[26];
+typedef char _Xctimeparams[26];
+# endif
+typedef struct tm _Xgtimeparams;
+typedef struct tm _Xltimeparams;
+# define _XAsctime(t,p)		asctime_r((t),(p),sizeof((p)))
+# define _XCtime(t,p)		ctime_r((t),(p),sizeof((p)))
+# define _XGmtime(t,p)		gmtime_r((t),&(p))
+# define _XLocaltime(t,p)	localtime_r((t),&(p))
+
+#else /* defined(_POSIX_THREAD_SAFE_FUNCTIONS) */
+/* POSIX final API.
+ * extern char *asctime_r(const struct tm *timeptr, char *buffer);
+ * extern char *ctime_r(const time_t *timer, char *buffer);
+ * extern struct tm *gmtime_r(const time_t *timer, struct tm *result);
+ * extern struct tm *localtime_r(const time_t *timer, struct tm *result);
+ */
+# ifdef TIMELEN
+typedef char _Xatimeparams[TIMELEN];
+typedef char _Xctimeparams[TIMELEN];
+# else
+typedef char _Xatimeparams[26];
+typedef char _Xctimeparams[26];
+# endif
+typedef struct tm _Xgtimeparams;
+typedef struct tm _Xltimeparams;
+# define _XAsctime(t,p)		asctime_r((t),(p))
+# define _XCtime(t,p)		ctime_r((t),(p))
+# define _XGmtime(t,p)		gmtime_r((t),&(p))
+# define _XLocaltime(t,p)	localtime_r((t),&(p))
+#endif /* X_INCLUDE_TIME_H */
+
+#if defined(X_INCLUDE_TIME_H) && !defined(_XOS_INCLUDED_TIME_H)
+# define _XOS_INCLUDED_TIME_H
+#endif
+
+
+/***** <grp.h> wrappers *****/
+
+/*
+ * Effective prototypes for <grp.h> wrappers:
+ *
+ * NOTE: On systems lacking appropriate _r functions Getgrgid() and
+ *	Getgrnam() do NOT copy the list of group members!
+ *
+ * Remember that fgetgrent(), setgrent(), getgrent(), and endgrent()
+ * are not included in POSIX.
+ *
+ * #define X_INCLUDE_GRP_H
+ * #define XOS_USE_..._LOCKING
+ * #include <X11/Xos_r.h>
+ *
+ * typedef ... _Xgetgrparams;
+ *
+ * struct group *_XGetgrgid(gid_t, _Xgetgrparams);
+ * struct group *_XGetgrnam(const char *, _Xgetgrparams);
+ */
+
+#if defined(X_INCLUDE_GRP_H) && !defined(_XOS_INCLUDED_GRP_H)
+# include <grp.h>
+# if defined(XUSE_MTSAFE_API) || defined(XUSE_MTSAFE_GRPAPI)
+#  define XOS_USE_MTSAFE_GRPAPI 1
+# endif
+#endif
+
+#if !defined(X_INCLUDE_GRP_H) || defined(_XOS_INCLUDED_GRP_H)
+/* Do nothing. */
+
+#elif !defined(XTHREADS) && !defined(X_FORCE_USE_MTSAFE_API)
+/* Use regular, unsafe API. */
+typedef int _Xgetgrparams;	/* dummy */
+#define _XGetgrgid(g,p)	getgrgid((g))
+#define _XGetgrnam(n,p)	getgrnam((n))
+
+#elif !defined(XOS_USE_MTSAFE_GRPAPI) || defined(XNO_MTSAFE_GRPAPI)
+/* Systems with thread support but no _r API.  UnixWare 2.0. */
+typedef struct {
+  struct group grp;
+  char buf[X_LINE_MAX];	/* Should be sysconf(_SC_GETGR_R_SIZE_MAX)? */
+  struct group *pgrp;
+  size_t len;
+} _Xgetgrparams;
+#ifdef SVR4
+/* Copy the gr_passwd field too. */
+# define _Xgrp_copyGroup(p) \
+ ( memcpy(&(p).grp, (p).pgrp, sizeof(struct group)), \
+   ((p).grp.gr_name = (p).buf), \
+   ((p).len = strlen((p).pgrp->gr_name)), \
+   strcpy((p).grp.gr_name, (p).pgrp->gr_name), \
+   ((p).grp.gr_passwd = (p).grp.gr_name + (p).len + 1), \
+   ((p).pgrp = &(p).grp), \
+   0 )
+#else
+# define _Xgrp_copyGroup(p) \
+ ( memcpy(&(p).grp, (p).pgrp, sizeof(struct group)), \
+   ((p).grp.gr_name = (p).buf), \
+   strcpy((p).grp.gr_name, (p).pgrp->gr_name), \
+   ((p).pgrp = &(p).grp), \
+   0 )
+#endif
+#define _XGetgrgid(g,p) \
+ ( (_Xos_processLock), \
+   (((p).pgrp = getgrgid((g))) ? _Xgrp_copyGroup(p) : 0), \
+   (_Xos_processUnlock), \
+   (p).pgrp )
+#define _XGetgrnam(n,p) \
+ ( (_Xos_processLock), \
+   (((p).pgrp = getgrnam((n))) ? _Xgrp_copyGroup(p) : 0), \
+   (_Xos_processUnlock), \
+   (p).pgrp )
+
+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS) && defined(__sun)
+/* Non-POSIX API.  Solaris.
+ *
+ * extern struct group *getgrgid_r(gid_t, struct group *, char *, int);
+ * extern struct group *getgrnam_r(const char *, struct group *, char *, int);
+ */
+typedef struct {
+  struct group grp;
+  char buf[X_LINE_MAX];	/* Should be sysconf(_SC_GETGR_R_SIZE_MAX)? */
+} _Xgetgrparams;
+#define _XGetgrgid(g,p)	getgrgid_r((g), &(p).grp, (p).buf, sizeof((p).buf))
+#define _XGetgrnam(n,p)	getgrnam_r((n), &(p).grp, (p).buf, sizeof((p).buf))
+
+#elif !defined(_POSIX_THREAD_SAFE_FUNCTIONS)
+/* Non-POSIX API.
+ * extern int getgrgid_r(gid_t, struct group *, char *, int);
+ * extern int getgrnam_r(const char *, struct group *, char *, int);
+ */
+typedef struct {
+  struct group grp;
+  char buf[X_LINE_MAX];	/* Should be sysconf(_SC_GETGR_R_SIZE_MAX)? */
+} _Xgetgrparams;
+#define _XGetgrgid(g,p)	\
+ ((getgrgid_r((g), &(p).grp, (p).buf, sizeof((p).buf)) ? NULL : &(p).grp))
+#define _XGetgrnam(n,p)	\
+ ((getgrnam_r((n), &(p).grp, (p).buf, sizeof((p).buf)) ? NULL : &(p).grp))
+
+#else
+/* POSIX final API.
+ *
+ * int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);
+ * int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);
+ */
+typedef struct {
+  struct group grp;
+  char buf[X_LINE_MAX];	/* Should be sysconf(_SC_GETGR_R_SIZE_MAX)? */
+  struct group *result;
+} _Xgetgrparams;
+
+#define _XGetgrgid(g,p)	\
+ ((getgrgid_r((g), &(p).grp, (p).buf, sizeof((p).buf), &(p).result) ? \
+   NULL : (p).result))
+#define _XGetgrnam(n,p)	\
+ ((getgrnam_r((n), &(p).grp, (p).buf, sizeof((p).buf), &(p).result) ? \
+   NULL : (p).result))
+#endif
+
+#if defined(X_INCLUDE_GRP_H) && !defined(_XOS_INCLUDED_GRP_H)
+# define _XOS_INCLUDED_GRP_H
+#endif
+
+
+#ifdef __cplusplus
+}  /* Close scope of 'extern "C"' declaration which encloses file. */
+#endif
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xproto.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xproto.h
@@ -0,0 +1,2157 @@
+/* Definitions for the X window system used by server and c bindings */
+
+/*
+ * This packet-construction scheme makes the following assumptions:
+ *
+ * 1. The compiler is able
+ * to generate code which addresses one- and two-byte quantities.
+ * In the worst case, this would be done with bit-fields.  If bit-fields
+ * are used it may be necessary to reorder the request fields in this file,
+ * depending on the order in which the machine assigns bit fields to
+ * machine words.  There may also be a problem with sign extension,
+ * as K+R specify that bitfields are always unsigned.
+ *
+ * 2. 2- and 4-byte fields in packet structures must be ordered by hand
+ * such that they are naturally-aligned, so that no compiler will ever
+ * insert padding bytes.
+ *
+ * 3. All packets are hand-padded to a multiple of 4 bytes, for
+ * the same reason.
+ */
+
+#ifndef XPROTO_H
+#define XPROTO_H
+
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#include <X11/Xmd.h>
+#include <X11/Xprotostr.h>
+
+/*
+ * Define constants for the sizes of the network packets.  The sz_ prefix is
+ * used instead of something more descriptive so that the symbols are no more
+ * than 32 characters in length (which causes problems for some compilers).
+ */
+#define sz_xSegment 8
+#define sz_xPoint 4
+#define sz_xRectangle 8
+#define sz_xArc 12
+#define sz_xConnClientPrefix 12
+#define sz_xConnSetupPrefix 8
+#define sz_xConnSetup 32
+#define sz_xPixmapFormat 8
+#define sz_xDepth 8
+#define sz_xVisualType 24
+#define sz_xWindowRoot 40
+#define sz_xTimecoord 8
+#define sz_xHostEntry 4
+#define sz_xCharInfo 12
+#define sz_xFontProp 8
+#define sz_xTextElt 2
+#define sz_xColorItem 12
+#define sz_xrgb 8
+#define sz_xGenericReply 32
+#define sz_xGetWindowAttributesReply 44
+#define sz_xGetGeometryReply 32
+#define sz_xQueryTreeReply 32
+#define sz_xInternAtomReply 32
+#define sz_xGetAtomNameReply 32
+#define sz_xGetPropertyReply 32
+#define sz_xListPropertiesReply 32
+#define sz_xGetSelectionOwnerReply 32
+#define sz_xGrabPointerReply 32
+#define sz_xQueryPointerReply 32
+#define sz_xGetMotionEventsReply 32
+#define sz_xTranslateCoordsReply 32
+#define sz_xGetInputFocusReply 32
+#define sz_xQueryKeymapReply 40
+#define sz_xQueryFontReply 60
+#define sz_xQueryTextExtentsReply 32
+#define sz_xListFontsReply 32
+#define sz_xGetFontPathReply 32
+#define sz_xGetImageReply 32
+#define sz_xListInstalledColormapsReply 32
+#define sz_xAllocColorReply 32
+#define sz_xAllocNamedColorReply 32
+#define sz_xAllocColorCellsReply 32
+#define sz_xAllocColorPlanesReply 32
+#define sz_xQueryColorsReply 32
+#define sz_xLookupColorReply 32
+#define sz_xQueryBestSizeReply 32
+#define sz_xQueryExtensionReply 32
+#define sz_xListExtensionsReply 32
+#define sz_xSetMappingReply 32
+#define sz_xGetKeyboardControlReply 52
+#define sz_xGetPointerControlReply 32
+#define sz_xGetScreenSaverReply 32
+#define sz_xListHostsReply 32
+#define sz_xSetModifierMappingReply 32
+#define sz_xError 32
+#define sz_xEvent 32
+#define sz_xKeymapEvent 32
+#define sz_xReq 4
+#define sz_xResourceReq 8
+#define sz_xCreateWindowReq 32
+#define sz_xChangeWindowAttributesReq 12
+#define sz_xChangeSaveSetReq 8
+#define sz_xReparentWindowReq 16
+#define sz_xConfigureWindowReq 12
+#define sz_xCirculateWindowReq 8
+#define sz_xInternAtomReq 8
+#define sz_xChangePropertyReq 24
+#define sz_xDeletePropertyReq 12
+#define sz_xGetPropertyReq 24
+#define sz_xSetSelectionOwnerReq 16
+#define sz_xConvertSelectionReq 24
+#define sz_xSendEventReq 44
+#define sz_xGrabPointerReq 24
+#define sz_xGrabButtonReq 24
+#define sz_xUngrabButtonReq 12
+#define sz_xChangeActivePointerGrabReq 16
+#define sz_xGrabKeyboardReq 16
+#define sz_xGrabKeyReq 16
+#define sz_xUngrabKeyReq 12
+#define sz_xAllowEventsReq 8
+#define sz_xGetMotionEventsReq 16
+#define sz_xTranslateCoordsReq 16
+#define sz_xWarpPointerReq 24
+#define sz_xSetInputFocusReq 12
+#define sz_xOpenFontReq 12
+#define sz_xQueryTextExtentsReq 8
+#define sz_xListFontsReq 8
+#define sz_xSetFontPathReq 8
+#define sz_xCreatePixmapReq 16
+#define sz_xCreateGCReq 16
+#define sz_xChangeGCReq 12
+#define sz_xCopyGCReq 16
+#define sz_xSetDashesReq 12
+#define sz_xSetClipRectanglesReq 12
+#define sz_xCopyAreaReq 28
+#define sz_xCopyPlaneReq 32
+#define sz_xPolyPointReq 12
+#define sz_xPolySegmentReq 12
+#define sz_xFillPolyReq 16
+#define sz_xPutImageReq 24
+#define sz_xGetImageReq 20
+#define sz_xPolyTextReq 16
+#define sz_xImageTextReq 16
+#define sz_xCreateColormapReq 16
+#define sz_xCopyColormapAndFreeReq 12
+#define sz_xAllocColorReq 16
+#define sz_xAllocNamedColorReq 12
+#define sz_xAllocColorCellsReq 12
+#define sz_xAllocColorPlanesReq 16
+#define sz_xFreeColorsReq 12
+#define sz_xStoreColorsReq 8
+#define sz_xStoreNamedColorReq 16
+#define sz_xQueryColorsReq 8
+#define sz_xLookupColorReq 12
+#define sz_xCreateCursorReq 32
+#define sz_xCreateGlyphCursorReq 32
+#define sz_xRecolorCursorReq 20
+#define sz_xQueryBestSizeReq 12
+#define sz_xQueryExtensionReq 8
+#define sz_xChangeKeyboardControlReq 8
+#define sz_xBellReq 4
+#define sz_xChangePointerControlReq 12
+#define sz_xSetScreenSaverReq 12
+#define sz_xChangeHostsReq 8
+#define sz_xListHostsReq 4
+#define sz_xChangeModeReq 4
+#define sz_xRotatePropertiesReq 12
+#define sz_xReply 32
+#define sz_xGrabKeyboardReply 32
+#define sz_xListFontsWithInfoReply 60
+#define sz_xSetPointerMappingReply 32
+#define sz_xGetKeyboardMappingReply 32
+#define sz_xGetPointerMappingReply 32
+#define sz_xGetModifierMappingReply 32
+#define sz_xListFontsWithInfoReq 8
+#define sz_xPolyLineReq 12
+#define sz_xPolyArcReq 12
+#define sz_xPolyRectangleReq 12
+#define sz_xPolyFillRectangleReq 12
+#define sz_xPolyFillArcReq 12
+#define sz_xPolyText8Req 16
+#define sz_xPolyText16Req 16
+#define sz_xImageText8Req 16
+#define sz_xImageText16Req 16
+#define sz_xSetPointerMappingReq 4
+#define sz_xForceScreenSaverReq 4
+#define sz_xSetCloseDownModeReq 4
+#define sz_xClearAreaReq 16
+#define sz_xSetAccessControlReq 4
+#define sz_xGetKeyboardMappingReq 8
+#define sz_xSetModifierMappingReq 4
+#define sz_xPropIconSize 24
+#define sz_xChangeKeyboardMappingReq 8
+
+
+/* For the purpose of the structure definitions in this file,
+we must redefine the following types in terms of Xmd.h's types, which may
+include bit fields.  All of these are #undef'd at the end of this file,
+restoring the definitions in X.h.  */
+
+#define Window CARD32
+#define Drawable CARD32
+#define Font CARD32
+#define Pixmap CARD32
+#define Cursor CARD32
+#define Colormap CARD32
+#define GContext CARD32
+#define Atom CARD32
+#define VisualID CARD32
+#define Time CARD32
+#define KeyCode CARD8
+#define KeySym CARD32
+
+#define X_TCP_PORT 6000     /* add display number */
+
+#define xTrue        1
+#define xFalse       0
+
+
+typedef CARD16 KeyButMask;
+
+/***************** 
+   connection setup structure.  This is followed by
+   numRoots xWindowRoot structs.
+*****************/
+
+typedef struct {
+    CARD8	byteOrder;
+    BYTE	pad;
+    CARD16	majorVersion B16, minorVersion B16;
+    CARD16	nbytesAuthProto B16;	/* Authorization protocol */
+    CARD16	nbytesAuthString B16;	/* Authorization string */
+    CARD16	pad2 B16;
+} xConnClientPrefix;
+
+typedef struct {
+    CARD8          success;
+    BYTE           lengthReason; /*num bytes in string following if failure */
+    CARD16         majorVersion B16, 
+                   minorVersion B16;
+    CARD16         length B16;  /* 1/4 additional bytes in setup info */
+} xConnSetupPrefix;
+
+
+typedef struct {
+    CARD32         release B32;
+    CARD32         ridBase B32, 
+                   ridMask B32;
+    CARD32         motionBufferSize B32;
+    CARD16         nbytesVendor B16;  /* number of bytes in vendor string */
+    CARD16         maxRequestSize B16;
+    CARD8          numRoots;          /* number of roots structs to follow */
+    CARD8          numFormats;        /* number of pixmap formats */
+    CARD8          imageByteOrder;        /* LSBFirst, MSBFirst */
+    CARD8          bitmapBitOrder;        /* LeastSignificant, MostSign...*/
+    CARD8          bitmapScanlineUnit,     /* 8, 16, 32 */
+                   bitmapScanlinePad;     /* 8, 16, 32 */
+    KeyCode	   minKeyCode, maxKeyCode;
+    CARD32	   pad2 B32;
+} xConnSetup;
+
+typedef struct {
+    CARD8          depth;
+    CARD8          bitsPerPixel;
+    CARD8          scanLinePad;
+    CARD8          pad1;
+    CARD32	   pad2 B32;
+} xPixmapFormat;
+
+/* window root */
+
+typedef struct {
+    CARD8 	depth;
+    CARD8 	pad1;
+    CARD16	nVisuals B16;  /* number of xVisualType structures following */
+    CARD32	pad2 B32;
+    } xDepth;
+
+typedef struct {
+    VisualID visualID B32;
+#if defined(__cplusplus) || defined(c_plusplus)
+    CARD8 c_class;
+#else
+    CARD8 class;
+#endif
+    CARD8 bitsPerRGB;
+    CARD16 colormapEntries B16;
+    CARD32 redMask B32, greenMask B32, blueMask B32;
+    CARD32 pad B32;
+    } xVisualType;
+
+typedef struct {
+    Window         windowId B32;
+    Colormap       defaultColormap B32;
+    CARD32         whitePixel B32, blackPixel B32;
+    CARD32         currentInputMask B32;   
+    CARD16         pixWidth B16, pixHeight B16;
+    CARD16         mmWidth B16, mmHeight B16;
+    CARD16         minInstalledMaps B16, maxInstalledMaps B16;
+    VisualID       rootVisualID B32;
+    CARD8          backingStore;
+    BOOL           saveUnders;
+    CARD8          rootDepth;
+    CARD8          nDepths;  /* number of xDepth structures following */
+} xWindowRoot;
+
+
+/*****************************************************************
+ * Structure Defns
+ *   Structures needed for replies 
+ *****************************************************************/
+
+/* Used in GetMotionEvents */
+
+typedef struct {
+    CARD32 time B32;
+    INT16 x B16, y B16;
+} xTimecoord;
+
+typedef struct {
+    CARD8 family;
+    BYTE pad;
+    CARD16 length B16;
+} xHostEntry;
+
+typedef struct {
+    INT16 leftSideBearing B16,
+	  rightSideBearing B16,
+	  characterWidth B16,
+	  ascent B16,
+	  descent B16;
+    CARD16 attributes B16;
+} xCharInfo;
+
+typedef struct {
+    Atom name B32;
+    CARD32 value B32;
+} xFontProp;
+
+/*
+ * non-aligned big-endian font ID follows this struct
+ */
+typedef struct {           /* followed by string */
+    CARD8 len;	/* number of *characters* in string, or FontChange (255)
+		   for font change, or 0 if just delta given */
+    INT8 delta;
+} xTextElt;
+
+
+typedef struct {        
+    CARD32 pixel B32;
+    CARD16 red B16, green B16, blue B16;
+    CARD8 flags;  /* DoRed, DoGreen, DoBlue booleans */
+    CARD8 pad;
+} xColorItem;
+
+
+typedef struct {
+    CARD16 red B16, green B16, blue B16, pad B16;
+} xrgb;
+
+typedef CARD8 KEYCODE;
+
+
+/*****************
+ * XRep:
+ *    meant to be 32 byte quantity 
+ *****************/
+
+/* GenericReply is the common format of all replies.  The "data" items
+   are specific to each individual reply type. */
+
+typedef struct {	
+    BYTE type;              /* X_Reply */
+    BYTE data1;             /* depends on reply type */
+    CARD16 sequenceNumber B16;  /* of last request received by server */
+    CARD32 length B32;      /* 4 byte quantities beyond size of GenericReply */
+    CARD32 data00 B32;
+    CARD32 data01 B32;
+    CARD32 data02 B32;
+    CARD32 data03 B32;
+    CARD32 data04 B32;
+    CARD32 data05 B32;
+    } xGenericReply;
+
+/* Individual reply formats. */
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 backingStore;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;	/* NOT 0; this is an extra-large reply */
+    VisualID visualID B32;
+#if defined(__cplusplus) || defined(c_plusplus)
+    CARD16 c_class B16;
+#else
+    CARD16 class B16;
+#endif
+    CARD8 bitGravity;
+    CARD8 winGravity;
+    CARD32 backingBitPlanes B32;
+    CARD32 backingPixel B32;
+    BOOL saveUnder;
+    BOOL mapInstalled;
+    CARD8 mapState;
+    BOOL override;
+    Colormap colormap B32;
+    CARD32 allEventMasks B32;
+    CARD32 yourEventMask B32;
+    CARD16 doNotPropagateMask B16;
+    CARD16 pad B16;
+    } xGetWindowAttributesReply;
+
+typedef struct {
+    BYTE type;   /* X_Reply */
+    CARD8 depth;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    Window root B32;
+    INT16 x B16, y B16;
+    CARD16 width B16, height B16;
+    CARD16 borderWidth B16;
+    CARD16 pad1 B16;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    } xGetGeometryReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    Window root B32, parent B32;
+    CARD16 nChildren B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    } xQueryTreeReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32; /* 0 */
+    Atom atom B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xInternAtomReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* of additional bytes */
+    CARD16 nameLength B16;  /* # of characters in name */
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xGetAtomNameReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 format;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32; /* of additional bytes */
+    Atom propertyType B32;
+    CARD32 bytesAfter B32;
+    CARD32 nItems B32; /* # of 8, 16, or 32-bit entities in reply */
+    CARD32 pad1 B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    } xGetPropertyReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nProperties B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xListPropertiesReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    Window owner B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xGetSelectionOwnerReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE status;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD32 pad1 B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xGrabPointerReply;
+
+typedef xGrabPointerReply xGrabKeyboardReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BOOL sameScreen;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    Window root B32, child B32;
+    INT16 rootX B16, rootY B16, winX B16, winY B16;
+    CARD16 mask B16;
+    CARD16 pad1 B16;
+    CARD32 pad B32;
+    } xQueryPointerReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 nEvents B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xGetMotionEventsReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BOOL sameScreen;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32; /* 0 */
+    Window child B32;
+    INT16 dstX B16, dstY B16;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    } xTranslateCoordsReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 revertTo;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    Window focus B32;
+    CARD32 pad1 B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    } xGetInputFocusReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 2, NOT 0; this is an extra-large reply */
+    BYTE map[32];
+    } xQueryKeymapReply;
+
+/* Warning: this MUST match (up to component renaming) xListFontsWithInfoReply */
+typedef struct _xQueryFontReply {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* definitely > 0, even if "nCharInfos" is 0 */
+    xCharInfo minBounds; 
+#ifndef WORD64
+    CARD32 walign1 B32;
+#endif
+    xCharInfo maxBounds; 
+#ifndef WORD64
+    CARD32 walign2 B32;
+#endif
+    CARD16 minCharOrByte2 B16, maxCharOrByte2 B16;
+    CARD16 defaultChar B16;
+    CARD16 nFontProps B16;  /* followed by this many xFontProp structures */
+    CARD8 drawDirection;
+    CARD8 minByte1, maxByte1;
+    BOOL allCharsExist;
+    INT16 fontAscent B16, fontDescent B16;
+    CARD32 nCharInfos B32; /* followed by this many xCharInfo structures */
+} xQueryFontReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 drawDirection;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    INT16 fontAscent B16, fontDescent B16;
+    INT16 overallAscent B16, overallDescent B16;
+    INT32 overallWidth B32, overallLeft B32, overallRight B32;
+    CARD32 pad B32;
+    } xQueryTextExtentsReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nFonts B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xListFontsReply;
+
+/* Warning: this MUST match (up to component renaming) xQueryFontReply */
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 nameLength;  /* 0 indicates end-of-reply-sequence */
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* definitely > 0, even if "nameLength" is 0 */
+    xCharInfo minBounds; 
+#ifndef WORD64
+    CARD32 walign1 B32;
+#endif
+    xCharInfo maxBounds; 
+#ifndef WORD64
+    CARD32 walign2 B32;
+#endif
+    CARD16 minCharOrByte2 B16, maxCharOrByte2 B16;
+    CARD16 defaultChar B16;
+    CARD16 nFontProps B16;  /* followed by this many xFontProp structures */
+    CARD8 drawDirection;
+    CARD8 minByte1, maxByte1;
+    BOOL allCharsExist;
+    INT16 fontAscent B16, fontDescent B16;
+    CARD32 nReplies B32;   /* hint as to how many more replies might be coming */
+} xListFontsWithInfoReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nPaths B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xGetFontPathReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 depth;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    VisualID visual B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xGetImageReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nColormaps B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xListInstalledColormapsReply;
+
+typedef struct {
+    BYTE type; /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;   /* 0 */
+    CARD16 red B16, green B16, blue B16;
+    CARD16 pad2 B16;
+    CARD32 pixel B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    } xAllocColorReply;
+
+typedef struct {
+    BYTE type; /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD32 pixel B32;
+    CARD16 exactRed B16, exactGreen B16, exactBlue B16;
+    CARD16 screenRed B16, screenGreen B16, screenBlue B16;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    } xAllocNamedColorReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nPixels B16, nMasks B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xAllocColorCellsReply;
+
+typedef struct {
+    BYTE type; /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nPixels B16;
+    CARD16 pad2 B16;
+    CARD32 redMask B32, greenMask B32, blueMask B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    } xAllocColorPlanesReply;
+
+typedef struct {
+    BYTE type; /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nColors B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xQueryColorsReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD16 exactRed B16, exactGreen B16, exactBlue B16;
+    CARD16 screenRed B16, screenGreen B16, screenBlue B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    } xLookupColorReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD16 width B16, height B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xQueryBestSizeReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32; /* 0 */
+    BOOL  present;
+    CARD8 major_opcode;
+    CARD8 first_event;
+    CARD8 first_error;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xQueryExtensionReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 nExtensions;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xListExtensionsReply;
+
+
+typedef struct {
+    BYTE   type;  /* X_Reply */
+    CARD8  success;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xSetMappingReply;
+typedef xSetMappingReply xSetPointerMappingReply;
+typedef xSetMappingReply xSetModifierMappingReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    CARD8 nElts;  /* how many elements does the map have */
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xGetPointerMappingReply;
+
+typedef struct {
+    BYTE type;
+    CARD8 keySymsPerKeyCode;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+} xGetKeyboardMappingReply;    
+
+typedef struct {
+    BYTE type;
+    CARD8 numKeyPerModifier;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD32 pad1 B32;
+    CARD32 pad2 B32;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+} xGetModifierMappingReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BOOL globalAutoRepeat;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 5 */
+    CARD32 ledMask B32;
+    CARD8 keyClickPercent, bellPercent;
+    CARD16 bellPitch B16, bellDuration B16;
+    CARD16 pad B16;
+    BYTE map[32];  /* bit masks start here */
+    } xGetKeyboardControlReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD16 accelNumerator B16, accelDenominator B16;
+    CARD16 threshold B16;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xGetPointerControlReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BYTE pad1;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;  /* 0 */
+    CARD16 timeout B16, interval B16;
+    BOOL preferBlanking;
+    BOOL allowExposures;
+    CARD16 pad2 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    } xGetScreenSaverReply;
+
+typedef struct {
+    BYTE type;  /* X_Reply */
+    BOOL enabled;
+    CARD16 sequenceNumber B16;
+    CARD32 length B32;
+    CARD16 nHosts B16;
+    CARD16 pad1 B16;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+    } xListHostsReply;
+
+
+
+
+/*****************************************************************
+ * Xerror
+ *    All errors  are 32 bytes 
+ *****************************************************************/
+
+typedef struct {
+    BYTE type;                  /* X_Error */
+    BYTE errorCode;
+    CARD16 sequenceNumber B16;       /* the nth request from this client */
+    CARD32 resourceID B32;
+    CARD16 minorCode B16;
+    CARD8 majorCode;
+    BYTE pad1;
+    CARD32 pad3 B32;
+    CARD32 pad4 B32;
+    CARD32 pad5 B32;
+    CARD32 pad6 B32;
+    CARD32 pad7 B32;
+} xError;
+
+/*****************************************************************
+ * xEvent
+ *    All events are 32 bytes
+ *****************************************************************/
+
+typedef struct _xEvent {
+    union {
+	struct {
+	    BYTE type;
+	    BYTE detail;
+	    CARD16 sequenceNumber B16;
+	    } u;
+	struct {
+            CARD32 pad00 B32;
+	    Time time B32;
+	    Window root B32, event B32, child B32;
+	    INT16 rootX B16, rootY B16, eventX B16, eventY B16;
+	    KeyButMask state B16;
+	    BOOL sameScreen;		
+	    BYTE pad1;
+	} keyButtonPointer;
+	struct {
+            CARD32 pad00 B32;
+            Time time B32;
+	    Window root B32, event B32, child B32;
+	    INT16 rootX B16, rootY B16, eventX B16, eventY B16;
+	    KeyButMask state B16;
+	    BYTE mode; 			/* really XMode */
+	    BYTE flags;		/* sameScreen and focus booleans, packed together */
+#define ELFlagFocus        (1<<0)
+#define ELFlagSameScreen   (1<<1)
+	} enterLeave;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    BYTE mode; 			/* really XMode */
+	    BYTE pad1, pad2, pad3;
+	} focus;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    CARD16 x B16, y B16, width B16, height B16;
+	    CARD16 count B16;
+	    CARD16 pad2 B16;
+	} expose;
+	struct {
+            CARD32 pad00 B32;
+	    Drawable drawable B32;
+	    CARD16 x B16, y B16, width B16, height B16;
+	    CARD16 minorEvent B16;
+	    CARD16 count B16;
+	    BYTE majorEvent;
+	    BYTE pad1, pad2, pad3;
+	} graphicsExposure;
+	struct {
+            CARD32 pad00 B32;
+	    Drawable drawable B32;
+	    CARD16 minorEvent B16;
+	    BYTE majorEvent;
+	    BYTE bpad;
+	} noExposure;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    CARD8 state;
+	    BYTE pad1, pad2, pad3;
+	} visibility;
+	struct {
+            CARD32 pad00 B32;
+	    Window parent B32, window B32;
+	    INT16 x B16, y B16;
+	    CARD16 width B16, height B16, borderWidth B16;
+	    BOOL override;
+	    BYTE bpad;
+        } createNotify;
+/*
+ * The event fields in the structures for DestroyNotify, UnmapNotify,
+ * MapNotify, ReparentNotify, ConfigureNotify, CirculateNotify, GravityNotify,
+ * must be at the same offset because server internal code is depending upon
+ * this to patch up the events before they are delivered.
+ * Also note that MapRequest, ConfigureRequest and CirculateRequest have
+ * the same offset for the event window.
+ */
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32;
+	} destroyNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32;
+	    BOOL fromConfigure;
+	    BYTE pad1, pad2, pad3;
+        } unmapNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32;
+	    BOOL override;
+	    BYTE pad1, pad2, pad3;
+        } mapNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window parent B32, window B32;
+        } mapRequest;
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32, parent B32;
+	    INT16 x B16, y B16;
+	    BOOL override;
+	    BYTE pad1, pad2, pad3;
+	} reparent;
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32, aboveSibling B32;
+	    INT16 x B16, y B16;
+	    CARD16 width B16, height B16, borderWidth B16;
+	    BOOL override;		
+	    BYTE bpad;
+	} configureNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window parent B32, window B32, sibling B32;
+	    INT16 x B16, y B16;
+	    CARD16 width B16, height B16, borderWidth B16;
+	    CARD16 valueMask B16;
+	    CARD32 pad1 B32;
+	} configureRequest;
+	struct {
+            CARD32 pad00 B32;
+	    Window event B32, window B32;
+	    INT16 x B16, y B16;
+	    CARD32 pad1 B32, pad2 B32, pad3 B32, pad4 B32;
+	} gravity;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    CARD16 width B16, height B16;
+	} resizeRequest;
+	struct {
+/* The event field in the circulate record is really the parent when this
+   is used as a CirculateRequest instead of a CirculateNotify */
+            CARD32 pad00 B32;
+	    Window event B32, window B32, parent B32;
+	    BYTE place;			/* Top or Bottom */
+	    BYTE pad1, pad2, pad3;
+	} circulate;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    Atom atom B32;
+	    Time time B32;
+	    BYTE state;			/* NewValue or Deleted */
+	    BYTE pad1;
+	    CARD16 pad2 B16;
+	} property;
+	struct {
+            CARD32 pad00 B32;
+            Time time B32;     
+	    Window window B32;
+	    Atom atom B32;
+	} selectionClear;
+	struct {
+            CARD32 pad00 B32;
+            Time time B32;    
+	    Window owner B32, requestor B32;
+	    Atom selection B32, target B32, property B32;
+	} selectionRequest;
+	struct {
+            CARD32 pad00 B32;
+            Time time B32;   
+	    Window requestor B32;
+	    Atom selection B32, target B32, property B32;
+	} selectionNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    Colormap colormap B32;
+#if defined(__cplusplus) || defined(c_plusplus)
+	    BOOL c_new;
+#else
+	    BOOL new;
+#endif
+	    BYTE state;			/* Installed or UnInstalled */
+	    BYTE pad1, pad2;
+	} colormap;
+	struct {
+	    CARD32 pad00 B32;
+	    CARD8 request;
+	    KeyCode firstKeyCode;
+	    CARD8 count;
+	    BYTE pad1;
+	} mappingNotify;
+	struct {
+            CARD32 pad00 B32;
+	    Window window B32;
+	    union {
+		struct {
+		    Atom type B32;
+		    INT32 longs0 B32;
+		    INT32 longs1 B32;
+		    INT32 longs2 B32;
+		    INT32 longs3 B32;
+		    INT32 longs4 B32;
+		} l;
+		struct {
+		    Atom type B32;
+		    INT16 shorts0 B16;
+		    INT16 shorts1 B16;
+		    INT16 shorts2 B16;
+		    INT16 shorts3 B16;
+		    INT16 shorts4 B16;
+		    INT16 shorts5 B16;
+		    INT16 shorts6 B16;
+		    INT16 shorts7 B16;
+		    INT16 shorts8 B16;
+		    INT16 shorts9 B16;
+		} s;
+		struct {
+		    Atom type B32;
+		    INT8 bytes[20];
+		} b;
+	    } u; 
+	} clientMessage;
+    } u;
+} xEvent;
+
+/*********************************************************
+ *
+ * Generic event
+ * 
+ * Those events are not part of the core protocol spec and can be used by
+ * various extensions.
+ * type is always GenericEvent
+ * extension is the minor opcode of the extension the event belongs to.
+ * evtype is the actual event type, unique __per extension__. 
+ *
+ * GenericEvents can be longer than 32 bytes, with the length field
+ * specifying the number of 4 byte blocks after the first 32 bytes. 
+ *
+ *
+ */
+typedef struct 
+{
+    BYTE    type;
+    CARD8   extension;
+    CARD16  sequenceNumber B16;
+    CARD32  length B32;
+    CARD16  evtype B16;
+    CARD16  pad2 B16;
+    CARD32  pad3 B32;
+    CARD32  pad4 B32;
+    CARD32  pad5 B32;
+    CARD32  pad6 B32;
+    CARD32  pad7 B32;
+} xGenericEvent;
+
+
+
+/* KeymapNotify events are not included in the above union because they
+   are different from all other events: they do not have a "detail"
+   or "sequenceNumber", so there is room for a 248-bit key mask. */
+
+typedef struct {
+    BYTE type;
+    BYTE map[31];
+    } xKeymapEvent;
+
+#define XEventSize (sizeof(xEvent))
+
+/* XReply is the union of all the replies above whose "fixed part"
+fits in 32 bytes.  It does NOT include GetWindowAttributesReply,
+QueryFontReply, QueryKeymapReply, or GetKeyboardControlReply 
+ListFontsWithInfoReply */
+
+typedef union {
+    xGenericReply generic;
+    xGetGeometryReply geom;
+    xQueryTreeReply tree;
+    xInternAtomReply atom;
+    xGetAtomNameReply atomName;
+    xGetPropertyReply property;
+    xListPropertiesReply listProperties;
+    xGetSelectionOwnerReply selection;
+    xGrabPointerReply grabPointer;
+    xGrabKeyboardReply grabKeyboard;
+    xQueryPointerReply pointer;
+    xGetMotionEventsReply motionEvents;
+    xTranslateCoordsReply coords;
+    xGetInputFocusReply inputFocus;
+    xQueryTextExtentsReply textExtents;
+    xListFontsReply fonts;
+    xGetFontPathReply fontPath;
+    xGetImageReply image;
+    xListInstalledColormapsReply colormaps;
+    xAllocColorReply allocColor;
+    xAllocNamedColorReply allocNamedColor;
+    xAllocColorCellsReply colorCells;
+    xAllocColorPlanesReply colorPlanes;
+    xQueryColorsReply colors;
+    xLookupColorReply lookupColor;
+    xQueryBestSizeReply bestSize;
+    xQueryExtensionReply extension;
+    xListExtensionsReply extensions;
+    xSetModifierMappingReply setModifierMapping;
+    xGetModifierMappingReply getModifierMapping;
+    xSetPointerMappingReply setPointerMapping;
+    xGetKeyboardMappingReply getKeyboardMapping;
+    xGetPointerMappingReply getPointerMapping;
+    xGetPointerControlReply pointerControl;
+    xGetScreenSaverReply screenSaver;
+    xListHostsReply hosts;
+    xError error;
+    xEvent event;
+} xReply;
+
+
+
+/*****************************************************************
+ * REQUESTS
+ *****************************************************************/
+
+
+/* Request structure */
+
+typedef struct _xReq {
+	CARD8 reqType;
+	CARD8 data;            /* meaning depends on request type */
+	CARD16 length B16;         /* length in 4 bytes quantities 
+				  of whole request, including this header */
+} xReq;
+
+/*****************************************************************
+ *  structures that follow request. 
+ *****************************************************************/
+
+/* ResourceReq is used for any request which has a resource ID 
+   (or Atom or Time) as its one and only argument.  */
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    CARD32 id B32;  /* a Window, Drawable, Font, GContext, Pixmap, etc. */
+    } xResourceReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 depth;
+    CARD16 length B16;
+    Window wid B32, parent B32;
+    INT16 x B16, y B16;
+    CARD16 width B16, height B16, borderWidth B16;  
+#if defined(__cplusplus) || defined(c_plusplus)
+    CARD16 c_class B16;
+#else
+    CARD16 class B16;
+#endif
+    VisualID visual B32;
+    CARD32 mask B32;
+} xCreateWindowReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32;
+    CARD32 valueMask B32; 
+} xChangeWindowAttributesReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE mode;
+    CARD16 length B16;
+    Window window B32;
+} xChangeSaveSetReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32, parent B32;
+    INT16 x B16, y B16;
+} xReparentWindowReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 pad;
+    CARD16 length B16;
+    Window window B32;
+    CARD16 mask B16;
+    CARD16 pad2 B16;
+} xConfigureWindowReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 direction;
+    CARD16 length B16;
+    Window window B32;
+} xCirculateWindowReq;
+
+typedef struct {    /* followed by padded string */
+    CARD8 reqType;
+    BOOL onlyIfExists;
+    CARD16 length B16;
+    CARD16 nbytes  B16;    /* number of bytes in string */
+    CARD16 pad B16;
+} xInternAtomReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 mode;
+    CARD16 length B16;
+    Window window B32;
+    Atom property B32, type B32;
+    CARD8 format;
+    BYTE pad[3];
+    CARD32 nUnits B32;     /* length of stuff following, depends on format */
+} xChangePropertyReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32;
+    Atom property B32;
+} xDeletePropertyReq;
+
+typedef struct {
+    CARD8 reqType;
+#if defined(__cplusplus) || defined(c_plusplus)
+    BOOL c_delete;
+#else
+    BOOL delete;
+#endif
+    CARD16 length B16;
+    Window window B32;
+    Atom property B32, type B32;
+    CARD32 longOffset B32;
+    CARD32 longLength B32;
+} xGetPropertyReq;
+ 
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32;
+    Atom selection B32;
+    Time time B32;
+} xSetSelectionOwnerReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window requestor B32;
+    Atom selection B32, target B32, property B32;
+    Time time B32;
+    } xConvertSelectionReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL propagate;
+    CARD16 length B16;
+    Window destination B32;
+    CARD32 eventMask B32;
+#ifdef WORD64
+    /* the structure should have been quad-aligned */
+    BYTE eventdata[SIZEOF(xEvent)];
+#else
+    xEvent event;
+#endif /* WORD64 */
+} xSendEventReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL ownerEvents;
+    CARD16 length B16;
+    Window grabWindow B32;
+    CARD16 eventMask B16;
+    BYTE pointerMode, keyboardMode;
+    Window confineTo B32;
+    Cursor cursor B32;
+    Time time B32;
+} xGrabPointerReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL ownerEvents;
+    CARD16 length B16;
+    Window grabWindow B32;
+    CARD16 eventMask B16;
+    BYTE pointerMode, keyboardMode;
+    Window confineTo B32;
+    Cursor cursor B32;
+    CARD8 button;
+    BYTE pad;
+    CARD16 modifiers B16;
+} xGrabButtonReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 button;
+    CARD16 length B16;
+    Window grabWindow B32;
+    CARD16 modifiers B16;
+    CARD16 pad B16;
+} xUngrabButtonReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Cursor cursor B32;
+    Time time B32;
+    CARD16 eventMask B16;
+    CARD16 pad2 B16;
+} xChangeActivePointerGrabReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL ownerEvents;
+    CARD16 length B16;
+    Window grabWindow B32;
+    Time time B32;
+    BYTE pointerMode, keyboardMode;  
+    CARD16 pad B16;
+} xGrabKeyboardReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL ownerEvents;
+    CARD16 length B16;
+    Window grabWindow B32;
+    CARD16 modifiers B16;
+    CARD8 key;
+    BYTE pointerMode, keyboardMode;  
+    BYTE pad1, pad2, pad3;
+} xGrabKeyReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 key;
+    CARD16 length B16;
+    Window grabWindow B32;
+    CARD16 modifiers B16;
+    CARD16 pad B16;
+} xUngrabKeyReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 mode;
+    CARD16 length B16;
+    Time time B32;
+} xAllowEventsReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32;
+    Time start B32, stop B32;
+} xGetMotionEventsReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window srcWid B32, dstWid B32;
+    INT16 srcX B16, srcY B16;
+} xTranslateCoordsReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window srcWid B32, dstWid B32;
+    INT16 srcX B16, srcY B16;
+    CARD16 srcWidth B16, srcHeight B16;
+    INT16 dstX B16, dstY B16;
+} xWarpPointerReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 revertTo;
+    CARD16 length B16;
+    Window focus B32;
+    Time time B32;
+} xSetInputFocusReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Font fid B32;
+    CARD16 nbytes B16;
+    BYTE pad1, pad2;	/* string follows on word boundary */
+} xOpenFontReq;
+
+typedef struct {
+    CARD8 reqType;
+    BOOL oddLength;
+    CARD16 length B16;
+    Font fid B32;
+    } xQueryTextExtentsReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    CARD16 maxNames B16;
+    CARD16 nbytes B16;  /* followed immediately by string bytes */
+} xListFontsReq;
+
+typedef xListFontsReq xListFontsWithInfoReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    CARD16 nFonts B16;
+    BYTE pad1, pad2;	/* LISTofSTRING8 follows on word boundary */
+} xSetFontPathReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 depth;
+    CARD16 length B16;
+    Pixmap pid B32;
+    Drawable drawable B32;
+    CARD16 width B16, height B16;
+} xCreatePixmapReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    GContext gc B32;
+    Drawable drawable B32;
+    CARD32 mask B32;
+} xCreateGCReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    GContext gc B32;
+    CARD32 mask B32;
+} xChangeGCReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    GContext srcGC B32, dstGC B32;
+    CARD32 mask B32;
+} xCopyGCReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    GContext gc B32;
+    CARD16 dashOffset B16;
+    CARD16 nDashes B16;        /* length LISTofCARD8 of values following */
+} xSetDashesReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE ordering;
+    CARD16 length B16;
+    GContext gc B32;
+    INT16 xOrigin B16, yOrigin B16;
+} xSetClipRectanglesReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BOOL exposures;
+    CARD16 length B16;
+    Window window B32;
+    INT16 x B16, y B16;
+    CARD16 width B16, height B16;
+} xClearAreaReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Drawable srcDrawable B32, dstDrawable B32;
+    GContext gc B32;
+    INT16 srcX B16, srcY B16, dstX B16, dstY B16;
+    CARD16 width B16, height B16;
+} xCopyAreaReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Drawable srcDrawable B32, dstDrawable B32;
+    GContext gc B32;
+    INT16 srcX B16, srcY B16, dstX B16, dstY B16;
+    CARD16 width B16, height B16;
+    CARD32 bitPlane B32;
+} xCopyPlaneReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE coordMode;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+} xPolyPointReq;    
+
+typedef xPolyPointReq xPolyLineReq;  /* same request structure */
+
+/* The following used for PolySegment, PolyRectangle, PolyArc, PolyFillRectangle, PolyFillArc */
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+} xPolySegmentReq;    
+
+typedef xPolySegmentReq xPolyArcReq;
+typedef xPolySegmentReq xPolyRectangleReq;
+typedef xPolySegmentReq xPolyFillRectangleReq;
+typedef xPolySegmentReq xPolyFillArcReq;
+
+typedef struct _FillPolyReq {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+    BYTE shape;
+    BYTE coordMode;
+    CARD16 pad1 B16;
+} xFillPolyReq;    
+
+
+typedef struct _PutImageReq {
+    CARD8 reqType;
+    CARD8 format;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+    CARD16 width B16, height B16;
+    INT16 dstX B16, dstY B16;
+    CARD8 leftPad;
+    CARD8 depth;
+    CARD16 pad B16;
+} xPutImageReq;    
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 format;
+    CARD16 length B16;
+    Drawable drawable B32;
+    INT16 x B16, y B16;
+    CARD16 width B16, height B16;
+    CARD32 planeMask B32;
+} xGetImageReq;    
+
+/* the following used by PolyText8 and PolyText16 */
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 pad;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+    INT16 x B16, y B16;		/* items (xTextElt) start after struct */
+} xPolyTextReq;    
+
+typedef xPolyTextReq xPolyText8Req;
+typedef xPolyTextReq xPolyText16Req;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE nChars;
+    CARD16 length B16;
+    Drawable drawable B32;
+    GContext gc B32;
+    INT16 x B16, y B16;
+} xImageTextReq;    
+
+typedef xImageTextReq xImageText8Req;
+typedef xImageTextReq xImageText16Req;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE alloc;
+    CARD16 length B16;
+    Colormap mid B32;
+    Window window B32;
+    VisualID visual B32;
+} xCreateColormapReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap mid B32;
+    Colormap srcCmap B32;
+} xCopyColormapAndFreeReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD16 red B16, green B16, blue B16;
+    CARD16 pad2 B16;
+} xAllocColorReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD16 nbytes B16;  /* followed by structure */
+    BYTE pad1, pad2;
+} xAllocNamedColorReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BOOL contiguous;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD16 colors B16, planes B16;
+} xAllocColorCellsReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BOOL contiguous;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD16 colors B16, red B16, green B16, blue B16;
+} xAllocColorPlanesReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD32 planeMask B32;
+} xFreeColorsReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+} xStoreColorsReq;    
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 flags;   /* DoRed, DoGreen, DoBlue, as in xColorItem */
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD32 pixel B32;
+    CARD16 nbytes B16;  /* number of name string bytes following structure */
+    BYTE pad1, pad2;
+    } xStoreNamedColorReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+} xQueryColorsReq;    
+
+typedef struct {    /* followed  by string of length len */
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Colormap cmap B32;
+    CARD16 nbytes B16;  /* number of string bytes following structure*/
+    BYTE pad1, pad2;
+} xLookupColorReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Cursor cid B32;
+    Pixmap source B32, mask B32;
+    CARD16 foreRed B16, foreGreen B16, foreBlue B16;
+    CARD16 backRed B16, backGreen B16, backBlue B16;
+    CARD16 x B16, y B16;
+} xCreateCursorReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Cursor cid B32;
+    Font source B32, mask B32;
+    CARD16 sourceChar B16, maskChar B16;
+    CARD16 foreRed B16, foreGreen B16, foreBlue B16;
+    CARD16 backRed B16, backGreen B16, backBlue B16;
+} xCreateGlyphCursorReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Cursor cursor B32;
+    CARD16 foreRed B16, foreGreen B16, foreBlue B16;
+    CARD16 backRed B16, backGreen B16, backBlue B16;
+} xRecolorCursorReq;    
+
+typedef struct {
+    CARD8 reqType;
+#if defined(__cplusplus) || defined(c_plusplus)
+    CARD8 c_class;
+#else
+    CARD8 class;
+#endif
+    CARD16 length B16;
+    Drawable drawable B32;
+    CARD16 width B16, height B16;
+} xQueryBestSizeReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    CARD16 nbytes B16;  /* number of string bytes following structure */
+    BYTE pad1, pad2;
+} xQueryExtensionReq;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   numKeyPerModifier;
+    CARD16  length B16;
+} xSetModifierMappingReq;
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 nElts;  /* how many elements in the map */
+    CARD16 length B16;
+} xSetPointerMappingReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    KeyCode firstKeyCode;
+    CARD8 count;
+    CARD16 pad1 B16;
+} xGetKeyboardMappingReq;    
+
+typedef struct {
+    CARD8 reqType;
+    CARD8 keyCodes;
+    CARD16 length B16;
+    KeyCode firstKeyCode;
+    CARD8 keySymsPerKeyCode;
+    CARD16 pad1 B16;
+} xChangeKeyboardMappingReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    CARD32 mask B32;
+} xChangeKeyboardControlReq;    
+
+typedef struct {
+    CARD8 reqType;
+    INT8 percent;  /* -100 to 100 */
+    CARD16 length B16;
+} xBellReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    INT16 accelNum B16, accelDenum B16;
+    INT16 threshold B16;             
+    BOOL doAccel, doThresh;
+} xChangePointerControlReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    INT16 timeout B16, interval B16;
+    BYTE preferBlank, allowExpose;  
+    CARD16 pad2 B16;
+} xSetScreenSaverReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE mode;
+    CARD16 length B16;
+    CARD8 hostFamily;
+    BYTE pad;
+    CARD16 hostLength B16;
+} xChangeHostsReq;    
+
+typedef struct {
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    } xListHostsReq;
+
+typedef struct {
+    CARD8 reqType;
+    BYTE mode;
+    CARD16 length B16;
+    } xChangeModeReq;
+
+typedef xChangeModeReq xSetAccessControlReq;
+typedef xChangeModeReq xSetCloseDownModeReq;
+typedef xChangeModeReq xForceScreenSaverReq;
+
+typedef struct { /* followed by LIST of ATOM */
+    CARD8 reqType;
+    BYTE pad;
+    CARD16 length B16;
+    Window window B32;
+    CARD16 nAtoms B16;
+    INT16 nPositions B16;
+    } xRotatePropertiesReq;
+    
+
+
+/* Reply codes */
+
+#define X_Reply		1		/* Normal reply */
+#define X_Error		0		/* Error */
+
+/* Request codes */
+
+#define X_CreateWindow                  1              
+#define X_ChangeWindowAttributes        2        
+#define X_GetWindowAttributes           3     
+#define X_DestroyWindow                 4
+#define X_DestroySubwindows             5   
+#define X_ChangeSaveSet                 6
+#define X_ReparentWindow                7
+#define X_MapWindow                     8
+#define X_MapSubwindows                 9
+#define X_UnmapWindow                  10
+#define X_UnmapSubwindows              11  
+#define X_ConfigureWindow              12  
+#define X_CirculateWindow              13  
+#define X_GetGeometry                  14
+#define X_QueryTree                    15
+#define X_InternAtom                   16
+#define X_GetAtomName                  17
+#define X_ChangeProperty               18 
+#define X_DeleteProperty               19 
+#define X_GetProperty                  20
+#define X_ListProperties               21 
+#define X_SetSelectionOwner            22    
+#define X_GetSelectionOwner            23    
+#define X_ConvertSelection             24   
+#define X_SendEvent                    25
+#define X_GrabPointer                  26
+#define X_UngrabPointer                27
+#define X_GrabButton                   28
+#define X_UngrabButton                 29
+#define X_ChangeActivePointerGrab      30          
+#define X_GrabKeyboard                 31
+#define X_UngrabKeyboard               32 
+#define X_GrabKey                      33
+#define X_UngrabKey                    34
+#define X_AllowEvents                  35       
+#define X_GrabServer                   36      
+#define X_UngrabServer                 37        
+#define X_QueryPointer                 38        
+#define X_GetMotionEvents              39           
+#define X_TranslateCoords              40                
+#define X_WarpPointer                  41       
+#define X_SetInputFocus                42         
+#define X_GetInputFocus                43         
+#define X_QueryKeymap                  44       
+#define X_OpenFont                     45    
+#define X_CloseFont                    46     
+#define X_QueryFont                    47
+#define X_QueryTextExtents             48     
+#define X_ListFonts                    49  
+#define X_ListFontsWithInfo    	       50 
+#define X_SetFontPath                  51 
+#define X_GetFontPath                  52 
+#define X_CreatePixmap                 53        
+#define X_FreePixmap                   54      
+#define X_CreateGC                     55    
+#define X_ChangeGC                     56    
+#define X_CopyGC                       57  
+#define X_SetDashes                    58     
+#define X_SetClipRectangles            59             
+#define X_FreeGC                       60  
+#define X_ClearArea                    61             
+#define X_CopyArea                     62    
+#define X_CopyPlane                    63     
+#define X_PolyPoint                    64     
+#define X_PolyLine                     65    
+#define X_PolySegment                  66       
+#define X_PolyRectangle                67         
+#define X_PolyArc                      68   
+#define X_FillPoly                     69    
+#define X_PolyFillRectangle            70             
+#define X_PolyFillArc                  71       
+#define X_PutImage                     72    
+#define X_GetImage                     73 
+#define X_PolyText8                    74     
+#define X_PolyText16                   75      
+#define X_ImageText8                   76      
+#define X_ImageText16                  77       
+#define X_CreateColormap               78          
+#define X_FreeColormap                 79        
+#define X_CopyColormapAndFree          80               
+#define X_InstallColormap              81           
+#define X_UninstallColormap            82             
+#define X_ListInstalledColormaps       83                  
+#define X_AllocColor                   84      
+#define X_AllocNamedColor              85           
+#define X_AllocColorCells              86           
+#define X_AllocColorPlanes             87            
+#define X_FreeColors                   88      
+#define X_StoreColors                  89       
+#define X_StoreNamedColor              90           
+#define X_QueryColors                  91       
+#define X_LookupColor                  92       
+#define X_CreateCursor                 93        
+#define X_CreateGlyphCursor            94             
+#define X_FreeCursor                   95      
+#define X_RecolorCursor                96         
+#define X_QueryBestSize                97         
+#define X_QueryExtension               98          
+#define X_ListExtensions               99          
+#define X_ChangeKeyboardMapping        100
+#define X_GetKeyboardMapping           101
+#define X_ChangeKeyboardControl        102                
+#define X_GetKeyboardControl           103             
+#define X_Bell                         104
+#define X_ChangePointerControl         105
+#define X_GetPointerControl            106
+#define X_SetScreenSaver               107          
+#define X_GetScreenSaver               108          
+#define X_ChangeHosts                  109       
+#define X_ListHosts                    110     
+#define X_SetAccessControl             111               
+#define X_SetCloseDownMode             112
+#define X_KillClient                   113 
+#define X_RotateProperties	       114
+#define X_ForceScreenSaver	       115
+#define X_SetPointerMapping            116
+#define X_GetPointerMapping            117
+#define X_SetModifierMapping	       118
+#define X_GetModifierMapping	       119
+#define X_NoOperation                  127
+
+/* restore these definitions back to the typedefs in X.h */
+#undef Window
+#undef Drawable
+#undef Font
+#undef Pixmap
+#undef Cursor
+#undef Colormap
+#undef GContext
+#undef Atom
+#undef VisualID
+#undef Time
+#undef KeyCode
+#undef KeySym
+
+#endif /* XPROTO_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/do-not-use-config.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/do-not-use-config.h
@@ -0,0 +1,76 @@
+/* do-not-use-config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* FUNCPROTO */
+#undef FUNCPROTO
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Narrow prototypes */
+#undef NARROWPROTO
+
+/* Name of package */
+#undef PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Major version of this package */
+#undef PACKAGE_VERSION_MAJOR
+
+/* Minor version of this package */
+#undef PACKAGE_VERSION_MINOR
+
+/* Patch version of this package */
+#undef PACKAGE_VERSION_PATCHLEVEL
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Version number of package */
+#undef VERSION
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/DECkeysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/DECkeysym.h
@@ -0,0 +1,65 @@
+/***********************************************************
+
+Copyright 1988, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1988 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * DEC private keysyms
+ * (29th bit set)
+ */
+
+/* two-key compose sequence initiators, chosen to map to Latin1 characters */
+
+#define DXK_ring_accent         0x1000FEB0
+#define DXK_circumflex_accent   0x1000FE5E
+#define DXK_cedilla_accent      0x1000FE2C
+#define DXK_acute_accent        0x1000FE27
+#define DXK_grave_accent        0x1000FE60
+#define DXK_tilde               0x1000FE7E
+#define DXK_diaeresis           0x1000FE22
+
+/* special keysym for LK2** "Remove" key on editing keypad */
+
+#define DXK_Remove	0x1000FF00   /* Remove */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/XF86keysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/XF86keysym.h
@@ -0,0 +1,230 @@
+/*
+ * XFree86 vendor specific keysyms.
+ *
+ * The XFree86 keysym range is 0x10080001 - 0x1008FFFF.
+ *
+ * When adding new entries, the xc/lib/XKeysymDB file should also be
+ * updated to make the new entries visible to Xlib.
+ */
+
+/*
+ * ModeLock
+ *
+ * This one is old, and not really used any more since XKB offers this
+ * functionality.
+ */
+
+#define XF86XK_ModeLock		0x1008FF01	/* Mode Switch Lock */
+
+/*
+ * Note, 0x1008FF07 - 0x1008FF0F are free and should be used for misc new
+ * keysyms that don't fit into any of the groups below.
+ *
+ * 0x1008FF64, 0x1008FF6F, 0x1008FF71, 0x1008FF83 are no longer used,
+ * and should be used first for new keysyms.
+ *
+ * Check in keysymdef.h for generic symbols before adding new XFree86-specific
+ * symbols here.
+ *
+ * X.Org will not be adding to the XF86 set of keysyms, though they have
+ * been adopted and are considered a "standard" part of X keysym definitions.
+ * XFree86 never properly commented these keysyms, so we have done our
+ * best to explain the semantic meaning of these keys.
+ *
+ * XFree86 has removed their mail archives of the period, that might have
+ * shed more light on some of these definitions. Until/unless we resurrect
+ * these archives, these are from memory and usage.
+ */
+
+
+/* Backlight controls. */
+#define XF86XK_MonBrightnessUp   0x1008FF02  /* Monitor/panel brightness */
+#define XF86XK_MonBrightnessDown 0x1008FF03  /* Monitor/panel brightness */
+#define XF86XK_KbdLightOnOff     0x1008FF04  /* Keyboards may be lit     */
+#define XF86XK_KbdBrightnessUp   0x1008FF05  /* Keyboards may be lit     */
+#define XF86XK_KbdBrightnessDown 0x1008FF06  /* Keyboards may be lit     */
+
+/*
+ * Keys found on some "Internet" keyboards.
+ */
+#define XF86XK_Standby		0x1008FF10   /* System into standby mode   */
+#define XF86XK_AudioLowerVolume	0x1008FF11   /* Volume control down        */
+#define XF86XK_AudioMute	0x1008FF12   /* Mute sound from the system */
+#define XF86XK_AudioRaiseVolume	0x1008FF13   /* Volume control up          */
+#define XF86XK_AudioPlay	0x1008FF14   /* Start playing of audio >   */
+#define XF86XK_AudioStop	0x1008FF15   /* Stop playing audio         */
+#define XF86XK_AudioPrev	0x1008FF16   /* Previous track             */
+#define XF86XK_AudioNext	0x1008FF17   /* Next track                 */
+#define XF86XK_HomePage		0x1008FF18   /* Display user's home page   */
+#define XF86XK_Mail		0x1008FF19   /* Invoke user's mail program */
+#define XF86XK_Start		0x1008FF1A   /* Start application          */
+#define XF86XK_Search		0x1008FF1B   /* Search                     */
+#define XF86XK_AudioRecord	0x1008FF1C   /* Record audio application   */
+
+/* These are sometimes found on PDA's (e.g. Palm, PocketPC or elsewhere)   */
+#define XF86XK_Calculator	0x1008FF1D   /* Invoke calculator program  */
+#define XF86XK_Memo		0x1008FF1E   /* Invoke Memo taking program */
+#define XF86XK_ToDoList		0x1008FF1F   /* Invoke To Do List program  */
+#define XF86XK_Calendar		0x1008FF20   /* Invoke Calendar program    */
+#define XF86XK_PowerDown	0x1008FF21   /* Deep sleep the system      */
+#define XF86XK_ContrastAdjust	0x1008FF22   /* Adjust screen contrast     */
+#define XF86XK_RockerUp		0x1008FF23   /* Rocker switches exist up   */
+#define XF86XK_RockerDown	0x1008FF24   /* and down                   */
+#define XF86XK_RockerEnter	0x1008FF25   /* and let you press them     */
+
+/* Some more "Internet" keyboard symbols */
+#define XF86XK_Back		0x1008FF26   /* Like back on a browser     */
+#define XF86XK_Forward		0x1008FF27   /* Like forward on a browser  */
+#define XF86XK_Stop		0x1008FF28   /* Stop current operation     */
+#define XF86XK_Refresh		0x1008FF29   /* Refresh the page           */
+#define XF86XK_PowerOff		0x1008FF2A   /* Power off system entirely  */
+#define XF86XK_WakeUp		0x1008FF2B   /* Wake up system from sleep  */
+#define XF86XK_Eject            0x1008FF2C   /* Eject device (e.g. DVD)    */
+#define XF86XK_ScreenSaver      0x1008FF2D   /* Invoke screensaver         */
+#define XF86XK_WWW              0x1008FF2E   /* Invoke web browser         */
+#define XF86XK_Sleep            0x1008FF2F   /* Put system to sleep        */
+#define XF86XK_Favorites	0x1008FF30   /* Show favorite locations    */
+#define XF86XK_AudioPause	0x1008FF31   /* Pause audio playing        */
+#define XF86XK_AudioMedia	0x1008FF32   /* Launch media collection app */
+#define XF86XK_MyComputer	0x1008FF33   /* Display "My Computer" window */
+#define XF86XK_VendorHome	0x1008FF34   /* Display vendor home web site */
+#define XF86XK_LightBulb	0x1008FF35   /* Light bulb keys exist       */
+#define XF86XK_Shop		0x1008FF36   /* Display shopping web site   */
+#define XF86XK_History		0x1008FF37   /* Show history of web surfing */
+#define XF86XK_OpenURL		0x1008FF38   /* Open selected URL           */
+#define XF86XK_AddFavorite	0x1008FF39   /* Add URL to favorites list   */
+#define XF86XK_HotLinks		0x1008FF3A   /* Show "hot" links            */
+#define XF86XK_BrightnessAdjust	0x1008FF3B   /* Invoke brightness adj. UI   */
+#define XF86XK_Finance		0x1008FF3C   /* Display financial site      */
+#define XF86XK_Community	0x1008FF3D   /* Display user's community    */
+#define XF86XK_AudioRewind	0x1008FF3E   /* "rewind" audio track        */
+#define XF86XK_BackForward	0x1008FF3F   /* ??? */
+#define XF86XK_Launch0		0x1008FF40   /* Launch Application          */
+#define XF86XK_Launch1		0x1008FF41   /* Launch Application          */
+#define XF86XK_Launch2		0x1008FF42   /* Launch Application          */
+#define XF86XK_Launch3		0x1008FF43   /* Launch Application          */
+#define XF86XK_Launch4		0x1008FF44   /* Launch Application          */
+#define XF86XK_Launch5		0x1008FF45   /* Launch Application          */
+#define XF86XK_Launch6		0x1008FF46   /* Launch Application          */
+#define XF86XK_Launch7		0x1008FF47   /* Launch Application          */
+#define XF86XK_Launch8		0x1008FF48   /* Launch Application          */
+#define XF86XK_Launch9		0x1008FF49   /* Launch Application          */
+#define XF86XK_LaunchA		0x1008FF4A   /* Launch Application          */
+#define XF86XK_LaunchB		0x1008FF4B   /* Launch Application          */
+#define XF86XK_LaunchC		0x1008FF4C   /* Launch Application          */
+#define XF86XK_LaunchD		0x1008FF4D   /* Launch Application          */
+#define XF86XK_LaunchE		0x1008FF4E   /* Launch Application          */
+#define XF86XK_LaunchF		0x1008FF4F   /* Launch Application          */
+
+#define XF86XK_ApplicationLeft	0x1008FF50   /* switch to application, left */
+#define XF86XK_ApplicationRight	0x1008FF51   /* switch to application, right*/
+#define XF86XK_Book		0x1008FF52   /* Launch bookreader           */
+#define XF86XK_CD		0x1008FF53   /* Launch CD/DVD player        */
+#define XF86XK_Calculater	0x1008FF54   /* Launch Calculater           */
+#define XF86XK_Clear		0x1008FF55   /* Clear window, screen        */
+#define XF86XK_Close		0x1008FF56   /* Close window                */
+#define XF86XK_Copy		0x1008FF57   /* Copy selection              */
+#define XF86XK_Cut		0x1008FF58   /* Cut selection               */
+#define XF86XK_Display		0x1008FF59   /* Output switch key           */
+#define XF86XK_DOS		0x1008FF5A   /* Launch DOS (emulation)      */
+#define XF86XK_Documents	0x1008FF5B   /* Open documents window       */
+#define XF86XK_Excel		0x1008FF5C   /* Launch spread sheet         */
+#define XF86XK_Explorer		0x1008FF5D   /* Launch file explorer        */
+#define XF86XK_Game		0x1008FF5E   /* Launch game                 */
+#define XF86XK_Go		0x1008FF5F   /* Go to URL                   */
+#define XF86XK_iTouch		0x1008FF60   /* Logitch iTouch- don't use   */
+#define XF86XK_LogOff		0x1008FF61   /* Log off system              */
+#define XF86XK_Market		0x1008FF62   /* ??                          */
+#define XF86XK_Meeting		0x1008FF63   /* enter meeting in calendar   */
+#define XF86XK_MenuKB		0x1008FF65   /* distingush keyboard from PB */
+#define XF86XK_MenuPB		0x1008FF66   /* distinuish PB from keyboard */
+#define XF86XK_MySites		0x1008FF67   /* Favourites                  */
+#define XF86XK_New		0x1008FF68   /* New (folder, document...    */
+#define XF86XK_News		0x1008FF69   /* News                        */
+#define XF86XK_OfficeHome	0x1008FF6A   /* Office home (old Staroffice)*/
+#define XF86XK_Open		0x1008FF6B   /* Open                        */
+#define XF86XK_Option		0x1008FF6C   /* ?? */
+#define XF86XK_Paste		0x1008FF6D   /* Paste                       */
+#define XF86XK_Phone		0x1008FF6E   /* Launch phone; dial number   */
+#define XF86XK_Q		0x1008FF70   /* Compaq's Q - don't use      */
+#define XF86XK_Reply		0x1008FF72   /* Reply e.g., mail            */
+#define XF86XK_Reload		0x1008FF73   /* Reload web page, file, etc. */
+#define XF86XK_RotateWindows	0x1008FF74   /* Rotate windows e.g. xrandr  */
+#define XF86XK_RotationPB	0x1008FF75   /* don't use                   */
+#define XF86XK_RotationKB	0x1008FF76   /* don't use                   */
+#define XF86XK_Save		0x1008FF77   /* Save (file, document, state */
+#define XF86XK_ScrollUp		0x1008FF78   /* Scroll window/contents up   */
+#define XF86XK_ScrollDown	0x1008FF79   /* Scrool window/contentd down */
+#define XF86XK_ScrollClick	0x1008FF7A   /* Use XKB mousekeys instead   */
+#define XF86XK_Send		0x1008FF7B   /* Send mail, file, object     */
+#define XF86XK_Spell		0x1008FF7C   /* Spell checker               */
+#define XF86XK_SplitScreen	0x1008FF7D   /* Split window or screen      */
+#define XF86XK_Support		0x1008FF7E   /* Get support (??)            */
+#define XF86XK_TaskPane		0x1008FF7F   /* Show tasks */
+#define XF86XK_Terminal		0x1008FF80   /* Launch terminal emulator    */
+#define XF86XK_Tools		0x1008FF81   /* toolbox of desktop/app.     */
+#define XF86XK_Travel		0x1008FF82   /* ?? */
+#define XF86XK_UserPB		0x1008FF84   /* ?? */
+#define XF86XK_User1KB		0x1008FF85   /* ?? */
+#define XF86XK_User2KB		0x1008FF86   /* ?? */
+#define XF86XK_Video		0x1008FF87   /* Launch video player       */
+#define XF86XK_WheelButton	0x1008FF88   /* button from a mouse wheel */
+#define XF86XK_Word		0x1008FF89   /* Launch word processor     */
+#define XF86XK_Xfer		0x1008FF8A
+#define XF86XK_ZoomIn		0x1008FF8B   /* zoom in view, map, etc.   */
+#define XF86XK_ZoomOut		0x1008FF8C   /* zoom out view, map, etc.  */
+
+#define XF86XK_Away		0x1008FF8D   /* mark yourself as away     */
+#define XF86XK_Messenger	0x1008FF8E   /* as in instant messaging   */
+#define XF86XK_WebCam		0x1008FF8F   /* Launch web camera app.    */
+#define XF86XK_MailForward	0x1008FF90   /* Forward in mail           */
+#define XF86XK_Pictures		0x1008FF91   /* Show pictures             */
+#define XF86XK_Music		0x1008FF92   /* Launch music application  */
+
+#define XF86XK_Battery		0x1008FF93   /* Display battery information */
+#define XF86XK_Bluetooth	0x1008FF94   /* Enable/disable Bluetooth    */
+#define XF86XK_WLAN		0x1008FF95   /* Enable/disable WLAN         */
+#define XF86XK_UWB		0x1008FF96   /* Enable/disable UWB	    */
+
+#define XF86XK_AudioForward	0x1008FF97   /* fast-forward audio track    */
+#define XF86XK_AudioRepeat	0x1008FF98   /* toggle repeat mode          */
+#define XF86XK_AudioRandomPlay	0x1008FF99   /* toggle shuffle mode         */
+#define XF86XK_Subtitle		0x1008FF9A   /* cycle through subtitle      */
+#define XF86XK_AudioCycleTrack	0x1008FF9B   /* cycle through audio tracks  */
+#define XF86XK_CycleAngle	0x1008FF9C   /* cycle through angles        */
+#define XF86XK_FrameBack	0x1008FF9D   /* video: go one frame back    */
+#define XF86XK_FrameForward	0x1008FF9E   /* video: go one frame forward */
+#define XF86XK_Time		0x1008FF9F   /* display, or shows an entry for time seeking */
+#define XF86XK_Select		0x1008FFA0   /* Select button on joypads and remotes */
+#define XF86XK_View		0x1008FFA1   /* Show a view options/properties */
+#define XF86XK_TopMenu		0x1008FFA2   /* Go to a top-level menu in a video */
+
+#define XF86XK_Red		0x1008FFA3   /* Red button                  */
+#define XF86XK_Green		0x1008FFA4   /* Green button                */
+#define XF86XK_Yellow		0x1008FFA5   /* Yellow button               */
+#define XF86XK_Blue             0x1008FFA6   /* Blue button                 */
+
+#define XF86XK_Suspend		0x1008FFA7   /* Sleep to RAM                */
+#define XF86XK_Hibernate	0x1008FFA8   /* Sleep to disk               */
+#define XF86XK_TouchpadToggle	0x1008FFA9   /* Toggle between touchpad/trackstick */
+
+/* Keys for special action keys (hot keys) */
+/* Virtual terminals on some operating systems */
+#define XF86XK_Switch_VT_1	0x1008FE01
+#define XF86XK_Switch_VT_2	0x1008FE02
+#define XF86XK_Switch_VT_3	0x1008FE03
+#define XF86XK_Switch_VT_4	0x1008FE04
+#define XF86XK_Switch_VT_5	0x1008FE05
+#define XF86XK_Switch_VT_6	0x1008FE06
+#define XF86XK_Switch_VT_7	0x1008FE07
+#define XF86XK_Switch_VT_8	0x1008FE08
+#define XF86XK_Switch_VT_9	0x1008FE09
+#define XF86XK_Switch_VT_10	0x1008FE0A
+#define XF86XK_Switch_VT_11	0x1008FE0B
+#define XF86XK_Switch_VT_12	0x1008FE0C
+
+#define XF86XK_Ungrab		0x1008FE20   /* force ungrab               */
+#define XF86XK_ClearGrab	0x1008FE21   /* kill application with grab */
+#define XF86XK_Next_VMode	0x1008FE22   /* next video mode available  */
+#define XF86XK_Prev_VMode	0x1008FE23   /* prev. video mode available */
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xpoll.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xpoll.h
@@ -0,0 +1,218 @@
+/*
+
+Copyright 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/*
+ * Copyright © 2005 Daniel Stone
+ * 
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Daniel Stone not be used in advertising
+ * or publicity pertaining to distribution of the software without specific,
+ * written prior permission.  Daniel Stone makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * DANIEL STONE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ * DANIEL STONE BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+*/
+
+#ifndef _XPOLL_H_
+#define _XPOLL_H_
+
+#ifndef WIN32
+
+#ifndef USE_POLL
+
+#include <X11/Xos.h>
+
+#include <sys/select.h>  /* Get the FD_* macros. */
+
+#include <X11/Xmd.h>
+
+#ifdef CSRG_BASED
+#include <sys/param.h>
+# if BSD < 199103
+typedef long fd_mask;
+# endif
+#endif
+
+#define XFD_SETSIZE	256
+
+#ifndef FD_SETSIZE
+#define FD_SETSIZE	XFD_SETSIZE
+#endif
+
+#ifndef NBBY
+#define NBBY	8		/* number of bits in a byte */
+#endif
+
+#ifndef NFDBITS
+#define NFDBITS (sizeof(fd_mask) * NBBY)	/* bits per mask */
+#endif
+
+#ifndef howmany
+#define howmany(x,y)	(((x)+((y)-1))/(y))
+#endif
+
+#if defined(BSD) && BSD < 198911 
+typedef struct fd_set {
+	fd_mask fds_bits[howmany(FD_SETSIZE, NFDBITS)];
+} fd_set;
+#endif
+
+# define Select(n,r,w,e,t) select(n,(fd_set*)r,(fd_set*)w,(fd_set*)e,(struct timeval*)t)
+
+#define __X_FDS_BITS @USE_FDS_BITS@
+
+#ifndef __FDS_BITS
+# define __FDS_BITS(p)  ((p)->__X_FDS_BITS)
+#endif
+
+#define __XFDS_BITS(p, n) (__FDS_BITS(p))[n]
+
+#ifndef FD_SET
+#define FD_SET(n, p)    (__XFDS_BITS(p, ((n)/NFDBITS)) |= ((fd_mask)1 << ((n) % NFDBITS)))
+#endif
+#ifndef FD_CLR
+#define FD_CLR(n, p)    (__XFDS_BITS((p), ((n)/NFDBITS)) &= ~((fd_mask)1 << ((n) % NFDBITS)))
+#endif
+#ifndef FD_ISSET
+#define FD_ISSET(n, p)  ((__XFDS_BITS((p), ((n)/NFDBITS))) & ((fd_mask)1 << ((n) % NFDBITS)))
+#endif
+#ifndef FD_ZERO
+#define FD_ZERO(p)      bzero((char *)(p), sizeof(*(p)))
+#endif
+
+/*
+ * The howmany(FD_SETSIZE, NFDBITS) computes the number of elements in the
+ * array. before accessing an element in the array we check it exists.
+ * If it does not exist then the compiler discards the code to access it. 
+ */
+#define XFD_ANYSET(p) \
+        ((howmany(FD_SETSIZE, NFDBITS) > 0 && (__XFDS_BITS(p, 0))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 1 && (__XFDS_BITS(p, 1))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 2 && (__XFDS_BITS(p, 2))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 3 && (__XFDS_BITS(p, 3))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 4 && (__XFDS_BITS(p, 4))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 5 && (__XFDS_BITS(p, 5))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 6 && (__XFDS_BITS(p, 6))) || \
+        (howmany(FD_SETSIZE, NFDBITS) > 7 && (__XFDS_BITS(p, 7))))
+
+#define XFD_COPYSET(src,dst) { \
+        int __i__; \
+		for (__i__ = 0; __i__ < howmany(FD_SETSIZE, NFDBITS); __i__++) \
+            __XFDS_BITS((dst), __i__) = __XFDS_BITS((src), __i__); \
+        }
+#define XFD_ANDSET(dst,b1,b2) { \
+        int __i__; \
+        for (__i__ = 0; __i__ < howmany(FD_SETSIZE, NFDBITS); __i__++) \
+            __XFDS_BITS((dst), __i__) = ((__XFDS_BITS((b1), __i__)) & (__XFDS_BITS((b2), __i__))); \
+        }
+#define XFD_ORSET(dst,b1,b2) { \
+        int __i__; \
+        for (__i__ = 0; __i__ < howmany(FD_SETSIZE, NFDBITS); __i__++) \
+		__XFDS_BITS((dst), __i__) = ((__XFDS_BITS((b1), __i__)) | (__XFDS_BITS((b2), __i__))); \
+        }        
+#define XFD_UNSET(dst,b1) { \
+        int __i__; \
+        for (__i__ = 0; __i__ < howmany(FD_SETSIZE, NFDBITS); __i__++) \
+    		__XFDS_BITS((dst), __i__) &= ~(__XFDS_BITS((b1), __i__)); \
+        }
+
+#else /* USE_POLL */
+#include <sys/poll.h>
+#endif /* USE_POLL */
+
+#else /* WIN32 */
+
+#define XFD_SETSIZE	256
+#ifndef FD_SETSIZE
+#define FD_SETSIZE	XFD_SETSIZE
+#endif
+#include <X11/Xwinsock.h>
+
+#define Select(n,r,w,e,t) select(0,(fd_set*)r,(fd_set*)w,(fd_set*)e,(struct timeval*)t)
+
+#define XFD_SETCOUNT(p)	(((fd_set FAR *)(p))->fd_count)
+#define XFD_FD(p,i) (((fd_set FAR *)(p))->fd_array[i])
+#define XFD_ANYSET(p)	XFD_SETCOUNT(p)
+
+#define XFD_COPYSET(src,dst) { \
+    u_int __i; \
+    FD_ZERO(dst); \
+    for (__i = 0; __i < XFD_SETCOUNT(src) ; __i++) { \
+        XFD_FD(dst,__i) = XFD_FD(src,__i); \
+    } \
+    XFD_SETCOUNT(dst) = XFD_SETCOUNT(src); \
+}
+
+#define XFD_ANDSET(dst,b1,b2) { \
+    u_int __i; \
+    FD_ZERO(dst); \
+    for (__i = 0; __i < XFD_SETCOUNT(b1) ; __i++) { \
+        if (FD_ISSET(XFD_FD(b1,__i), b2)) \
+	   FD_SET(XFD_FD(b1,__i), dst); \
+    } \
+}
+
+#define XFD_ORSET(dst,b1,b2) { \
+    u_int __i; \
+    if (dst != b1) XFD_COPYSET(b1,dst); \
+    for (__i = 0; __i < XFD_SETCOUNT(b2) ; __i++) { \
+        if (!FD_ISSET(XFD_FD(b2,__i), dst)) \
+	   FD_SET(XFD_FD(b2,__i), dst); \
+    } \
+}
+
+/* this one is really sub-optimal */
+#define XFD_UNSET(dst,b1) { \
+    u_int __i; \
+    for (__i = 0; __i < XFD_SETCOUNT(b1) ; __i++) { \
+	FD_CLR(XFD_FD(b1,__i), dst); \
+    } \
+}
+
+/* we have to pay the price of having an array here, unlike with bitmasks
+   calling twice FD_SET with the same fd is not transparent, so be careful */
+#undef FD_SET
+#define FD_SET(fd,set) do { \
+    if (XFD_SETCOUNT(set) < FD_SETSIZE && !FD_ISSET(fd,set)) \
+        XFD_FD(set,XFD_SETCOUNT(set)++)=(fd); \
+} while(0)
+
+#define getdtablesize() FD_SETSIZE 
+
+#endif /* WIN32 */
+
+#endif /* _XPOLL_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/keysymdef.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/keysymdef.h
@@ -0,0 +1,2389 @@
+/***********************************************************
+Copyright 1987, 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/*
+ * The "X11 Window System Protocol" standard defines in Appendix A the
+ * keysym codes. These 29-bit integer values identify characters or
+ * functions associated with each key (e.g., via the visible
+ * engraving) of a keyboard layout. This file assigns mnemonic macro
+ * names for these keysyms.
+ *
+ * This file is also compiled (by src/util/makekeys.c in libX11) into
+ * hash tables that can be accessed with X11 library functions such as
+ * XStringToKeysym() and XKeysymToString().
+ *
+ * Where a keysym corresponds one-to-one to an ISO 10646 / Unicode
+ * character, this is noted in a comment that provides both the U+xxxx
+ * Unicode position, as well as the official Unicode name of the
+ * character.
+ *
+ * Where the correspondence is either not one-to-one or semantically
+ * unclear, the Unicode position and name are enclosed in
+ * parentheses. Such legacy keysyms should be considered deprecated
+ * and are not recommended for use in future keyboard mappings.
+ *
+ * For any future extension of the keysyms with characters already
+ * found in ISO 10646 / Unicode, the following algorithm shall be
+ * used. The new keysym code position will simply be the character's
+ * Unicode number plus 0x01000000. The keysym values in the range
+ * 0x01000100 to 0x0110ffff are reserved to represent Unicode
+ * characters in the range U+0100 to U+10FFFF.
+ * 
+ * While most newer Unicode-based X11 clients do already accept
+ * Unicode-mapped keysyms in the range 0x01000100 to 0x0110ffff, it
+ * will remain necessary for clients -- in the interest of
+ * compatibility with existing servers -- to also understand the
+ * existing legacy keysym values in the range 0x0100 to 0x20ff.
+ *
+ * Where several mnemonic names are defined for the same keysym in this
+ * file, all but the first one listed should be considered deprecated.
+ *
+ * Mnemonic names for keysyms are defined in this file with lines
+ * that match one of these Perl regular expressions:
+ *
+ *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\* U+([0-9A-F]{4,6}) (.*) \*\/\s*$/
+ *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*\/\*\(U+([0-9A-F]{4,6}) (.*)\)\*\/\s*$/
+ *    /^\#define XK_([a-zA-Z_0-9]+)\s+0x([0-9a-f]+)\s*(\/\*\s*(.*)\s*\*\/)?\s*$/
+ *
+ * Before adding new keysyms, please do consider the following: In
+ * addition to the keysym names defined in this file, the
+ * XStringToKeysym() and XKeysymToString() functions will also handle
+ * any keysym string of the form "U0020" to "U007E" and "U00A0" to
+ * "U10FFFF" for all possible Unicode characters. In other words,
+ * every possible Unicode character has already a keysym string
+ * defined algorithmically, even if it is not listed here. Therefore,
+ * defining an additional keysym macro is only necessary where a
+ * non-hexadecimal mnemonic name is needed, or where the new keysym
+ * does not represent any existing Unicode character.
+ *
+ * When adding new keysyms to this file, do not forget to also update the
+ * following:
+ *
+ *   - the mappings in src/KeyBind.c in the repo
+ *     git://anongit.freedesktop.org/xorg/lib/libX11
+ *
+ *   - the protocol specification in specs/XProtocol/X11.keysyms
+ *     in the repo git://anongit.freedesktop.org/xorg/doc/xorg-docs
+ *
+ */
+
+#define XK_VoidSymbol                  0xffffff  /* Void symbol */
+
+#ifdef XK_MISCELLANY
+/*
+ * TTY function keys, cleverly chosen to map to ASCII, for convenience of
+ * programming, but could have been arbitrary (at the cost of lookup
+ * tables in client code).
+ */
+
+#define XK_BackSpace                     0xff08  /* Back space, back char */
+#define XK_Tab                           0xff09
+#define XK_Linefeed                      0xff0a  /* Linefeed, LF */
+#define XK_Clear                         0xff0b
+#define XK_Return                        0xff0d  /* Return, enter */
+#define XK_Pause                         0xff13  /* Pause, hold */
+#define XK_Scroll_Lock                   0xff14
+#define XK_Sys_Req                       0xff15
+#define XK_Escape                        0xff1b
+#define XK_Delete                        0xffff  /* Delete, rubout */
+
+
+
+/* International & multi-key character composition */
+
+#define XK_Multi_key                     0xff20  /* Multi-key character compose */
+#define XK_Codeinput                     0xff37
+#define XK_SingleCandidate               0xff3c
+#define XK_MultipleCandidate             0xff3d
+#define XK_PreviousCandidate             0xff3e
+
+/* Japanese keyboard support */
+
+#define XK_Kanji                         0xff21  /* Kanji, Kanji convert */
+#define XK_Muhenkan                      0xff22  /* Cancel Conversion */
+#define XK_Henkan_Mode                   0xff23  /* Start/Stop Conversion */
+#define XK_Henkan                        0xff23  /* Alias for Henkan_Mode */
+#define XK_Romaji                        0xff24  /* to Romaji */
+#define XK_Hiragana                      0xff25  /* to Hiragana */
+#define XK_Katakana                      0xff26  /* to Katakana */
+#define XK_Hiragana_Katakana             0xff27  /* Hiragana/Katakana toggle */
+#define XK_Zenkaku                       0xff28  /* to Zenkaku */
+#define XK_Hankaku                       0xff29  /* to Hankaku */
+#define XK_Zenkaku_Hankaku               0xff2a  /* Zenkaku/Hankaku toggle */
+#define XK_Touroku                       0xff2b  /* Add to Dictionary */
+#define XK_Massyo                        0xff2c  /* Delete from Dictionary */
+#define XK_Kana_Lock                     0xff2d  /* Kana Lock */
+#define XK_Kana_Shift                    0xff2e  /* Kana Shift */
+#define XK_Eisu_Shift                    0xff2f  /* Alphanumeric Shift */
+#define XK_Eisu_toggle                   0xff30  /* Alphanumeric toggle */
+#define XK_Kanji_Bangou                  0xff37  /* Codeinput */
+#define XK_Zen_Koho                      0xff3d  /* Multiple/All Candidate(s) */
+#define XK_Mae_Koho                      0xff3e  /* Previous Candidate */
+
+/* 0xff31 thru 0xff3f are under XK_KOREAN */
+
+/* Cursor control & motion */
+
+#define XK_Home                          0xff50
+#define XK_Left                          0xff51  /* Move left, left arrow */
+#define XK_Up                            0xff52  /* Move up, up arrow */
+#define XK_Right                         0xff53  /* Move right, right arrow */
+#define XK_Down                          0xff54  /* Move down, down arrow */
+#define XK_Prior                         0xff55  /* Prior, previous */
+#define XK_Page_Up                       0xff55
+#define XK_Next                          0xff56  /* Next */
+#define XK_Page_Down                     0xff56
+#define XK_End                           0xff57  /* EOL */
+#define XK_Begin                         0xff58  /* BOL */
+
+
+/* Misc functions */
+
+#define XK_Select                        0xff60  /* Select, mark */
+#define XK_Print                         0xff61
+#define XK_Execute                       0xff62  /* Execute, run, do */
+#define XK_Insert                        0xff63  /* Insert, insert here */
+#define XK_Undo                          0xff65
+#define XK_Redo                          0xff66  /* Redo, again */
+#define XK_Menu                          0xff67
+#define XK_Find                          0xff68  /* Find, search */
+#define XK_Cancel                        0xff69  /* Cancel, stop, abort, exit */
+#define XK_Help                          0xff6a  /* Help */
+#define XK_Break                         0xff6b
+#define XK_Mode_switch                   0xff7e  /* Character set switch */
+#define XK_script_switch                 0xff7e  /* Alias for mode_switch */
+#define XK_Num_Lock                      0xff7f
+
+/* Keypad functions, keypad numbers cleverly chosen to map to ASCII */
+
+#define XK_KP_Space                      0xff80  /* Space */
+#define XK_KP_Tab                        0xff89
+#define XK_KP_Enter                      0xff8d  /* Enter */
+#define XK_KP_F1                         0xff91  /* PF1, KP_A, ... */
+#define XK_KP_F2                         0xff92
+#define XK_KP_F3                         0xff93
+#define XK_KP_F4                         0xff94
+#define XK_KP_Home                       0xff95
+#define XK_KP_Left                       0xff96
+#define XK_KP_Up                         0xff97
+#define XK_KP_Right                      0xff98
+#define XK_KP_Down                       0xff99
+#define XK_KP_Prior                      0xff9a
+#define XK_KP_Page_Up                    0xff9a
+#define XK_KP_Next                       0xff9b
+#define XK_KP_Page_Down                  0xff9b
+#define XK_KP_End                        0xff9c
+#define XK_KP_Begin                      0xff9d
+#define XK_KP_Insert                     0xff9e
+#define XK_KP_Delete                     0xff9f
+#define XK_KP_Equal                      0xffbd  /* Equals */
+#define XK_KP_Multiply                   0xffaa
+#define XK_KP_Add                        0xffab
+#define XK_KP_Separator                  0xffac  /* Separator, often comma */
+#define XK_KP_Subtract                   0xffad
+#define XK_KP_Decimal                    0xffae
+#define XK_KP_Divide                     0xffaf
+
+#define XK_KP_0                          0xffb0
+#define XK_KP_1                          0xffb1
+#define XK_KP_2                          0xffb2
+#define XK_KP_3                          0xffb3
+#define XK_KP_4                          0xffb4
+#define XK_KP_5                          0xffb5
+#define XK_KP_6                          0xffb6
+#define XK_KP_7                          0xffb7
+#define XK_KP_8                          0xffb8
+#define XK_KP_9                          0xffb9
+
+
+
+/*
+ * Auxiliary functions; note the duplicate definitions for left and right
+ * function keys;  Sun keyboards and a few other manufacturers have such
+ * function key groups on the left and/or right sides of the keyboard.
+ * We've not found a keyboard with more than 35 function keys total.
+ */
+
+#define XK_F1                            0xffbe
+#define XK_F2                            0xffbf
+#define XK_F3                            0xffc0
+#define XK_F4                            0xffc1
+#define XK_F5                            0xffc2
+#define XK_F6                            0xffc3
+#define XK_F7                            0xffc4
+#define XK_F8                            0xffc5
+#define XK_F9                            0xffc6
+#define XK_F10                           0xffc7
+#define XK_F11                           0xffc8
+#define XK_L1                            0xffc8
+#define XK_F12                           0xffc9
+#define XK_L2                            0xffc9
+#define XK_F13                           0xffca
+#define XK_L3                            0xffca
+#define XK_F14                           0xffcb
+#define XK_L4                            0xffcb
+#define XK_F15                           0xffcc
+#define XK_L5                            0xffcc
+#define XK_F16                           0xffcd
+#define XK_L6                            0xffcd
+#define XK_F17                           0xffce
+#define XK_L7                            0xffce
+#define XK_F18                           0xffcf
+#define XK_L8                            0xffcf
+#define XK_F19                           0xffd0
+#define XK_L9                            0xffd0
+#define XK_F20                           0xffd1
+#define XK_L10                           0xffd1
+#define XK_F21                           0xffd2
+#define XK_R1                            0xffd2
+#define XK_F22                           0xffd3
+#define XK_R2                            0xffd3
+#define XK_F23                           0xffd4
+#define XK_R3                            0xffd4
+#define XK_F24                           0xffd5
+#define XK_R4                            0xffd5
+#define XK_F25                           0xffd6
+#define XK_R5                            0xffd6
+#define XK_F26                           0xffd7
+#define XK_R6                            0xffd7
+#define XK_F27                           0xffd8
+#define XK_R7                            0xffd8
+#define XK_F28                           0xffd9
+#define XK_R8                            0xffd9
+#define XK_F29                           0xffda
+#define XK_R9                            0xffda
+#define XK_F30                           0xffdb
+#define XK_R10                           0xffdb
+#define XK_F31                           0xffdc
+#define XK_R11                           0xffdc
+#define XK_F32                           0xffdd
+#define XK_R12                           0xffdd
+#define XK_F33                           0xffde
+#define XK_R13                           0xffde
+#define XK_F34                           0xffdf
+#define XK_R14                           0xffdf
+#define XK_F35                           0xffe0
+#define XK_R15                           0xffe0
+
+/* Modifiers */
+
+#define XK_Shift_L                       0xffe1  /* Left shift */
+#define XK_Shift_R                       0xffe2  /* Right shift */
+#define XK_Control_L                     0xffe3  /* Left control */
+#define XK_Control_R                     0xffe4  /* Right control */
+#define XK_Caps_Lock                     0xffe5  /* Caps lock */
+#define XK_Shift_Lock                    0xffe6  /* Shift lock */
+
+#define XK_Meta_L                        0xffe7  /* Left meta */
+#define XK_Meta_R                        0xffe8  /* Right meta */
+#define XK_Alt_L                         0xffe9  /* Left alt */
+#define XK_Alt_R                         0xffea  /* Right alt */
+#define XK_Super_L                       0xffeb  /* Left super */
+#define XK_Super_R                       0xffec  /* Right super */
+#define XK_Hyper_L                       0xffed  /* Left hyper */
+#define XK_Hyper_R                       0xffee  /* Right hyper */
+#endif /* XK_MISCELLANY */
+
+/*
+ * Keyboard (XKB) Extension function and modifier keys
+ * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
+ * Byte 3 = 0xfe
+ */
+
+#ifdef XK_XKB_KEYS
+#define XK_ISO_Lock                      0xfe01
+#define XK_ISO_Level2_Latch              0xfe02
+#define XK_ISO_Level3_Shift              0xfe03
+#define XK_ISO_Level3_Latch              0xfe04
+#define XK_ISO_Level3_Lock               0xfe05
+#define XK_ISO_Level5_Shift              0xfe11
+#define XK_ISO_Level5_Latch              0xfe12
+#define XK_ISO_Level5_Lock               0xfe13
+#define XK_ISO_Group_Shift               0xff7e  /* Alias for mode_switch */
+#define XK_ISO_Group_Latch               0xfe06
+#define XK_ISO_Group_Lock                0xfe07
+#define XK_ISO_Next_Group                0xfe08
+#define XK_ISO_Next_Group_Lock           0xfe09
+#define XK_ISO_Prev_Group                0xfe0a
+#define XK_ISO_Prev_Group_Lock           0xfe0b
+#define XK_ISO_First_Group               0xfe0c
+#define XK_ISO_First_Group_Lock          0xfe0d
+#define XK_ISO_Last_Group                0xfe0e
+#define XK_ISO_Last_Group_Lock           0xfe0f
+
+#define XK_ISO_Left_Tab                  0xfe20
+#define XK_ISO_Move_Line_Up              0xfe21
+#define XK_ISO_Move_Line_Down            0xfe22
+#define XK_ISO_Partial_Line_Up           0xfe23
+#define XK_ISO_Partial_Line_Down         0xfe24
+#define XK_ISO_Partial_Space_Left        0xfe25
+#define XK_ISO_Partial_Space_Right       0xfe26
+#define XK_ISO_Set_Margin_Left           0xfe27
+#define XK_ISO_Set_Margin_Right          0xfe28
+#define XK_ISO_Release_Margin_Left       0xfe29
+#define XK_ISO_Release_Margin_Right      0xfe2a
+#define XK_ISO_Release_Both_Margins      0xfe2b
+#define XK_ISO_Fast_Cursor_Left          0xfe2c
+#define XK_ISO_Fast_Cursor_Right         0xfe2d
+#define XK_ISO_Fast_Cursor_Up            0xfe2e
+#define XK_ISO_Fast_Cursor_Down          0xfe2f
+#define XK_ISO_Continuous_Underline      0xfe30
+#define XK_ISO_Discontinuous_Underline   0xfe31
+#define XK_ISO_Emphasize                 0xfe32
+#define XK_ISO_Center_Object             0xfe33
+#define XK_ISO_Enter                     0xfe34
+
+#define XK_dead_grave                    0xfe50
+#define XK_dead_acute                    0xfe51
+#define XK_dead_circumflex               0xfe52
+#define XK_dead_tilde                    0xfe53
+#define XK_dead_perispomeni              0xfe53  /* alias for dead_tilde */
+#define XK_dead_macron                   0xfe54
+#define XK_dead_breve                    0xfe55
+#define XK_dead_abovedot                 0xfe56
+#define XK_dead_diaeresis                0xfe57
+#define XK_dead_abovering                0xfe58
+#define XK_dead_doubleacute              0xfe59
+#define XK_dead_caron                    0xfe5a
+#define XK_dead_cedilla                  0xfe5b
+#define XK_dead_ogonek                   0xfe5c
+#define XK_dead_iota                     0xfe5d
+#define XK_dead_voiced_sound             0xfe5e
+#define XK_dead_semivoiced_sound         0xfe5f
+#define XK_dead_belowdot                 0xfe60
+#define XK_dead_hook                     0xfe61
+#define XK_dead_horn                     0xfe62
+#define XK_dead_stroke                   0xfe63
+#define XK_dead_abovecomma               0xfe64
+#define XK_dead_psili                    0xfe64  /* alias for dead_abovecomma */
+#define XK_dead_abovereversedcomma       0xfe65
+#define XK_dead_dasia                    0xfe65  /* alias for dead_abovereversedcomma */
+#define XK_dead_doublegrave              0xfe66
+#define XK_dead_belowring                0xfe67
+#define XK_dead_belowmacron              0xfe68
+#define XK_dead_belowcircumflex          0xfe69
+#define XK_dead_belowtilde               0xfe6a
+#define XK_dead_belowbreve               0xfe6b
+#define XK_dead_belowdiaeresis           0xfe6c
+#define XK_dead_invertedbreve            0xfe6d
+#define XK_dead_belowcomma               0xfe6e
+#define XK_dead_currency                 0xfe6f
+
+/* dead vowels for universal syllable entry */
+#define XK_dead_a                        0xfe80
+#define XK_dead_A                        0xfe81
+#define XK_dead_e                        0xfe82
+#define XK_dead_E                        0xfe83
+#define XK_dead_i                        0xfe84
+#define XK_dead_I                        0xfe85
+#define XK_dead_o                        0xfe86
+#define XK_dead_O                        0xfe87
+#define XK_dead_u                        0xfe88
+#define XK_dead_U                        0xfe89
+#define XK_dead_small_schwa              0xfe8a
+#define XK_dead_capital_schwa            0xfe8b
+
+#define XK_First_Virtual_Screen          0xfed0
+#define XK_Prev_Virtual_Screen           0xfed1
+#define XK_Next_Virtual_Screen           0xfed2
+#define XK_Last_Virtual_Screen           0xfed4
+#define XK_Terminate_Server              0xfed5
+
+#define XK_AccessX_Enable                0xfe70
+#define XK_AccessX_Feedback_Enable       0xfe71
+#define XK_RepeatKeys_Enable             0xfe72
+#define XK_SlowKeys_Enable               0xfe73
+#define XK_BounceKeys_Enable             0xfe74
+#define XK_StickyKeys_Enable             0xfe75
+#define XK_MouseKeys_Enable              0xfe76
+#define XK_MouseKeys_Accel_Enable        0xfe77
+#define XK_Overlay1_Enable               0xfe78
+#define XK_Overlay2_Enable               0xfe79
+#define XK_AudibleBell_Enable            0xfe7a
+
+#define XK_Pointer_Left                  0xfee0
+#define XK_Pointer_Right                 0xfee1
+#define XK_Pointer_Up                    0xfee2
+#define XK_Pointer_Down                  0xfee3
+#define XK_Pointer_UpLeft                0xfee4
+#define XK_Pointer_UpRight               0xfee5
+#define XK_Pointer_DownLeft              0xfee6
+#define XK_Pointer_DownRight             0xfee7
+#define XK_Pointer_Button_Dflt           0xfee8
+#define XK_Pointer_Button1               0xfee9
+#define XK_Pointer_Button2               0xfeea
+#define XK_Pointer_Button3               0xfeeb
+#define XK_Pointer_Button4               0xfeec
+#define XK_Pointer_Button5               0xfeed
+#define XK_Pointer_DblClick_Dflt         0xfeee
+#define XK_Pointer_DblClick1             0xfeef
+#define XK_Pointer_DblClick2             0xfef0
+#define XK_Pointer_DblClick3             0xfef1
+#define XK_Pointer_DblClick4             0xfef2
+#define XK_Pointer_DblClick5             0xfef3
+#define XK_Pointer_Drag_Dflt             0xfef4
+#define XK_Pointer_Drag1                 0xfef5
+#define XK_Pointer_Drag2                 0xfef6
+#define XK_Pointer_Drag3                 0xfef7
+#define XK_Pointer_Drag4                 0xfef8
+#define XK_Pointer_Drag5                 0xfefd
+
+#define XK_Pointer_EnableKeys            0xfef9
+#define XK_Pointer_Accelerate            0xfefa
+#define XK_Pointer_DfltBtnNext           0xfefb
+#define XK_Pointer_DfltBtnPrev           0xfefc
+
+#endif /* XK_XKB_KEYS */
+
+/*
+ * 3270 Terminal Keys
+ * Byte 3 = 0xfd
+ */
+
+#ifdef XK_3270
+#define XK_3270_Duplicate                0xfd01
+#define XK_3270_FieldMark                0xfd02
+#define XK_3270_Right2                   0xfd03
+#define XK_3270_Left2                    0xfd04
+#define XK_3270_BackTab                  0xfd05
+#define XK_3270_EraseEOF                 0xfd06
+#define XK_3270_EraseInput               0xfd07
+#define XK_3270_Reset                    0xfd08
+#define XK_3270_Quit                     0xfd09
+#define XK_3270_PA1                      0xfd0a
+#define XK_3270_PA2                      0xfd0b
+#define XK_3270_PA3                      0xfd0c
+#define XK_3270_Test                     0xfd0d
+#define XK_3270_Attn                     0xfd0e
+#define XK_3270_CursorBlink              0xfd0f
+#define XK_3270_AltCursor                0xfd10
+#define XK_3270_KeyClick                 0xfd11
+#define XK_3270_Jump                     0xfd12
+#define XK_3270_Ident                    0xfd13
+#define XK_3270_Rule                     0xfd14
+#define XK_3270_Copy                     0xfd15
+#define XK_3270_Play                     0xfd16
+#define XK_3270_Setup                    0xfd17
+#define XK_3270_Record                   0xfd18
+#define XK_3270_ChangeScreen             0xfd19
+#define XK_3270_DeleteWord               0xfd1a
+#define XK_3270_ExSelect                 0xfd1b
+#define XK_3270_CursorSelect             0xfd1c
+#define XK_3270_PrintScreen              0xfd1d
+#define XK_3270_Enter                    0xfd1e
+#endif /* XK_3270 */
+
+/*
+ * Latin 1
+ * (ISO/IEC 8859-1 = Unicode U+0020..U+00FF)
+ * Byte 3 = 0
+ */
+#ifdef XK_LATIN1
+#define XK_space                         0x0020  /* U+0020 SPACE */
+#define XK_exclam                        0x0021  /* U+0021 EXCLAMATION MARK */
+#define XK_quotedbl                      0x0022  /* U+0022 QUOTATION MARK */
+#define XK_numbersign                    0x0023  /* U+0023 NUMBER SIGN */
+#define XK_dollar                        0x0024  /* U+0024 DOLLAR SIGN */
+#define XK_percent                       0x0025  /* U+0025 PERCENT SIGN */
+#define XK_ampersand                     0x0026  /* U+0026 AMPERSAND */
+#define XK_apostrophe                    0x0027  /* U+0027 APOSTROPHE */
+#define XK_quoteright                    0x0027  /* deprecated */
+#define XK_parenleft                     0x0028  /* U+0028 LEFT PARENTHESIS */
+#define XK_parenright                    0x0029  /* U+0029 RIGHT PARENTHESIS */
+#define XK_asterisk                      0x002a  /* U+002A ASTERISK */
+#define XK_plus                          0x002b  /* U+002B PLUS SIGN */
+#define XK_comma                         0x002c  /* U+002C COMMA */
+#define XK_minus                         0x002d  /* U+002D HYPHEN-MINUS */
+#define XK_period                        0x002e  /* U+002E FULL STOP */
+#define XK_slash                         0x002f  /* U+002F SOLIDUS */
+#define XK_0                             0x0030  /* U+0030 DIGIT ZERO */
+#define XK_1                             0x0031  /* U+0031 DIGIT ONE */
+#define XK_2                             0x0032  /* U+0032 DIGIT TWO */
+#define XK_3                             0x0033  /* U+0033 DIGIT THREE */
+#define XK_4                             0x0034  /* U+0034 DIGIT FOUR */
+#define XK_5                             0x0035  /* U+0035 DIGIT FIVE */
+#define XK_6                             0x0036  /* U+0036 DIGIT SIX */
+#define XK_7                             0x0037  /* U+0037 DIGIT SEVEN */
+#define XK_8                             0x0038  /* U+0038 DIGIT EIGHT */
+#define XK_9                             0x0039  /* U+0039 DIGIT NINE */
+#define XK_colon                         0x003a  /* U+003A COLON */
+#define XK_semicolon                     0x003b  /* U+003B SEMICOLON */
+#define XK_less                          0x003c  /* U+003C LESS-THAN SIGN */
+#define XK_equal                         0x003d  /* U+003D EQUALS SIGN */
+#define XK_greater                       0x003e  /* U+003E GREATER-THAN SIGN */
+#define XK_question                      0x003f  /* U+003F QUESTION MARK */
+#define XK_at                            0x0040  /* U+0040 COMMERCIAL AT */
+#define XK_A                             0x0041  /* U+0041 LATIN CAPITAL LETTER A */
+#define XK_B                             0x0042  /* U+0042 LATIN CAPITAL LETTER B */
+#define XK_C                             0x0043  /* U+0043 LATIN CAPITAL LETTER C */
+#define XK_D                             0x0044  /* U+0044 LATIN CAPITAL LETTER D */
+#define XK_E                             0x0045  /* U+0045 LATIN CAPITAL LETTER E */
+#define XK_F                             0x0046  /* U+0046 LATIN CAPITAL LETTER F */
+#define XK_G                             0x0047  /* U+0047 LATIN CAPITAL LETTER G */
+#define XK_H                             0x0048  /* U+0048 LATIN CAPITAL LETTER H */
+#define XK_I                             0x0049  /* U+0049 LATIN CAPITAL LETTER I */
+#define XK_J                             0x004a  /* U+004A LATIN CAPITAL LETTER J */
+#define XK_K                             0x004b  /* U+004B LATIN CAPITAL LETTER K */
+#define XK_L                             0x004c  /* U+004C LATIN CAPITAL LETTER L */
+#define XK_M                             0x004d  /* U+004D LATIN CAPITAL LETTER M */
+#define XK_N                             0x004e  /* U+004E LATIN CAPITAL LETTER N */
+#define XK_O                             0x004f  /* U+004F LATIN CAPITAL LETTER O */
+#define XK_P                             0x0050  /* U+0050 LATIN CAPITAL LETTER P */
+#define XK_Q                             0x0051  /* U+0051 LATIN CAPITAL LETTER Q */
+#define XK_R                             0x0052  /* U+0052 LATIN CAPITAL LETTER R */
+#define XK_S                             0x0053  /* U+0053 LATIN CAPITAL LETTER S */
+#define XK_T                             0x0054  /* U+0054 LATIN CAPITAL LETTER T */
+#define XK_U                             0x0055  /* U+0055 LATIN CAPITAL LETTER U */
+#define XK_V                             0x0056  /* U+0056 LATIN CAPITAL LETTER V */
+#define XK_W                             0x0057  /* U+0057 LATIN CAPITAL LETTER W */
+#define XK_X                             0x0058  /* U+0058 LATIN CAPITAL LETTER X */
+#define XK_Y                             0x0059  /* U+0059 LATIN CAPITAL LETTER Y */
+#define XK_Z                             0x005a  /* U+005A LATIN CAPITAL LETTER Z */
+#define XK_bracketleft                   0x005b  /* U+005B LEFT SQUARE BRACKET */
+#define XK_backslash                     0x005c  /* U+005C REVERSE SOLIDUS */
+#define XK_bracketright                  0x005d  /* U+005D RIGHT SQUARE BRACKET */
+#define XK_asciicircum                   0x005e  /* U+005E CIRCUMFLEX ACCENT */
+#define XK_underscore                    0x005f  /* U+005F LOW LINE */
+#define XK_grave                         0x0060  /* U+0060 GRAVE ACCENT */
+#define XK_quoteleft                     0x0060  /* deprecated */
+#define XK_a                             0x0061  /* U+0061 LATIN SMALL LETTER A */
+#define XK_b                             0x0062  /* U+0062 LATIN SMALL LETTER B */
+#define XK_c                             0x0063  /* U+0063 LATIN SMALL LETTER C */
+#define XK_d                             0x0064  /* U+0064 LATIN SMALL LETTER D */
+#define XK_e                             0x0065  /* U+0065 LATIN SMALL LETTER E */
+#define XK_f                             0x0066  /* U+0066 LATIN SMALL LETTER F */
+#define XK_g                             0x0067  /* U+0067 LATIN SMALL LETTER G */
+#define XK_h                             0x0068  /* U+0068 LATIN SMALL LETTER H */
+#define XK_i                             0x0069  /* U+0069 LATIN SMALL LETTER I */
+#define XK_j                             0x006a  /* U+006A LATIN SMALL LETTER J */
+#define XK_k                             0x006b  /* U+006B LATIN SMALL LETTER K */
+#define XK_l                             0x006c  /* U+006C LATIN SMALL LETTER L */
+#define XK_m                             0x006d  /* U+006D LATIN SMALL LETTER M */
+#define XK_n                             0x006e  /* U+006E LATIN SMALL LETTER N */
+#define XK_o                             0x006f  /* U+006F LATIN SMALL LETTER O */
+#define XK_p                             0x0070  /* U+0070 LATIN SMALL LETTER P */
+#define XK_q                             0x0071  /* U+0071 LATIN SMALL LETTER Q */
+#define XK_r                             0x0072  /* U+0072 LATIN SMALL LETTER R */
+#define XK_s                             0x0073  /* U+0073 LATIN SMALL LETTER S */
+#define XK_t                             0x0074  /* U+0074 LATIN SMALL LETTER T */
+#define XK_u                             0x0075  /* U+0075 LATIN SMALL LETTER U */
+#define XK_v                             0x0076  /* U+0076 LATIN SMALL LETTER V */
+#define XK_w                             0x0077  /* U+0077 LATIN SMALL LETTER W */
+#define XK_x                             0x0078  /* U+0078 LATIN SMALL LETTER X */
+#define XK_y                             0x0079  /* U+0079 LATIN SMALL LETTER Y */
+#define XK_z                             0x007a  /* U+007A LATIN SMALL LETTER Z */
+#define XK_braceleft                     0x007b  /* U+007B LEFT CURLY BRACKET */
+#define XK_bar                           0x007c  /* U+007C VERTICAL LINE */
+#define XK_braceright                    0x007d  /* U+007D RIGHT CURLY BRACKET */
+#define XK_asciitilde                    0x007e  /* U+007E TILDE */
+
+#define XK_nobreakspace                  0x00a0  /* U+00A0 NO-BREAK SPACE */
+#define XK_exclamdown                    0x00a1  /* U+00A1 INVERTED EXCLAMATION MARK */
+#define XK_cent                          0x00a2  /* U+00A2 CENT SIGN */
+#define XK_sterling                      0x00a3  /* U+00A3 POUND SIGN */
+#define XK_currency                      0x00a4  /* U+00A4 CURRENCY SIGN */
+#define XK_yen                           0x00a5  /* U+00A5 YEN SIGN */
+#define XK_brokenbar                     0x00a6  /* U+00A6 BROKEN BAR */
+#define XK_section                       0x00a7  /* U+00A7 SECTION SIGN */
+#define XK_diaeresis                     0x00a8  /* U+00A8 DIAERESIS */
+#define XK_copyright                     0x00a9  /* U+00A9 COPYRIGHT SIGN */
+#define XK_ordfeminine                   0x00aa  /* U+00AA FEMININE ORDINAL INDICATOR */
+#define XK_guillemotleft                 0x00ab  /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
+#define XK_notsign                       0x00ac  /* U+00AC NOT SIGN */
+#define XK_hyphen                        0x00ad  /* U+00AD SOFT HYPHEN */
+#define XK_registered                    0x00ae  /* U+00AE REGISTERED SIGN */
+#define XK_macron                        0x00af  /* U+00AF MACRON */
+#define XK_degree                        0x00b0  /* U+00B0 DEGREE SIGN */
+#define XK_plusminus                     0x00b1  /* U+00B1 PLUS-MINUS SIGN */
+#define XK_twosuperior                   0x00b2  /* U+00B2 SUPERSCRIPT TWO */
+#define XK_threesuperior                 0x00b3  /* U+00B3 SUPERSCRIPT THREE */
+#define XK_acute                         0x00b4  /* U+00B4 ACUTE ACCENT */
+#define XK_mu                            0x00b5  /* U+00B5 MICRO SIGN */
+#define XK_paragraph                     0x00b6  /* U+00B6 PILCROW SIGN */
+#define XK_periodcentered                0x00b7  /* U+00B7 MIDDLE DOT */
+#define XK_cedilla                       0x00b8  /* U+00B8 CEDILLA */
+#define XK_onesuperior                   0x00b9  /* U+00B9 SUPERSCRIPT ONE */
+#define XK_masculine                     0x00ba  /* U+00BA MASCULINE ORDINAL INDICATOR */
+#define XK_guillemotright                0x00bb  /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
+#define XK_onequarter                    0x00bc  /* U+00BC VULGAR FRACTION ONE QUARTER */
+#define XK_onehalf                       0x00bd  /* U+00BD VULGAR FRACTION ONE HALF */
+#define XK_threequarters                 0x00be  /* U+00BE VULGAR FRACTION THREE QUARTERS */
+#define XK_questiondown                  0x00bf  /* U+00BF INVERTED QUESTION MARK */
+#define XK_Agrave                        0x00c0  /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
+#define XK_Aacute                        0x00c1  /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
+#define XK_Acircumflex                   0x00c2  /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
+#define XK_Atilde                        0x00c3  /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
+#define XK_Adiaeresis                    0x00c4  /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
+#define XK_Aring                         0x00c5  /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
+#define XK_AE                            0x00c6  /* U+00C6 LATIN CAPITAL LETTER AE */
+#define XK_Ccedilla                      0x00c7  /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
+#define XK_Egrave                        0x00c8  /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
+#define XK_Eacute                        0x00c9  /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
+#define XK_Ecircumflex                   0x00ca  /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
+#define XK_Ediaeresis                    0x00cb  /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
+#define XK_Igrave                        0x00cc  /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
+#define XK_Iacute                        0x00cd  /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
+#define XK_Icircumflex                   0x00ce  /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
+#define XK_Idiaeresis                    0x00cf  /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
+#define XK_ETH                           0x00d0  /* U+00D0 LATIN CAPITAL LETTER ETH */
+#define XK_Eth                           0x00d0  /* deprecated */
+#define XK_Ntilde                        0x00d1  /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
+#define XK_Ograve                        0x00d2  /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
+#define XK_Oacute                        0x00d3  /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
+#define XK_Ocircumflex                   0x00d4  /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
+#define XK_Otilde                        0x00d5  /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
+#define XK_Odiaeresis                    0x00d6  /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
+#define XK_multiply                      0x00d7  /* U+00D7 MULTIPLICATION SIGN */
+#define XK_Oslash                        0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+#define XK_Ooblique                      0x00d8  /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
+#define XK_Ugrave                        0x00d9  /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
+#define XK_Uacute                        0x00da  /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
+#define XK_Ucircumflex                   0x00db  /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
+#define XK_Udiaeresis                    0x00dc  /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
+#define XK_Yacute                        0x00dd  /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
+#define XK_THORN                         0x00de  /* U+00DE LATIN CAPITAL LETTER THORN */
+#define XK_Thorn                         0x00de  /* deprecated */
+#define XK_ssharp                        0x00df  /* U+00DF LATIN SMALL LETTER SHARP S */
+#define XK_agrave                        0x00e0  /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
+#define XK_aacute                        0x00e1  /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
+#define XK_acircumflex                   0x00e2  /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
+#define XK_atilde                        0x00e3  /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
+#define XK_adiaeresis                    0x00e4  /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
+#define XK_aring                         0x00e5  /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
+#define XK_ae                            0x00e6  /* U+00E6 LATIN SMALL LETTER AE */
+#define XK_ccedilla                      0x00e7  /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
+#define XK_egrave                        0x00e8  /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
+#define XK_eacute                        0x00e9  /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
+#define XK_ecircumflex                   0x00ea  /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
+#define XK_ediaeresis                    0x00eb  /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
+#define XK_igrave                        0x00ec  /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
+#define XK_iacute                        0x00ed  /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
+#define XK_icircumflex                   0x00ee  /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
+#define XK_idiaeresis                    0x00ef  /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
+#define XK_eth                           0x00f0  /* U+00F0 LATIN SMALL LETTER ETH */
+#define XK_ntilde                        0x00f1  /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
+#define XK_ograve                        0x00f2  /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
+#define XK_oacute                        0x00f3  /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
+#define XK_ocircumflex                   0x00f4  /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
+#define XK_otilde                        0x00f5  /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
+#define XK_odiaeresis                    0x00f6  /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
+#define XK_division                      0x00f7  /* U+00F7 DIVISION SIGN */
+#define XK_oslash                        0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+#define XK_ooblique                      0x00f8  /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
+#define XK_ugrave                        0x00f9  /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
+#define XK_uacute                        0x00fa  /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
+#define XK_ucircumflex                   0x00fb  /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
+#define XK_udiaeresis                    0x00fc  /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
+#define XK_yacute                        0x00fd  /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
+#define XK_thorn                         0x00fe  /* U+00FE LATIN SMALL LETTER THORN */
+#define XK_ydiaeresis                    0x00ff  /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */
+#endif /* XK_LATIN1 */
+
+/*
+ * Latin 2
+ * Byte 3 = 1
+ */
+
+#ifdef XK_LATIN2
+#define XK_Aogonek                       0x01a1  /* U+0104 LATIN CAPITAL LETTER A WITH OGONEK */
+#define XK_breve                         0x01a2  /* U+02D8 BREVE */
+#define XK_Lstroke                       0x01a3  /* U+0141 LATIN CAPITAL LETTER L WITH STROKE */
+#define XK_Lcaron                        0x01a5  /* U+013D LATIN CAPITAL LETTER L WITH CARON */
+#define XK_Sacute                        0x01a6  /* U+015A LATIN CAPITAL LETTER S WITH ACUTE */
+#define XK_Scaron                        0x01a9  /* U+0160 LATIN CAPITAL LETTER S WITH CARON */
+#define XK_Scedilla                      0x01aa  /* U+015E LATIN CAPITAL LETTER S WITH CEDILLA */
+#define XK_Tcaron                        0x01ab  /* U+0164 LATIN CAPITAL LETTER T WITH CARON */
+#define XK_Zacute                        0x01ac  /* U+0179 LATIN CAPITAL LETTER Z WITH ACUTE */
+#define XK_Zcaron                        0x01ae  /* U+017D LATIN CAPITAL LETTER Z WITH CARON */
+#define XK_Zabovedot                     0x01af  /* U+017B LATIN CAPITAL LETTER Z WITH DOT ABOVE */
+#define XK_aogonek                       0x01b1  /* U+0105 LATIN SMALL LETTER A WITH OGONEK */
+#define XK_ogonek                        0x01b2  /* U+02DB OGONEK */
+#define XK_lstroke                       0x01b3  /* U+0142 LATIN SMALL LETTER L WITH STROKE */
+#define XK_lcaron                        0x01b5  /* U+013E LATIN SMALL LETTER L WITH CARON */
+#define XK_sacute                        0x01b6  /* U+015B LATIN SMALL LETTER S WITH ACUTE */
+#define XK_caron                         0x01b7  /* U+02C7 CARON */
+#define XK_scaron                        0x01b9  /* U+0161 LATIN SMALL LETTER S WITH CARON */
+#define XK_scedilla                      0x01ba  /* U+015F LATIN SMALL LETTER S WITH CEDILLA */
+#define XK_tcaron                        0x01bb  /* U+0165 LATIN SMALL LETTER T WITH CARON */
+#define XK_zacute                        0x01bc  /* U+017A LATIN SMALL LETTER Z WITH ACUTE */
+#define XK_doubleacute                   0x01bd  /* U+02DD DOUBLE ACUTE ACCENT */
+#define XK_zcaron                        0x01be  /* U+017E LATIN SMALL LETTER Z WITH CARON */
+#define XK_zabovedot                     0x01bf  /* U+017C LATIN SMALL LETTER Z WITH DOT ABOVE */
+#define XK_Racute                        0x01c0  /* U+0154 LATIN CAPITAL LETTER R WITH ACUTE */
+#define XK_Abreve                        0x01c3  /* U+0102 LATIN CAPITAL LETTER A WITH BREVE */
+#define XK_Lacute                        0x01c5  /* U+0139 LATIN CAPITAL LETTER L WITH ACUTE */
+#define XK_Cacute                        0x01c6  /* U+0106 LATIN CAPITAL LETTER C WITH ACUTE */
+#define XK_Ccaron                        0x01c8  /* U+010C LATIN CAPITAL LETTER C WITH CARON */
+#define XK_Eogonek                       0x01ca  /* U+0118 LATIN CAPITAL LETTER E WITH OGONEK */
+#define XK_Ecaron                        0x01cc  /* U+011A LATIN CAPITAL LETTER E WITH CARON */
+#define XK_Dcaron                        0x01cf  /* U+010E LATIN CAPITAL LETTER D WITH CARON */
+#define XK_Dstroke                       0x01d0  /* U+0110 LATIN CAPITAL LETTER D WITH STROKE */
+#define XK_Nacute                        0x01d1  /* U+0143 LATIN CAPITAL LETTER N WITH ACUTE */
+#define XK_Ncaron                        0x01d2  /* U+0147 LATIN CAPITAL LETTER N WITH CARON */
+#define XK_Odoubleacute                  0x01d5  /* U+0150 LATIN CAPITAL LETTER O WITH DOUBLE ACUTE */
+#define XK_Rcaron                        0x01d8  /* U+0158 LATIN CAPITAL LETTER R WITH CARON */
+#define XK_Uring                         0x01d9  /* U+016E LATIN CAPITAL LETTER U WITH RING ABOVE */
+#define XK_Udoubleacute                  0x01db  /* U+0170 LATIN CAPITAL LETTER U WITH DOUBLE ACUTE */
+#define XK_Tcedilla                      0x01de  /* U+0162 LATIN CAPITAL LETTER T WITH CEDILLA */
+#define XK_racute                        0x01e0  /* U+0155 LATIN SMALL LETTER R WITH ACUTE */
+#define XK_abreve                        0x01e3  /* U+0103 LATIN SMALL LETTER A WITH BREVE */
+#define XK_lacute                        0x01e5  /* U+013A LATIN SMALL LETTER L WITH ACUTE */
+#define XK_cacute                        0x01e6  /* U+0107 LATIN SMALL LETTER C WITH ACUTE */
+#define XK_ccaron                        0x01e8  /* U+010D LATIN SMALL LETTER C WITH CARON */
+#define XK_eogonek                       0x01ea  /* U+0119 LATIN SMALL LETTER E WITH OGONEK */
+#define XK_ecaron                        0x01ec  /* U+011B LATIN SMALL LETTER E WITH CARON */
+#define XK_dcaron                        0x01ef  /* U+010F LATIN SMALL LETTER D WITH CARON */
+#define XK_dstroke                       0x01f0  /* U+0111 LATIN SMALL LETTER D WITH STROKE */
+#define XK_nacute                        0x01f1  /* U+0144 LATIN SMALL LETTER N WITH ACUTE */
+#define XK_ncaron                        0x01f2  /* U+0148 LATIN SMALL LETTER N WITH CARON */
+#define XK_odoubleacute                  0x01f5  /* U+0151 LATIN SMALL LETTER O WITH DOUBLE ACUTE */
+#define XK_udoubleacute                  0x01fb  /* U+0171 LATIN SMALL LETTER U WITH DOUBLE ACUTE */
+#define XK_rcaron                        0x01f8  /* U+0159 LATIN SMALL LETTER R WITH CARON */
+#define XK_uring                         0x01f9  /* U+016F LATIN SMALL LETTER U WITH RING ABOVE */
+#define XK_tcedilla                      0x01fe  /* U+0163 LATIN SMALL LETTER T WITH CEDILLA */
+#define XK_abovedot                      0x01ff  /* U+02D9 DOT ABOVE */
+#endif /* XK_LATIN2 */
+
+/*
+ * Latin 3
+ * Byte 3 = 2
+ */
+
+#ifdef XK_LATIN3
+#define XK_Hstroke                       0x02a1  /* U+0126 LATIN CAPITAL LETTER H WITH STROKE */
+#define XK_Hcircumflex                   0x02a6  /* U+0124 LATIN CAPITAL LETTER H WITH CIRCUMFLEX */
+#define XK_Iabovedot                     0x02a9  /* U+0130 LATIN CAPITAL LETTER I WITH DOT ABOVE */
+#define XK_Gbreve                        0x02ab  /* U+011E LATIN CAPITAL LETTER G WITH BREVE */
+#define XK_Jcircumflex                   0x02ac  /* U+0134 LATIN CAPITAL LETTER J WITH CIRCUMFLEX */
+#define XK_hstroke                       0x02b1  /* U+0127 LATIN SMALL LETTER H WITH STROKE */
+#define XK_hcircumflex                   0x02b6  /* U+0125 LATIN SMALL LETTER H WITH CIRCUMFLEX */
+#define XK_idotless                      0x02b9  /* U+0131 LATIN SMALL LETTER DOTLESS I */
+#define XK_gbreve                        0x02bb  /* U+011F LATIN SMALL LETTER G WITH BREVE */
+#define XK_jcircumflex                   0x02bc  /* U+0135 LATIN SMALL LETTER J WITH CIRCUMFLEX */
+#define XK_Cabovedot                     0x02c5  /* U+010A LATIN CAPITAL LETTER C WITH DOT ABOVE */
+#define XK_Ccircumflex                   0x02c6  /* U+0108 LATIN CAPITAL LETTER C WITH CIRCUMFLEX */
+#define XK_Gabovedot                     0x02d5  /* U+0120 LATIN CAPITAL LETTER G WITH DOT ABOVE */
+#define XK_Gcircumflex                   0x02d8  /* U+011C LATIN CAPITAL LETTER G WITH CIRCUMFLEX */
+#define XK_Ubreve                        0x02dd  /* U+016C LATIN CAPITAL LETTER U WITH BREVE */
+#define XK_Scircumflex                   0x02de  /* U+015C LATIN CAPITAL LETTER S WITH CIRCUMFLEX */
+#define XK_cabovedot                     0x02e5  /* U+010B LATIN SMALL LETTER C WITH DOT ABOVE */
+#define XK_ccircumflex                   0x02e6  /* U+0109 LATIN SMALL LETTER C WITH CIRCUMFLEX */
+#define XK_gabovedot                     0x02f5  /* U+0121 LATIN SMALL LETTER G WITH DOT ABOVE */
+#define XK_gcircumflex                   0x02f8  /* U+011D LATIN SMALL LETTER G WITH CIRCUMFLEX */
+#define XK_ubreve                        0x02fd  /* U+016D LATIN SMALL LETTER U WITH BREVE */
+#define XK_scircumflex                   0x02fe  /* U+015D LATIN SMALL LETTER S WITH CIRCUMFLEX */
+#endif /* XK_LATIN3 */
+
+
+/*
+ * Latin 4
+ * Byte 3 = 3
+ */
+
+#ifdef XK_LATIN4
+#define XK_kra                           0x03a2  /* U+0138 LATIN SMALL LETTER KRA */
+#define XK_kappa                         0x03a2  /* deprecated */
+#define XK_Rcedilla                      0x03a3  /* U+0156 LATIN CAPITAL LETTER R WITH CEDILLA */
+#define XK_Itilde                        0x03a5  /* U+0128 LATIN CAPITAL LETTER I WITH TILDE */
+#define XK_Lcedilla                      0x03a6  /* U+013B LATIN CAPITAL LETTER L WITH CEDILLA */
+#define XK_Emacron                       0x03aa  /* U+0112 LATIN CAPITAL LETTER E WITH MACRON */
+#define XK_Gcedilla                      0x03ab  /* U+0122 LATIN CAPITAL LETTER G WITH CEDILLA */
+#define XK_Tslash                        0x03ac  /* U+0166 LATIN CAPITAL LETTER T WITH STROKE */
+#define XK_rcedilla                      0x03b3  /* U+0157 LATIN SMALL LETTER R WITH CEDILLA */
+#define XK_itilde                        0x03b5  /* U+0129 LATIN SMALL LETTER I WITH TILDE */
+#define XK_lcedilla                      0x03b6  /* U+013C LATIN SMALL LETTER L WITH CEDILLA */
+#define XK_emacron                       0x03ba  /* U+0113 LATIN SMALL LETTER E WITH MACRON */
+#define XK_gcedilla                      0x03bb  /* U+0123 LATIN SMALL LETTER G WITH CEDILLA */
+#define XK_tslash                        0x03bc  /* U+0167 LATIN SMALL LETTER T WITH STROKE */
+#define XK_ENG                           0x03bd  /* U+014A LATIN CAPITAL LETTER ENG */
+#define XK_eng                           0x03bf  /* U+014B LATIN SMALL LETTER ENG */
+#define XK_Amacron                       0x03c0  /* U+0100 LATIN CAPITAL LETTER A WITH MACRON */
+#define XK_Iogonek                       0x03c7  /* U+012E LATIN CAPITAL LETTER I WITH OGONEK */
+#define XK_Eabovedot                     0x03cc  /* U+0116 LATIN CAPITAL LETTER E WITH DOT ABOVE */
+#define XK_Imacron                       0x03cf  /* U+012A LATIN CAPITAL LETTER I WITH MACRON */
+#define XK_Ncedilla                      0x03d1  /* U+0145 LATIN CAPITAL LETTER N WITH CEDILLA */
+#define XK_Omacron                       0x03d2  /* U+014C LATIN CAPITAL LETTER O WITH MACRON */
+#define XK_Kcedilla                      0x03d3  /* U+0136 LATIN CAPITAL LETTER K WITH CEDILLA */
+#define XK_Uogonek                       0x03d9  /* U+0172 LATIN CAPITAL LETTER U WITH OGONEK */
+#define XK_Utilde                        0x03dd  /* U+0168 LATIN CAPITAL LETTER U WITH TILDE */
+#define XK_Umacron                       0x03de  /* U+016A LATIN CAPITAL LETTER U WITH MACRON */
+#define XK_amacron                       0x03e0  /* U+0101 LATIN SMALL LETTER A WITH MACRON */
+#define XK_iogonek                       0x03e7  /* U+012F LATIN SMALL LETTER I WITH OGONEK */
+#define XK_eabovedot                     0x03ec  /* U+0117 LATIN SMALL LETTER E WITH DOT ABOVE */
+#define XK_imacron                       0x03ef  /* U+012B LATIN SMALL LETTER I WITH MACRON */
+#define XK_ncedilla                      0x03f1  /* U+0146 LATIN SMALL LETTER N WITH CEDILLA */
+#define XK_omacron                       0x03f2  /* U+014D LATIN SMALL LETTER O WITH MACRON */
+#define XK_kcedilla                      0x03f3  /* U+0137 LATIN SMALL LETTER K WITH CEDILLA */
+#define XK_uogonek                       0x03f9  /* U+0173 LATIN SMALL LETTER U WITH OGONEK */
+#define XK_utilde                        0x03fd  /* U+0169 LATIN SMALL LETTER U WITH TILDE */
+#define XK_umacron                       0x03fe  /* U+016B LATIN SMALL LETTER U WITH MACRON */
+#endif /* XK_LATIN4 */
+
+/*
+ * Latin 8
+ */
+#ifdef XK_LATIN8
+#define XK_Babovedot                  0x1001e02  /* U+1E02 LATIN CAPITAL LETTER B WITH DOT ABOVE */
+#define XK_babovedot                  0x1001e03  /* U+1E03 LATIN SMALL LETTER B WITH DOT ABOVE */
+#define XK_Dabovedot                  0x1001e0a  /* U+1E0A LATIN CAPITAL LETTER D WITH DOT ABOVE */
+#define XK_Wgrave                     0x1001e80  /* U+1E80 LATIN CAPITAL LETTER W WITH GRAVE */
+#define XK_Wacute                     0x1001e82  /* U+1E82 LATIN CAPITAL LETTER W WITH ACUTE */
+#define XK_dabovedot                  0x1001e0b  /* U+1E0B LATIN SMALL LETTER D WITH DOT ABOVE */
+#define XK_Ygrave                     0x1001ef2  /* U+1EF2 LATIN CAPITAL LETTER Y WITH GRAVE */
+#define XK_Fabovedot                  0x1001e1e  /* U+1E1E LATIN CAPITAL LETTER F WITH DOT ABOVE */
+#define XK_fabovedot                  0x1001e1f  /* U+1E1F LATIN SMALL LETTER F WITH DOT ABOVE */
+#define XK_Mabovedot                  0x1001e40  /* U+1E40 LATIN CAPITAL LETTER M WITH DOT ABOVE */
+#define XK_mabovedot                  0x1001e41  /* U+1E41 LATIN SMALL LETTER M WITH DOT ABOVE */
+#define XK_Pabovedot                  0x1001e56  /* U+1E56 LATIN CAPITAL LETTER P WITH DOT ABOVE */
+#define XK_wgrave                     0x1001e81  /* U+1E81 LATIN SMALL LETTER W WITH GRAVE */
+#define XK_pabovedot                  0x1001e57  /* U+1E57 LATIN SMALL LETTER P WITH DOT ABOVE */
+#define XK_wacute                     0x1001e83  /* U+1E83 LATIN SMALL LETTER W WITH ACUTE */
+#define XK_Sabovedot                  0x1001e60  /* U+1E60 LATIN CAPITAL LETTER S WITH DOT ABOVE */
+#define XK_ygrave                     0x1001ef3  /* U+1EF3 LATIN SMALL LETTER Y WITH GRAVE */
+#define XK_Wdiaeresis                 0x1001e84  /* U+1E84 LATIN CAPITAL LETTER W WITH DIAERESIS */
+#define XK_wdiaeresis                 0x1001e85  /* U+1E85 LATIN SMALL LETTER W WITH DIAERESIS */
+#define XK_sabovedot                  0x1001e61  /* U+1E61 LATIN SMALL LETTER S WITH DOT ABOVE */
+#define XK_Wcircumflex                0x1000174  /* U+0174 LATIN CAPITAL LETTER W WITH CIRCUMFLEX */
+#define XK_Tabovedot                  0x1001e6a  /* U+1E6A LATIN CAPITAL LETTER T WITH DOT ABOVE */
+#define XK_Ycircumflex                0x1000176  /* U+0176 LATIN CAPITAL LETTER Y WITH CIRCUMFLEX */
+#define XK_wcircumflex                0x1000175  /* U+0175 LATIN SMALL LETTER W WITH CIRCUMFLEX */
+#define XK_tabovedot                  0x1001e6b  /* U+1E6B LATIN SMALL LETTER T WITH DOT ABOVE */
+#define XK_ycircumflex                0x1000177  /* U+0177 LATIN SMALL LETTER Y WITH CIRCUMFLEX */
+#endif /* XK_LATIN8 */
+
+/*
+ * Latin 9
+ * Byte 3 = 0x13
+ */
+
+#ifdef XK_LATIN9
+#define XK_OE                            0x13bc  /* U+0152 LATIN CAPITAL LIGATURE OE */
+#define XK_oe                            0x13bd  /* U+0153 LATIN SMALL LIGATURE OE */
+#define XK_Ydiaeresis                    0x13be  /* U+0178 LATIN CAPITAL LETTER Y WITH DIAERESIS */
+#endif /* XK_LATIN9 */
+
+/*
+ * Katakana
+ * Byte 3 = 4
+ */
+
+#ifdef XK_KATAKANA
+#define XK_overline                      0x047e  /* U+203E OVERLINE */
+#define XK_kana_fullstop                 0x04a1  /* U+3002 IDEOGRAPHIC FULL STOP */
+#define XK_kana_openingbracket           0x04a2  /* U+300C LEFT CORNER BRACKET */
+#define XK_kana_closingbracket           0x04a3  /* U+300D RIGHT CORNER BRACKET */
+#define XK_kana_comma                    0x04a4  /* U+3001 IDEOGRAPHIC COMMA */
+#define XK_kana_conjunctive              0x04a5  /* U+30FB KATAKANA MIDDLE DOT */
+#define XK_kana_middledot                0x04a5  /* deprecated */
+#define XK_kana_WO                       0x04a6  /* U+30F2 KATAKANA LETTER WO */
+#define XK_kana_a                        0x04a7  /* U+30A1 KATAKANA LETTER SMALL A */
+#define XK_kana_i                        0x04a8  /* U+30A3 KATAKANA LETTER SMALL I */
+#define XK_kana_u                        0x04a9  /* U+30A5 KATAKANA LETTER SMALL U */
+#define XK_kana_e                        0x04aa  /* U+30A7 KATAKANA LETTER SMALL E */
+#define XK_kana_o                        0x04ab  /* U+30A9 KATAKANA LETTER SMALL O */
+#define XK_kana_ya                       0x04ac  /* U+30E3 KATAKANA LETTER SMALL YA */
+#define XK_kana_yu                       0x04ad  /* U+30E5 KATAKANA LETTER SMALL YU */
+#define XK_kana_yo                       0x04ae  /* U+30E7 KATAKANA LETTER SMALL YO */
+#define XK_kana_tsu                      0x04af  /* U+30C3 KATAKANA LETTER SMALL TU */
+#define XK_kana_tu                       0x04af  /* deprecated */
+#define XK_prolongedsound                0x04b0  /* U+30FC KATAKANA-HIRAGANA PROLONGED SOUND MARK */
+#define XK_kana_A                        0x04b1  /* U+30A2 KATAKANA LETTER A */
+#define XK_kana_I                        0x04b2  /* U+30A4 KATAKANA LETTER I */
+#define XK_kana_U                        0x04b3  /* U+30A6 KATAKANA LETTER U */
+#define XK_kana_E                        0x04b4  /* U+30A8 KATAKANA LETTER E */
+#define XK_kana_O                        0x04b5  /* U+30AA KATAKANA LETTER O */
+#define XK_kana_KA                       0x04b6  /* U+30AB KATAKANA LETTER KA */
+#define XK_kana_KI                       0x04b7  /* U+30AD KATAKANA LETTER KI */
+#define XK_kana_KU                       0x04b8  /* U+30AF KATAKANA LETTER KU */
+#define XK_kana_KE                       0x04b9  /* U+30B1 KATAKANA LETTER KE */
+#define XK_kana_KO                       0x04ba  /* U+30B3 KATAKANA LETTER KO */
+#define XK_kana_SA                       0x04bb  /* U+30B5 KATAKANA LETTER SA */
+#define XK_kana_SHI                      0x04bc  /* U+30B7 KATAKANA LETTER SI */
+#define XK_kana_SU                       0x04bd  /* U+30B9 KATAKANA LETTER SU */
+#define XK_kana_SE                       0x04be  /* U+30BB KATAKANA LETTER SE */
+#define XK_kana_SO                       0x04bf  /* U+30BD KATAKANA LETTER SO */
+#define XK_kana_TA                       0x04c0  /* U+30BF KATAKANA LETTER TA */
+#define XK_kana_CHI                      0x04c1  /* U+30C1 KATAKANA LETTER TI */
+#define XK_kana_TI                       0x04c1  /* deprecated */
+#define XK_kana_TSU                      0x04c2  /* U+30C4 KATAKANA LETTER TU */
+#define XK_kana_TU                       0x04c2  /* deprecated */
+#define XK_kana_TE                       0x04c3  /* U+30C6 KATAKANA LETTER TE */
+#define XK_kana_TO                       0x04c4  /* U+30C8 KATAKANA LETTER TO */
+#define XK_kana_NA                       0x04c5  /* U+30CA KATAKANA LETTER NA */
+#define XK_kana_NI                       0x04c6  /* U+30CB KATAKANA LETTER NI */
+#define XK_kana_NU                       0x04c7  /* U+30CC KATAKANA LETTER NU */
+#define XK_kana_NE                       0x04c8  /* U+30CD KATAKANA LETTER NE */
+#define XK_kana_NO                       0x04c9  /* U+30CE KATAKANA LETTER NO */
+#define XK_kana_HA                       0x04ca  /* U+30CF KATAKANA LETTER HA */
+#define XK_kana_HI                       0x04cb  /* U+30D2 KATAKANA LETTER HI */
+#define XK_kana_FU                       0x04cc  /* U+30D5 KATAKANA LETTER HU */
+#define XK_kana_HU                       0x04cc  /* deprecated */
+#define XK_kana_HE                       0x04cd  /* U+30D8 KATAKANA LETTER HE */
+#define XK_kana_HO                       0x04ce  /* U+30DB KATAKANA LETTER HO */
+#define XK_kana_MA                       0x04cf  /* U+30DE KATAKANA LETTER MA */
+#define XK_kana_MI                       0x04d0  /* U+30DF KATAKANA LETTER MI */
+#define XK_kana_MU                       0x04d1  /* U+30E0 KATAKANA LETTER MU */
+#define XK_kana_ME                       0x04d2  /* U+30E1 KATAKANA LETTER ME */
+#define XK_kana_MO                       0x04d3  /* U+30E2 KATAKANA LETTER MO */
+#define XK_kana_YA                       0x04d4  /* U+30E4 KATAKANA LETTER YA */
+#define XK_kana_YU                       0x04d5  /* U+30E6 KATAKANA LETTER YU */
+#define XK_kana_YO                       0x04d6  /* U+30E8 KATAKANA LETTER YO */
+#define XK_kana_RA                       0x04d7  /* U+30E9 KATAKANA LETTER RA */
+#define XK_kana_RI                       0x04d8  /* U+30EA KATAKANA LETTER RI */
+#define XK_kana_RU                       0x04d9  /* U+30EB KATAKANA LETTER RU */
+#define XK_kana_RE                       0x04da  /* U+30EC KATAKANA LETTER RE */
+#define XK_kana_RO                       0x04db  /* U+30ED KATAKANA LETTER RO */
+#define XK_kana_WA                       0x04dc  /* U+30EF KATAKANA LETTER WA */
+#define XK_kana_N                        0x04dd  /* U+30F3 KATAKANA LETTER N */
+#define XK_voicedsound                   0x04de  /* U+309B KATAKANA-HIRAGANA VOICED SOUND MARK */
+#define XK_semivoicedsound               0x04df  /* U+309C KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK */
+#define XK_kana_switch                   0xff7e  /* Alias for mode_switch */
+#endif /* XK_KATAKANA */
+
+/*
+ * Arabic
+ * Byte 3 = 5
+ */
+
+#ifdef XK_ARABIC
+#define XK_Farsi_0                    0x10006f0  /* U+06F0 EXTENDED ARABIC-INDIC DIGIT ZERO */
+#define XK_Farsi_1                    0x10006f1  /* U+06F1 EXTENDED ARABIC-INDIC DIGIT ONE */
+#define XK_Farsi_2                    0x10006f2  /* U+06F2 EXTENDED ARABIC-INDIC DIGIT TWO */
+#define XK_Farsi_3                    0x10006f3  /* U+06F3 EXTENDED ARABIC-INDIC DIGIT THREE */
+#define XK_Farsi_4                    0x10006f4  /* U+06F4 EXTENDED ARABIC-INDIC DIGIT FOUR */
+#define XK_Farsi_5                    0x10006f5  /* U+06F5 EXTENDED ARABIC-INDIC DIGIT FIVE */
+#define XK_Farsi_6                    0x10006f6  /* U+06F6 EXTENDED ARABIC-INDIC DIGIT SIX */
+#define XK_Farsi_7                    0x10006f7  /* U+06F7 EXTENDED ARABIC-INDIC DIGIT SEVEN */
+#define XK_Farsi_8                    0x10006f8  /* U+06F8 EXTENDED ARABIC-INDIC DIGIT EIGHT */
+#define XK_Farsi_9                    0x10006f9  /* U+06F9 EXTENDED ARABIC-INDIC DIGIT NINE */
+#define XK_Arabic_percent             0x100066a  /* U+066A ARABIC PERCENT SIGN */
+#define XK_Arabic_superscript_alef    0x1000670  /* U+0670 ARABIC LETTER SUPERSCRIPT ALEF */
+#define XK_Arabic_tteh                0x1000679  /* U+0679 ARABIC LETTER TTEH */
+#define XK_Arabic_peh                 0x100067e  /* U+067E ARABIC LETTER PEH */
+#define XK_Arabic_tcheh               0x1000686  /* U+0686 ARABIC LETTER TCHEH */
+#define XK_Arabic_ddal                0x1000688  /* U+0688 ARABIC LETTER DDAL */
+#define XK_Arabic_rreh                0x1000691  /* U+0691 ARABIC LETTER RREH */
+#define XK_Arabic_comma                  0x05ac  /* U+060C ARABIC COMMA */
+#define XK_Arabic_fullstop            0x10006d4  /* U+06D4 ARABIC FULL STOP */
+#define XK_Arabic_0                   0x1000660  /* U+0660 ARABIC-INDIC DIGIT ZERO */
+#define XK_Arabic_1                   0x1000661  /* U+0661 ARABIC-INDIC DIGIT ONE */
+#define XK_Arabic_2                   0x1000662  /* U+0662 ARABIC-INDIC DIGIT TWO */
+#define XK_Arabic_3                   0x1000663  /* U+0663 ARABIC-INDIC DIGIT THREE */
+#define XK_Arabic_4                   0x1000664  /* U+0664 ARABIC-INDIC DIGIT FOUR */
+#define XK_Arabic_5                   0x1000665  /* U+0665 ARABIC-INDIC DIGIT FIVE */
+#define XK_Arabic_6                   0x1000666  /* U+0666 ARABIC-INDIC DIGIT SIX */
+#define XK_Arabic_7                   0x1000667  /* U+0667 ARABIC-INDIC DIGIT SEVEN */
+#define XK_Arabic_8                   0x1000668  /* U+0668 ARABIC-INDIC DIGIT EIGHT */
+#define XK_Arabic_9                   0x1000669  /* U+0669 ARABIC-INDIC DIGIT NINE */
+#define XK_Arabic_semicolon              0x05bb  /* U+061B ARABIC SEMICOLON */
+#define XK_Arabic_question_mark          0x05bf  /* U+061F ARABIC QUESTION MARK */
+#define XK_Arabic_hamza                  0x05c1  /* U+0621 ARABIC LETTER HAMZA */
+#define XK_Arabic_maddaonalef            0x05c2  /* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE */
+#define XK_Arabic_hamzaonalef            0x05c3  /* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE */
+#define XK_Arabic_hamzaonwaw             0x05c4  /* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE */
+#define XK_Arabic_hamzaunderalef         0x05c5  /* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW */
+#define XK_Arabic_hamzaonyeh             0x05c6  /* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE */
+#define XK_Arabic_alef                   0x05c7  /* U+0627 ARABIC LETTER ALEF */
+#define XK_Arabic_beh                    0x05c8  /* U+0628 ARABIC LETTER BEH */
+#define XK_Arabic_tehmarbuta             0x05c9  /* U+0629 ARABIC LETTER TEH MARBUTA */
+#define XK_Arabic_teh                    0x05ca  /* U+062A ARABIC LETTER TEH */
+#define XK_Arabic_theh                   0x05cb  /* U+062B ARABIC LETTER THEH */
+#define XK_Arabic_jeem                   0x05cc  /* U+062C ARABIC LETTER JEEM */
+#define XK_Arabic_hah                    0x05cd  /* U+062D ARABIC LETTER HAH */
+#define XK_Arabic_khah                   0x05ce  /* U+062E ARABIC LETTER KHAH */
+#define XK_Arabic_dal                    0x05cf  /* U+062F ARABIC LETTER DAL */
+#define XK_Arabic_thal                   0x05d0  /* U+0630 ARABIC LETTER THAL */
+#define XK_Arabic_ra                     0x05d1  /* U+0631 ARABIC LETTER REH */
+#define XK_Arabic_zain                   0x05d2  /* U+0632 ARABIC LETTER ZAIN */
+#define XK_Arabic_seen                   0x05d3  /* U+0633 ARABIC LETTER SEEN */
+#define XK_Arabic_sheen                  0x05d4  /* U+0634 ARABIC LETTER SHEEN */
+#define XK_Arabic_sad                    0x05d5  /* U+0635 ARABIC LETTER SAD */
+#define XK_Arabic_dad                    0x05d6  /* U+0636 ARABIC LETTER DAD */
+#define XK_Arabic_tah                    0x05d7  /* U+0637 ARABIC LETTER TAH */
+#define XK_Arabic_zah                    0x05d8  /* U+0638 ARABIC LETTER ZAH */
+#define XK_Arabic_ain                    0x05d9  /* U+0639 ARABIC LETTER AIN */
+#define XK_Arabic_ghain                  0x05da  /* U+063A ARABIC LETTER GHAIN */
+#define XK_Arabic_tatweel                0x05e0  /* U+0640 ARABIC TATWEEL */
+#define XK_Arabic_feh                    0x05e1  /* U+0641 ARABIC LETTER FEH */
+#define XK_Arabic_qaf                    0x05e2  /* U+0642 ARABIC LETTER QAF */
+#define XK_Arabic_kaf                    0x05e3  /* U+0643 ARABIC LETTER KAF */
+#define XK_Arabic_lam                    0x05e4  /* U+0644 ARABIC LETTER LAM */
+#define XK_Arabic_meem                   0x05e5  /* U+0645 ARABIC LETTER MEEM */
+#define XK_Arabic_noon                   0x05e6  /* U+0646 ARABIC LETTER NOON */
+#define XK_Arabic_ha                     0x05e7  /* U+0647 ARABIC LETTER HEH */
+#define XK_Arabic_heh                    0x05e7  /* deprecated */
+#define XK_Arabic_waw                    0x05e8  /* U+0648 ARABIC LETTER WAW */
+#define XK_Arabic_alefmaksura            0x05e9  /* U+0649 ARABIC LETTER ALEF MAKSURA */
+#define XK_Arabic_yeh                    0x05ea  /* U+064A ARABIC LETTER YEH */
+#define XK_Arabic_fathatan               0x05eb  /* U+064B ARABIC FATHATAN */
+#define XK_Arabic_dammatan               0x05ec  /* U+064C ARABIC DAMMATAN */
+#define XK_Arabic_kasratan               0x05ed  /* U+064D ARABIC KASRATAN */
+#define XK_Arabic_fatha                  0x05ee  /* U+064E ARABIC FATHA */
+#define XK_Arabic_damma                  0x05ef  /* U+064F ARABIC DAMMA */
+#define XK_Arabic_kasra                  0x05f0  /* U+0650 ARABIC KASRA */
+#define XK_Arabic_shadda                 0x05f1  /* U+0651 ARABIC SHADDA */
+#define XK_Arabic_sukun                  0x05f2  /* U+0652 ARABIC SUKUN */
+#define XK_Arabic_madda_above         0x1000653  /* U+0653 ARABIC MADDAH ABOVE */
+#define XK_Arabic_hamza_above         0x1000654  /* U+0654 ARABIC HAMZA ABOVE */
+#define XK_Arabic_hamza_below         0x1000655  /* U+0655 ARABIC HAMZA BELOW */
+#define XK_Arabic_jeh                 0x1000698  /* U+0698 ARABIC LETTER JEH */
+#define XK_Arabic_veh                 0x10006a4  /* U+06A4 ARABIC LETTER VEH */
+#define XK_Arabic_keheh               0x10006a9  /* U+06A9 ARABIC LETTER KEHEH */
+#define XK_Arabic_gaf                 0x10006af  /* U+06AF ARABIC LETTER GAF */
+#define XK_Arabic_noon_ghunna         0x10006ba  /* U+06BA ARABIC LETTER NOON GHUNNA */
+#define XK_Arabic_heh_doachashmee     0x10006be  /* U+06BE ARABIC LETTER HEH DOACHASHMEE */
+#define XK_Farsi_yeh                  0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
+#define XK_Arabic_farsi_yeh           0x10006cc  /* U+06CC ARABIC LETTER FARSI YEH */
+#define XK_Arabic_yeh_baree           0x10006d2  /* U+06D2 ARABIC LETTER YEH BARREE */
+#define XK_Arabic_heh_goal            0x10006c1  /* U+06C1 ARABIC LETTER HEH GOAL */
+#define XK_Arabic_switch                 0xff7e  /* Alias for mode_switch */
+#endif /* XK_ARABIC */
+
+/*
+ * Cyrillic
+ * Byte 3 = 6
+ */
+#ifdef XK_CYRILLIC
+#define XK_Cyrillic_GHE_bar           0x1000492  /* U+0492 CYRILLIC CAPITAL LETTER GHE WITH STROKE */
+#define XK_Cyrillic_ghe_bar           0x1000493  /* U+0493 CYRILLIC SMALL LETTER GHE WITH STROKE */
+#define XK_Cyrillic_ZHE_descender     0x1000496  /* U+0496 CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER */
+#define XK_Cyrillic_zhe_descender     0x1000497  /* U+0497 CYRILLIC SMALL LETTER ZHE WITH DESCENDER */
+#define XK_Cyrillic_KA_descender      0x100049a  /* U+049A CYRILLIC CAPITAL LETTER KA WITH DESCENDER */
+#define XK_Cyrillic_ka_descender      0x100049b  /* U+049B CYRILLIC SMALL LETTER KA WITH DESCENDER */
+#define XK_Cyrillic_KA_vertstroke     0x100049c  /* U+049C CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE */
+#define XK_Cyrillic_ka_vertstroke     0x100049d  /* U+049D CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE */
+#define XK_Cyrillic_EN_descender      0x10004a2  /* U+04A2 CYRILLIC CAPITAL LETTER EN WITH DESCENDER */
+#define XK_Cyrillic_en_descender      0x10004a3  /* U+04A3 CYRILLIC SMALL LETTER EN WITH DESCENDER */
+#define XK_Cyrillic_U_straight        0x10004ae  /* U+04AE CYRILLIC CAPITAL LETTER STRAIGHT U */
+#define XK_Cyrillic_u_straight        0x10004af  /* U+04AF CYRILLIC SMALL LETTER STRAIGHT U */
+#define XK_Cyrillic_U_straight_bar    0x10004b0  /* U+04B0 CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE */
+#define XK_Cyrillic_u_straight_bar    0x10004b1  /* U+04B1 CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE */
+#define XK_Cyrillic_HA_descender      0x10004b2  /* U+04B2 CYRILLIC CAPITAL LETTER HA WITH DESCENDER */
+#define XK_Cyrillic_ha_descender      0x10004b3  /* U+04B3 CYRILLIC SMALL LETTER HA WITH DESCENDER */
+#define XK_Cyrillic_CHE_descender     0x10004b6  /* U+04B6 CYRILLIC CAPITAL LETTER CHE WITH DESCENDER */
+#define XK_Cyrillic_che_descender     0x10004b7  /* U+04B7 CYRILLIC SMALL LETTER CHE WITH DESCENDER */
+#define XK_Cyrillic_CHE_vertstroke    0x10004b8  /* U+04B8 CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE */
+#define XK_Cyrillic_che_vertstroke    0x10004b9  /* U+04B9 CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE */
+#define XK_Cyrillic_SHHA              0x10004ba  /* U+04BA CYRILLIC CAPITAL LETTER SHHA */
+#define XK_Cyrillic_shha              0x10004bb  /* U+04BB CYRILLIC SMALL LETTER SHHA */
+
+#define XK_Cyrillic_SCHWA             0x10004d8  /* U+04D8 CYRILLIC CAPITAL LETTER SCHWA */
+#define XK_Cyrillic_schwa             0x10004d9  /* U+04D9 CYRILLIC SMALL LETTER SCHWA */
+#define XK_Cyrillic_I_macron          0x10004e2  /* U+04E2 CYRILLIC CAPITAL LETTER I WITH MACRON */
+#define XK_Cyrillic_i_macron          0x10004e3  /* U+04E3 CYRILLIC SMALL LETTER I WITH MACRON */
+#define XK_Cyrillic_O_bar             0x10004e8  /* U+04E8 CYRILLIC CAPITAL LETTER BARRED O */
+#define XK_Cyrillic_o_bar             0x10004e9  /* U+04E9 CYRILLIC SMALL LETTER BARRED O */
+#define XK_Cyrillic_U_macron          0x10004ee  /* U+04EE CYRILLIC CAPITAL LETTER U WITH MACRON */
+#define XK_Cyrillic_u_macron          0x10004ef  /* U+04EF CYRILLIC SMALL LETTER U WITH MACRON */
+
+#define XK_Serbian_dje                   0x06a1  /* U+0452 CYRILLIC SMALL LETTER DJE */
+#define XK_Macedonia_gje                 0x06a2  /* U+0453 CYRILLIC SMALL LETTER GJE */
+#define XK_Cyrillic_io                   0x06a3  /* U+0451 CYRILLIC SMALL LETTER IO */
+#define XK_Ukrainian_ie                  0x06a4  /* U+0454 CYRILLIC SMALL LETTER UKRAINIAN IE */
+#define XK_Ukranian_je                   0x06a4  /* deprecated */
+#define XK_Macedonia_dse                 0x06a5  /* U+0455 CYRILLIC SMALL LETTER DZE */
+#define XK_Ukrainian_i                   0x06a6  /* U+0456 CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I */
+#define XK_Ukranian_i                    0x06a6  /* deprecated */
+#define XK_Ukrainian_yi                  0x06a7  /* U+0457 CYRILLIC SMALL LETTER YI */
+#define XK_Ukranian_yi                   0x06a7  /* deprecated */
+#define XK_Cyrillic_je                   0x06a8  /* U+0458 CYRILLIC SMALL LETTER JE */
+#define XK_Serbian_je                    0x06a8  /* deprecated */
+#define XK_Cyrillic_lje                  0x06a9  /* U+0459 CYRILLIC SMALL LETTER LJE */
+#define XK_Serbian_lje                   0x06a9  /* deprecated */
+#define XK_Cyrillic_nje                  0x06aa  /* U+045A CYRILLIC SMALL LETTER NJE */
+#define XK_Serbian_nje                   0x06aa  /* deprecated */
+#define XK_Serbian_tshe                  0x06ab  /* U+045B CYRILLIC SMALL LETTER TSHE */
+#define XK_Macedonia_kje                 0x06ac  /* U+045C CYRILLIC SMALL LETTER KJE */
+#define XK_Ukrainian_ghe_with_upturn     0x06ad  /* U+0491 CYRILLIC SMALL LETTER GHE WITH UPTURN */
+#define XK_Byelorussian_shortu           0x06ae  /* U+045E CYRILLIC SMALL LETTER SHORT U */
+#define XK_Cyrillic_dzhe                 0x06af  /* U+045F CYRILLIC SMALL LETTER DZHE */
+#define XK_Serbian_dze                   0x06af  /* deprecated */
+#define XK_numerosign                    0x06b0  /* U+2116 NUMERO SIGN */
+#define XK_Serbian_DJE                   0x06b1  /* U+0402 CYRILLIC CAPITAL LETTER DJE */
+#define XK_Macedonia_GJE                 0x06b2  /* U+0403 CYRILLIC CAPITAL LETTER GJE */
+#define XK_Cyrillic_IO                   0x06b3  /* U+0401 CYRILLIC CAPITAL LETTER IO */
+#define XK_Ukrainian_IE                  0x06b4  /* U+0404 CYRILLIC CAPITAL LETTER UKRAINIAN IE */
+#define XK_Ukranian_JE                   0x06b4  /* deprecated */
+#define XK_Macedonia_DSE                 0x06b5  /* U+0405 CYRILLIC CAPITAL LETTER DZE */
+#define XK_Ukrainian_I                   0x06b6  /* U+0406 CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I */
+#define XK_Ukranian_I                    0x06b6  /* deprecated */
+#define XK_Ukrainian_YI                  0x06b7  /* U+0407 CYRILLIC CAPITAL LETTER YI */
+#define XK_Ukranian_YI                   0x06b7  /* deprecated */
+#define XK_Cyrillic_JE                   0x06b8  /* U+0408 CYRILLIC CAPITAL LETTER JE */
+#define XK_Serbian_JE                    0x06b8  /* deprecated */
+#define XK_Cyrillic_LJE                  0x06b9  /* U+0409 CYRILLIC CAPITAL LETTER LJE */
+#define XK_Serbian_LJE                   0x06b9  /* deprecated */
+#define XK_Cyrillic_NJE                  0x06ba  /* U+040A CYRILLIC CAPITAL LETTER NJE */
+#define XK_Serbian_NJE                   0x06ba  /* deprecated */
+#define XK_Serbian_TSHE                  0x06bb  /* U+040B CYRILLIC CAPITAL LETTER TSHE */
+#define XK_Macedonia_KJE                 0x06bc  /* U+040C CYRILLIC CAPITAL LETTER KJE */
+#define XK_Ukrainian_GHE_WITH_UPTURN     0x06bd  /* U+0490 CYRILLIC CAPITAL LETTER GHE WITH UPTURN */
+#define XK_Byelorussian_SHORTU           0x06be  /* U+040E CYRILLIC CAPITAL LETTER SHORT U */
+#define XK_Cyrillic_DZHE                 0x06bf  /* U+040F CYRILLIC CAPITAL LETTER DZHE */
+#define XK_Serbian_DZE                   0x06bf  /* deprecated */
+#define XK_Cyrillic_yu                   0x06c0  /* U+044E CYRILLIC SMALL LETTER YU */
+#define XK_Cyrillic_a                    0x06c1  /* U+0430 CYRILLIC SMALL LETTER A */
+#define XK_Cyrillic_be                   0x06c2  /* U+0431 CYRILLIC SMALL LETTER BE */
+#define XK_Cyrillic_tse                  0x06c3  /* U+0446 CYRILLIC SMALL LETTER TSE */
+#define XK_Cyrillic_de                   0x06c4  /* U+0434 CYRILLIC SMALL LETTER DE */
+#define XK_Cyrillic_ie                   0x06c5  /* U+0435 CYRILLIC SMALL LETTER IE */
+#define XK_Cyrillic_ef                   0x06c6  /* U+0444 CYRILLIC SMALL LETTER EF */
+#define XK_Cyrillic_ghe                  0x06c7  /* U+0433 CYRILLIC SMALL LETTER GHE */
+#define XK_Cyrillic_ha                   0x06c8  /* U+0445 CYRILLIC SMALL LETTER HA */
+#define XK_Cyrillic_i                    0x06c9  /* U+0438 CYRILLIC SMALL LETTER I */
+#define XK_Cyrillic_shorti               0x06ca  /* U+0439 CYRILLIC SMALL LETTER SHORT I */
+#define XK_Cyrillic_ka                   0x06cb  /* U+043A CYRILLIC SMALL LETTER KA */
+#define XK_Cyrillic_el                   0x06cc  /* U+043B CYRILLIC SMALL LETTER EL */
+#define XK_Cyrillic_em                   0x06cd  /* U+043C CYRILLIC SMALL LETTER EM */
+#define XK_Cyrillic_en                   0x06ce  /* U+043D CYRILLIC SMALL LETTER EN */
+#define XK_Cyrillic_o                    0x06cf  /* U+043E CYRILLIC SMALL LETTER O */
+#define XK_Cyrillic_pe                   0x06d0  /* U+043F CYRILLIC SMALL LETTER PE */
+#define XK_Cyrillic_ya                   0x06d1  /* U+044F CYRILLIC SMALL LETTER YA */
+#define XK_Cyrillic_er                   0x06d2  /* U+0440 CYRILLIC SMALL LETTER ER */
+#define XK_Cyrillic_es                   0x06d3  /* U+0441 CYRILLIC SMALL LETTER ES */
+#define XK_Cyrillic_te                   0x06d4  /* U+0442 CYRILLIC SMALL LETTER TE */
+#define XK_Cyrillic_u                    0x06d5  /* U+0443 CYRILLIC SMALL LETTER U */
+#define XK_Cyrillic_zhe                  0x06d6  /* U+0436 CYRILLIC SMALL LETTER ZHE */
+#define XK_Cyrillic_ve                   0x06d7  /* U+0432 CYRILLIC SMALL LETTER VE */
+#define XK_Cyrillic_softsign             0x06d8  /* U+044C CYRILLIC SMALL LETTER SOFT SIGN */
+#define XK_Cyrillic_yeru                 0x06d9  /* U+044B CYRILLIC SMALL LETTER YERU */
+#define XK_Cyrillic_ze                   0x06da  /* U+0437 CYRILLIC SMALL LETTER ZE */
+#define XK_Cyrillic_sha                  0x06db  /* U+0448 CYRILLIC SMALL LETTER SHA */
+#define XK_Cyrillic_e                    0x06dc  /* U+044D CYRILLIC SMALL LETTER E */
+#define XK_Cyrillic_shcha                0x06dd  /* U+0449 CYRILLIC SMALL LETTER SHCHA */
+#define XK_Cyrillic_che                  0x06de  /* U+0447 CYRILLIC SMALL LETTER CHE */
+#define XK_Cyrillic_hardsign             0x06df  /* U+044A CYRILLIC SMALL LETTER HARD SIGN */
+#define XK_Cyrillic_YU                   0x06e0  /* U+042E CYRILLIC CAPITAL LETTER YU */
+#define XK_Cyrillic_A                    0x06e1  /* U+0410 CYRILLIC CAPITAL LETTER A */
+#define XK_Cyrillic_BE                   0x06e2  /* U+0411 CYRILLIC CAPITAL LETTER BE */
+#define XK_Cyrillic_TSE                  0x06e3  /* U+0426 CYRILLIC CAPITAL LETTER TSE */
+#define XK_Cyrillic_DE                   0x06e4  /* U+0414 CYRILLIC CAPITAL LETTER DE */
+#define XK_Cyrillic_IE                   0x06e5  /* U+0415 CYRILLIC CAPITAL LETTER IE */
+#define XK_Cyrillic_EF                   0x06e6  /* U+0424 CYRILLIC CAPITAL LETTER EF */
+#define XK_Cyrillic_GHE                  0x06e7  /* U+0413 CYRILLIC CAPITAL LETTER GHE */
+#define XK_Cyrillic_HA                   0x06e8  /* U+0425 CYRILLIC CAPITAL LETTER HA */
+#define XK_Cyrillic_I                    0x06e9  /* U+0418 CYRILLIC CAPITAL LETTER I */
+#define XK_Cyrillic_SHORTI               0x06ea  /* U+0419 CYRILLIC CAPITAL LETTER SHORT I */
+#define XK_Cyrillic_KA                   0x06eb  /* U+041A CYRILLIC CAPITAL LETTER KA */
+#define XK_Cyrillic_EL                   0x06ec  /* U+041B CYRILLIC CAPITAL LETTER EL */
+#define XK_Cyrillic_EM                   0x06ed  /* U+041C CYRILLIC CAPITAL LETTER EM */
+#define XK_Cyrillic_EN                   0x06ee  /* U+041D CYRILLIC CAPITAL LETTER EN */
+#define XK_Cyrillic_O                    0x06ef  /* U+041E CYRILLIC CAPITAL LETTER O */
+#define XK_Cyrillic_PE                   0x06f0  /* U+041F CYRILLIC CAPITAL LETTER PE */
+#define XK_Cyrillic_YA                   0x06f1  /* U+042F CYRILLIC CAPITAL LETTER YA */
+#define XK_Cyrillic_ER                   0x06f2  /* U+0420 CYRILLIC CAPITAL LETTER ER */
+#define XK_Cyrillic_ES                   0x06f3  /* U+0421 CYRILLIC CAPITAL LETTER ES */
+#define XK_Cyrillic_TE                   0x06f4  /* U+0422 CYRILLIC CAPITAL LETTER TE */
+#define XK_Cyrillic_U                    0x06f5  /* U+0423 CYRILLIC CAPITAL LETTER U */
+#define XK_Cyrillic_ZHE                  0x06f6  /* U+0416 CYRILLIC CAPITAL LETTER ZHE */
+#define XK_Cyrillic_VE                   0x06f7  /* U+0412 CYRILLIC CAPITAL LETTER VE */
+#define XK_Cyrillic_SOFTSIGN             0x06f8  /* U+042C CYRILLIC CAPITAL LETTER SOFT SIGN */
+#define XK_Cyrillic_YERU                 0x06f9  /* U+042B CYRILLIC CAPITAL LETTER YERU */
+#define XK_Cyrillic_ZE                   0x06fa  /* U+0417 CYRILLIC CAPITAL LETTER ZE */
+#define XK_Cyrillic_SHA                  0x06fb  /* U+0428 CYRILLIC CAPITAL LETTER SHA */
+#define XK_Cyrillic_E                    0x06fc  /* U+042D CYRILLIC CAPITAL LETTER E */
+#define XK_Cyrillic_SHCHA                0x06fd  /* U+0429 CYRILLIC CAPITAL LETTER SHCHA */
+#define XK_Cyrillic_CHE                  0x06fe  /* U+0427 CYRILLIC CAPITAL LETTER CHE */
+#define XK_Cyrillic_HARDSIGN             0x06ff  /* U+042A CYRILLIC CAPITAL LETTER HARD SIGN */
+#endif /* XK_CYRILLIC */
+
+/*
+ * Greek
+ * (based on an early draft of, and not quite identical to, ISO/IEC 8859-7)
+ * Byte 3 = 7
+ */
+
+#ifdef XK_GREEK
+#define XK_Greek_ALPHAaccent             0x07a1  /* U+0386 GREEK CAPITAL LETTER ALPHA WITH TONOS */
+#define XK_Greek_EPSILONaccent           0x07a2  /* U+0388 GREEK CAPITAL LETTER EPSILON WITH TONOS */
+#define XK_Greek_ETAaccent               0x07a3  /* U+0389 GREEK CAPITAL LETTER ETA WITH TONOS */
+#define XK_Greek_IOTAaccent              0x07a4  /* U+038A GREEK CAPITAL LETTER IOTA WITH TONOS */
+#define XK_Greek_IOTAdieresis            0x07a5  /* U+03AA GREEK CAPITAL LETTER IOTA WITH DIALYTIKA */
+#define XK_Greek_IOTAdiaeresis           0x07a5  /* old typo */
+#define XK_Greek_OMICRONaccent           0x07a7  /* U+038C GREEK CAPITAL LETTER OMICRON WITH TONOS */
+#define XK_Greek_UPSILONaccent           0x07a8  /* U+038E GREEK CAPITAL LETTER UPSILON WITH TONOS */
+#define XK_Greek_UPSILONdieresis         0x07a9  /* U+03AB GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA */
+#define XK_Greek_OMEGAaccent             0x07ab  /* U+038F GREEK CAPITAL LETTER OMEGA WITH TONOS */
+#define XK_Greek_accentdieresis          0x07ae  /* U+0385 GREEK DIALYTIKA TONOS */
+#define XK_Greek_horizbar                0x07af  /* U+2015 HORIZONTAL BAR */
+#define XK_Greek_alphaaccent             0x07b1  /* U+03AC GREEK SMALL LETTER ALPHA WITH TONOS */
+#define XK_Greek_epsilonaccent           0x07b2  /* U+03AD GREEK SMALL LETTER EPSILON WITH TONOS */
+#define XK_Greek_etaaccent               0x07b3  /* U+03AE GREEK SMALL LETTER ETA WITH TONOS */
+#define XK_Greek_iotaaccent              0x07b4  /* U+03AF GREEK SMALL LETTER IOTA WITH TONOS */
+#define XK_Greek_iotadieresis            0x07b5  /* U+03CA GREEK SMALL LETTER IOTA WITH DIALYTIKA */
+#define XK_Greek_iotaaccentdieresis      0x07b6  /* U+0390 GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS */
+#define XK_Greek_omicronaccent           0x07b7  /* U+03CC GREEK SMALL LETTER OMICRON WITH TONOS */
+#define XK_Greek_upsilonaccent           0x07b8  /* U+03CD GREEK SMALL LETTER UPSILON WITH TONOS */
+#define XK_Greek_upsilondieresis         0x07b9  /* U+03CB GREEK SMALL LETTER UPSILON WITH DIALYTIKA */
+#define XK_Greek_upsilonaccentdieresis   0x07ba  /* U+03B0 GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS */
+#define XK_Greek_omegaaccent             0x07bb  /* U+03CE GREEK SMALL LETTER OMEGA WITH TONOS */
+#define XK_Greek_ALPHA                   0x07c1  /* U+0391 GREEK CAPITAL LETTER ALPHA */
+#define XK_Greek_BETA                    0x07c2  /* U+0392 GREEK CAPITAL LETTER BETA */
+#define XK_Greek_GAMMA                   0x07c3  /* U+0393 GREEK CAPITAL LETTER GAMMA */
+#define XK_Greek_DELTA                   0x07c4  /* U+0394 GREEK CAPITAL LETTER DELTA */
+#define XK_Greek_EPSILON                 0x07c5  /* U+0395 GREEK CAPITAL LETTER EPSILON */
+#define XK_Greek_ZETA                    0x07c6  /* U+0396 GREEK CAPITAL LETTER ZETA */
+#define XK_Greek_ETA                     0x07c7  /* U+0397 GREEK CAPITAL LETTER ETA */
+#define XK_Greek_THETA                   0x07c8  /* U+0398 GREEK CAPITAL LETTER THETA */
+#define XK_Greek_IOTA                    0x07c9  /* U+0399 GREEK CAPITAL LETTER IOTA */
+#define XK_Greek_KAPPA                   0x07ca  /* U+039A GREEK CAPITAL LETTER KAPPA */
+#define XK_Greek_LAMDA                   0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
+#define XK_Greek_LAMBDA                  0x07cb  /* U+039B GREEK CAPITAL LETTER LAMDA */
+#define XK_Greek_MU                      0x07cc  /* U+039C GREEK CAPITAL LETTER MU */
+#define XK_Greek_NU                      0x07cd  /* U+039D GREEK CAPITAL LETTER NU */
+#define XK_Greek_XI                      0x07ce  /* U+039E GREEK CAPITAL LETTER XI */
+#define XK_Greek_OMICRON                 0x07cf  /* U+039F GREEK CAPITAL LETTER OMICRON */
+#define XK_Greek_PI                      0x07d0  /* U+03A0 GREEK CAPITAL LETTER PI */
+#define XK_Greek_RHO                     0x07d1  /* U+03A1 GREEK CAPITAL LETTER RHO */
+#define XK_Greek_SIGMA                   0x07d2  /* U+03A3 GREEK CAPITAL LETTER SIGMA */
+#define XK_Greek_TAU                     0x07d4  /* U+03A4 GREEK CAPITAL LETTER TAU */
+#define XK_Greek_UPSILON                 0x07d5  /* U+03A5 GREEK CAPITAL LETTER UPSILON */
+#define XK_Greek_PHI                     0x07d6  /* U+03A6 GREEK CAPITAL LETTER PHI */
+#define XK_Greek_CHI                     0x07d7  /* U+03A7 GREEK CAPITAL LETTER CHI */
+#define XK_Greek_PSI                     0x07d8  /* U+03A8 GREEK CAPITAL LETTER PSI */
+#define XK_Greek_OMEGA                   0x07d9  /* U+03A9 GREEK CAPITAL LETTER OMEGA */
+#define XK_Greek_alpha                   0x07e1  /* U+03B1 GREEK SMALL LETTER ALPHA */
+#define XK_Greek_beta                    0x07e2  /* U+03B2 GREEK SMALL LETTER BETA */
+#define XK_Greek_gamma                   0x07e3  /* U+03B3 GREEK SMALL LETTER GAMMA */
+#define XK_Greek_delta                   0x07e4  /* U+03B4 GREEK SMALL LETTER DELTA */
+#define XK_Greek_epsilon                 0x07e5  /* U+03B5 GREEK SMALL LETTER EPSILON */
+#define XK_Greek_zeta                    0x07e6  /* U+03B6 GREEK SMALL LETTER ZETA */
+#define XK_Greek_eta                     0x07e7  /* U+03B7 GREEK SMALL LETTER ETA */
+#define XK_Greek_theta                   0x07e8  /* U+03B8 GREEK SMALL LETTER THETA */
+#define XK_Greek_iota                    0x07e9  /* U+03B9 GREEK SMALL LETTER IOTA */
+#define XK_Greek_kappa                   0x07ea  /* U+03BA GREEK SMALL LETTER KAPPA */
+#define XK_Greek_lamda                   0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
+#define XK_Greek_lambda                  0x07eb  /* U+03BB GREEK SMALL LETTER LAMDA */
+#define XK_Greek_mu                      0x07ec  /* U+03BC GREEK SMALL LETTER MU */
+#define XK_Greek_nu                      0x07ed  /* U+03BD GREEK SMALL LETTER NU */
+#define XK_Greek_xi                      0x07ee  /* U+03BE GREEK SMALL LETTER XI */
+#define XK_Greek_omicron                 0x07ef  /* U+03BF GREEK SMALL LETTER OMICRON */
+#define XK_Greek_pi                      0x07f0  /* U+03C0 GREEK SMALL LETTER PI */
+#define XK_Greek_rho                     0x07f1  /* U+03C1 GREEK SMALL LETTER RHO */
+#define XK_Greek_sigma                   0x07f2  /* U+03C3 GREEK SMALL LETTER SIGMA */
+#define XK_Greek_finalsmallsigma         0x07f3  /* U+03C2 GREEK SMALL LETTER FINAL SIGMA */
+#define XK_Greek_tau                     0x07f4  /* U+03C4 GREEK SMALL LETTER TAU */
+#define XK_Greek_upsilon                 0x07f5  /* U+03C5 GREEK SMALL LETTER UPSILON */
+#define XK_Greek_phi                     0x07f6  /* U+03C6 GREEK SMALL LETTER PHI */
+#define XK_Greek_chi                     0x07f7  /* U+03C7 GREEK SMALL LETTER CHI */
+#define XK_Greek_psi                     0x07f8  /* U+03C8 GREEK SMALL LETTER PSI */
+#define XK_Greek_omega                   0x07f9  /* U+03C9 GREEK SMALL LETTER OMEGA */
+#define XK_Greek_switch                  0xff7e  /* Alias for mode_switch */
+#endif /* XK_GREEK */
+
+/*
+ * Technical
+ * (from the DEC VT330/VT420 Technical Character Set, http://vt100.net/charsets/technical.html)
+ * Byte 3 = 8
+ */
+
+#ifdef XK_TECHNICAL
+#define XK_leftradical                   0x08a1  /* U+23B7 RADICAL SYMBOL BOTTOM */
+#define XK_topleftradical                0x08a2  /*(U+250C BOX DRAWINGS LIGHT DOWN AND RIGHT)*/
+#define XK_horizconnector                0x08a3  /*(U+2500 BOX DRAWINGS LIGHT HORIZONTAL)*/
+#define XK_topintegral                   0x08a4  /* U+2320 TOP HALF INTEGRAL */
+#define XK_botintegral                   0x08a5  /* U+2321 BOTTOM HALF INTEGRAL */
+#define XK_vertconnector                 0x08a6  /*(U+2502 BOX DRAWINGS LIGHT VERTICAL)*/
+#define XK_topleftsqbracket              0x08a7  /* U+23A1 LEFT SQUARE BRACKET UPPER CORNER */
+#define XK_botleftsqbracket              0x08a8  /* U+23A3 LEFT SQUARE BRACKET LOWER CORNER */
+#define XK_toprightsqbracket             0x08a9  /* U+23A4 RIGHT SQUARE BRACKET UPPER CORNER */
+#define XK_botrightsqbracket             0x08aa  /* U+23A6 RIGHT SQUARE BRACKET LOWER CORNER */
+#define XK_topleftparens                 0x08ab  /* U+239B LEFT PARENTHESIS UPPER HOOK */
+#define XK_botleftparens                 0x08ac  /* U+239D LEFT PARENTHESIS LOWER HOOK */
+#define XK_toprightparens                0x08ad  /* U+239E RIGHT PARENTHESIS UPPER HOOK */
+#define XK_botrightparens                0x08ae  /* U+23A0 RIGHT PARENTHESIS LOWER HOOK */
+#define XK_leftmiddlecurlybrace          0x08af  /* U+23A8 LEFT CURLY BRACKET MIDDLE PIECE */
+#define XK_rightmiddlecurlybrace         0x08b0  /* U+23AC RIGHT CURLY BRACKET MIDDLE PIECE */
+#define XK_topleftsummation              0x08b1
+#define XK_botleftsummation              0x08b2
+#define XK_topvertsummationconnector     0x08b3
+#define XK_botvertsummationconnector     0x08b4
+#define XK_toprightsummation             0x08b5
+#define XK_botrightsummation             0x08b6
+#define XK_rightmiddlesummation          0x08b7
+#define XK_lessthanequal                 0x08bc  /* U+2264 LESS-THAN OR EQUAL TO */
+#define XK_notequal                      0x08bd  /* U+2260 NOT EQUAL TO */
+#define XK_greaterthanequal              0x08be  /* U+2265 GREATER-THAN OR EQUAL TO */
+#define XK_integral                      0x08bf  /* U+222B INTEGRAL */
+#define XK_therefore                     0x08c0  /* U+2234 THEREFORE */
+#define XK_variation                     0x08c1  /* U+221D PROPORTIONAL TO */
+#define XK_infinity                      0x08c2  /* U+221E INFINITY */
+#define XK_nabla                         0x08c5  /* U+2207 NABLA */
+#define XK_approximate                   0x08c8  /* U+223C TILDE OPERATOR */
+#define XK_similarequal                  0x08c9  /* U+2243 ASYMPTOTICALLY EQUAL TO */
+#define XK_ifonlyif                      0x08cd  /* U+21D4 LEFT RIGHT DOUBLE ARROW */
+#define XK_implies                       0x08ce  /* U+21D2 RIGHTWARDS DOUBLE ARROW */
+#define XK_identical                     0x08cf  /* U+2261 IDENTICAL TO */
+#define XK_radical                       0x08d6  /* U+221A SQUARE ROOT */
+#define XK_includedin                    0x08da  /* U+2282 SUBSET OF */
+#define XK_includes                      0x08db  /* U+2283 SUPERSET OF */
+#define XK_intersection                  0x08dc  /* U+2229 INTERSECTION */
+#define XK_union                         0x08dd  /* U+222A UNION */
+#define XK_logicaland                    0x08de  /* U+2227 LOGICAL AND */
+#define XK_logicalor                     0x08df  /* U+2228 LOGICAL OR */
+#define XK_partialderivative             0x08ef  /* U+2202 PARTIAL DIFFERENTIAL */
+#define XK_function                      0x08f6  /* U+0192 LATIN SMALL LETTER F WITH HOOK */
+#define XK_leftarrow                     0x08fb  /* U+2190 LEFTWARDS ARROW */
+#define XK_uparrow                       0x08fc  /* U+2191 UPWARDS ARROW */
+#define XK_rightarrow                    0x08fd  /* U+2192 RIGHTWARDS ARROW */
+#define XK_downarrow                     0x08fe  /* U+2193 DOWNWARDS ARROW */
+#endif /* XK_TECHNICAL */
+
+/*
+ * Special
+ * (from the DEC VT100 Special Graphics Character Set)
+ * Byte 3 = 9
+ */
+
+#ifdef XK_SPECIAL
+#define XK_blank                         0x09df
+#define XK_soliddiamond                  0x09e0  /* U+25C6 BLACK DIAMOND */
+#define XK_checkerboard                  0x09e1  /* U+2592 MEDIUM SHADE */
+#define XK_ht                            0x09e2  /* U+2409 SYMBOL FOR HORIZONTAL TABULATION */
+#define XK_ff                            0x09e3  /* U+240C SYMBOL FOR FORM FEED */
+#define XK_cr                            0x09e4  /* U+240D SYMBOL FOR CARRIAGE RETURN */
+#define XK_lf                            0x09e5  /* U+240A SYMBOL FOR LINE FEED */
+#define XK_nl                            0x09e8  /* U+2424 SYMBOL FOR NEWLINE */
+#define XK_vt                            0x09e9  /* U+240B SYMBOL FOR VERTICAL TABULATION */
+#define XK_lowrightcorner                0x09ea  /* U+2518 BOX DRAWINGS LIGHT UP AND LEFT */
+#define XK_uprightcorner                 0x09eb  /* U+2510 BOX DRAWINGS LIGHT DOWN AND LEFT */
+#define XK_upleftcorner                  0x09ec  /* U+250C BOX DRAWINGS LIGHT DOWN AND RIGHT */
+#define XK_lowleftcorner                 0x09ed  /* U+2514 BOX DRAWINGS LIGHT UP AND RIGHT */
+#define XK_crossinglines                 0x09ee  /* U+253C BOX DRAWINGS LIGHT VERTICAL AND HORIZONTAL */
+#define XK_horizlinescan1                0x09ef  /* U+23BA HORIZONTAL SCAN LINE-1 */
+#define XK_horizlinescan3                0x09f0  /* U+23BB HORIZONTAL SCAN LINE-3 */
+#define XK_horizlinescan5                0x09f1  /* U+2500 BOX DRAWINGS LIGHT HORIZONTAL */
+#define XK_horizlinescan7                0x09f2  /* U+23BC HORIZONTAL SCAN LINE-7 */
+#define XK_horizlinescan9                0x09f3  /* U+23BD HORIZONTAL SCAN LINE-9 */
+#define XK_leftt                         0x09f4  /* U+251C BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
+#define XK_rightt                        0x09f5  /* U+2524 BOX DRAWINGS LIGHT VERTICAL AND LEFT */
+#define XK_bott                          0x09f6  /* U+2534 BOX DRAWINGS LIGHT UP AND HORIZONTAL */
+#define XK_topt                          0x09f7  /* U+252C BOX DRAWINGS LIGHT DOWN AND HORIZONTAL */
+#define XK_vertbar                       0x09f8  /* U+2502 BOX DRAWINGS LIGHT VERTICAL */
+#endif /* XK_SPECIAL */
+
+/*
+ * Publishing
+ * (these are probably from a long forgotten DEC Publishing
+ * font that once shipped with DECwrite)
+ * Byte 3 = 0x0a
+ */
+
+#ifdef XK_PUBLISHING
+#define XK_emspace                       0x0aa1  /* U+2003 EM SPACE */
+#define XK_enspace                       0x0aa2  /* U+2002 EN SPACE */
+#define XK_em3space                      0x0aa3  /* U+2004 THREE-PER-EM SPACE */
+#define XK_em4space                      0x0aa4  /* U+2005 FOUR-PER-EM SPACE */
+#define XK_digitspace                    0x0aa5  /* U+2007 FIGURE SPACE */
+#define XK_punctspace                    0x0aa6  /* U+2008 PUNCTUATION SPACE */
+#define XK_thinspace                     0x0aa7  /* U+2009 THIN SPACE */
+#define XK_hairspace                     0x0aa8  /* U+200A HAIR SPACE */
+#define XK_emdash                        0x0aa9  /* U+2014 EM DASH */
+#define XK_endash                        0x0aaa  /* U+2013 EN DASH */
+#define XK_signifblank                   0x0aac  /*(U+2423 OPEN BOX)*/
+#define XK_ellipsis                      0x0aae  /* U+2026 HORIZONTAL ELLIPSIS */
+#define XK_doubbaselinedot               0x0aaf  /* U+2025 TWO DOT LEADER */
+#define XK_onethird                      0x0ab0  /* U+2153 VULGAR FRACTION ONE THIRD */
+#define XK_twothirds                     0x0ab1  /* U+2154 VULGAR FRACTION TWO THIRDS */
+#define XK_onefifth                      0x0ab2  /* U+2155 VULGAR FRACTION ONE FIFTH */
+#define XK_twofifths                     0x0ab3  /* U+2156 VULGAR FRACTION TWO FIFTHS */
+#define XK_threefifths                   0x0ab4  /* U+2157 VULGAR FRACTION THREE FIFTHS */
+#define XK_fourfifths                    0x0ab5  /* U+2158 VULGAR FRACTION FOUR FIFTHS */
+#define XK_onesixth                      0x0ab6  /* U+2159 VULGAR FRACTION ONE SIXTH */
+#define XK_fivesixths                    0x0ab7  /* U+215A VULGAR FRACTION FIVE SIXTHS */
+#define XK_careof                        0x0ab8  /* U+2105 CARE OF */
+#define XK_figdash                       0x0abb  /* U+2012 FIGURE DASH */
+#define XK_leftanglebracket              0x0abc  /*(U+27E8 MATHEMATICAL LEFT ANGLE BRACKET)*/
+#define XK_decimalpoint                  0x0abd  /*(U+002E FULL STOP)*/
+#define XK_rightanglebracket             0x0abe  /*(U+27E9 MATHEMATICAL RIGHT ANGLE BRACKET)*/
+#define XK_marker                        0x0abf
+#define XK_oneeighth                     0x0ac3  /* U+215B VULGAR FRACTION ONE EIGHTH */
+#define XK_threeeighths                  0x0ac4  /* U+215C VULGAR FRACTION THREE EIGHTHS */
+#define XK_fiveeighths                   0x0ac5  /* U+215D VULGAR FRACTION FIVE EIGHTHS */
+#define XK_seveneighths                  0x0ac6  /* U+215E VULGAR FRACTION SEVEN EIGHTHS */
+#define XK_trademark                     0x0ac9  /* U+2122 TRADE MARK SIGN */
+#define XK_signaturemark                 0x0aca  /*(U+2613 SALTIRE)*/
+#define XK_trademarkincircle             0x0acb
+#define XK_leftopentriangle              0x0acc  /*(U+25C1 WHITE LEFT-POINTING TRIANGLE)*/
+#define XK_rightopentriangle             0x0acd  /*(U+25B7 WHITE RIGHT-POINTING TRIANGLE)*/
+#define XK_emopencircle                  0x0ace  /*(U+25CB WHITE CIRCLE)*/
+#define XK_emopenrectangle               0x0acf  /*(U+25AF WHITE VERTICAL RECTANGLE)*/
+#define XK_leftsinglequotemark           0x0ad0  /* U+2018 LEFT SINGLE QUOTATION MARK */
+#define XK_rightsinglequotemark          0x0ad1  /* U+2019 RIGHT SINGLE QUOTATION MARK */
+#define XK_leftdoublequotemark           0x0ad2  /* U+201C LEFT DOUBLE QUOTATION MARK */
+#define XK_rightdoublequotemark          0x0ad3  /* U+201D RIGHT DOUBLE QUOTATION MARK */
+#define XK_prescription                  0x0ad4  /* U+211E PRESCRIPTION TAKE */
+#define XK_minutes                       0x0ad6  /* U+2032 PRIME */
+#define XK_seconds                       0x0ad7  /* U+2033 DOUBLE PRIME */
+#define XK_latincross                    0x0ad9  /* U+271D LATIN CROSS */
+#define XK_hexagram                      0x0ada
+#define XK_filledrectbullet              0x0adb  /*(U+25AC BLACK RECTANGLE)*/
+#define XK_filledlefttribullet           0x0adc  /*(U+25C0 BLACK LEFT-POINTING TRIANGLE)*/
+#define XK_filledrighttribullet          0x0add  /*(U+25B6 BLACK RIGHT-POINTING TRIANGLE)*/
+#define XK_emfilledcircle                0x0ade  /*(U+25CF BLACK CIRCLE)*/
+#define XK_emfilledrect                  0x0adf  /*(U+25AE BLACK VERTICAL RECTANGLE)*/
+#define XK_enopencircbullet              0x0ae0  /*(U+25E6 WHITE BULLET)*/
+#define XK_enopensquarebullet            0x0ae1  /*(U+25AB WHITE SMALL SQUARE)*/
+#define XK_openrectbullet                0x0ae2  /*(U+25AD WHITE RECTANGLE)*/
+#define XK_opentribulletup               0x0ae3  /*(U+25B3 WHITE UP-POINTING TRIANGLE)*/
+#define XK_opentribulletdown             0x0ae4  /*(U+25BD WHITE DOWN-POINTING TRIANGLE)*/
+#define XK_openstar                      0x0ae5  /*(U+2606 WHITE STAR)*/
+#define XK_enfilledcircbullet            0x0ae6  /*(U+2022 BULLET)*/
+#define XK_enfilledsqbullet              0x0ae7  /*(U+25AA BLACK SMALL SQUARE)*/
+#define XK_filledtribulletup             0x0ae8  /*(U+25B2 BLACK UP-POINTING TRIANGLE)*/
+#define XK_filledtribulletdown           0x0ae9  /*(U+25BC BLACK DOWN-POINTING TRIANGLE)*/
+#define XK_leftpointer                   0x0aea  /*(U+261C WHITE LEFT POINTING INDEX)*/
+#define XK_rightpointer                  0x0aeb  /*(U+261E WHITE RIGHT POINTING INDEX)*/
+#define XK_club                          0x0aec  /* U+2663 BLACK CLUB SUIT */
+#define XK_diamond                       0x0aed  /* U+2666 BLACK DIAMOND SUIT */
+#define XK_heart                         0x0aee  /* U+2665 BLACK HEART SUIT */
+#define XK_maltesecross                  0x0af0  /* U+2720 MALTESE CROSS */
+#define XK_dagger                        0x0af1  /* U+2020 DAGGER */
+#define XK_doubledagger                  0x0af2  /* U+2021 DOUBLE DAGGER */
+#define XK_checkmark                     0x0af3  /* U+2713 CHECK MARK */
+#define XK_ballotcross                   0x0af4  /* U+2717 BALLOT X */
+#define XK_musicalsharp                  0x0af5  /* U+266F MUSIC SHARP SIGN */
+#define XK_musicalflat                   0x0af6  /* U+266D MUSIC FLAT SIGN */
+#define XK_malesymbol                    0x0af7  /* U+2642 MALE SIGN */
+#define XK_femalesymbol                  0x0af8  /* U+2640 FEMALE SIGN */
+#define XK_telephone                     0x0af9  /* U+260E BLACK TELEPHONE */
+#define XK_telephonerecorder             0x0afa  /* U+2315 TELEPHONE RECORDER */
+#define XK_phonographcopyright           0x0afb  /* U+2117 SOUND RECORDING COPYRIGHT */
+#define XK_caret                         0x0afc  /* U+2038 CARET */
+#define XK_singlelowquotemark            0x0afd  /* U+201A SINGLE LOW-9 QUOTATION MARK */
+#define XK_doublelowquotemark            0x0afe  /* U+201E DOUBLE LOW-9 QUOTATION MARK */
+#define XK_cursor                        0x0aff
+#endif /* XK_PUBLISHING */
+
+/*
+ * APL
+ * Byte 3 = 0x0b
+ */
+
+#ifdef XK_APL
+#define XK_leftcaret                     0x0ba3  /*(U+003C LESS-THAN SIGN)*/
+#define XK_rightcaret                    0x0ba6  /*(U+003E GREATER-THAN SIGN)*/
+#define XK_downcaret                     0x0ba8  /*(U+2228 LOGICAL OR)*/
+#define XK_upcaret                       0x0ba9  /*(U+2227 LOGICAL AND)*/
+#define XK_overbar                       0x0bc0  /*(U+00AF MACRON)*/
+#define XK_downtack                      0x0bc2  /* U+22A4 DOWN TACK */
+#define XK_upshoe                        0x0bc3  /*(U+2229 INTERSECTION)*/
+#define XK_downstile                     0x0bc4  /* U+230A LEFT FLOOR */
+#define XK_underbar                      0x0bc6  /*(U+005F LOW LINE)*/
+#define XK_jot                           0x0bca  /* U+2218 RING OPERATOR */
+#define XK_quad                          0x0bcc  /* U+2395 APL FUNCTIONAL SYMBOL QUAD */
+#define XK_uptack                        0x0bce  /* U+22A5 UP TACK */
+#define XK_circle                        0x0bcf  /* U+25CB WHITE CIRCLE */
+#define XK_upstile                       0x0bd3  /* U+2308 LEFT CEILING */
+#define XK_downshoe                      0x0bd6  /*(U+222A UNION)*/
+#define XK_rightshoe                     0x0bd8  /*(U+2283 SUPERSET OF)*/
+#define XK_leftshoe                      0x0bda  /*(U+2282 SUBSET OF)*/
+#define XK_lefttack                      0x0bdc  /* U+22A3 LEFT TACK */
+#define XK_righttack                     0x0bfc  /* U+22A2 RIGHT TACK */
+#endif /* XK_APL */
+
+/*
+ * Hebrew
+ * Byte 3 = 0x0c
+ */
+
+#ifdef XK_HEBREW
+#define XK_hebrew_doublelowline          0x0cdf  /* U+2017 DOUBLE LOW LINE */
+#define XK_hebrew_aleph                  0x0ce0  /* U+05D0 HEBREW LETTER ALEF */
+#define XK_hebrew_bet                    0x0ce1  /* U+05D1 HEBREW LETTER BET */
+#define XK_hebrew_beth                   0x0ce1  /* deprecated */
+#define XK_hebrew_gimel                  0x0ce2  /* U+05D2 HEBREW LETTER GIMEL */
+#define XK_hebrew_gimmel                 0x0ce2  /* deprecated */
+#define XK_hebrew_dalet                  0x0ce3  /* U+05D3 HEBREW LETTER DALET */
+#define XK_hebrew_daleth                 0x0ce3  /* deprecated */
+#define XK_hebrew_he                     0x0ce4  /* U+05D4 HEBREW LETTER HE */
+#define XK_hebrew_waw                    0x0ce5  /* U+05D5 HEBREW LETTER VAV */
+#define XK_hebrew_zain                   0x0ce6  /* U+05D6 HEBREW LETTER ZAYIN */
+#define XK_hebrew_zayin                  0x0ce6  /* deprecated */
+#define XK_hebrew_chet                   0x0ce7  /* U+05D7 HEBREW LETTER HET */
+#define XK_hebrew_het                    0x0ce7  /* deprecated */
+#define XK_hebrew_tet                    0x0ce8  /* U+05D8 HEBREW LETTER TET */
+#define XK_hebrew_teth                   0x0ce8  /* deprecated */
+#define XK_hebrew_yod                    0x0ce9  /* U+05D9 HEBREW LETTER YOD */
+#define XK_hebrew_finalkaph              0x0cea  /* U+05DA HEBREW LETTER FINAL KAF */
+#define XK_hebrew_kaph                   0x0ceb  /* U+05DB HEBREW LETTER KAF */
+#define XK_hebrew_lamed                  0x0cec  /* U+05DC HEBREW LETTER LAMED */
+#define XK_hebrew_finalmem               0x0ced  /* U+05DD HEBREW LETTER FINAL MEM */
+#define XK_hebrew_mem                    0x0cee  /* U+05DE HEBREW LETTER MEM */
+#define XK_hebrew_finalnun               0x0cef  /* U+05DF HEBREW LETTER FINAL NUN */
+#define XK_hebrew_nun                    0x0cf0  /* U+05E0 HEBREW LETTER NUN */
+#define XK_hebrew_samech                 0x0cf1  /* U+05E1 HEBREW LETTER SAMEKH */
+#define XK_hebrew_samekh                 0x0cf1  /* deprecated */
+#define XK_hebrew_ayin                   0x0cf2  /* U+05E2 HEBREW LETTER AYIN */
+#define XK_hebrew_finalpe                0x0cf3  /* U+05E3 HEBREW LETTER FINAL PE */
+#define XK_hebrew_pe                     0x0cf4  /* U+05E4 HEBREW LETTER PE */
+#define XK_hebrew_finalzade              0x0cf5  /* U+05E5 HEBREW LETTER FINAL TSADI */
+#define XK_hebrew_finalzadi              0x0cf5  /* deprecated */
+#define XK_hebrew_zade                   0x0cf6  /* U+05E6 HEBREW LETTER TSADI */
+#define XK_hebrew_zadi                   0x0cf6  /* deprecated */
+#define XK_hebrew_qoph                   0x0cf7  /* U+05E7 HEBREW LETTER QOF */
+#define XK_hebrew_kuf                    0x0cf7  /* deprecated */
+#define XK_hebrew_resh                   0x0cf8  /* U+05E8 HEBREW LETTER RESH */
+#define XK_hebrew_shin                   0x0cf9  /* U+05E9 HEBREW LETTER SHIN */
+#define XK_hebrew_taw                    0x0cfa  /* U+05EA HEBREW LETTER TAV */
+#define XK_hebrew_taf                    0x0cfa  /* deprecated */
+#define XK_Hebrew_switch                 0xff7e  /* Alias for mode_switch */
+#endif /* XK_HEBREW */
+
+/*
+ * Thai
+ * Byte 3 = 0x0d
+ */
+
+#ifdef XK_THAI
+#define XK_Thai_kokai                    0x0da1  /* U+0E01 THAI CHARACTER KO KAI */
+#define XK_Thai_khokhai                  0x0da2  /* U+0E02 THAI CHARACTER KHO KHAI */
+#define XK_Thai_khokhuat                 0x0da3  /* U+0E03 THAI CHARACTER KHO KHUAT */
+#define XK_Thai_khokhwai                 0x0da4  /* U+0E04 THAI CHARACTER KHO KHWAI */
+#define XK_Thai_khokhon                  0x0da5  /* U+0E05 THAI CHARACTER KHO KHON */
+#define XK_Thai_khorakhang               0x0da6  /* U+0E06 THAI CHARACTER KHO RAKHANG */
+#define XK_Thai_ngongu                   0x0da7  /* U+0E07 THAI CHARACTER NGO NGU */
+#define XK_Thai_chochan                  0x0da8  /* U+0E08 THAI CHARACTER CHO CHAN */
+#define XK_Thai_choching                 0x0da9  /* U+0E09 THAI CHARACTER CHO CHING */
+#define XK_Thai_chochang                 0x0daa  /* U+0E0A THAI CHARACTER CHO CHANG */
+#define XK_Thai_soso                     0x0dab  /* U+0E0B THAI CHARACTER SO SO */
+#define XK_Thai_chochoe                  0x0dac  /* U+0E0C THAI CHARACTER CHO CHOE */
+#define XK_Thai_yoying                   0x0dad  /* U+0E0D THAI CHARACTER YO YING */
+#define XK_Thai_dochada                  0x0dae  /* U+0E0E THAI CHARACTER DO CHADA */
+#define XK_Thai_topatak                  0x0daf  /* U+0E0F THAI CHARACTER TO PATAK */
+#define XK_Thai_thothan                  0x0db0  /* U+0E10 THAI CHARACTER THO THAN */
+#define XK_Thai_thonangmontho            0x0db1  /* U+0E11 THAI CHARACTER THO NANGMONTHO */
+#define XK_Thai_thophuthao               0x0db2  /* U+0E12 THAI CHARACTER THO PHUTHAO */
+#define XK_Thai_nonen                    0x0db3  /* U+0E13 THAI CHARACTER NO NEN */
+#define XK_Thai_dodek                    0x0db4  /* U+0E14 THAI CHARACTER DO DEK */
+#define XK_Thai_totao                    0x0db5  /* U+0E15 THAI CHARACTER TO TAO */
+#define XK_Thai_thothung                 0x0db6  /* U+0E16 THAI CHARACTER THO THUNG */
+#define XK_Thai_thothahan                0x0db7  /* U+0E17 THAI CHARACTER THO THAHAN */
+#define XK_Thai_thothong                 0x0db8  /* U+0E18 THAI CHARACTER THO THONG */
+#define XK_Thai_nonu                     0x0db9  /* U+0E19 THAI CHARACTER NO NU */
+#define XK_Thai_bobaimai                 0x0dba  /* U+0E1A THAI CHARACTER BO BAIMAI */
+#define XK_Thai_popla                    0x0dbb  /* U+0E1B THAI CHARACTER PO PLA */
+#define XK_Thai_phophung                 0x0dbc  /* U+0E1C THAI CHARACTER PHO PHUNG */
+#define XK_Thai_fofa                     0x0dbd  /* U+0E1D THAI CHARACTER FO FA */
+#define XK_Thai_phophan                  0x0dbe  /* U+0E1E THAI CHARACTER PHO PHAN */
+#define XK_Thai_fofan                    0x0dbf  /* U+0E1F THAI CHARACTER FO FAN */
+#define XK_Thai_phosamphao               0x0dc0  /* U+0E20 THAI CHARACTER PHO SAMPHAO */
+#define XK_Thai_moma                     0x0dc1  /* U+0E21 THAI CHARACTER MO MA */
+#define XK_Thai_yoyak                    0x0dc2  /* U+0E22 THAI CHARACTER YO YAK */
+#define XK_Thai_rorua                    0x0dc3  /* U+0E23 THAI CHARACTER RO RUA */
+#define XK_Thai_ru                       0x0dc4  /* U+0E24 THAI CHARACTER RU */
+#define XK_Thai_loling                   0x0dc5  /* U+0E25 THAI CHARACTER LO LING */
+#define XK_Thai_lu                       0x0dc6  /* U+0E26 THAI CHARACTER LU */
+#define XK_Thai_wowaen                   0x0dc7  /* U+0E27 THAI CHARACTER WO WAEN */
+#define XK_Thai_sosala                   0x0dc8  /* U+0E28 THAI CHARACTER SO SALA */
+#define XK_Thai_sorusi                   0x0dc9  /* U+0E29 THAI CHARACTER SO RUSI */
+#define XK_Thai_sosua                    0x0dca  /* U+0E2A THAI CHARACTER SO SUA */
+#define XK_Thai_hohip                    0x0dcb  /* U+0E2B THAI CHARACTER HO HIP */
+#define XK_Thai_lochula                  0x0dcc  /* U+0E2C THAI CHARACTER LO CHULA */
+#define XK_Thai_oang                     0x0dcd  /* U+0E2D THAI CHARACTER O ANG */
+#define XK_Thai_honokhuk                 0x0dce  /* U+0E2E THAI CHARACTER HO NOKHUK */
+#define XK_Thai_paiyannoi                0x0dcf  /* U+0E2F THAI CHARACTER PAIYANNOI */
+#define XK_Thai_saraa                    0x0dd0  /* U+0E30 THAI CHARACTER SARA A */
+#define XK_Thai_maihanakat               0x0dd1  /* U+0E31 THAI CHARACTER MAI HAN-AKAT */
+#define XK_Thai_saraaa                   0x0dd2  /* U+0E32 THAI CHARACTER SARA AA */
+#define XK_Thai_saraam                   0x0dd3  /* U+0E33 THAI CHARACTER SARA AM */
+#define XK_Thai_sarai                    0x0dd4  /* U+0E34 THAI CHARACTER SARA I */
+#define XK_Thai_saraii                   0x0dd5  /* U+0E35 THAI CHARACTER SARA II */
+#define XK_Thai_saraue                   0x0dd6  /* U+0E36 THAI CHARACTER SARA UE */
+#define XK_Thai_sarauee                  0x0dd7  /* U+0E37 THAI CHARACTER SARA UEE */
+#define XK_Thai_sarau                    0x0dd8  /* U+0E38 THAI CHARACTER SARA U */
+#define XK_Thai_sarauu                   0x0dd9  /* U+0E39 THAI CHARACTER SARA UU */
+#define XK_Thai_phinthu                  0x0dda  /* U+0E3A THAI CHARACTER PHINTHU */
+#define XK_Thai_maihanakat_maitho        0x0dde
+#define XK_Thai_baht                     0x0ddf  /* U+0E3F THAI CURRENCY SYMBOL BAHT */
+#define XK_Thai_sarae                    0x0de0  /* U+0E40 THAI CHARACTER SARA E */
+#define XK_Thai_saraae                   0x0de1  /* U+0E41 THAI CHARACTER SARA AE */
+#define XK_Thai_sarao                    0x0de2  /* U+0E42 THAI CHARACTER SARA O */
+#define XK_Thai_saraaimaimuan            0x0de3  /* U+0E43 THAI CHARACTER SARA AI MAIMUAN */
+#define XK_Thai_saraaimaimalai           0x0de4  /* U+0E44 THAI CHARACTER SARA AI MAIMALAI */
+#define XK_Thai_lakkhangyao              0x0de5  /* U+0E45 THAI CHARACTER LAKKHANGYAO */
+#define XK_Thai_maiyamok                 0x0de6  /* U+0E46 THAI CHARACTER MAIYAMOK */
+#define XK_Thai_maitaikhu                0x0de7  /* U+0E47 THAI CHARACTER MAITAIKHU */
+#define XK_Thai_maiek                    0x0de8  /* U+0E48 THAI CHARACTER MAI EK */
+#define XK_Thai_maitho                   0x0de9  /* U+0E49 THAI CHARACTER MAI THO */
+#define XK_Thai_maitri                   0x0dea  /* U+0E4A THAI CHARACTER MAI TRI */
+#define XK_Thai_maichattawa              0x0deb  /* U+0E4B THAI CHARACTER MAI CHATTAWA */
+#define XK_Thai_thanthakhat              0x0dec  /* U+0E4C THAI CHARACTER THANTHAKHAT */
+#define XK_Thai_nikhahit                 0x0ded  /* U+0E4D THAI CHARACTER NIKHAHIT */
+#define XK_Thai_leksun                   0x0df0  /* U+0E50 THAI DIGIT ZERO */
+#define XK_Thai_leknung                  0x0df1  /* U+0E51 THAI DIGIT ONE */
+#define XK_Thai_leksong                  0x0df2  /* U+0E52 THAI DIGIT TWO */
+#define XK_Thai_leksam                   0x0df3  /* U+0E53 THAI DIGIT THREE */
+#define XK_Thai_leksi                    0x0df4  /* U+0E54 THAI DIGIT FOUR */
+#define XK_Thai_lekha                    0x0df5  /* U+0E55 THAI DIGIT FIVE */
+#define XK_Thai_lekhok                   0x0df6  /* U+0E56 THAI DIGIT SIX */
+#define XK_Thai_lekchet                  0x0df7  /* U+0E57 THAI DIGIT SEVEN */
+#define XK_Thai_lekpaet                  0x0df8  /* U+0E58 THAI DIGIT EIGHT */
+#define XK_Thai_lekkao                   0x0df9  /* U+0E59 THAI DIGIT NINE */
+#endif /* XK_THAI */
+
+/*
+ * Korean
+ * Byte 3 = 0x0e
+ */
+
+#ifdef XK_KOREAN
+
+#define XK_Hangul                        0xff31  /* Hangul start/stop(toggle) */
+#define XK_Hangul_Start                  0xff32  /* Hangul start */
+#define XK_Hangul_End                    0xff33  /* Hangul end, English start */
+#define XK_Hangul_Hanja                  0xff34  /* Start Hangul->Hanja Conversion */
+#define XK_Hangul_Jamo                   0xff35  /* Hangul Jamo mode */
+#define XK_Hangul_Romaja                 0xff36  /* Hangul Romaja mode */
+#define XK_Hangul_Codeinput              0xff37  /* Hangul code input mode */
+#define XK_Hangul_Jeonja                 0xff38  /* Jeonja mode */
+#define XK_Hangul_Banja                  0xff39  /* Banja mode */
+#define XK_Hangul_PreHanja               0xff3a  /* Pre Hanja conversion */
+#define XK_Hangul_PostHanja              0xff3b  /* Post Hanja conversion */
+#define XK_Hangul_SingleCandidate        0xff3c  /* Single candidate */
+#define XK_Hangul_MultipleCandidate      0xff3d  /* Multiple candidate */
+#define XK_Hangul_PreviousCandidate      0xff3e  /* Previous candidate */
+#define XK_Hangul_Special                0xff3f  /* Special symbols */
+#define XK_Hangul_switch                 0xff7e  /* Alias for mode_switch */
+
+/* Hangul Consonant Characters */
+#define XK_Hangul_Kiyeog                 0x0ea1
+#define XK_Hangul_SsangKiyeog            0x0ea2
+#define XK_Hangul_KiyeogSios             0x0ea3
+#define XK_Hangul_Nieun                  0x0ea4
+#define XK_Hangul_NieunJieuj             0x0ea5
+#define XK_Hangul_NieunHieuh             0x0ea6
+#define XK_Hangul_Dikeud                 0x0ea7
+#define XK_Hangul_SsangDikeud            0x0ea8
+#define XK_Hangul_Rieul                  0x0ea9
+#define XK_Hangul_RieulKiyeog            0x0eaa
+#define XK_Hangul_RieulMieum             0x0eab
+#define XK_Hangul_RieulPieub             0x0eac
+#define XK_Hangul_RieulSios              0x0ead
+#define XK_Hangul_RieulTieut             0x0eae
+#define XK_Hangul_RieulPhieuf            0x0eaf
+#define XK_Hangul_RieulHieuh             0x0eb0
+#define XK_Hangul_Mieum                  0x0eb1
+#define XK_Hangul_Pieub                  0x0eb2
+#define XK_Hangul_SsangPieub             0x0eb3
+#define XK_Hangul_PieubSios              0x0eb4
+#define XK_Hangul_Sios                   0x0eb5
+#define XK_Hangul_SsangSios              0x0eb6
+#define XK_Hangul_Ieung                  0x0eb7
+#define XK_Hangul_Jieuj                  0x0eb8
+#define XK_Hangul_SsangJieuj             0x0eb9
+#define XK_Hangul_Cieuc                  0x0eba
+#define XK_Hangul_Khieuq                 0x0ebb
+#define XK_Hangul_Tieut                  0x0ebc
+#define XK_Hangul_Phieuf                 0x0ebd
+#define XK_Hangul_Hieuh                  0x0ebe
+
+/* Hangul Vowel Characters */
+#define XK_Hangul_A                      0x0ebf
+#define XK_Hangul_AE                     0x0ec0
+#define XK_Hangul_YA                     0x0ec1
+#define XK_Hangul_YAE                    0x0ec2
+#define XK_Hangul_EO                     0x0ec3
+#define XK_Hangul_E                      0x0ec4
+#define XK_Hangul_YEO                    0x0ec5
+#define XK_Hangul_YE                     0x0ec6
+#define XK_Hangul_O                      0x0ec7
+#define XK_Hangul_WA                     0x0ec8
+#define XK_Hangul_WAE                    0x0ec9
+#define XK_Hangul_OE                     0x0eca
+#define XK_Hangul_YO                     0x0ecb
+#define XK_Hangul_U                      0x0ecc
+#define XK_Hangul_WEO                    0x0ecd
+#define XK_Hangul_WE                     0x0ece
+#define XK_Hangul_WI                     0x0ecf
+#define XK_Hangul_YU                     0x0ed0
+#define XK_Hangul_EU                     0x0ed1
+#define XK_Hangul_YI                     0x0ed2
+#define XK_Hangul_I                      0x0ed3
+
+/* Hangul syllable-final (JongSeong) Characters */
+#define XK_Hangul_J_Kiyeog               0x0ed4
+#define XK_Hangul_J_SsangKiyeog          0x0ed5
+#define XK_Hangul_J_KiyeogSios           0x0ed6
+#define XK_Hangul_J_Nieun                0x0ed7
+#define XK_Hangul_J_NieunJieuj           0x0ed8
+#define XK_Hangul_J_NieunHieuh           0x0ed9
+#define XK_Hangul_J_Dikeud               0x0eda
+#define XK_Hangul_J_Rieul                0x0edb
+#define XK_Hangul_J_RieulKiyeog          0x0edc
+#define XK_Hangul_J_RieulMieum           0x0edd
+#define XK_Hangul_J_RieulPieub           0x0ede
+#define XK_Hangul_J_RieulSios            0x0edf
+#define XK_Hangul_J_RieulTieut           0x0ee0
+#define XK_Hangul_J_RieulPhieuf          0x0ee1
+#define XK_Hangul_J_RieulHieuh           0x0ee2
+#define XK_Hangul_J_Mieum                0x0ee3
+#define XK_Hangul_J_Pieub                0x0ee4
+#define XK_Hangul_J_PieubSios            0x0ee5
+#define XK_Hangul_J_Sios                 0x0ee6
+#define XK_Hangul_J_SsangSios            0x0ee7
+#define XK_Hangul_J_Ieung                0x0ee8
+#define XK_Hangul_J_Jieuj                0x0ee9
+#define XK_Hangul_J_Cieuc                0x0eea
+#define XK_Hangul_J_Khieuq               0x0eeb
+#define XK_Hangul_J_Tieut                0x0eec
+#define XK_Hangul_J_Phieuf               0x0eed
+#define XK_Hangul_J_Hieuh                0x0eee
+
+/* Ancient Hangul Consonant Characters */
+#define XK_Hangul_RieulYeorinHieuh       0x0eef
+#define XK_Hangul_SunkyeongeumMieum      0x0ef0
+#define XK_Hangul_SunkyeongeumPieub      0x0ef1
+#define XK_Hangul_PanSios                0x0ef2
+#define XK_Hangul_KkogjiDalrinIeung      0x0ef3
+#define XK_Hangul_SunkyeongeumPhieuf     0x0ef4
+#define XK_Hangul_YeorinHieuh            0x0ef5
+
+/* Ancient Hangul Vowel Characters */
+#define XK_Hangul_AraeA                  0x0ef6
+#define XK_Hangul_AraeAE                 0x0ef7
+
+/* Ancient Hangul syllable-final (JongSeong) Characters */
+#define XK_Hangul_J_PanSios              0x0ef8
+#define XK_Hangul_J_KkogjiDalrinIeung    0x0ef9
+#define XK_Hangul_J_YeorinHieuh          0x0efa
+
+/* Korean currency symbol */
+#define XK_Korean_Won                    0x0eff  /*(U+20A9 WON SIGN)*/
+
+#endif /* XK_KOREAN */
+
+/*
+ * Armenian
+ */
+
+#ifdef XK_ARMENIAN
+#define XK_Armenian_ligature_ew       0x1000587  /* U+0587 ARMENIAN SMALL LIGATURE ECH YIWN */
+#define XK_Armenian_full_stop         0x1000589  /* U+0589 ARMENIAN FULL STOP */
+#define XK_Armenian_verjaket          0x1000589  /* U+0589 ARMENIAN FULL STOP */
+#define XK_Armenian_separation_mark   0x100055d  /* U+055D ARMENIAN COMMA */
+#define XK_Armenian_but               0x100055d  /* U+055D ARMENIAN COMMA */
+#define XK_Armenian_hyphen            0x100058a  /* U+058A ARMENIAN HYPHEN */
+#define XK_Armenian_yentamna          0x100058a  /* U+058A ARMENIAN HYPHEN */
+#define XK_Armenian_exclam            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
+#define XK_Armenian_amanak            0x100055c  /* U+055C ARMENIAN EXCLAMATION MARK */
+#define XK_Armenian_accent            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
+#define XK_Armenian_shesht            0x100055b  /* U+055B ARMENIAN EMPHASIS MARK */
+#define XK_Armenian_question          0x100055e  /* U+055E ARMENIAN QUESTION MARK */
+#define XK_Armenian_paruyk            0x100055e  /* U+055E ARMENIAN QUESTION MARK */
+#define XK_Armenian_AYB               0x1000531  /* U+0531 ARMENIAN CAPITAL LETTER AYB */
+#define XK_Armenian_ayb               0x1000561  /* U+0561 ARMENIAN SMALL LETTER AYB */
+#define XK_Armenian_BEN               0x1000532  /* U+0532 ARMENIAN CAPITAL LETTER BEN */
+#define XK_Armenian_ben               0x1000562  /* U+0562 ARMENIAN SMALL LETTER BEN */
+#define XK_Armenian_GIM               0x1000533  /* U+0533 ARMENIAN CAPITAL LETTER GIM */
+#define XK_Armenian_gim               0x1000563  /* U+0563 ARMENIAN SMALL LETTER GIM */
+#define XK_Armenian_DA                0x1000534  /* U+0534 ARMENIAN CAPITAL LETTER DA */
+#define XK_Armenian_da                0x1000564  /* U+0564 ARMENIAN SMALL LETTER DA */
+#define XK_Armenian_YECH              0x1000535  /* U+0535 ARMENIAN CAPITAL LETTER ECH */
+#define XK_Armenian_yech              0x1000565  /* U+0565 ARMENIAN SMALL LETTER ECH */
+#define XK_Armenian_ZA                0x1000536  /* U+0536 ARMENIAN CAPITAL LETTER ZA */
+#define XK_Armenian_za                0x1000566  /* U+0566 ARMENIAN SMALL LETTER ZA */
+#define XK_Armenian_E                 0x1000537  /* U+0537 ARMENIAN CAPITAL LETTER EH */
+#define XK_Armenian_e                 0x1000567  /* U+0567 ARMENIAN SMALL LETTER EH */
+#define XK_Armenian_AT                0x1000538  /* U+0538 ARMENIAN CAPITAL LETTER ET */
+#define XK_Armenian_at                0x1000568  /* U+0568 ARMENIAN SMALL LETTER ET */
+#define XK_Armenian_TO                0x1000539  /* U+0539 ARMENIAN CAPITAL LETTER TO */
+#define XK_Armenian_to                0x1000569  /* U+0569 ARMENIAN SMALL LETTER TO */
+#define XK_Armenian_ZHE               0x100053a  /* U+053A ARMENIAN CAPITAL LETTER ZHE */
+#define XK_Armenian_zhe               0x100056a  /* U+056A ARMENIAN SMALL LETTER ZHE */
+#define XK_Armenian_INI               0x100053b  /* U+053B ARMENIAN CAPITAL LETTER INI */
+#define XK_Armenian_ini               0x100056b  /* U+056B ARMENIAN SMALL LETTER INI */
+#define XK_Armenian_LYUN              0x100053c  /* U+053C ARMENIAN CAPITAL LETTER LIWN */
+#define XK_Armenian_lyun              0x100056c  /* U+056C ARMENIAN SMALL LETTER LIWN */
+#define XK_Armenian_KHE               0x100053d  /* U+053D ARMENIAN CAPITAL LETTER XEH */
+#define XK_Armenian_khe               0x100056d  /* U+056D ARMENIAN SMALL LETTER XEH */
+#define XK_Armenian_TSA               0x100053e  /* U+053E ARMENIAN CAPITAL LETTER CA */
+#define XK_Armenian_tsa               0x100056e  /* U+056E ARMENIAN SMALL LETTER CA */
+#define XK_Armenian_KEN               0x100053f  /* U+053F ARMENIAN CAPITAL LETTER KEN */
+#define XK_Armenian_ken               0x100056f  /* U+056F ARMENIAN SMALL LETTER KEN */
+#define XK_Armenian_HO                0x1000540  /* U+0540 ARMENIAN CAPITAL LETTER HO */
+#define XK_Armenian_ho                0x1000570  /* U+0570 ARMENIAN SMALL LETTER HO */
+#define XK_Armenian_DZA               0x1000541  /* U+0541 ARMENIAN CAPITAL LETTER JA */
+#define XK_Armenian_dza               0x1000571  /* U+0571 ARMENIAN SMALL LETTER JA */
+#define XK_Armenian_GHAT              0x1000542  /* U+0542 ARMENIAN CAPITAL LETTER GHAD */
+#define XK_Armenian_ghat              0x1000572  /* U+0572 ARMENIAN SMALL LETTER GHAD */
+#define XK_Armenian_TCHE              0x1000543  /* U+0543 ARMENIAN CAPITAL LETTER CHEH */
+#define XK_Armenian_tche              0x1000573  /* U+0573 ARMENIAN SMALL LETTER CHEH */
+#define XK_Armenian_MEN               0x1000544  /* U+0544 ARMENIAN CAPITAL LETTER MEN */
+#define XK_Armenian_men               0x1000574  /* U+0574 ARMENIAN SMALL LETTER MEN */
+#define XK_Armenian_HI                0x1000545  /* U+0545 ARMENIAN CAPITAL LETTER YI */
+#define XK_Armenian_hi                0x1000575  /* U+0575 ARMENIAN SMALL LETTER YI */
+#define XK_Armenian_NU                0x1000546  /* U+0546 ARMENIAN CAPITAL LETTER NOW */
+#define XK_Armenian_nu                0x1000576  /* U+0576 ARMENIAN SMALL LETTER NOW */
+#define XK_Armenian_SHA               0x1000547  /* U+0547 ARMENIAN CAPITAL LETTER SHA */
+#define XK_Armenian_sha               0x1000577  /* U+0577 ARMENIAN SMALL LETTER SHA */
+#define XK_Armenian_VO                0x1000548  /* U+0548 ARMENIAN CAPITAL LETTER VO */
+#define XK_Armenian_vo                0x1000578  /* U+0578 ARMENIAN SMALL LETTER VO */
+#define XK_Armenian_CHA               0x1000549  /* U+0549 ARMENIAN CAPITAL LETTER CHA */
+#define XK_Armenian_cha               0x1000579  /* U+0579 ARMENIAN SMALL LETTER CHA */
+#define XK_Armenian_PE                0x100054a  /* U+054A ARMENIAN CAPITAL LETTER PEH */
+#define XK_Armenian_pe                0x100057a  /* U+057A ARMENIAN SMALL LETTER PEH */
+#define XK_Armenian_JE                0x100054b  /* U+054B ARMENIAN CAPITAL LETTER JHEH */
+#define XK_Armenian_je                0x100057b  /* U+057B ARMENIAN SMALL LETTER JHEH */
+#define XK_Armenian_RA                0x100054c  /* U+054C ARMENIAN CAPITAL LETTER RA */
+#define XK_Armenian_ra                0x100057c  /* U+057C ARMENIAN SMALL LETTER RA */
+#define XK_Armenian_SE                0x100054d  /* U+054D ARMENIAN CAPITAL LETTER SEH */
+#define XK_Armenian_se                0x100057d  /* U+057D ARMENIAN SMALL LETTER SEH */
+#define XK_Armenian_VEV               0x100054e  /* U+054E ARMENIAN CAPITAL LETTER VEW */
+#define XK_Armenian_vev               0x100057e  /* U+057E ARMENIAN SMALL LETTER VEW */
+#define XK_Armenian_TYUN              0x100054f  /* U+054F ARMENIAN CAPITAL LETTER TIWN */
+#define XK_Armenian_tyun              0x100057f  /* U+057F ARMENIAN SMALL LETTER TIWN */
+#define XK_Armenian_RE                0x1000550  /* U+0550 ARMENIAN CAPITAL LETTER REH */
+#define XK_Armenian_re                0x1000580  /* U+0580 ARMENIAN SMALL LETTER REH */
+#define XK_Armenian_TSO               0x1000551  /* U+0551 ARMENIAN CAPITAL LETTER CO */
+#define XK_Armenian_tso               0x1000581  /* U+0581 ARMENIAN SMALL LETTER CO */
+#define XK_Armenian_VYUN              0x1000552  /* U+0552 ARMENIAN CAPITAL LETTER YIWN */
+#define XK_Armenian_vyun              0x1000582  /* U+0582 ARMENIAN SMALL LETTER YIWN */
+#define XK_Armenian_PYUR              0x1000553  /* U+0553 ARMENIAN CAPITAL LETTER PIWR */
+#define XK_Armenian_pyur              0x1000583  /* U+0583 ARMENIAN SMALL LETTER PIWR */
+#define XK_Armenian_KE                0x1000554  /* U+0554 ARMENIAN CAPITAL LETTER KEH */
+#define XK_Armenian_ke                0x1000584  /* U+0584 ARMENIAN SMALL LETTER KEH */
+#define XK_Armenian_O                 0x1000555  /* U+0555 ARMENIAN CAPITAL LETTER OH */
+#define XK_Armenian_o                 0x1000585  /* U+0585 ARMENIAN SMALL LETTER OH */
+#define XK_Armenian_FE                0x1000556  /* U+0556 ARMENIAN CAPITAL LETTER FEH */
+#define XK_Armenian_fe                0x1000586  /* U+0586 ARMENIAN SMALL LETTER FEH */
+#define XK_Armenian_apostrophe        0x100055a  /* U+055A ARMENIAN APOSTROPHE */
+#endif /* XK_ARMENIAN */
+
+/*
+ * Georgian
+ */
+
+#ifdef XK_GEORGIAN
+#define XK_Georgian_an                0x10010d0  /* U+10D0 GEORGIAN LETTER AN */
+#define XK_Georgian_ban               0x10010d1  /* U+10D1 GEORGIAN LETTER BAN */
+#define XK_Georgian_gan               0x10010d2  /* U+10D2 GEORGIAN LETTER GAN */
+#define XK_Georgian_don               0x10010d3  /* U+10D3 GEORGIAN LETTER DON */
+#define XK_Georgian_en                0x10010d4  /* U+10D4 GEORGIAN LETTER EN */
+#define XK_Georgian_vin               0x10010d5  /* U+10D5 GEORGIAN LETTER VIN */
+#define XK_Georgian_zen               0x10010d6  /* U+10D6 GEORGIAN LETTER ZEN */
+#define XK_Georgian_tan               0x10010d7  /* U+10D7 GEORGIAN LETTER TAN */
+#define XK_Georgian_in                0x10010d8  /* U+10D8 GEORGIAN LETTER IN */
+#define XK_Georgian_kan               0x10010d9  /* U+10D9 GEORGIAN LETTER KAN */
+#define XK_Georgian_las               0x10010da  /* U+10DA GEORGIAN LETTER LAS */
+#define XK_Georgian_man               0x10010db  /* U+10DB GEORGIAN LETTER MAN */
+#define XK_Georgian_nar               0x10010dc  /* U+10DC GEORGIAN LETTER NAR */
+#define XK_Georgian_on                0x10010dd  /* U+10DD GEORGIAN LETTER ON */
+#define XK_Georgian_par               0x10010de  /* U+10DE GEORGIAN LETTER PAR */
+#define XK_Georgian_zhar              0x10010df  /* U+10DF GEORGIAN LETTER ZHAR */
+#define XK_Georgian_rae               0x10010e0  /* U+10E0 GEORGIAN LETTER RAE */
+#define XK_Georgian_san               0x10010e1  /* U+10E1 GEORGIAN LETTER SAN */
+#define XK_Georgian_tar               0x10010e2  /* U+10E2 GEORGIAN LETTER TAR */
+#define XK_Georgian_un                0x10010e3  /* U+10E3 GEORGIAN LETTER UN */
+#define XK_Georgian_phar              0x10010e4  /* U+10E4 GEORGIAN LETTER PHAR */
+#define XK_Georgian_khar              0x10010e5  /* U+10E5 GEORGIAN LETTER KHAR */
+#define XK_Georgian_ghan              0x10010e6  /* U+10E6 GEORGIAN LETTER GHAN */
+#define XK_Georgian_qar               0x10010e7  /* U+10E7 GEORGIAN LETTER QAR */
+#define XK_Georgian_shin              0x10010e8  /* U+10E8 GEORGIAN LETTER SHIN */
+#define XK_Georgian_chin              0x10010e9  /* U+10E9 GEORGIAN LETTER CHIN */
+#define XK_Georgian_can               0x10010ea  /* U+10EA GEORGIAN LETTER CAN */
+#define XK_Georgian_jil               0x10010eb  /* U+10EB GEORGIAN LETTER JIL */
+#define XK_Georgian_cil               0x10010ec  /* U+10EC GEORGIAN LETTER CIL */
+#define XK_Georgian_char              0x10010ed  /* U+10ED GEORGIAN LETTER CHAR */
+#define XK_Georgian_xan               0x10010ee  /* U+10EE GEORGIAN LETTER XAN */
+#define XK_Georgian_jhan              0x10010ef  /* U+10EF GEORGIAN LETTER JHAN */
+#define XK_Georgian_hae               0x10010f0  /* U+10F0 GEORGIAN LETTER HAE */
+#define XK_Georgian_he                0x10010f1  /* U+10F1 GEORGIAN LETTER HE */
+#define XK_Georgian_hie               0x10010f2  /* U+10F2 GEORGIAN LETTER HIE */
+#define XK_Georgian_we                0x10010f3  /* U+10F3 GEORGIAN LETTER WE */
+#define XK_Georgian_har               0x10010f4  /* U+10F4 GEORGIAN LETTER HAR */
+#define XK_Georgian_hoe               0x10010f5  /* U+10F5 GEORGIAN LETTER HOE */
+#define XK_Georgian_fi                0x10010f6  /* U+10F6 GEORGIAN LETTER FI */
+#endif /* XK_GEORGIAN */
+
+/*
+ * Azeri (and other Turkic or Caucasian languages)
+ */
+
+#ifdef XK_CAUCASUS
+/* latin */
+#define XK_Xabovedot                  0x1001e8a  /* U+1E8A LATIN CAPITAL LETTER X WITH DOT ABOVE */
+#define XK_Ibreve                     0x100012c  /* U+012C LATIN CAPITAL LETTER I WITH BREVE */
+#define XK_Zstroke                    0x10001b5  /* U+01B5 LATIN CAPITAL LETTER Z WITH STROKE */
+#define XK_Gcaron                     0x10001e6  /* U+01E6 LATIN CAPITAL LETTER G WITH CARON */
+#define XK_Ocaron                     0x10001d1  /* U+01D2 LATIN CAPITAL LETTER O WITH CARON */
+#define XK_Obarred                    0x100019f  /* U+019F LATIN CAPITAL LETTER O WITH MIDDLE TILDE */
+#define XK_xabovedot                  0x1001e8b  /* U+1E8B LATIN SMALL LETTER X WITH DOT ABOVE */
+#define XK_ibreve                     0x100012d  /* U+012D LATIN SMALL LETTER I WITH BREVE */
+#define XK_zstroke                    0x10001b6  /* U+01B6 LATIN SMALL LETTER Z WITH STROKE */
+#define XK_gcaron                     0x10001e7  /* U+01E7 LATIN SMALL LETTER G WITH CARON */
+#define XK_ocaron                     0x10001d2  /* U+01D2 LATIN SMALL LETTER O WITH CARON */
+#define XK_obarred                    0x1000275  /* U+0275 LATIN SMALL LETTER BARRED O */
+#define XK_SCHWA                      0x100018f  /* U+018F LATIN CAPITAL LETTER SCHWA */
+#define XK_schwa                      0x1000259  /* U+0259 LATIN SMALL LETTER SCHWA */
+/* those are not really Caucasus */
+/* For Inupiak */
+#define XK_Lbelowdot                  0x1001e36  /* U+1E36 LATIN CAPITAL LETTER L WITH DOT BELOW */
+#define XK_lbelowdot                  0x1001e37  /* U+1E37 LATIN SMALL LETTER L WITH DOT BELOW */
+#endif /* XK_CAUCASUS */
+
+/*
+ * Vietnamese
+ */
+ 
+#ifdef XK_VIETNAMESE
+#define XK_Abelowdot                  0x1001ea0  /* U+1EA0 LATIN CAPITAL LETTER A WITH DOT BELOW */
+#define XK_abelowdot                  0x1001ea1  /* U+1EA1 LATIN SMALL LETTER A WITH DOT BELOW */
+#define XK_Ahook                      0x1001ea2  /* U+1EA2 LATIN CAPITAL LETTER A WITH HOOK ABOVE */
+#define XK_ahook                      0x1001ea3  /* U+1EA3 LATIN SMALL LETTER A WITH HOOK ABOVE */
+#define XK_Acircumflexacute           0x1001ea4  /* U+1EA4 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE */
+#define XK_acircumflexacute           0x1001ea5  /* U+1EA5 LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE */
+#define XK_Acircumflexgrave           0x1001ea6  /* U+1EA6 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE */
+#define XK_acircumflexgrave           0x1001ea7  /* U+1EA7 LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE */
+#define XK_Acircumflexhook            0x1001ea8  /* U+1EA8 LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_acircumflexhook            0x1001ea9  /* U+1EA9 LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_Acircumflextilde           0x1001eaa  /* U+1EAA LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE */
+#define XK_acircumflextilde           0x1001eab  /* U+1EAB LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE */
+#define XK_Acircumflexbelowdot        0x1001eac  /* U+1EAC LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_acircumflexbelowdot        0x1001ead  /* U+1EAD LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_Abreveacute                0x1001eae  /* U+1EAE LATIN CAPITAL LETTER A WITH BREVE AND ACUTE */
+#define XK_abreveacute                0x1001eaf  /* U+1EAF LATIN SMALL LETTER A WITH BREVE AND ACUTE */
+#define XK_Abrevegrave                0x1001eb0  /* U+1EB0 LATIN CAPITAL LETTER A WITH BREVE AND GRAVE */
+#define XK_abrevegrave                0x1001eb1  /* U+1EB1 LATIN SMALL LETTER A WITH BREVE AND GRAVE */
+#define XK_Abrevehook                 0x1001eb2  /* U+1EB2 LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE */
+#define XK_abrevehook                 0x1001eb3  /* U+1EB3 LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE */
+#define XK_Abrevetilde                0x1001eb4  /* U+1EB4 LATIN CAPITAL LETTER A WITH BREVE AND TILDE */
+#define XK_abrevetilde                0x1001eb5  /* U+1EB5 LATIN SMALL LETTER A WITH BREVE AND TILDE */
+#define XK_Abrevebelowdot             0x1001eb6  /* U+1EB6 LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW */
+#define XK_abrevebelowdot             0x1001eb7  /* U+1EB7 LATIN SMALL LETTER A WITH BREVE AND DOT BELOW */
+#define XK_Ebelowdot                  0x1001eb8  /* U+1EB8 LATIN CAPITAL LETTER E WITH DOT BELOW */
+#define XK_ebelowdot                  0x1001eb9  /* U+1EB9 LATIN SMALL LETTER E WITH DOT BELOW */
+#define XK_Ehook                      0x1001eba  /* U+1EBA LATIN CAPITAL LETTER E WITH HOOK ABOVE */
+#define XK_ehook                      0x1001ebb  /* U+1EBB LATIN SMALL LETTER E WITH HOOK ABOVE */
+#define XK_Etilde                     0x1001ebc  /* U+1EBC LATIN CAPITAL LETTER E WITH TILDE */
+#define XK_etilde                     0x1001ebd  /* U+1EBD LATIN SMALL LETTER E WITH TILDE */
+#define XK_Ecircumflexacute           0x1001ebe  /* U+1EBE LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE */
+#define XK_ecircumflexacute           0x1001ebf  /* U+1EBF LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE */
+#define XK_Ecircumflexgrave           0x1001ec0  /* U+1EC0 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE */
+#define XK_ecircumflexgrave           0x1001ec1  /* U+1EC1 LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE */
+#define XK_Ecircumflexhook            0x1001ec2  /* U+1EC2 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_ecircumflexhook            0x1001ec3  /* U+1EC3 LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_Ecircumflextilde           0x1001ec4  /* U+1EC4 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE */
+#define XK_ecircumflextilde           0x1001ec5  /* U+1EC5 LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE */
+#define XK_Ecircumflexbelowdot        0x1001ec6  /* U+1EC6 LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_ecircumflexbelowdot        0x1001ec7  /* U+1EC7 LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_Ihook                      0x1001ec8  /* U+1EC8 LATIN CAPITAL LETTER I WITH HOOK ABOVE */
+#define XK_ihook                      0x1001ec9  /* U+1EC9 LATIN SMALL LETTER I WITH HOOK ABOVE */
+#define XK_Ibelowdot                  0x1001eca  /* U+1ECA LATIN CAPITAL LETTER I WITH DOT BELOW */
+#define XK_ibelowdot                  0x1001ecb  /* U+1ECB LATIN SMALL LETTER I WITH DOT BELOW */
+#define XK_Obelowdot                  0x1001ecc  /* U+1ECC LATIN CAPITAL LETTER O WITH DOT BELOW */
+#define XK_obelowdot                  0x1001ecd  /* U+1ECD LATIN SMALL LETTER O WITH DOT BELOW */
+#define XK_Ohook                      0x1001ece  /* U+1ECE LATIN CAPITAL LETTER O WITH HOOK ABOVE */
+#define XK_ohook                      0x1001ecf  /* U+1ECF LATIN SMALL LETTER O WITH HOOK ABOVE */
+#define XK_Ocircumflexacute           0x1001ed0  /* U+1ED0 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE */
+#define XK_ocircumflexacute           0x1001ed1  /* U+1ED1 LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE */
+#define XK_Ocircumflexgrave           0x1001ed2  /* U+1ED2 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE */
+#define XK_ocircumflexgrave           0x1001ed3  /* U+1ED3 LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE */
+#define XK_Ocircumflexhook            0x1001ed4  /* U+1ED4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_ocircumflexhook            0x1001ed5  /* U+1ED5 LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE */
+#define XK_Ocircumflextilde           0x1001ed6  /* U+1ED6 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE */
+#define XK_ocircumflextilde           0x1001ed7  /* U+1ED7 LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE */
+#define XK_Ocircumflexbelowdot        0x1001ed8  /* U+1ED8 LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_ocircumflexbelowdot        0x1001ed9  /* U+1ED9 LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW */
+#define XK_Ohornacute                 0x1001eda  /* U+1EDA LATIN CAPITAL LETTER O WITH HORN AND ACUTE */
+#define XK_ohornacute                 0x1001edb  /* U+1EDB LATIN SMALL LETTER O WITH HORN AND ACUTE */
+#define XK_Ohorngrave                 0x1001edc  /* U+1EDC LATIN CAPITAL LETTER O WITH HORN AND GRAVE */
+#define XK_ohorngrave                 0x1001edd  /* U+1EDD LATIN SMALL LETTER O WITH HORN AND GRAVE */
+#define XK_Ohornhook                  0x1001ede  /* U+1EDE LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE */
+#define XK_ohornhook                  0x1001edf  /* U+1EDF LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE */
+#define XK_Ohorntilde                 0x1001ee0  /* U+1EE0 LATIN CAPITAL LETTER O WITH HORN AND TILDE */
+#define XK_ohorntilde                 0x1001ee1  /* U+1EE1 LATIN SMALL LETTER O WITH HORN AND TILDE */
+#define XK_Ohornbelowdot              0x1001ee2  /* U+1EE2 LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW */
+#define XK_ohornbelowdot              0x1001ee3  /* U+1EE3 LATIN SMALL LETTER O WITH HORN AND DOT BELOW */
+#define XK_Ubelowdot                  0x1001ee4  /* U+1EE4 LATIN CAPITAL LETTER U WITH DOT BELOW */
+#define XK_ubelowdot                  0x1001ee5  /* U+1EE5 LATIN SMALL LETTER U WITH DOT BELOW */
+#define XK_Uhook                      0x1001ee6  /* U+1EE6 LATIN CAPITAL LETTER U WITH HOOK ABOVE */
+#define XK_uhook                      0x1001ee7  /* U+1EE7 LATIN SMALL LETTER U WITH HOOK ABOVE */
+#define XK_Uhornacute                 0x1001ee8  /* U+1EE8 LATIN CAPITAL LETTER U WITH HORN AND ACUTE */
+#define XK_uhornacute                 0x1001ee9  /* U+1EE9 LATIN SMALL LETTER U WITH HORN AND ACUTE */
+#define XK_Uhorngrave                 0x1001eea  /* U+1EEA LATIN CAPITAL LETTER U WITH HORN AND GRAVE */
+#define XK_uhorngrave                 0x1001eeb  /* U+1EEB LATIN SMALL LETTER U WITH HORN AND GRAVE */
+#define XK_Uhornhook                  0x1001eec  /* U+1EEC LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE */
+#define XK_uhornhook                  0x1001eed  /* U+1EED LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE */
+#define XK_Uhorntilde                 0x1001eee  /* U+1EEE LATIN CAPITAL LETTER U WITH HORN AND TILDE */
+#define XK_uhorntilde                 0x1001eef  /* U+1EEF LATIN SMALL LETTER U WITH HORN AND TILDE */
+#define XK_Uhornbelowdot              0x1001ef0  /* U+1EF0 LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW */
+#define XK_uhornbelowdot              0x1001ef1  /* U+1EF1 LATIN SMALL LETTER U WITH HORN AND DOT BELOW */
+#define XK_Ybelowdot                  0x1001ef4  /* U+1EF4 LATIN CAPITAL LETTER Y WITH DOT BELOW */
+#define XK_ybelowdot                  0x1001ef5  /* U+1EF5 LATIN SMALL LETTER Y WITH DOT BELOW */
+#define XK_Yhook                      0x1001ef6  /* U+1EF6 LATIN CAPITAL LETTER Y WITH HOOK ABOVE */
+#define XK_yhook                      0x1001ef7  /* U+1EF7 LATIN SMALL LETTER Y WITH HOOK ABOVE */
+#define XK_Ytilde                     0x1001ef8  /* U+1EF8 LATIN CAPITAL LETTER Y WITH TILDE */
+#define XK_ytilde                     0x1001ef9  /* U+1EF9 LATIN SMALL LETTER Y WITH TILDE */
+#define XK_Ohorn                      0x10001a0  /* U+01A0 LATIN CAPITAL LETTER O WITH HORN */
+#define XK_ohorn                      0x10001a1  /* U+01A1 LATIN SMALL LETTER O WITH HORN */
+#define XK_Uhorn                      0x10001af  /* U+01AF LATIN CAPITAL LETTER U WITH HORN */
+#define XK_uhorn                      0x10001b0  /* U+01B0 LATIN SMALL LETTER U WITH HORN */
+
+#endif /* XK_VIETNAMESE */
+
+#ifdef XK_CURRENCY
+#define XK_EcuSign                    0x10020a0  /* U+20A0 EURO-CURRENCY SIGN */
+#define XK_ColonSign                  0x10020a1  /* U+20A1 COLON SIGN */
+#define XK_CruzeiroSign               0x10020a2  /* U+20A2 CRUZEIRO SIGN */
+#define XK_FFrancSign                 0x10020a3  /* U+20A3 FRENCH FRANC SIGN */
+#define XK_LiraSign                   0x10020a4  /* U+20A4 LIRA SIGN */
+#define XK_MillSign                   0x10020a5  /* U+20A5 MILL SIGN */
+#define XK_NairaSign                  0x10020a6  /* U+20A6 NAIRA SIGN */
+#define XK_PesetaSign                 0x10020a7  /* U+20A7 PESETA SIGN */
+#define XK_RupeeSign                  0x10020a8  /* U+20A8 RUPEE SIGN */
+#define XK_WonSign                    0x10020a9  /* U+20A9 WON SIGN */
+#define XK_NewSheqelSign              0x10020aa  /* U+20AA NEW SHEQEL SIGN */
+#define XK_DongSign                   0x10020ab  /* U+20AB DONG SIGN */
+#define XK_EuroSign                      0x20ac  /* U+20AC EURO SIGN */
+#endif /* XK_CURRENCY */
+
+#ifdef XK_MATHEMATICAL
+/* one, two and three are defined above. */
+#define XK_zerosuperior               0x1002070  /* U+2070 SUPERSCRIPT ZERO */
+#define XK_foursuperior               0x1002074  /* U+2074 SUPERSCRIPT FOUR */
+#define XK_fivesuperior               0x1002075  /* U+2075 SUPERSCRIPT FIVE */
+#define XK_sixsuperior                0x1002076  /* U+2076 SUPERSCRIPT SIX */
+#define XK_sevensuperior              0x1002077  /* U+2077 SUPERSCRIPT SEVEN */
+#define XK_eightsuperior              0x1002078  /* U+2078 SUPERSCRIPT EIGHT */
+#define XK_ninesuperior               0x1002079  /* U+2079 SUPERSCRIPT NINE */
+#define XK_zerosubscript              0x1002080  /* U+2080 SUBSCRIPT ZERO */
+#define XK_onesubscript               0x1002081  /* U+2081 SUBSCRIPT ONE */
+#define XK_twosubscript               0x1002082  /* U+2082 SUBSCRIPT TWO */
+#define XK_threesubscript             0x1002083  /* U+2083 SUBSCRIPT THREE */
+#define XK_foursubscript              0x1002084  /* U+2084 SUBSCRIPT FOUR */
+#define XK_fivesubscript              0x1002085  /* U+2085 SUBSCRIPT FIVE */
+#define XK_sixsubscript               0x1002086  /* U+2086 SUBSCRIPT SIX */
+#define XK_sevensubscript             0x1002087  /* U+2087 SUBSCRIPT SEVEN */
+#define XK_eightsubscript             0x1002088  /* U+2088 SUBSCRIPT EIGHT */
+#define XK_ninesubscript              0x1002089  /* U+2089 SUBSCRIPT NINE */
+#define XK_partdifferential           0x1002202  /* U+2202 PARTIAL DIFFERENTIAL */
+#define XK_emptyset                   0x1002205  /* U+2205 NULL SET */
+#define XK_elementof                  0x1002208  /* U+2208 ELEMENT OF */
+#define XK_notelementof               0x1002209  /* U+2209 NOT AN ELEMENT OF */
+#define XK_containsas                 0x100220B  /* U+220B CONTAINS AS MEMBER */
+#define XK_squareroot                 0x100221A  /* U+221A SQUARE ROOT */
+#define XK_cuberoot                   0x100221B  /* U+221B CUBE ROOT */
+#define XK_fourthroot                 0x100221C  /* U+221C FOURTH ROOT */
+#define XK_dintegral                  0x100222C  /* U+222C DOUBLE INTEGRAL */
+#define XK_tintegral                  0x100222D  /* U+222D TRIPLE INTEGRAL */
+#define XK_because                    0x1002235  /* U+2235 BECAUSE */
+#define XK_approxeq                   0x1002248  /* U+2245 ALMOST EQUAL TO */
+#define XK_notapproxeq                0x1002247  /* U+2247 NOT ALMOST EQUAL TO */
+#define XK_notidentical               0x1002262  /* U+2262 NOT IDENTICAL TO */
+#define XK_stricteq                   0x1002263  /* U+2263 STRICTLY EQUIVALENT TO */          
+#endif /* XK_MATHEMATICAL */
+
+#ifdef XK_BRAILLE
+#define XK_braille_dot_1                 0xfff1
+#define XK_braille_dot_2                 0xfff2
+#define XK_braille_dot_3                 0xfff3
+#define XK_braille_dot_4                 0xfff4
+#define XK_braille_dot_5                 0xfff5
+#define XK_braille_dot_6                 0xfff6
+#define XK_braille_dot_7                 0xfff7
+#define XK_braille_dot_8                 0xfff8
+#define XK_braille_dot_9                 0xfff9
+#define XK_braille_dot_10                0xfffa
+#define XK_braille_blank              0x1002800  /* U+2800 BRAILLE PATTERN BLANK */
+#define XK_braille_dots_1             0x1002801  /* U+2801 BRAILLE PATTERN DOTS-1 */
+#define XK_braille_dots_2             0x1002802  /* U+2802 BRAILLE PATTERN DOTS-2 */
+#define XK_braille_dots_12            0x1002803  /* U+2803 BRAILLE PATTERN DOTS-12 */
+#define XK_braille_dots_3             0x1002804  /* U+2804 BRAILLE PATTERN DOTS-3 */
+#define XK_braille_dots_13            0x1002805  /* U+2805 BRAILLE PATTERN DOTS-13 */
+#define XK_braille_dots_23            0x1002806  /* U+2806 BRAILLE PATTERN DOTS-23 */
+#define XK_braille_dots_123           0x1002807  /* U+2807 BRAILLE PATTERN DOTS-123 */
+#define XK_braille_dots_4             0x1002808  /* U+2808 BRAILLE PATTERN DOTS-4 */
+#define XK_braille_dots_14            0x1002809  /* U+2809 BRAILLE PATTERN DOTS-14 */
+#define XK_braille_dots_24            0x100280a  /* U+280a BRAILLE PATTERN DOTS-24 */
+#define XK_braille_dots_124           0x100280b  /* U+280b BRAILLE PATTERN DOTS-124 */
+#define XK_braille_dots_34            0x100280c  /* U+280c BRAILLE PATTERN DOTS-34 */
+#define XK_braille_dots_134           0x100280d  /* U+280d BRAILLE PATTERN DOTS-134 */
+#define XK_braille_dots_234           0x100280e  /* U+280e BRAILLE PATTERN DOTS-234 */
+#define XK_braille_dots_1234          0x100280f  /* U+280f BRAILLE PATTERN DOTS-1234 */
+#define XK_braille_dots_5             0x1002810  /* U+2810 BRAILLE PATTERN DOTS-5 */
+#define XK_braille_dots_15            0x1002811  /* U+2811 BRAILLE PATTERN DOTS-15 */
+#define XK_braille_dots_25            0x1002812  /* U+2812 BRAILLE PATTERN DOTS-25 */
+#define XK_braille_dots_125           0x1002813  /* U+2813 BRAILLE PATTERN DOTS-125 */
+#define XK_braille_dots_35            0x1002814  /* U+2814 BRAILLE PATTERN DOTS-35 */
+#define XK_braille_dots_135           0x1002815  /* U+2815 BRAILLE PATTERN DOTS-135 */
+#define XK_braille_dots_235           0x1002816  /* U+2816 BRAILLE PATTERN DOTS-235 */
+#define XK_braille_dots_1235          0x1002817  /* U+2817 BRAILLE PATTERN DOTS-1235 */
+#define XK_braille_dots_45            0x1002818  /* U+2818 BRAILLE PATTERN DOTS-45 */
+#define XK_braille_dots_145           0x1002819  /* U+2819 BRAILLE PATTERN DOTS-145 */
+#define XK_braille_dots_245           0x100281a  /* U+281a BRAILLE PATTERN DOTS-245 */
+#define XK_braille_dots_1245          0x100281b  /* U+281b BRAILLE PATTERN DOTS-1245 */
+#define XK_braille_dots_345           0x100281c  /* U+281c BRAILLE PATTERN DOTS-345 */
+#define XK_braille_dots_1345          0x100281d  /* U+281d BRAILLE PATTERN DOTS-1345 */
+#define XK_braille_dots_2345          0x100281e  /* U+281e BRAILLE PATTERN DOTS-2345 */
+#define XK_braille_dots_12345         0x100281f  /* U+281f BRAILLE PATTERN DOTS-12345 */
+#define XK_braille_dots_6             0x1002820  /* U+2820 BRAILLE PATTERN DOTS-6 */
+#define XK_braille_dots_16            0x1002821  /* U+2821 BRAILLE PATTERN DOTS-16 */
+#define XK_braille_dots_26            0x1002822  /* U+2822 BRAILLE PATTERN DOTS-26 */
+#define XK_braille_dots_126           0x1002823  /* U+2823 BRAILLE PATTERN DOTS-126 */
+#define XK_braille_dots_36            0x1002824  /* U+2824 BRAILLE PATTERN DOTS-36 */
+#define XK_braille_dots_136           0x1002825  /* U+2825 BRAILLE PATTERN DOTS-136 */
+#define XK_braille_dots_236           0x1002826  /* U+2826 BRAILLE PATTERN DOTS-236 */
+#define XK_braille_dots_1236          0x1002827  /* U+2827 BRAILLE PATTERN DOTS-1236 */
+#define XK_braille_dots_46            0x1002828  /* U+2828 BRAILLE PATTERN DOTS-46 */
+#define XK_braille_dots_146           0x1002829  /* U+2829 BRAILLE PATTERN DOTS-146 */
+#define XK_braille_dots_246           0x100282a  /* U+282a BRAILLE PATTERN DOTS-246 */
+#define XK_braille_dots_1246          0x100282b  /* U+282b BRAILLE PATTERN DOTS-1246 */
+#define XK_braille_dots_346           0x100282c  /* U+282c BRAILLE PATTERN DOTS-346 */
+#define XK_braille_dots_1346          0x100282d  /* U+282d BRAILLE PATTERN DOTS-1346 */
+#define XK_braille_dots_2346          0x100282e  /* U+282e BRAILLE PATTERN DOTS-2346 */
+#define XK_braille_dots_12346         0x100282f  /* U+282f BRAILLE PATTERN DOTS-12346 */
+#define XK_braille_dots_56            0x1002830  /* U+2830 BRAILLE PATTERN DOTS-56 */
+#define XK_braille_dots_156           0x1002831  /* U+2831 BRAILLE PATTERN DOTS-156 */
+#define XK_braille_dots_256           0x1002832  /* U+2832 BRAILLE PATTERN DOTS-256 */
+#define XK_braille_dots_1256          0x1002833  /* U+2833 BRAILLE PATTERN DOTS-1256 */
+#define XK_braille_dots_356           0x1002834  /* U+2834 BRAILLE PATTERN DOTS-356 */
+#define XK_braille_dots_1356          0x1002835  /* U+2835 BRAILLE PATTERN DOTS-1356 */
+#define XK_braille_dots_2356          0x1002836  /* U+2836 BRAILLE PATTERN DOTS-2356 */
+#define XK_braille_dots_12356         0x1002837  /* U+2837 BRAILLE PATTERN DOTS-12356 */
+#define XK_braille_dots_456           0x1002838  /* U+2838 BRAILLE PATTERN DOTS-456 */
+#define XK_braille_dots_1456          0x1002839  /* U+2839 BRAILLE PATTERN DOTS-1456 */
+#define XK_braille_dots_2456          0x100283a  /* U+283a BRAILLE PATTERN DOTS-2456 */
+#define XK_braille_dots_12456         0x100283b  /* U+283b BRAILLE PATTERN DOTS-12456 */
+#define XK_braille_dots_3456          0x100283c  /* U+283c BRAILLE PATTERN DOTS-3456 */
+#define XK_braille_dots_13456         0x100283d  /* U+283d BRAILLE PATTERN DOTS-13456 */
+#define XK_braille_dots_23456         0x100283e  /* U+283e BRAILLE PATTERN DOTS-23456 */
+#define XK_braille_dots_123456        0x100283f  /* U+283f BRAILLE PATTERN DOTS-123456 */
+#define XK_braille_dots_7             0x1002840  /* U+2840 BRAILLE PATTERN DOTS-7 */
+#define XK_braille_dots_17            0x1002841  /* U+2841 BRAILLE PATTERN DOTS-17 */
+#define XK_braille_dots_27            0x1002842  /* U+2842 BRAILLE PATTERN DOTS-27 */
+#define XK_braille_dots_127           0x1002843  /* U+2843 BRAILLE PATTERN DOTS-127 */
+#define XK_braille_dots_37            0x1002844  /* U+2844 BRAILLE PATTERN DOTS-37 */
+#define XK_braille_dots_137           0x1002845  /* U+2845 BRAILLE PATTERN DOTS-137 */
+#define XK_braille_dots_237           0x1002846  /* U+2846 BRAILLE PATTERN DOTS-237 */
+#define XK_braille_dots_1237          0x1002847  /* U+2847 BRAILLE PATTERN DOTS-1237 */
+#define XK_braille_dots_47            0x1002848  /* U+2848 BRAILLE PATTERN DOTS-47 */
+#define XK_braille_dots_147           0x1002849  /* U+2849 BRAILLE PATTERN DOTS-147 */
+#define XK_braille_dots_247           0x100284a  /* U+284a BRAILLE PATTERN DOTS-247 */
+#define XK_braille_dots_1247          0x100284b  /* U+284b BRAILLE PATTERN DOTS-1247 */
+#define XK_braille_dots_347           0x100284c  /* U+284c BRAILLE PATTERN DOTS-347 */
+#define XK_braille_dots_1347          0x100284d  /* U+284d BRAILLE PATTERN DOTS-1347 */
+#define XK_braille_dots_2347          0x100284e  /* U+284e BRAILLE PATTERN DOTS-2347 */
+#define XK_braille_dots_12347         0x100284f  /* U+284f BRAILLE PATTERN DOTS-12347 */
+#define XK_braille_dots_57            0x1002850  /* U+2850 BRAILLE PATTERN DOTS-57 */
+#define XK_braille_dots_157           0x1002851  /* U+2851 BRAILLE PATTERN DOTS-157 */
+#define XK_braille_dots_257           0x1002852  /* U+2852 BRAILLE PATTERN DOTS-257 */
+#define XK_braille_dots_1257          0x1002853  /* U+2853 BRAILLE PATTERN DOTS-1257 */
+#define XK_braille_dots_357           0x1002854  /* U+2854 BRAILLE PATTERN DOTS-357 */
+#define XK_braille_dots_1357          0x1002855  /* U+2855 BRAILLE PATTERN DOTS-1357 */
+#define XK_braille_dots_2357          0x1002856  /* U+2856 BRAILLE PATTERN DOTS-2357 */
+#define XK_braille_dots_12357         0x1002857  /* U+2857 BRAILLE PATTERN DOTS-12357 */
+#define XK_braille_dots_457           0x1002858  /* U+2858 BRAILLE PATTERN DOTS-457 */
+#define XK_braille_dots_1457          0x1002859  /* U+2859 BRAILLE PATTERN DOTS-1457 */
+#define XK_braille_dots_2457          0x100285a  /* U+285a BRAILLE PATTERN DOTS-2457 */
+#define XK_braille_dots_12457         0x100285b  /* U+285b BRAILLE PATTERN DOTS-12457 */
+#define XK_braille_dots_3457          0x100285c  /* U+285c BRAILLE PATTERN DOTS-3457 */
+#define XK_braille_dots_13457         0x100285d  /* U+285d BRAILLE PATTERN DOTS-13457 */
+#define XK_braille_dots_23457         0x100285e  /* U+285e BRAILLE PATTERN DOTS-23457 */
+#define XK_braille_dots_123457        0x100285f  /* U+285f BRAILLE PATTERN DOTS-123457 */
+#define XK_braille_dots_67            0x1002860  /* U+2860 BRAILLE PATTERN DOTS-67 */
+#define XK_braille_dots_167           0x1002861  /* U+2861 BRAILLE PATTERN DOTS-167 */
+#define XK_braille_dots_267           0x1002862  /* U+2862 BRAILLE PATTERN DOTS-267 */
+#define XK_braille_dots_1267          0x1002863  /* U+2863 BRAILLE PATTERN DOTS-1267 */
+#define XK_braille_dots_367           0x1002864  /* U+2864 BRAILLE PATTERN DOTS-367 */
+#define XK_braille_dots_1367          0x1002865  /* U+2865 BRAILLE PATTERN DOTS-1367 */
+#define XK_braille_dots_2367          0x1002866  /* U+2866 BRAILLE PATTERN DOTS-2367 */
+#define XK_braille_dots_12367         0x1002867  /* U+2867 BRAILLE PATTERN DOTS-12367 */
+#define XK_braille_dots_467           0x1002868  /* U+2868 BRAILLE PATTERN DOTS-467 */
+#define XK_braille_dots_1467          0x1002869  /* U+2869 BRAILLE PATTERN DOTS-1467 */
+#define XK_braille_dots_2467          0x100286a  /* U+286a BRAILLE PATTERN DOTS-2467 */
+#define XK_braille_dots_12467         0x100286b  /* U+286b BRAILLE PATTERN DOTS-12467 */
+#define XK_braille_dots_3467          0x100286c  /* U+286c BRAILLE PATTERN DOTS-3467 */
+#define XK_braille_dots_13467         0x100286d  /* U+286d BRAILLE PATTERN DOTS-13467 */
+#define XK_braille_dots_23467         0x100286e  /* U+286e BRAILLE PATTERN DOTS-23467 */
+#define XK_braille_dots_123467        0x100286f  /* U+286f BRAILLE PATTERN DOTS-123467 */
+#define XK_braille_dots_567           0x1002870  /* U+2870 BRAILLE PATTERN DOTS-567 */
+#define XK_braille_dots_1567          0x1002871  /* U+2871 BRAILLE PATTERN DOTS-1567 */
+#define XK_braille_dots_2567          0x1002872  /* U+2872 BRAILLE PATTERN DOTS-2567 */
+#define XK_braille_dots_12567         0x1002873  /* U+2873 BRAILLE PATTERN DOTS-12567 */
+#define XK_braille_dots_3567          0x1002874  /* U+2874 BRAILLE PATTERN DOTS-3567 */
+#define XK_braille_dots_13567         0x1002875  /* U+2875 BRAILLE PATTERN DOTS-13567 */
+#define XK_braille_dots_23567         0x1002876  /* U+2876 BRAILLE PATTERN DOTS-23567 */
+#define XK_braille_dots_123567        0x1002877  /* U+2877 BRAILLE PATTERN DOTS-123567 */
+#define XK_braille_dots_4567          0x1002878  /* U+2878 BRAILLE PATTERN DOTS-4567 */
+#define XK_braille_dots_14567         0x1002879  /* U+2879 BRAILLE PATTERN DOTS-14567 */
+#define XK_braille_dots_24567         0x100287a  /* U+287a BRAILLE PATTERN DOTS-24567 */
+#define XK_braille_dots_124567        0x100287b  /* U+287b BRAILLE PATTERN DOTS-124567 */
+#define XK_braille_dots_34567         0x100287c  /* U+287c BRAILLE PATTERN DOTS-34567 */
+#define XK_braille_dots_134567        0x100287d  /* U+287d BRAILLE PATTERN DOTS-134567 */
+#define XK_braille_dots_234567        0x100287e  /* U+287e BRAILLE PATTERN DOTS-234567 */
+#define XK_braille_dots_1234567       0x100287f  /* U+287f BRAILLE PATTERN DOTS-1234567 */
+#define XK_braille_dots_8             0x1002880  /* U+2880 BRAILLE PATTERN DOTS-8 */
+#define XK_braille_dots_18            0x1002881  /* U+2881 BRAILLE PATTERN DOTS-18 */
+#define XK_braille_dots_28            0x1002882  /* U+2882 BRAILLE PATTERN DOTS-28 */
+#define XK_braille_dots_128           0x1002883  /* U+2883 BRAILLE PATTERN DOTS-128 */
+#define XK_braille_dots_38            0x1002884  /* U+2884 BRAILLE PATTERN DOTS-38 */
+#define XK_braille_dots_138           0x1002885  /* U+2885 BRAILLE PATTERN DOTS-138 */
+#define XK_braille_dots_238           0x1002886  /* U+2886 BRAILLE PATTERN DOTS-238 */
+#define XK_braille_dots_1238          0x1002887  /* U+2887 BRAILLE PATTERN DOTS-1238 */
+#define XK_braille_dots_48            0x1002888  /* U+2888 BRAILLE PATTERN DOTS-48 */
+#define XK_braille_dots_148           0x1002889  /* U+2889 BRAILLE PATTERN DOTS-148 */
+#define XK_braille_dots_248           0x100288a  /* U+288a BRAILLE PATTERN DOTS-248 */
+#define XK_braille_dots_1248          0x100288b  /* U+288b BRAILLE PATTERN DOTS-1248 */
+#define XK_braille_dots_348           0x100288c  /* U+288c BRAILLE PATTERN DOTS-348 */
+#define XK_braille_dots_1348          0x100288d  /* U+288d BRAILLE PATTERN DOTS-1348 */
+#define XK_braille_dots_2348          0x100288e  /* U+288e BRAILLE PATTERN DOTS-2348 */
+#define XK_braille_dots_12348         0x100288f  /* U+288f BRAILLE PATTERN DOTS-12348 */
+#define XK_braille_dots_58            0x1002890  /* U+2890 BRAILLE PATTERN DOTS-58 */
+#define XK_braille_dots_158           0x1002891  /* U+2891 BRAILLE PATTERN DOTS-158 */
+#define XK_braille_dots_258           0x1002892  /* U+2892 BRAILLE PATTERN DOTS-258 */
+#define XK_braille_dots_1258          0x1002893  /* U+2893 BRAILLE PATTERN DOTS-1258 */
+#define XK_braille_dots_358           0x1002894  /* U+2894 BRAILLE PATTERN DOTS-358 */
+#define XK_braille_dots_1358          0x1002895  /* U+2895 BRAILLE PATTERN DOTS-1358 */
+#define XK_braille_dots_2358          0x1002896  /* U+2896 BRAILLE PATTERN DOTS-2358 */
+#define XK_braille_dots_12358         0x1002897  /* U+2897 BRAILLE PATTERN DOTS-12358 */
+#define XK_braille_dots_458           0x1002898  /* U+2898 BRAILLE PATTERN DOTS-458 */
+#define XK_braille_dots_1458          0x1002899  /* U+2899 BRAILLE PATTERN DOTS-1458 */
+#define XK_braille_dots_2458          0x100289a  /* U+289a BRAILLE PATTERN DOTS-2458 */
+#define XK_braille_dots_12458         0x100289b  /* U+289b BRAILLE PATTERN DOTS-12458 */
+#define XK_braille_dots_3458          0x100289c  /* U+289c BRAILLE PATTERN DOTS-3458 */
+#define XK_braille_dots_13458         0x100289d  /* U+289d BRAILLE PATTERN DOTS-13458 */
+#define XK_braille_dots_23458         0x100289e  /* U+289e BRAILLE PATTERN DOTS-23458 */
+#define XK_braille_dots_123458        0x100289f  /* U+289f BRAILLE PATTERN DOTS-123458 */
+#define XK_braille_dots_68            0x10028a0  /* U+28a0 BRAILLE PATTERN DOTS-68 */
+#define XK_braille_dots_168           0x10028a1  /* U+28a1 BRAILLE PATTERN DOTS-168 */
+#define XK_braille_dots_268           0x10028a2  /* U+28a2 BRAILLE PATTERN DOTS-268 */
+#define XK_braille_dots_1268          0x10028a3  /* U+28a3 BRAILLE PATTERN DOTS-1268 */
+#define XK_braille_dots_368           0x10028a4  /* U+28a4 BRAILLE PATTERN DOTS-368 */
+#define XK_braille_dots_1368          0x10028a5  /* U+28a5 BRAILLE PATTERN DOTS-1368 */
+#define XK_braille_dots_2368          0x10028a6  /* U+28a6 BRAILLE PATTERN DOTS-2368 */
+#define XK_braille_dots_12368         0x10028a7  /* U+28a7 BRAILLE PATTERN DOTS-12368 */
+#define XK_braille_dots_468           0x10028a8  /* U+28a8 BRAILLE PATTERN DOTS-468 */
+#define XK_braille_dots_1468          0x10028a9  /* U+28a9 BRAILLE PATTERN DOTS-1468 */
+#define XK_braille_dots_2468          0x10028aa  /* U+28aa BRAILLE PATTERN DOTS-2468 */
+#define XK_braille_dots_12468         0x10028ab  /* U+28ab BRAILLE PATTERN DOTS-12468 */
+#define XK_braille_dots_3468          0x10028ac  /* U+28ac BRAILLE PATTERN DOTS-3468 */
+#define XK_braille_dots_13468         0x10028ad  /* U+28ad BRAILLE PATTERN DOTS-13468 */
+#define XK_braille_dots_23468         0x10028ae  /* U+28ae BRAILLE PATTERN DOTS-23468 */
+#define XK_braille_dots_123468        0x10028af  /* U+28af BRAILLE PATTERN DOTS-123468 */
+#define XK_braille_dots_568           0x10028b0  /* U+28b0 BRAILLE PATTERN DOTS-568 */
+#define XK_braille_dots_1568          0x10028b1  /* U+28b1 BRAILLE PATTERN DOTS-1568 */
+#define XK_braille_dots_2568          0x10028b2  /* U+28b2 BRAILLE PATTERN DOTS-2568 */
+#define XK_braille_dots_12568         0x10028b3  /* U+28b3 BRAILLE PATTERN DOTS-12568 */
+#define XK_braille_dots_3568          0x10028b4  /* U+28b4 BRAILLE PATTERN DOTS-3568 */
+#define XK_braille_dots_13568         0x10028b5  /* U+28b5 BRAILLE PATTERN DOTS-13568 */
+#define XK_braille_dots_23568         0x10028b6  /* U+28b6 BRAILLE PATTERN DOTS-23568 */
+#define XK_braille_dots_123568        0x10028b7  /* U+28b7 BRAILLE PATTERN DOTS-123568 */
+#define XK_braille_dots_4568          0x10028b8  /* U+28b8 BRAILLE PATTERN DOTS-4568 */
+#define XK_braille_dots_14568         0x10028b9  /* U+28b9 BRAILLE PATTERN DOTS-14568 */
+#define XK_braille_dots_24568         0x10028ba  /* U+28ba BRAILLE PATTERN DOTS-24568 */
+#define XK_braille_dots_124568        0x10028bb  /* U+28bb BRAILLE PATTERN DOTS-124568 */
+#define XK_braille_dots_34568         0x10028bc  /* U+28bc BRAILLE PATTERN DOTS-34568 */
+#define XK_braille_dots_134568        0x10028bd  /* U+28bd BRAILLE PATTERN DOTS-134568 */
+#define XK_braille_dots_234568        0x10028be  /* U+28be BRAILLE PATTERN DOTS-234568 */
+#define XK_braille_dots_1234568       0x10028bf  /* U+28bf BRAILLE PATTERN DOTS-1234568 */
+#define XK_braille_dots_78            0x10028c0  /* U+28c0 BRAILLE PATTERN DOTS-78 */
+#define XK_braille_dots_178           0x10028c1  /* U+28c1 BRAILLE PATTERN DOTS-178 */
+#define XK_braille_dots_278           0x10028c2  /* U+28c2 BRAILLE PATTERN DOTS-278 */
+#define XK_braille_dots_1278          0x10028c3  /* U+28c3 BRAILLE PATTERN DOTS-1278 */
+#define XK_braille_dots_378           0x10028c4  /* U+28c4 BRAILLE PATTERN DOTS-378 */
+#define XK_braille_dots_1378          0x10028c5  /* U+28c5 BRAILLE PATTERN DOTS-1378 */
+#define XK_braille_dots_2378          0x10028c6  /* U+28c6 BRAILLE PATTERN DOTS-2378 */
+#define XK_braille_dots_12378         0x10028c7  /* U+28c7 BRAILLE PATTERN DOTS-12378 */
+#define XK_braille_dots_478           0x10028c8  /* U+28c8 BRAILLE PATTERN DOTS-478 */
+#define XK_braille_dots_1478          0x10028c9  /* U+28c9 BRAILLE PATTERN DOTS-1478 */
+#define XK_braille_dots_2478          0x10028ca  /* U+28ca BRAILLE PATTERN DOTS-2478 */
+#define XK_braille_dots_12478         0x10028cb  /* U+28cb BRAILLE PATTERN DOTS-12478 */
+#define XK_braille_dots_3478          0x10028cc  /* U+28cc BRAILLE PATTERN DOTS-3478 */
+#define XK_braille_dots_13478         0x10028cd  /* U+28cd BRAILLE PATTERN DOTS-13478 */
+#define XK_braille_dots_23478         0x10028ce  /* U+28ce BRAILLE PATTERN DOTS-23478 */
+#define XK_braille_dots_123478        0x10028cf  /* U+28cf BRAILLE PATTERN DOTS-123478 */
+#define XK_braille_dots_578           0x10028d0  /* U+28d0 BRAILLE PATTERN DOTS-578 */
+#define XK_braille_dots_1578          0x10028d1  /* U+28d1 BRAILLE PATTERN DOTS-1578 */
+#define XK_braille_dots_2578          0x10028d2  /* U+28d2 BRAILLE PATTERN DOTS-2578 */
+#define XK_braille_dots_12578         0x10028d3  /* U+28d3 BRAILLE PATTERN DOTS-12578 */
+#define XK_braille_dots_3578          0x10028d4  /* U+28d4 BRAILLE PATTERN DOTS-3578 */
+#define XK_braille_dots_13578         0x10028d5  /* U+28d5 BRAILLE PATTERN DOTS-13578 */
+#define XK_braille_dots_23578         0x10028d6  /* U+28d6 BRAILLE PATTERN DOTS-23578 */
+#define XK_braille_dots_123578        0x10028d7  /* U+28d7 BRAILLE PATTERN DOTS-123578 */
+#define XK_braille_dots_4578          0x10028d8  /* U+28d8 BRAILLE PATTERN DOTS-4578 */
+#define XK_braille_dots_14578         0x10028d9  /* U+28d9 BRAILLE PATTERN DOTS-14578 */
+#define XK_braille_dots_24578         0x10028da  /* U+28da BRAILLE PATTERN DOTS-24578 */
+#define XK_braille_dots_124578        0x10028db  /* U+28db BRAILLE PATTERN DOTS-124578 */
+#define XK_braille_dots_34578         0x10028dc  /* U+28dc BRAILLE PATTERN DOTS-34578 */
+#define XK_braille_dots_134578        0x10028dd  /* U+28dd BRAILLE PATTERN DOTS-134578 */
+#define XK_braille_dots_234578        0x10028de  /* U+28de BRAILLE PATTERN DOTS-234578 */
+#define XK_braille_dots_1234578       0x10028df  /* U+28df BRAILLE PATTERN DOTS-1234578 */
+#define XK_braille_dots_678           0x10028e0  /* U+28e0 BRAILLE PATTERN DOTS-678 */
+#define XK_braille_dots_1678          0x10028e1  /* U+28e1 BRAILLE PATTERN DOTS-1678 */
+#define XK_braille_dots_2678          0x10028e2  /* U+28e2 BRAILLE PATTERN DOTS-2678 */
+#define XK_braille_dots_12678         0x10028e3  /* U+28e3 BRAILLE PATTERN DOTS-12678 */
+#define XK_braille_dots_3678          0x10028e4  /* U+28e4 BRAILLE PATTERN DOTS-3678 */
+#define XK_braille_dots_13678         0x10028e5  /* U+28e5 BRAILLE PATTERN DOTS-13678 */
+#define XK_braille_dots_23678         0x10028e6  /* U+28e6 BRAILLE PATTERN DOTS-23678 */
+#define XK_braille_dots_123678        0x10028e7  /* U+28e7 BRAILLE PATTERN DOTS-123678 */
+#define XK_braille_dots_4678          0x10028e8  /* U+28e8 BRAILLE PATTERN DOTS-4678 */
+#define XK_braille_dots_14678         0x10028e9  /* U+28e9 BRAILLE PATTERN DOTS-14678 */
+#define XK_braille_dots_24678         0x10028ea  /* U+28ea BRAILLE PATTERN DOTS-24678 */
+#define XK_braille_dots_124678        0x10028eb  /* U+28eb BRAILLE PATTERN DOTS-124678 */
+#define XK_braille_dots_34678         0x10028ec  /* U+28ec BRAILLE PATTERN DOTS-34678 */
+#define XK_braille_dots_134678        0x10028ed  /* U+28ed BRAILLE PATTERN DOTS-134678 */
+#define XK_braille_dots_234678        0x10028ee  /* U+28ee BRAILLE PATTERN DOTS-234678 */
+#define XK_braille_dots_1234678       0x10028ef  /* U+28ef BRAILLE PATTERN DOTS-1234678 */
+#define XK_braille_dots_5678          0x10028f0  /* U+28f0 BRAILLE PATTERN DOTS-5678 */
+#define XK_braille_dots_15678         0x10028f1  /* U+28f1 BRAILLE PATTERN DOTS-15678 */
+#define XK_braille_dots_25678         0x10028f2  /* U+28f2 BRAILLE PATTERN DOTS-25678 */
+#define XK_braille_dots_125678        0x10028f3  /* U+28f3 BRAILLE PATTERN DOTS-125678 */
+#define XK_braille_dots_35678         0x10028f4  /* U+28f4 BRAILLE PATTERN DOTS-35678 */
+#define XK_braille_dots_135678        0x10028f5  /* U+28f5 BRAILLE PATTERN DOTS-135678 */
+#define XK_braille_dots_235678        0x10028f6  /* U+28f6 BRAILLE PATTERN DOTS-235678 */
+#define XK_braille_dots_1235678       0x10028f7  /* U+28f7 BRAILLE PATTERN DOTS-1235678 */
+#define XK_braille_dots_45678         0x10028f8  /* U+28f8 BRAILLE PATTERN DOTS-45678 */
+#define XK_braille_dots_145678        0x10028f9  /* U+28f9 BRAILLE PATTERN DOTS-145678 */
+#define XK_braille_dots_245678        0x10028fa  /* U+28fa BRAILLE PATTERN DOTS-245678 */
+#define XK_braille_dots_1245678       0x10028fb  /* U+28fb BRAILLE PATTERN DOTS-1245678 */
+#define XK_braille_dots_345678        0x10028fc  /* U+28fc BRAILLE PATTERN DOTS-345678 */
+#define XK_braille_dots_1345678       0x10028fd  /* U+28fd BRAILLE PATTERN DOTS-1345678 */
+#define XK_braille_dots_2345678       0x10028fe  /* U+28fe BRAILLE PATTERN DOTS-2345678 */
+#define XK_braille_dots_12345678      0x10028ff  /* U+28ff BRAILLE PATTERN DOTS-12345678 */
+#endif /* XK_BRAILLE */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/ap_keysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/ap_keysym.h
@@ -0,0 +1,51 @@
+/******************************************************************
+Copyright 1987 by Apollo Computer Inc., Chelmsford, Massachusetts.
+Copyright 1989 by Hewlett-Packard Company.
+
+                        All Rights Reserved
+
+Permission to use, duplicate, change, and distribute this software and
+its documentation for any purpose and without fee is granted, provided
+that the above copyright notice appear in such copy and that this
+copyright notice appear in all supporting documentation, and that the
+names of Apollo Computer Inc., the Hewlett-Packard Company, or the X
+Consortium not be used in advertising or publicity pertaining to
+distribution of the software without written prior permission.
+
+HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD
+TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
+PURPOSE.  Hewlett-Packard shall not be liable for errors 
+contained herein or direct, indirect, special, incidental or 
+consequential damages in connection with the furnishing, 
+performance, or use of this material.
+
+This software is not subject to any license of the American
+Telephone and Telegraph Company or of the Regents of the
+University of California.
+******************************************************************/
+
+#define apXK_LineDel            0x1000FF00
+#define apXK_CharDel            0x1000FF01
+#define apXK_Copy               0x1000FF02
+#define apXK_Cut                0x1000FF03
+#define apXK_Paste              0x1000FF04
+#define apXK_Move               0x1000FF05
+#define apXK_Grow               0x1000FF06
+#define apXK_Cmd                0x1000FF07
+#define apXK_Shell              0x1000FF08
+#define apXK_LeftBar            0x1000FF09
+#define apXK_RightBar           0x1000FF0A
+#define apXK_LeftBox            0x1000FF0B
+#define apXK_RightBox           0x1000FF0C
+#define apXK_UpBox              0x1000FF0D
+#define apXK_DownBox            0x1000FF0E
+#define apXK_Pop                0x1000FF0F
+#define apXK_Read               0x1000FF10
+#define apXK_Edit               0x1000FF11
+#define apXK_Save               0x1000FF12
+#define apXK_Exit               0x1000FF13
+#define apXK_Repeat             0x1000FF14
+
+#define apXK_KP_parenleft       0x1000FFA8
+#define apXK_KP_parenright      0x1000FFA9
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/XWDFile.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/XWDFile.h
@@ -0,0 +1,113 @@
+/*
+
+Copyright 1985, 1986, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/*
+ * XWDFile.h	MIT Project Athena, X Window system window raster
+ *		image dumper, dump file format header file.
+ *
+ *  Author:	Tony Della Fera, DEC
+ *		27-Jun-85
+ * 
+ * Modifier:    William F. Wyatt, SAO
+ *              18-Nov-86  - version 6 for saving/restoring color maps
+ */
+
+#ifndef XWDFILE_H
+#define XWDFILE_H
+
+#include <X11/Xmd.h>
+
+#define XWD_FILE_VERSION 7
+#define sz_XWDheader 100
+#define sz_XWDColor 12
+
+typedef CARD32 xwdval;		/* for old broken programs */
+
+/* Values in the file are most significant byte first. */
+
+typedef struct _xwd_file_header {
+	/* header_size = SIZEOF(XWDheader) + length of null-terminated
+	 * window name. */
+	CARD32 header_size B32;		
+
+	CARD32 file_version B32;	/* = XWD_FILE_VERSION above */
+	CARD32 pixmap_format B32;	/* ZPixmap or XYPixmap */
+	CARD32 pixmap_depth B32;	/* Pixmap depth */
+	CARD32 pixmap_width B32;	/* Pixmap width */
+	CARD32 pixmap_height B32;	/* Pixmap height */
+	CARD32 xoffset B32;		/* Bitmap x offset, normally 0 */
+	CARD32 byte_order B32;		/* of image data: MSBFirst, LSBFirst */
+
+	/* bitmap_unit applies to bitmaps (depth 1 format XY) only.
+	 * It is the number of bits that each scanline is padded to. */
+	CARD32 bitmap_unit B32;		
+
+	CARD32 bitmap_bit_order B32;	/* bitmaps only: MSBFirst, LSBFirst */
+
+	/* bitmap_pad applies to pixmaps (non-bitmaps) only.
+	 * It is the number of bits that each scanline is padded to. */
+	CARD32 bitmap_pad B32;		
+
+	CARD32 bits_per_pixel B32;	/* Bits per pixel */
+
+	/* bytes_per_line is pixmap_width padded to bitmap_unit (bitmaps)
+	 * or bitmap_pad (pixmaps).  It is the delta (in bytes) to get
+	 * to the same x position on an adjacent row. */
+	CARD32 bytes_per_line B32;
+	CARD32 visual_class B32;	/* Class of colormap */
+	CARD32 red_mask B32;		/* Z red mask */
+	CARD32 green_mask B32;		/* Z green mask */
+	CARD32 blue_mask B32;		/* Z blue mask */
+	CARD32 bits_per_rgb B32;	/* Log2 of distinct color values */
+	CARD32 colormap_entries B32;	/* Number of entries in colormap; not used? */
+	CARD32 ncolors B32;		/* Number of XWDColor structures */
+	CARD32 window_width B32;	/* Window width */
+	CARD32 window_height B32;	/* Window height */
+	CARD32 window_x B32;		/* Window upper left X coordinate */
+	CARD32 window_y B32;		/* Window upper left Y coordinate */
+	CARD32 window_bdrwidth B32;	/* Window border width */
+} XWDFileHeader;
+
+/* Null-terminated window name follows the above structure. */
+
+/* Next comes XWDColor structures, at offset XWDFileHeader.header_size in
+ * the file.  XWDFileHeader.ncolors tells how many XWDColor structures
+ * there are.
+ */
+
+typedef struct {
+        CARD32	pixel B32;
+        CARD16	red B16;
+	CARD16	green B16;
+	CARD16	blue B16;
+        CARD8	flags;
+        CARD8	pad;
+} XWDColor;
+
+/* Last comes the image data in the format described by XWDFileHeader. */
+
+#endif /* XWDFILE_H */
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xwinsock.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xwinsock.h
@@ -0,0 +1,65 @@
+/*
+
+Copyright 1996, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
+SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABIL-
+ITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization from
+The Open Group.
+
+*/
+
+/*
+ * This header file has for sole purpose to allow to include winsock.h
+ * without getting any name conflicts with our code.
+ * Conflicts come from the fact that including winsock.h actually pulls
+ * in the whole Windows API...
+ */
+
+#undef _XFree86Server
+#ifdef XFree86Server 
+# define _XFree86Server
+# undef XFree86Server
+#endif
+
+#define BOOL wBOOL
+#define INT32 wINT32
+#undef Status
+#define Status wStatus
+#define ATOM wATOM
+#define BYTE wBYTE
+#define FreeResource wFreeResource
+#include <winsock2.h>
+#undef Status
+#define Status int
+#undef BYTE
+#undef BOOL
+#undef INT32
+#undef ATOM
+#undef FreeResource
+#undef CreateWindowA
+#undef RT_FONT
+#undef RT_CURSOR
+
+#ifdef _XFree86Server
+# define XFree86Server
+# undef _XFree86Server
+#endif
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xw32defs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xw32defs.h
@@ -0,0 +1,79 @@
+#ifndef _XW32DEFS_H
+# define  _XW32DEFS_H
+
+# ifdef __GNUC__ /* mingw is more close to unix than msvc */
+#  if !defined(__daddr_t_defined) 
+typedef char *caddr_t;
+#  endif
+#  define lstat stat
+
+# else
+typedef char *caddr_t;
+
+#  define access	   _access
+#  define alloca	   _alloca
+#  define chdir	_chdir
+#  define chmod	   _chmod
+#  define close	   _close
+#  define creat	   _creat
+#  define dup	   _dup
+#  define dup2	   _dup2
+#  define environ     _environ
+#  define execl	 _execl
+#  define execle	 _execle
+#  define execlp	 _execlp
+#  define execlpe  _execlpe
+#  define execv	 _execv
+#  define execve	 _execve
+#  define execvp	 _execvp
+#  define execvpe  _execvpe
+#  define fdopen	  _fdopen
+#  define fileno	  _fileno
+#  define fstat	 _fstat
+#  define getcwd	_getcwd
+#  define getpid	 _getpid
+#  define hypot		_hypot
+#  define isascii __isascii
+#  define isatty	   _isatty
+#  define lseek	   _lseek
+#  define mkdir	_mkdir
+#  define mktemp	   _mktemp
+#  define open	   _open
+#  define putenv	    _putenv
+#  define read	   _read
+#  define rmdir	_rmdir
+#  define sleep(x) Sleep((x) * 1000)
+#  define stat	 _stat
+#  define sys_errlist _sys_errlist
+#  define sys_nerr    _sys_nerr
+#  define umask	   _umask
+#  define unlink	   _unlink
+#  define write	   _write
+#  define random   rand
+#  define srandom  srand
+
+#  define O_RDONLY    _O_RDONLY
+#  define O_WRONLY    _O_WRONLY
+#  define O_RDWR	    _O_RDWR
+#  define O_APPEND    _O_APPEND
+#  define O_CREAT     _O_CREAT
+#  define O_TRUNC     _O_TRUNC
+#  define O_EXCL	    _O_EXCL
+#  define O_TEXT	    _O_TEXT
+#  define O_BINARY    _O_BINARY
+#  define O_RAW	    _O_BINARY
+
+#  define S_IFMT	 _S_IFMT
+#  define S_IFDIR  _S_IFDIR
+#  define S_IFCHR  _S_IFCHR
+#  define S_IFREG  _S_IFREG
+#  define S_IREAD  _S_IREAD
+#  define S_IWRITE _S_IWRITE
+#  define S_IEXEC  _S_IEXEC
+
+#  define	F_OK	0
+#  define	X_OK	1
+#  define	W_OK	2
+#  define	R_OK	4
+# endif /* __GNUC__ */
+#endif
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xarch.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xarch.h
@@ -0,0 +1,93 @@
+#ifndef _XARCH_H_
+# define _XARCH_H_
+
+/*
+ * Copyright 1997 Metro Link Incorporated
+ *
+ *                           All Rights Reserved
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holder(s)
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holder(s) make(s) no representations about the suitability of
+ * this software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+/*
+ * Determine the machine's byte order.
+ */
+
+/* See if it is set in the imake config first */
+# ifdef X_BYTE_ORDER
+
+#  define X_BIG_ENDIAN 4321
+#  define X_LITTLE_ENDIAN 1234
+
+# else
+
+#  if defined(SVR4) || defined(__SVR4)
+#   include <sys/byteorder.h>
+#  elif defined(CSRG_BASED)
+#   if defined(__NetBSD__) || defined(__OpenBSD__)
+#    include <sys/types.h>
+#   endif
+#   include <machine/endian.h>
+#  elif defined(linux)
+#   if defined __STRICT_ANSI__
+#    undef __STRICT_ANSI__
+#    include <endian.h>
+#    define __STRICT_ANSI__
+#   else
+#    include <endian.h>
+#   endif
+/* 'endian.h' might have been included before 'Xarch.h' */
+#   if !defined(LITTLE_ENDIAN) && defined(__LITTLE_ENDIAN)
+#    define LITTLE_ENDIAN __LITTLE_ENDIAN
+#   endif
+#   if !defined(BIG_ENDIAN) && defined(__BIG_ENDIAN)
+#    define BIG_ENDIAN __BIG_ENDIAN
+#   endif
+#   if !defined(PDP_ENDIAN) && defined(__PDP_ENDIAN)
+#    define PDP_ENDIAN __PDP_ENDIAN
+#   endif
+#   if !defined(BYTE_ORDER) && defined(__BYTE_ORDER)
+#    define BYTE_ORDER __BYTE_ORDER
+#   endif
+#  endif
+
+#  ifndef BYTE_ORDER
+#   define LITTLE_ENDIAN 1234
+#   define BIG_ENDIAN    4321
+
+#   if defined(__sun) && defined(__SVR4)
+#    include <sys/isa_defs.h>
+#    ifdef _LITTLE_ENDIAN
+#     define BYTE_ORDER LITTLE_ENDIAN
+#    endif
+#    ifdef _BIG_ENDIAN
+#     define BYTE_ORDER BIG_ENDIAN
+#    endif
+#   endif /* sun */
+#  endif /* BYTE_ORDER */
+
+#  define X_BYTE_ORDER BYTE_ORDER
+#  define X_BIG_ENDIAN BIG_ENDIAN
+#  define X_LITTLE_ENDIAN LITTLE_ENDIAN
+
+# endif /* not in imake config */
+
+#endif /* _XARCH_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xfuncs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xfuncs.h
@@ -0,0 +1,69 @@
+/*
+ * 
+Copyright 1990, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+ *
+ */
+
+#ifndef _XFUNCS_H_
+# define _XFUNCS_H_
+
+# include <X11/Xosdefs.h>
+
+/* the old Xfuncs.h, for pre-R6 */
+# if !(defined(XFree86LOADER) && defined(IN_MODULE))
+
+#  ifdef X_USEBFUNCS
+void bcopy();
+void bzero();
+int bcmp();
+#  else
+#   if defined(SYSV) && !defined(__SCO__) && !defined(__sun) && !defined(__UNIXWARE__)
+#    include <memory.h>
+void bcopy();
+#    define bzero(b,len) memset(b, 0, len)
+#    define bcmp(b1,b2,len) memcmp(b1, b2, len)
+#   else
+#    include <string.h>
+#    if defined(__SCO__) || defined(__sun) || defined(__UNIXWARE__)
+#     include <strings.h>
+#    endif
+#    define _XFUNCS_H_INCLUDED_STRING_H
+#   endif
+#  endif /* X_USEBFUNCS */
+
+/* the new Xfuncs.h */
+
+/* the ANSI C way */
+#  ifndef _XFUNCS_H_INCLUDED_STRING_H
+#   include <string.h>
+#  endif
+#  undef bzero
+#  define bzero(b,len) memset(b,0,len)
+
+#  if defined WIN32 && defined __MINGW32__
+#   define bcopy(b1,b2,len) memmove(b2, b1, (size_t)(len))
+#  endif
+
+# endif /* !(defined(XFree86LOADER) && defined(IN_MODULE)) */
+
+#endif /* _XFUNCS_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Sunkeysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Sunkeysym.h
@@ -0,0 +1,106 @@
+/*
+ * Copyright © 1991 Sun Microsystems, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/************************************************************
+
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+***********************************************************/
+
+/*
+ * Floating Accent
+ */
+
+#define	SunXK_FA_Grave		0x1005FF00
+#define	SunXK_FA_Circum		0x1005FF01
+#define	SunXK_FA_Tilde		0x1005FF02
+#define	SunXK_FA_Acute		0x1005FF03
+#define	SunXK_FA_Diaeresis	0x1005FF04
+#define	SunXK_FA_Cedilla	0x1005FF05
+
+/*
+ * Miscellaneous Functions
+ */
+
+#define	SunXK_F36		0x1005FF10	/* Labeled F11 */
+#define	SunXK_F37		0x1005FF11	/* Labeled F12 */
+
+#define SunXK_Sys_Req   	0x1005FF60
+#define SunXK_Print_Screen	0x0000FF61	/* Same as XK_Print */
+
+/*
+ * International & Multi-Key Character Composition
+ */
+
+#define SunXK_Compose		0x0000FF20	/* Same as XK_Multi_key */
+#define SunXK_AltGraph		0x0000FF7E	/* Same as XK_Mode_switch */
+
+/*
+ * Cursor Control
+ */
+
+#define SunXK_PageUp		0x0000FF55 	/* Same as XK_Prior */
+#define SunXK_PageDown		0x0000FF56	/* Same as XK_Next */
+
+/*
+ * Open Look Functions
+ */
+
+#define SunXK_Undo		0x0000FF65	/* Same as XK_Undo */
+#define SunXK_Again		0x0000FF66	/* Same as XK_Redo */
+#define SunXK_Find		0x0000FF68	/* Same as XK_Find */
+#define SunXK_Stop		0x0000FF69	/* Same as XK_Cancel */
+#define SunXK_Props		0x1005FF70
+#define SunXK_Front		0x1005FF71
+#define SunXK_Copy		0x1005FF72
+#define SunXK_Open		0x1005FF73
+#define SunXK_Paste		0x1005FF74
+#define SunXK_Cut		0x1005FF75
+
+#define SunXK_PowerSwitch		0x1005FF76
+#define SunXK_AudioLowerVolume		0x1005FF77
+#define SunXK_AudioMute			0x1005FF78
+#define SunXK_AudioRaiseVolume		0x1005FF79
+#define SunXK_VideoDegauss		0x1005FF7A
+#define SunXK_VideoLowerBrightness	0x1005FF7B
+#define SunXK_VideoRaiseBrightness	0x1005FF7C
+#define SunXK_PowerSwitchShift		0x1005FF7D
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/X.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/X.h
@@ -0,0 +1,717 @@
+/* Definitions for the X window system likely to be used by applications */
+
+#ifndef X_H
+#define X_H
+
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#define X_PROTOCOL	11		/* current protocol version */
+#define X_PROTOCOL_REVISION 0		/* current minor version */
+
+/* Resources */
+
+/*
+ * _XSERVER64 must ONLY be defined when compiling X server sources on
+ * systems where unsigned long is not 32 bits, must NOT be used in
+ * client or library code.
+ */
+#ifndef _XSERVER64
+#  ifndef _XTYPEDEF_XID
+#    define _XTYPEDEF_XID
+typedef unsigned long XID;
+#  endif
+#  ifndef _XTYPEDEF_MASK
+#    define _XTYPEDEF_MASK
+typedef unsigned long Mask;
+#  endif
+#  ifndef _XTYPEDEF_ATOM
+#    define _XTYPEDEF_ATOM
+typedef unsigned long Atom;		/* Also in Xdefs.h */
+#  endif
+typedef unsigned long VisualID;
+typedef unsigned long Time;
+#else
+#  include <X11/Xmd.h>
+#  ifndef _XTYPEDEF_XID
+#    define _XTYPEDEF_XID
+typedef CARD32 XID;
+#  endif
+#  ifndef _XTYPEDEF_MASK
+#    define _XTYPEDEF_MASK
+typedef CARD32 Mask;
+#  endif
+#  ifndef _XTYPEDEF_ATOM
+#    define _XTYPEDEF_ATOM
+typedef CARD32 Atom;
+#  endif
+typedef CARD32 VisualID;
+typedef CARD32 Time;
+#endif
+
+typedef XID Window;
+typedef XID Drawable;
+#ifndef _XTYPEDEF_FONT
+#  define _XTYPEDEF_FONT
+typedef XID Font;
+#endif
+typedef XID Pixmap;
+typedef XID Cursor;
+typedef XID Colormap;
+typedef XID GContext;
+typedef XID KeySym;
+
+typedef unsigned char KeyCode;
+
+/*****************************************************************
+ * RESERVED RESOURCE AND CONSTANT DEFINITIONS
+ *****************************************************************/
+
+#ifndef None
+#define None                 0L	/* universal null resource or null atom */
+#endif
+
+#define ParentRelative       1L	/* background pixmap in CreateWindow
+				    and ChangeWindowAttributes */
+
+#define CopyFromParent       0L	/* border pixmap in CreateWindow
+				       and ChangeWindowAttributes
+				   special VisualID and special window
+				       class passed to CreateWindow */
+
+#define PointerWindow        0L	/* destination window in SendEvent */
+#define InputFocus           1L	/* destination window in SendEvent */
+
+#define PointerRoot          1L	/* focus window in SetInputFocus */
+
+#define AnyPropertyType      0L	/* special Atom, passed to GetProperty */
+
+#define AnyKey		     0L	/* special Key Code, passed to GrabKey */
+
+#define AnyButton            0L	/* special Button Code, passed to GrabButton */
+
+#define AllTemporary         0L	/* special Resource ID passed to KillClient */
+
+#define CurrentTime          0L	/* special Time */
+
+#define NoSymbol	     0L	/* special KeySym */
+
+/***************************************************************** 
+ * EVENT DEFINITIONS 
+ *****************************************************************/
+
+/* Input Event Masks. Used as event-mask window attribute and as arguments
+   to Grab requests.  Not to be confused with event names.  */
+
+#define NoEventMask			0L
+#define KeyPressMask			(1L<<0)  
+#define KeyReleaseMask			(1L<<1)  
+#define ButtonPressMask			(1L<<2)  
+#define ButtonReleaseMask		(1L<<3)  
+#define EnterWindowMask			(1L<<4)  
+#define LeaveWindowMask			(1L<<5)  
+#define PointerMotionMask		(1L<<6)  
+#define PointerMotionHintMask		(1L<<7)  
+#define Button1MotionMask		(1L<<8)  
+#define Button2MotionMask		(1L<<9)  
+#define Button3MotionMask		(1L<<10) 
+#define Button4MotionMask		(1L<<11) 
+#define Button5MotionMask		(1L<<12) 
+#define ButtonMotionMask		(1L<<13) 
+#define KeymapStateMask			(1L<<14)
+#define ExposureMask			(1L<<15) 
+#define VisibilityChangeMask		(1L<<16) 
+#define StructureNotifyMask		(1L<<17) 
+#define ResizeRedirectMask		(1L<<18) 
+#define SubstructureNotifyMask		(1L<<19) 
+#define SubstructureRedirectMask	(1L<<20) 
+#define FocusChangeMask			(1L<<21) 
+#define PropertyChangeMask		(1L<<22) 
+#define ColormapChangeMask		(1L<<23) 
+#define OwnerGrabButtonMask		(1L<<24) 
+
+/* Event names.  Used in "type" field in XEvent structures.  Not to be
+confused with event masks above.  They start from 2 because 0 and 1
+are reserved in the protocol for errors and replies. */
+
+#define KeyPress		2
+#define KeyRelease		3
+#define ButtonPress		4
+#define ButtonRelease		5
+#define MotionNotify		6
+#define EnterNotify		7
+#define LeaveNotify		8
+#define FocusIn			9
+#define FocusOut		10
+#define KeymapNotify		11
+#define Expose			12
+#define GraphicsExpose		13
+#define NoExpose		14
+#define VisibilityNotify	15
+#define CreateNotify		16
+#define DestroyNotify		17
+#define UnmapNotify		18
+#define MapNotify		19
+#define MapRequest		20
+#define ReparentNotify		21
+#define ConfigureNotify		22
+#define ConfigureRequest	23
+#define GravityNotify		24
+#define ResizeRequest		25
+#define CirculateNotify		26
+#define CirculateRequest	27
+#define PropertyNotify		28
+#define SelectionClear		29
+#define SelectionRequest	30
+#define SelectionNotify		31
+#define ColormapNotify		32
+#define ClientMessage		33
+#define MappingNotify		34
+#define GenericEvent		35
+#define LASTEvent		36	/* must be bigger than any event # */
+
+
+/* Key masks. Used as modifiers to GrabButton and GrabKey, results of QueryPointer,
+   state in various key-, mouse-, and button-related events. */
+
+#define ShiftMask		(1<<0)
+#define LockMask		(1<<1)
+#define ControlMask		(1<<2)
+#define Mod1Mask		(1<<3)
+#define Mod2Mask		(1<<4)
+#define Mod3Mask		(1<<5)
+#define Mod4Mask		(1<<6)
+#define Mod5Mask		(1<<7)
+
+/* modifier names.  Used to build a SetModifierMapping request or
+   to read a GetModifierMapping request.  These correspond to the
+   masks defined above. */
+#define ShiftMapIndex		0
+#define LockMapIndex		1
+#define ControlMapIndex		2
+#define Mod1MapIndex		3
+#define Mod2MapIndex		4
+#define Mod3MapIndex		5
+#define Mod4MapIndex		6
+#define Mod5MapIndex		7
+
+
+/* button masks.  Used in same manner as Key masks above. Not to be confused
+   with button names below. */
+
+#define Button1Mask		(1<<8)
+#define Button2Mask		(1<<9)
+#define Button3Mask		(1<<10)
+#define Button4Mask		(1<<11)
+#define Button5Mask		(1<<12)
+
+#define AnyModifier		(1<<15)  /* used in GrabButton, GrabKey */
+
+
+/* button names. Used as arguments to GrabButton and as detail in ButtonPress
+   and ButtonRelease events.  Not to be confused with button masks above.
+   Note that 0 is already defined above as "AnyButton".  */
+
+#define Button1			1
+#define Button2			2
+#define Button3			3
+#define Button4			4
+#define Button5			5
+
+/* Notify modes */
+
+#define NotifyNormal		0
+#define NotifyGrab		1
+#define NotifyUngrab		2
+#define NotifyWhileGrabbed	3
+
+#define NotifyHint		1	/* for MotionNotify events */
+		       
+/* Notify detail */
+
+#define NotifyAncestor		0
+#define NotifyVirtual		1
+#define NotifyInferior		2
+#define NotifyNonlinear		3
+#define NotifyNonlinearVirtual	4
+#define NotifyPointer		5
+#define NotifyPointerRoot	6
+#define NotifyDetailNone	7
+
+/* Visibility notify */
+
+#define VisibilityUnobscured		0
+#define VisibilityPartiallyObscured	1
+#define VisibilityFullyObscured		2
+
+/* Circulation request */
+
+#define PlaceOnTop		0
+#define PlaceOnBottom		1
+
+/* protocol families */
+
+#define FamilyInternet		0	/* IPv4 */
+#define FamilyDECnet		1
+#define FamilyChaos		2
+#define FamilyInternet6		6	/* IPv6 */
+
+/* authentication families not tied to a specific protocol */
+#define FamilyServerInterpreted 5
+
+/* Property notification */
+
+#define PropertyNewValue	0
+#define PropertyDelete		1
+
+/* Color Map notification */
+
+#define ColormapUninstalled	0
+#define ColormapInstalled	1
+
+/* GrabPointer, GrabButton, GrabKeyboard, GrabKey Modes */
+
+#define GrabModeSync		0
+#define GrabModeAsync		1
+
+/* GrabPointer, GrabKeyboard reply status */
+
+#define GrabSuccess		0
+#define AlreadyGrabbed		1
+#define GrabInvalidTime		2
+#define GrabNotViewable		3
+#define GrabFrozen		4
+
+/* AllowEvents modes */
+
+#define AsyncPointer		0
+#define SyncPointer		1
+#define ReplayPointer		2
+#define AsyncKeyboard		3
+#define SyncKeyboard		4
+#define ReplayKeyboard		5
+#define AsyncBoth		6
+#define SyncBoth		7
+
+/* Used in SetInputFocus, GetInputFocus */
+
+#define RevertToNone		(int)None
+#define RevertToPointerRoot	(int)PointerRoot
+#define RevertToParent		2
+
+/*****************************************************************
+ * ERROR CODES 
+ *****************************************************************/
+
+#define Success		   0	/* everything's okay */
+#define BadRequest	   1	/* bad request code */
+#define BadValue	   2	/* int parameter out of range */
+#define BadWindow	   3	/* parameter not a Window */
+#define BadPixmap	   4	/* parameter not a Pixmap */
+#define BadAtom		   5	/* parameter not an Atom */
+#define BadCursor	   6	/* parameter not a Cursor */
+#define BadFont		   7	/* parameter not a Font */
+#define BadMatch	   8	/* parameter mismatch */
+#define BadDrawable	   9	/* parameter not a Pixmap or Window */
+#define BadAccess	  10	/* depending on context:
+				 - key/button already grabbed
+				 - attempt to free an illegal 
+				   cmap entry 
+				- attempt to store into a read-only 
+				   color map entry.
+ 				- attempt to modify the access control
+				   list from other than the local host.
+				*/
+#define BadAlloc	  11	/* insufficient resources */
+#define BadColor	  12	/* no such colormap */
+#define BadGC		  13	/* parameter not a GC */
+#define BadIDChoice	  14	/* choice not in range or already used */
+#define BadName		  15	/* font or color name doesn't exist */
+#define BadLength	  16	/* Request length incorrect */
+#define BadImplementation 17	/* server is defective */
+
+#define FirstExtensionError	128
+#define LastExtensionError	255
+
+/*****************************************************************
+ * WINDOW DEFINITIONS 
+ *****************************************************************/
+
+/* Window classes used by CreateWindow */
+/* Note that CopyFromParent is already defined as 0 above */
+
+#define InputOutput		1
+#define InputOnly		2
+
+/* Window attributes for CreateWindow and ChangeWindowAttributes */
+
+#define CWBackPixmap		(1L<<0)
+#define CWBackPixel		(1L<<1)
+#define CWBorderPixmap		(1L<<2)
+#define CWBorderPixel           (1L<<3)
+#define CWBitGravity		(1L<<4)
+#define CWWinGravity		(1L<<5)
+#define CWBackingStore          (1L<<6)
+#define CWBackingPlanes	        (1L<<7)
+#define CWBackingPixel	        (1L<<8)
+#define CWOverrideRedirect	(1L<<9)
+#define CWSaveUnder		(1L<<10)
+#define CWEventMask		(1L<<11)
+#define CWDontPropagate	        (1L<<12)
+#define CWColormap		(1L<<13)
+#define CWCursor	        (1L<<14)
+
+/* ConfigureWindow structure */
+
+#define CWX			(1<<0)
+#define CWY			(1<<1)
+#define CWWidth			(1<<2)
+#define CWHeight		(1<<3)
+#define CWBorderWidth		(1<<4)
+#define CWSibling		(1<<5)
+#define CWStackMode		(1<<6)
+
+
+/* Bit Gravity */
+
+#define ForgetGravity		0
+#define NorthWestGravity	1
+#define NorthGravity		2
+#define NorthEastGravity	3
+#define WestGravity		4
+#define CenterGravity		5
+#define EastGravity		6
+#define SouthWestGravity	7
+#define SouthGravity		8
+#define SouthEastGravity	9
+#define StaticGravity		10
+
+/* Window gravity + bit gravity above */
+
+#define UnmapGravity		0
+
+/* Used in CreateWindow for backing-store hint */
+
+#define NotUseful               0
+#define WhenMapped              1
+#define Always                  2
+
+/* Used in GetWindowAttributes reply */
+
+#define IsUnmapped		0
+#define IsUnviewable		1
+#define IsViewable		2
+
+/* Used in ChangeSaveSet */
+
+#define SetModeInsert           0
+#define SetModeDelete           1
+
+/* Used in ChangeCloseDownMode */
+
+#define DestroyAll              0
+#define RetainPermanent         1
+#define RetainTemporary         2
+
+/* Window stacking method (in configureWindow) */
+
+#define Above                   0
+#define Below                   1
+#define TopIf                   2
+#define BottomIf                3
+#define Opposite                4
+
+/* Circulation direction */
+
+#define RaiseLowest             0
+#define LowerHighest            1
+
+/* Property modes */
+
+#define PropModeReplace         0
+#define PropModePrepend         1
+#define PropModeAppend          2
+
+/*****************************************************************
+ * GRAPHICS DEFINITIONS
+ *****************************************************************/
+
+/* graphics functions, as in GC.alu */
+
+#define	GXclear			0x0		/* 0 */
+#define GXand			0x1		/* src AND dst */
+#define GXandReverse		0x2		/* src AND NOT dst */
+#define GXcopy			0x3		/* src */
+#define GXandInverted		0x4		/* NOT src AND dst */
+#define	GXnoop			0x5		/* dst */
+#define GXxor			0x6		/* src XOR dst */
+#define GXor			0x7		/* src OR dst */
+#define GXnor			0x8		/* NOT src AND NOT dst */
+#define GXequiv			0x9		/* NOT src XOR dst */
+#define GXinvert		0xa		/* NOT dst */
+#define GXorReverse		0xb		/* src OR NOT dst */
+#define GXcopyInverted		0xc		/* NOT src */
+#define GXorInverted		0xd		/* NOT src OR dst */
+#define GXnand			0xe		/* NOT src OR NOT dst */
+#define GXset			0xf		/* 1 */
+
+/* LineStyle */
+
+#define LineSolid		0
+#define LineOnOffDash		1
+#define LineDoubleDash		2
+
+/* capStyle */
+
+#define CapNotLast		0
+#define CapButt			1
+#define CapRound		2
+#define CapProjecting		3
+
+/* joinStyle */
+
+#define JoinMiter		0
+#define JoinRound		1
+#define JoinBevel		2
+
+/* fillStyle */
+
+#define FillSolid		0
+#define FillTiled		1
+#define FillStippled		2
+#define FillOpaqueStippled	3
+
+/* fillRule */
+
+#define EvenOddRule		0
+#define WindingRule		1
+
+/* subwindow mode */
+
+#define ClipByChildren		0
+#define IncludeInferiors	1
+
+/* SetClipRectangles ordering */
+
+#define Unsorted		0
+#define YSorted			1
+#define YXSorted		2
+#define YXBanded		3
+
+/* CoordinateMode for drawing routines */
+
+#define CoordModeOrigin		0	/* relative to the origin */
+#define CoordModePrevious       1	/* relative to previous point */
+
+/* Polygon shapes */
+
+#define Complex			0	/* paths may intersect */
+#define Nonconvex		1	/* no paths intersect, but not convex */
+#define Convex			2	/* wholly convex */
+
+/* Arc modes for PolyFillArc */
+
+#define ArcChord		0	/* join endpoints of arc */
+#define ArcPieSlice		1	/* join endpoints to center of arc */
+
+/* GC components: masks used in CreateGC, CopyGC, ChangeGC, OR'ed into
+   GC.stateChanges */
+
+#define GCFunction              (1L<<0)
+#define GCPlaneMask             (1L<<1)
+#define GCForeground            (1L<<2)
+#define GCBackground            (1L<<3)
+#define GCLineWidth             (1L<<4)
+#define GCLineStyle             (1L<<5)
+#define GCCapStyle              (1L<<6)
+#define GCJoinStyle		(1L<<7)
+#define GCFillStyle		(1L<<8)
+#define GCFillRule		(1L<<9) 
+#define GCTile			(1L<<10)
+#define GCStipple		(1L<<11)
+#define GCTileStipXOrigin	(1L<<12)
+#define GCTileStipYOrigin	(1L<<13)
+#define GCFont 			(1L<<14)
+#define GCSubwindowMode		(1L<<15)
+#define GCGraphicsExposures     (1L<<16)
+#define GCClipXOrigin		(1L<<17)
+#define GCClipYOrigin		(1L<<18)
+#define GCClipMask		(1L<<19)
+#define GCDashOffset		(1L<<20)
+#define GCDashList		(1L<<21)
+#define GCArcMode		(1L<<22)
+
+#define GCLastBit		22
+/*****************************************************************
+ * FONTS 
+ *****************************************************************/
+
+/* used in QueryFont -- draw direction */
+
+#define FontLeftToRight		0
+#define FontRightToLeft		1
+
+#define FontChange		255
+
+/*****************************************************************
+ *  IMAGING 
+ *****************************************************************/
+
+/* ImageFormat -- PutImage, GetImage */
+
+#define XYBitmap		0	/* depth 1, XYFormat */
+#define XYPixmap		1	/* depth == drawable depth */
+#define ZPixmap			2	/* depth == drawable depth */
+
+/*****************************************************************
+ *  COLOR MAP STUFF 
+ *****************************************************************/
+
+/* For CreateColormap */
+
+#define AllocNone		0	/* create map with no entries */
+#define AllocAll		1	/* allocate entire map writeable */
+
+
+/* Flags used in StoreNamedColor, StoreColors */
+
+#define DoRed			(1<<0)
+#define DoGreen			(1<<1)
+#define DoBlue			(1<<2)
+
+/*****************************************************************
+ * CURSOR STUFF
+ *****************************************************************/
+
+/* QueryBestSize Class */
+
+#define CursorShape		0	/* largest size that can be displayed */
+#define TileShape		1	/* size tiled fastest */
+#define StippleShape		2	/* size stippled fastest */
+
+/***************************************************************** 
+ * KEYBOARD/POINTER STUFF
+ *****************************************************************/
+
+#define AutoRepeatModeOff	0
+#define AutoRepeatModeOn	1
+#define AutoRepeatModeDefault	2
+
+#define LedModeOff		0
+#define LedModeOn		1
+
+/* masks for ChangeKeyboardControl */
+
+#define KBKeyClickPercent	(1L<<0)
+#define KBBellPercent		(1L<<1)
+#define KBBellPitch		(1L<<2)
+#define KBBellDuration		(1L<<3)
+#define KBLed			(1L<<4)
+#define KBLedMode		(1L<<5)
+#define KBKey			(1L<<6)
+#define KBAutoRepeatMode	(1L<<7)
+
+#define MappingSuccess     	0
+#define MappingBusy        	1
+#define MappingFailed		2
+
+#define MappingModifier		0
+#define MappingKeyboard		1
+#define MappingPointer		2
+
+/*****************************************************************
+ * SCREEN SAVER STUFF 
+ *****************************************************************/
+
+#define DontPreferBlanking	0
+#define PreferBlanking		1
+#define DefaultBlanking		2
+
+#define DisableScreenSaver	0
+#define DisableScreenInterval	0
+
+#define DontAllowExposures	0
+#define AllowExposures		1
+#define DefaultExposures	2
+
+/* for ForceScreenSaver */
+
+#define ScreenSaverReset 0
+#define ScreenSaverActive 1
+
+/*****************************************************************
+ * HOSTS AND CONNECTIONS
+ *****************************************************************/
+
+/* for ChangeHosts */
+
+#define HostInsert		0
+#define HostDelete		1
+
+/* for ChangeAccessControl */
+
+#define EnableAccess		1      
+#define DisableAccess		0
+
+/* Display classes  used in opening the connection 
+ * Note that the statically allocated ones are even numbered and the
+ * dynamically changeable ones are odd numbered */
+
+#define StaticGray		0
+#define GrayScale		1
+#define StaticColor		2
+#define PseudoColor		3
+#define TrueColor		4
+#define DirectColor		5
+
+
+/* Byte order  used in imageByteOrder and bitmapBitOrder */
+
+#define LSBFirst		0
+#define MSBFirst		1
+
+#endif /* X_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xfuncproto.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xfuncproto.h
@@ -0,0 +1,127 @@
+/*
+ *
+Copyright 1989, 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+ *
+ */
+
+/* Definitions to make function prototypes manageable */
+
+#ifndef _XFUNCPROTO_H_
+#define _XFUNCPROTO_H_
+
+#ifndef NeedFunctionPrototypes
+#define NeedFunctionPrototypes 1
+#endif /* NeedFunctionPrototypes */
+
+#ifndef NeedVarargsPrototypes
+#define NeedVarargsPrototypes 1
+#endif /* NeedVarargsPrototypes */
+
+#if NeedFunctionPrototypes
+
+#ifndef NeedNestedPrototypes
+#define NeedNestedPrototypes 1
+#endif /* NeedNestedPrototypes */
+
+#ifndef _Xconst
+#define _Xconst const
+#endif /* _Xconst */
+
+/* Function prototype configuration (see configure for more info) */
+#ifndef NARROWPROTO
+#undef NARROWPROTO
+#endif
+#ifndef FUNCPROTO
+#undef FUNCPROTO
+#endif
+
+#ifndef NeedWidePrototypes
+#ifdef NARROWPROTO
+#define NeedWidePrototypes 0
+#else
+#define NeedWidePrototypes 1		/* default to make interropt. easier */
+#endif
+#endif /* NeedWidePrototypes */
+
+#endif /* NeedFunctionPrototypes */
+
+#ifndef _XFUNCPROTOBEGIN
+#if defined(__cplusplus) || defined(c_plusplus) /* for C++ V2.0 */
+#define _XFUNCPROTOBEGIN extern "C" {	/* do not leave open across includes */
+#define _XFUNCPROTOEND }
+#else
+#define _XFUNCPROTOBEGIN
+#define _XFUNCPROTOEND
+#endif
+#endif /* _XFUNCPROTOBEGIN */
+
+#if defined(__GNUC__) && (__GNUC__ >= 4)
+# define _X_SENTINEL(x) __attribute__ ((__sentinel__(x)))
+# define _X_ATTRIBUTE_PRINTF(x,y) __attribute__((__format__(__printf__,x,y)))
+#else
+# define _X_SENTINEL(x)
+# define _X_ATTRIBUTE_PRINTF(x,y)
+#endif /* GNUC >= 4 */
+
+#if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__CYGWIN__)
+# define _X_EXPORT      __attribute__((visibility("default")))
+# define _X_HIDDEN      __attribute__((visibility("hidden")))
+# define _X_INTERNAL    __attribute__((visibility("internal")))
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+# define _X_EXPORT      __global
+# define _X_HIDDEN      __hidden
+# define _X_INTERNAL    __hidden
+#else /* not gcc >= 4 and not Sun Studio >= 8 */
+# define _X_EXPORT
+# define _X_HIDDEN
+# define _X_INTERNAL
+#endif /* GNUC >= 4 */
+
+#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 303)
+# define _X_LIKELY(x)   __builtin_expect(!!(x), 1)
+# define _X_UNLIKELY(x) __builtin_expect(!!(x), 0)
+# define _X_INLINE      inline
+#elif defined(__SUNPRO_C) && (__SUNPRO_C >= 0x550)
+# define _X_LIKELY(x)   (x)
+# define _X_UNLIKELY(x) (x)
+# define _X_INLINE      inline
+#else /* not gcc >= 3.3 and not Sun Studio >= 8 */
+# define _X_LIKELY(x)   (x)
+# define _X_UNLIKELY(x) (x)
+# define _X_INLINE
+#endif
+
+#if defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 301)
+# define _X_DEPRECATED  __attribute__((deprecated))
+#else /* not gcc >= 3.1 */
+# define _X_DEPRECATED
+#endif
+
+#if (defined(__GNUC__) && ((__GNUC__ * 100 + __GNUC_MINOR__) >= 205)) \
+	|| (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+# define _X_NORETURN __attribute((noreturn))
+#else
+# define _X_NORETURN
+#endif /* GNUC  */
+
+#endif /* _XFUNCPROTO_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xos.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xos.h
@@ -0,0 +1,148 @@
+/*
+ *
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+ *
+ * The X Window System is a Trademark of The Open Group.
+ *
+ */
+
+/* This is a collection of things to try and minimize system dependencies
+ * in a "significant" number of source files.
+ */
+
+#ifndef _XOS_H_
+# define _XOS_H_
+
+# include <X11/Xosdefs.h>
+
+/*
+ * Get major data types (esp. caddr_t)
+ */
+
+# include <sys/types.h>
+
+# if defined(__SCO__) || defined(__UNIXWARE__)
+#  include <stdint.h>
+# endif
+
+
+/*
+ * Just about everyone needs the strings routines.  We provide both forms here,
+ * index/rindex and strchr/strrchr, so any systems that don't provide them all
+ * need to have #defines here.
+ *
+ * These macros are defined this way, rather than, e.g.:
+ *    #defined index(s,c) strchr(s,c)
+ * because someone might be using them as function pointers, and such
+ * a change would break compatibility for anyone who's relying on them
+ * being the way they currently are. So we're stuck with them this way,
+ * which can be really inconvenient. :-(
+ */
+
+# include <string.h>
+# if defined(__SCO__) || defined(__UNIXWARE__) || defined(__sun)
+#  include <strings.h>
+# else
+#  ifndef index
+#   define index(s,c) (strchr((s),(c)))
+#  endif
+#  ifndef rindex
+#   define rindex(s,c) (strrchr((s),(c)))
+#  endif
+# endif
+
+/*
+ * Get open(2) constants
+ */
+# if defined(X_NOT_POSIX)
+#  include <fcntl.h>
+#  if defined(USL) || defined(__i386__) && (defined(SYSV) || defined(SVR4))
+#   include <unistd.h>
+#  endif
+#  ifdef WIN32
+#   include <X11/Xw32defs.h>
+#  else
+#   include <sys/file.h>
+#  endif
+# else /* X_NOT_POSIX */
+#  include <fcntl.h>
+#  include <unistd.h>
+# endif /* X_NOT_POSIX else */
+
+/*
+ * Get struct timeval and struct tm
+ */
+
+# if defined(_POSIX_SOURCE) && defined(SVR4)
+/* need to omit _POSIX_SOURCE in order to get what we want in SVR4 */
+#  undef _POSIX_SOURCE
+#  include <sys/time.h>
+#  define _POSIX_SOURCE
+# elif defined(WIN32)
+#  include <time.h>
+#  if !defined(_WINSOCKAPI_) && !defined(_WILLWINSOCK_) && !defined(_TIMEVAL_DEFINED) && !defined(_STRUCT_TIMEVAL)
+struct timeval {
+    long    tv_sec;         /* seconds */
+    long    tv_usec;        /* and microseconds */
+};
+#   define _TIMEVAL_DEFINED
+#  endif
+#  include <sys/timeb.h>
+#  define gettimeofday(t) \
+{ \
+    struct _timeb _gtodtmp; \
+    _ftime (&_gtodtmp); \
+    (t)->tv_sec = _gtodtmp.time; \
+    (t)->tv_usec = _gtodtmp.millitm * 1000; \
+}
+# else
+#  include <sys/time.h>
+#  include <time.h>
+# endif /* defined(_POSIX_SOURCE) && defined(SVR4) */
+
+/* define X_GETTIMEOFDAY macro, a portable gettimeofday() */
+# if defined(_XOPEN_XPG4) || defined(_XOPEN_UNIX) /* _XOPEN_UNIX is XPG4.2 */
+#  define X_GETTIMEOFDAY(t) gettimeofday(t, (struct timezone*)0)
+# else
+#  if defined(SVR4) || defined(__SVR4) || defined(WIN32)
+#   define X_GETTIMEOFDAY(t) gettimeofday(t)
+#  else
+#   define X_GETTIMEOFDAY(t) gettimeofday(t, (struct timezone*)0)
+#  endif
+# endif /* XPG4 else */
+
+
+# ifdef __GNU__
+#  define PATH_MAX 4096
+#  define MAXPATHLEN 4096
+#  define OPEN_MAX 256 /* We define a reasonable limit.  */
+# endif
+
+/* use POSIX name for signal */
+# if defined(X_NOT_POSIX) && defined(SYSV) && !defined(SIGCHLD)
+#  define SIGCHLD SIGCLD
+# endif
+
+# include <X11/Xarch.h>
+
+#endif /* _XOS_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xdefs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xdefs.h
@@ -0,0 +1,108 @@
+/***********************************************************
+
+Copyright (c) 1999  The XFree86 Project Inc.
+
+All Rights Reserved.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The XFree86 Project
+Inc. shall not be used in advertising or otherwise to promote the
+sale, use or other dealings in this Software without prior written
+authorization from The XFree86 Project Inc..
+
+*/
+
+/**
+ ** Types definitions shared between server and clients 
+ **/
+
+#ifndef _XDEFS_H
+#define _XDEFS_H
+
+#ifdef _XSERVER64
+#include <X11/Xmd.h>
+#endif 
+
+#ifndef _XTYPEDEF_ATOM
+#  define _XTYPEDEF_ATOM
+#  ifndef _XSERVER64
+typedef unsigned long Atom;
+#  else
+typedef CARD32 Atom;
+#  endif
+#endif
+
+#ifndef Bool
+#  ifndef _XTYPEDEF_BOOL
+#   define _XTYPEDEF_BOOL
+typedef int Bool;
+#  endif
+#endif
+
+#ifndef _XTYPEDEF_POINTER
+#  define _XTYPEDEF_POINTER
+typedef void *pointer;
+#endif
+
+#ifndef _XTYPEDEF_CLIENTPTR
+typedef struct _Client *ClientPtr;
+#  define _XTYPEDEF_CLIENTPTR
+#endif
+
+#ifndef _XTYPEDEF_XID
+#  define _XTYPEDEF_XID
+#  ifndef _XSERVER64
+typedef unsigned long XID;
+#  else
+typedef CARD32 XID;
+#  endif
+#endif
+
+#ifndef _XTYPEDEF_MASK
+#  define _XTYPEDEF_MASK
+#  ifndef _XSERVER64
+typedef unsigned long Mask;
+#  else
+typedef CARD32 Mask;
+#  endif
+#endif
+
+#ifndef _XTYPEDEF_FONTPTR
+#  define _XTYPEDEF_FONTPTR
+typedef struct _Font *FontPtr; /* also in fonts/include/font.h */
+#endif
+
+#ifndef _XTYPEDEF_FONT
+#  define _XTYPEDEF_FONT
+typedef XID	Font;
+#endif
+
+#ifndef _XTYPEDEF_FSID
+#  ifndef _XSERVER64
+typedef unsigned long FSID;
+#  else
+typedef CARD32 FSID;
+#  endif
+#endif
+
+typedef FSID AccContext;
+
+/* OS independent time value 
+   XXX Should probably go in Xos.h */
+typedef struct timeval **OSTimePtr;
+
+
+typedef void (* BlockHandlerProcPtr)(pointer /* blockData */,
+				     OSTimePtr /* pTimeout */,
+				     pointer /* pReadmask */);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/HPkeysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/HPkeysym.h
@@ -0,0 +1,164 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts,
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Hewlett Packard
+or Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+HEWLETT-PACKARD MAKES NO WARRANTY OF ANY KIND WITH REGARD
+TO THIS SOFWARE, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  Hewlett-Packard shall not be liable for errors
+contained herein or direct, indirect, special, incidental or
+consequential damages in connection with the furnishing,
+performance, or use of this material.
+
+*/
+
+#ifndef _HPKEYSYM_H
+
+#define _HPKEYSYM
+
+#define hpXK_ClearLine		0x1000FF6F
+#define hpXK_InsertLine		0x1000FF70
+#define hpXK_DeleteLine		0x1000FF71
+#define hpXK_InsertChar		0x1000FF72
+#define hpXK_DeleteChar		0x1000FF73
+#define hpXK_BackTab		0x1000FF74
+#define hpXK_KP_BackTab		0x1000FF75
+#define hpXK_Modelock1		0x1000FF48
+#define hpXK_Modelock2		0x1000FF49
+#define hpXK_Reset		0x1000FF6C
+#define hpXK_System		0x1000FF6D
+#define hpXK_User		0x1000FF6E
+#define hpXK_mute_acute		0x100000A8
+#define hpXK_mute_grave		0x100000A9
+#define hpXK_mute_asciicircum	0x100000AA
+#define hpXK_mute_diaeresis	0x100000AB
+#define hpXK_mute_asciitilde	0x100000AC
+#define hpXK_lira		0x100000AF
+#define hpXK_guilder		0x100000BE
+#define hpXK_Ydiaeresis		0x100000EE
+#define hpXK_IO			0x100000EE
+#define hpXK_longminus		0x100000F6
+#define hpXK_block		0x100000FC
+
+
+#ifndef _OSF_Keysyms
+#define _OSF_Keysyms
+
+#define osfXK_Copy		0x1004FF02
+#define osfXK_Cut		0x1004FF03
+#define osfXK_Paste		0x1004FF04
+#define osfXK_BackTab		0x1004FF07
+#define osfXK_BackSpace		0x1004FF08
+#define osfXK_Clear		0x1004FF0B
+#define osfXK_Escape		0x1004FF1B
+#define osfXK_AddMode		0x1004FF31
+#define osfXK_PrimaryPaste	0x1004FF32
+#define osfXK_QuickPaste	0x1004FF33
+#define osfXK_PageLeft		0x1004FF40
+#define osfXK_PageUp		0x1004FF41
+#define osfXK_PageDown		0x1004FF42
+#define osfXK_PageRight		0x1004FF43
+#define osfXK_Activate		0x1004FF44
+#define osfXK_MenuBar		0x1004FF45
+#define osfXK_Left		0x1004FF51
+#define osfXK_Up		0x1004FF52
+#define osfXK_Right		0x1004FF53
+#define osfXK_Down		0x1004FF54
+#define osfXK_EndLine		0x1004FF57
+#define osfXK_BeginLine		0x1004FF58
+#define osfXK_EndData		0x1004FF59
+#define osfXK_BeginData		0x1004FF5A
+#define osfXK_PrevMenu		0x1004FF5B
+#define osfXK_NextMenu		0x1004FF5C
+#define osfXK_PrevField		0x1004FF5D
+#define osfXK_NextField		0x1004FF5E
+#define osfXK_Select		0x1004FF60
+#define osfXK_Insert		0x1004FF63
+#define osfXK_Undo		0x1004FF65
+#define osfXK_Menu		0x1004FF67
+#define osfXK_Cancel		0x1004FF69
+#define osfXK_Help		0x1004FF6A
+#define osfXK_SelectAll		0x1004FF71
+#define osfXK_DeselectAll	0x1004FF72
+#define osfXK_Reselect		0x1004FF73
+#define osfXK_Extend		0x1004FF74
+#define osfXK_Restore		0x1004FF78
+#define osfXK_Delete		0x1004FFFF
+
+#endif /* _OSF_Keysyms */
+
+
+/**************************************************************
+ * The use of the following macros is deprecated.
+ * They are listed below only for backwards compatibility.
+ */
+#define XK_Reset                0x1000FF6C
+#define XK_System               0x1000FF6D
+#define XK_User                 0x1000FF6E
+#define XK_ClearLine            0x1000FF6F
+#define XK_InsertLine           0x1000FF70
+#define XK_DeleteLine           0x1000FF71
+#define XK_InsertChar           0x1000FF72
+#define XK_DeleteChar           0x1000FF73
+#define XK_BackTab              0x1000FF74
+#define XK_KP_BackTab           0x1000FF75
+#define XK_Ext16bit_L           0x1000FF76
+#define XK_Ext16bit_R           0x1000FF77
+#define XK_mute_acute           0x100000a8
+#define XK_mute_grave           0x100000a9
+#define XK_mute_asciicircum     0x100000aa
+#define XK_mute_diaeresis       0x100000ab
+#define XK_mute_asciitilde      0x100000ac
+#define XK_lira                 0x100000af
+#define XK_guilder              0x100000be
+#ifndef XK_Ydiaeresis
+#define XK_Ydiaeresis           0x100000ee
+#endif
+#define XK_IO                   0x100000ee
+#define XK_longminus            0x100000f6
+#define XK_block                0x100000fc
+
+#endif /* _HPKEYSYM_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xosdefs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xosdefs.h
@@ -0,0 +1,116 @@
+/*
+ * O/S-dependent (mis)feature macro definitions
+ *
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+ */
+
+#ifndef _XOSDEFS_H_
+# define _XOSDEFS_H_
+
+/*
+ * X_NOT_POSIX means does not have POSIX header files.  Lack of this
+ * symbol does NOT mean that the POSIX environment is the default.
+ * You may still have to define _POSIX_SOURCE to get it.
+ */
+
+
+# ifdef _SCO_DS
+#  ifndef __SCO__
+#   define __SCO__
+#  endif
+# endif
+
+# ifdef __i386__
+#  ifdef SYSV
+#   if !defined(__SCO__) && \
+	!defined(__UNIXWARE__) && !defined(__sun)
+#    if !defined(_POSIX_SOURCE)
+#     define X_NOT_POSIX
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef __sun
+/* Imake configs define SVR4 on Solaris, but cc & gcc only define __SVR4
+ * This check allows non-Imake configured programs to build correctly.
+ */
+#  if defined(__SVR4) && !defined(SVR4)
+#   define SVR4 1
+#  endif
+#  ifdef SVR4
+/* define this to whatever it needs to be */
+#   define X_POSIX_C_SOURCE 199300L
+#  endif
+# endif
+
+# ifdef WIN32
+#  ifndef _POSIX_
+#   define X_NOT_POSIX
+#  endif
+# endif
+
+
+# ifdef __APPLE__
+#  define NULL_NOT_ZERO
+
+/* Defining any of these will sanitize the namespace to JUST want is defined by
+ * that particular standard.  If that happens, we don't get some expected
+ * prototypes, typedefs, etc (like fd_mask).  We can define _DARWIN_C_SOURCE to
+ * loosen our belts a tad.
+ */
+#  if defined(_XOPEN_SOURCE) || defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE)
+#   ifndef _DARWIN_C_SOURCE
+#    define _DARWIN_C_SOURCE
+#   endif
+#  endif
+
+# endif
+
+# ifdef __GNU__
+#  ifndef PATH_MAX
+#   define PATH_MAX 4096
+#  endif
+#  ifndef MAXPATHLEN
+#   define MAXPATHLEN 4096
+#  endif
+# endif
+
+# if defined(__SCO__) || defined(__UNIXWARE__)
+#  ifndef PATH_MAX
+#   define PATH_MAX	1024
+#  endif
+#  ifndef MAXPATHLEN
+#   define MAXPATHLEN	1024
+#  endif
+# endif
+
+# if defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) \
+	|| defined(__APPLE__) || defined(__DragonFly__)
+#  ifndef CSRG_BASED
+#   define CSRG_BASED
+#  endif
+# endif
+
+#endif /* _XOSDEFS_H_ */
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/keysym.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/keysym.h
@@ -0,0 +1,73 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+/* default keysyms */
+#define XK_MISCELLANY
+#define XK_XKB_KEYS
+#define XK_LATIN1
+#define XK_LATIN2
+#define XK_LATIN3
+#define XK_LATIN4
+#define XK_LATIN8
+#define XK_LATIN9
+#define XK_CAUCASUS
+#define XK_GREEK
+#define XK_KATAKANA
+#define XK_ARABIC
+#define XK_CYRILLIC
+#define XK_HEBREW
+#define XK_THAI
+#define XK_KOREAN
+#define XK_ARMENIAN
+#define XK_GEORGIAN
+#define XK_VIETNAMESE
+#define XK_CURRENCY
+#define XK_MATHEMATICAL
+#define XK_BRAILLE
+
+#include <X11/keysymdef.h>
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xthreads.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xthreads.h
@@ -0,0 +1,313 @@
+/*
+ *
+Copyright 1993, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+ * *
+ */
+
+#ifndef _XTHREADS_H_
+# define _XTHREADS_H_
+
+/* Redefine these to XtMalloc/XtFree or whatever you want before including
+ * this header file.
+ */
+# ifndef xmalloc
+#  define xmalloc malloc
+# endif
+# ifndef xfree
+#  define xfree free
+# endif
+
+# ifdef CTHREADS
+#  include <cthreads.h>
+typedef cthread_t xthread_t;
+typedef struct condition xcondition_rec;
+typedef struct mutex xmutex_rec;
+#  define xthread_init() cthread_init()
+#  define xthread_self cthread_self
+#  define xthread_fork(func,closure) cthread_fork(func,closure)
+#  define xthread_yield() cthread_yield()
+#  define xthread_exit(v) cthread_exit(v)
+#  define xthread_set_name(t,str) cthread_set_name(t,str)
+#  define xmutex_init(m) mutex_init(m)
+#  define xmutex_clear(m) mutex_clear(m)
+#  define xmutex_lock(m) mutex_lock(m)
+#  define xmutex_unlock(m) mutex_unlock(m)
+#  define xmutex_set_name(m,str) mutex_set_name(m,str)
+#  define xcondition_init(cv) condition_init(cv)
+#  define xcondition_clear(cv) condition_clear(cv)
+#  define xcondition_wait(cv,m) condition_wait(cv,m)
+#  define xcondition_signal(cv) condition_signal(cv)
+#  define xcondition_broadcast(cv) condition_broadcast(cv)
+#  define xcondition_set_name(cv,str) condition_set_name(cv,str)
+# else /* !CTHREADS */
+#  if defined(SVR4)
+#   include <thread.h>
+#   include <synch.h>
+typedef thread_t xthread_t;
+typedef thread_key_t xthread_key_t;
+typedef cond_t xcondition_rec;
+typedef mutex_t xmutex_rec;
+#   if defined(__UNIXWARE__)
+extern xthread_t (*_x11_thr_self)();
+#    define xthread_self  (_x11_thr_self)
+#   else
+#    define xthread_self thr_self
+#   endif
+#   define xthread_fork(func,closure) thr_create(NULL,0,func,closure,THR_NEW_LWP|THR_DETACHED,NULL)
+#   define xthread_yield() thr_yield()
+#   define xthread_exit(v) thr_exit(v)
+#   define xthread_key_create(kp,d) thr_keycreate(kp,d)
+#   ifdef __sun
+#    define xthread_key_delete(k) 0
+#   else
+#    define xthread_key_delete(k) thr_keydelete(k)
+#   endif
+#   define xthread_set_specific(k,v) thr_setspecific(k,v)
+#   define xthread_get_specific(k,vp) thr_getspecific(k,vp)
+#   define xmutex_init(m) mutex_init(m,USYNC_THREAD,0)
+#   define xmutex_clear(m) mutex_destroy(m)
+#   define xmutex_lock(m) mutex_lock(m)
+#   define xmutex_unlock(m) mutex_unlock(m)
+#   define xcondition_init(cv) cond_init(cv,USYNC_THREAD,0)
+#   define xcondition_clear(cv) cond_destroy(cv)
+#   define xcondition_wait(cv,m) cond_wait(cv,m)
+#   define xcondition_signal(cv) cond_signal(cv)
+#   define xcondition_broadcast(cv) cond_broadcast(cv)
+#  else /* !SVR4 */
+#   ifdef WIN32
+#    include <X11/Xwindows.h>
+typedef DWORD xthread_t;
+typedef DWORD xthread_key_t;
+struct _xthread_waiter {
+    HANDLE sem;
+    struct _xthread_waiter *next;
+};
+typedef struct {
+    CRITICAL_SECTION cs;
+    struct _xthread_waiter *waiters;
+} xcondition_rec;
+typedef CRITICAL_SECTION xmutex_rec;
+#    define xthread_init() _Xthread_init()
+#    define xthread_self GetCurrentThreadId
+#    define xthread_fork(func,closure) { \
+    DWORD _tmptid; \
+    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)func, (LPVOID)closure, 0, \
+		 &_tmptid); \
+}
+#    define xthread_yield() Sleep(0)
+#    define xthread_exit(v) ExitThread((DWORD)(v))
+#    define xthread_key_create(kp,d) *(kp) = TlsAlloc()
+#    define xthread_key_delete(k) TlsFree(k)
+#    define xthread_set_specific(k,v) TlsSetValue(k,v)
+#    define xthread_get_specific(k,vp) TlsGetValue(k)
+#    define xmutex_init(m) InitializeCriticalSection(m)
+#    define xmutex_clear(m) DeleteCriticalSection(m)
+#    define _XMUTEX_NESTS
+#    define xmutex_lock(m) EnterCriticalSection(m)
+#    define xmutex_unlock(m) LeaveCriticalSection(m)
+#    define xcondition_init(cv) { \
+    InitializeCriticalSection(&(cv)->cs); \
+    (cv)->waiters = NULL; \
+}
+#    define xcondition_clear(cv) DeleteCriticalSection(&(cv)->cs)
+extern struct _xthread_waiter *_Xthread_waiter();
+#    define xcondition_wait(cv,m) { \
+    struct _xthread_waiter *_tmpthr = _Xthread_waiter(); \
+    EnterCriticalSection(&(cv)->cs); \
+    _tmpthr->next = (cv)->waiters; \
+    (cv)->waiters = _tmpthr; \
+    LeaveCriticalSection(&(cv)->cs); \
+    LeaveCriticalSection(m); \
+    WaitForSingleObject(_tmpthr->sem, INFINITE); \
+    EnterCriticalSection(m); \
+}
+#    define xcondition_signal(cv) { \
+    EnterCriticalSection(&(cv)->cs); \
+    if ((cv)->waiters) { \
+        ReleaseSemaphore((cv)->waiters->sem, 1, NULL); \
+	(cv)->waiters = (cv)->waiters->next; \
+    } \
+    LeaveCriticalSection(&(cv)->cs); \
+}
+#    define xcondition_broadcast(cv) { \
+    struct _xthread_waiter *_tmpthr; \
+    EnterCriticalSection(&(cv)->cs); \
+    for (_tmpthr = (cv)->waiters; _tmpthr; _tmpthr = _tmpthr->next) \
+	ReleaseSemaphore(_tmpthr->sem, 1, NULL); \
+    (cv)->waiters = NULL; \
+    LeaveCriticalSection(&(cv)->cs); \
+}
+#   else /* !WIN32 */
+#    ifdef USE_TIS_SUPPORT
+/*
+ * TIS support is intended for thread safe libraries.
+ * This should not be used for general client programming.
+ */
+#     include <tis.h>
+typedef pthread_t xthread_t;
+typedef pthread_key_t xthread_key_t;
+typedef pthread_cond_t xcondition_rec;
+typedef pthread_mutex_t xmutex_rec;
+#     define xthread_self tis_self
+#     define xthread_fork(func,closure) { pthread_t _tmpxthr; \
+        pthread_create(&_tmpxthr,NULL,func,closure); }
+#     define xthread_yield() pthread_yield_np()
+#     define xthread_exit(v) pthread_exit(v)
+#     define xthread_key_create(kp,d) tis_key_create(kp,d)
+#     define xthread_key_delete(k) tis_key_delete(k)
+#     define xthread_set_specific(k,v) tis_setspecific(k,v)
+#     define xthread_get_specific(k,vp) *(vp) = tis_getspecific(k)
+#     define XMUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+#     define xmutex_init(m) tis_mutex_init(m)
+#     define xmutex_clear(m) tis_mutex_destroy(m)
+#     define xmutex_lock(m) tis_mutex_lock(m)
+#     define xmutex_unlock(m) tis_mutex_unlock(m)
+#     define xcondition_init(c) tis_cond_init(c)
+#     define xcondition_clear(c) tis_cond_destroy(c)
+#     define xcondition_wait(c,m) tis_cond_wait(c,m)
+#     define xcondition_signal(c) tis_cond_signal(c)
+#     define xcondition_broadcast(c) tis_cond_broadcast(c)
+#    else
+#     ifdef USE_NBSD_THREADLIB
+/*
+ * NetBSD threadlib support is intended for thread safe libraries.
+ * This should not be used for general client programming.
+ */
+#      include <threadlib.h>
+typedef thr_t xthread_t;
+typedef thread_key_t xthread_key_t;
+typedef cond_t xcondition_rec;
+typedef mutex_t xmutex_rec;
+#      define xthread_self thr_self
+#      define xthread_fork(func,closure) { thr_t _tmpxthr; \
+	/* XXX Create it detached?  --thorpej */ \
+	thr_create(&_tmpxthr,NULL,func,closure); }
+#      define xthread_yield() thr_yield()
+#      define xthread_exit(v) thr_exit(v)
+#      define xthread_key_create(kp,d) thr_keycreate(kp,d)
+#      define xthread_key_delete(k) thr_keydelete(k)
+#      define xthread_set_specific(k,v) thr_setspecific(k,v)
+#      define xthread_get_specific(k,vp) *(vp) = thr_getspecific(k)
+#      define XMUTEX_INITIALIZER MUTEX_INITIALIZER
+#      define xmutex_init(m) mutex_init(m, 0)
+#      define xmutex_clear(m) mutex_destroy(m)
+#      define xmutex_lock(m) mutex_lock(m)
+#      define xmutex_unlock(m) mutex_unlock(m)
+#      define xcondition_init(c) cond_init(c, 0, 0)
+#      define xcondition_clear(c) cond_destroy(c)
+#      define xcondition_wait(c,m) cond_wait(c,m)
+#      define xcondition_signal(c) cond_signal(c)
+#      define xcondition_broadcast(c) cond_broadcast(c)
+#     else
+#      include <pthread.h>
+typedef pthread_t xthread_t;
+typedef pthread_key_t xthread_key_t;
+typedef pthread_cond_t xcondition_rec;
+typedef pthread_mutex_t xmutex_rec;
+#      define xthread_self pthread_self
+#      define xthread_yield() pthread_yield()
+#      define xthread_exit(v) pthread_exit(v)
+#      define xthread_set_specific(k,v) pthread_setspecific(k,v)
+#      define xmutex_clear(m) pthread_mutex_destroy(m)
+#      define xmutex_lock(m) pthread_mutex_lock(m)
+#      define xmutex_unlock(m) pthread_mutex_unlock(m)
+#      ifndef XPRE_STANDARD_API
+#       define xthread_key_create(kp,d) pthread_key_create(kp,d)
+#       define xthread_key_delete(k) pthread_key_delete(k)
+#       define xthread_get_specific(k,vp) *(vp) = pthread_getspecific(k)
+#       define xthread_fork(func,closure) { pthread_t _tmpxthr; \
+	pthread_create(&_tmpxthr,NULL,func,closure); }
+#       define XMUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+#       define xmutex_init(m) pthread_mutex_init(m, NULL)
+#       define xcondition_init(c) pthread_cond_init(c, NULL)
+#      else /* XPRE_STANDARD_API */
+#       define xthread_key_create(kp,d) pthread_keycreate(kp,d)
+#       define xthread_key_delete(k) 0
+#       define xthread_get_specific(k,vp) pthread_getspecific(k,vp)
+#       define xthread_fork(func,closure) { pthread_t _tmpxthr; \
+	pthread_create(&_tmpxthr,pthread_attr_default,func,closure); }
+#       define xmutex_init(m) pthread_mutex_init(m, pthread_mutexattr_default)
+#       define xcondition_init(c) pthread_cond_init(c, pthread_condattr_default)
+#      endif /* XPRE_STANDARD_API */
+#      define xcondition_clear(c) pthread_cond_destroy(c)
+#      define xcondition_wait(c,m) pthread_cond_wait(c,m)
+#      define xcondition_signal(c) pthread_cond_signal(c)
+#      define xcondition_broadcast(c) pthread_cond_broadcast(c)
+#      if defined(_DECTHREADS_)
+static xthread_t _X_no_thread_id;
+#       define xthread_have_id(id) !pthread_equal(id, _X_no_thread_id)
+#       define xthread_clear_id(id) id = _X_no_thread_id
+#       define xthread_equal(id1,id2) pthread_equal(id1, id2)
+#      endif /* _DECTHREADS_ */
+#      if defined(__linux__)
+#       define xthread_have_id(id) !pthread_equal(id, 0)
+#       define xthread_clear_id(id) id = 0
+#       define xthread_equal(id1,id2) pthread_equal(id1, id2)
+#      endif /* linux */
+#      if defined(_CMA_VENDOR_) && defined(_CMA__IBM) && (_CMA_VENDOR_ == _CMA__IBM)
+#       ifdef DEBUG		/* too much of a hack to enable normally */
+/* see also cma__obj_set_name() */
+#        define xmutex_set_name(m,str) ((char**)(m)->field1)[5] = (str)
+#        define xcondition_set_name(cv,str) ((char**)(cv)->field1)[5] = (str)
+#       endif /* DEBUG */
+#      endif /* _CMA_VENDOR_ == _CMA__IBM */
+#     endif /* USE_NBSD_THREADLIB */
+#    endif /* USE_TIS_SUPPORT */
+#   endif /* WIN32 */
+#  endif /* SVR4 */
+# endif /* CTHREADS */
+typedef xcondition_rec *xcondition_t;
+typedef xmutex_rec *xmutex_t;
+# ifndef xcondition_malloc
+#  define xcondition_malloc() (xcondition_t)xmalloc(sizeof(xcondition_rec))
+# endif
+# ifndef xcondition_free
+#  define xcondition_free(c) xfree((char *)c)
+# endif
+# ifndef xmutex_malloc
+#  define xmutex_malloc() (xmutex_t)xmalloc(sizeof(xmutex_rec))
+# endif
+# ifndef xmutex_free
+#  define xmutex_free(m) xfree((char *)m)
+# endif
+# ifndef xthread_have_id
+#  define xthread_have_id(id) id
+# endif
+# ifndef xthread_clear_id
+#  define xthread_clear_id(id) id = 0
+# endif
+# ifndef xthread_equal
+#  define xthread_equal(id1,id2) ((id1) == (id2))
+# endif
+/* aids understood by some debuggers */
+# ifndef xthread_set_name
+#  define xthread_set_name(t,str)
+# endif
+# ifndef xmutex_set_name
+#  define xmutex_set_name(m,str)
+# endif
+# ifndef xcondition_set_name
+#  define xcondition_set_name(cv,str)
+# endif
+
+#endif /* _XTHREADS_H_ */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xwindows.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xwindows.h
@@ -0,0 +1,91 @@
+/*
+
+Copyright 1996, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT
+SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABIL-
+ITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization from
+The Open Group.
+
+*/
+
+/*
+ * This header file has the sole purpose of allowing the inclusion of
+ * windows.h without getting any name conflicts with X headers code, by
+ * renaming the conflicting definitions from windows.h
+ *
+ * Some (non-Microsoft) versions of the Windows API headers actually avoid
+ * making the conflicting definitions if XFree86Server is defined, so we
+ * need to remember if that was defined and undefine it during including
+ * windows.h (so the conflicting definitions get wrapped correctly), and
+ * then redefine it afterwards...
+ *
+ * There doesn't seem to be a good way to wrap the min/max macros from
+ * windows.h, so we simply avoid defining them completely, allowing any
+ * pre-existing definition to stand.
+ *
+ */
+
+#undef _XFree86Server
+#ifdef XFree86Server
+# define _XFree86Server
+# undef XFree86Server
+#endif
+
+#define NOMINMAX
+#define BOOL wBOOL
+#define INT32 wINT32
+#undef Status
+#define Status wStatus
+#define ATOM wATOM
+#define BYTE wBYTE
+#define FreeResource wFreeResource
+#include <windows.h>
+#undef NOMINMAX
+#undef Status
+#define Status int
+#undef BYTE
+#undef BOOL
+#undef INT32
+#undef ATOM
+#undef FreeResource
+#undef CreateWindowA
+
+#ifdef RESOURCE_H
+# undef RT_FONT
+# undef RT_CURSOR
+# define RT_FONT         ((RESTYPE)4)
+# define RT_CURSOR       ((RESTYPE)5)
+#endif
+
+#ifndef __CYGWIN__
+#define sleep(x) Sleep((x) * 1000)
+#endif
+
+#if defined(WIN32) && (!defined(PATH_MAX) || PATH_MAX < 1024)
+# undef PATH_MAX
+# define PATH_MAX 1024
+#endif
+
+#ifdef _XFree86Server
+# define XFree86Server
+# undef _XFree86Server
+#endif
+
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xalloca.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xalloca.h
@@ -0,0 +1,121 @@
+/*
+
+Copyright 1995, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+/*
+ * The purpose of this header is to define the macros ALLOCATE_LOCAL and
+ * DEALLOCATE_LOCAL appropriately for the platform being compiled on.
+ * These macros are used to make fast, function-local memory allocations.
+ * Their characteristics are as follows:
+ *
+ * void *ALLOCATE_LOCAL(int size)
+ *    Returns a pointer to size bytes of memory, or NULL if the allocation
+ *    failed.  The memory must be freed with DEALLOCATE_LOCAL before the
+ *    function that made the allocation returns.  You should not ask for
+ *    large blocks of memory with this function, since on many platforms
+ *    the memory comes from the stack, which may have limited size.
+ *
+ * void DEALLOCATE_LOCAL(void *)
+ *    Frees the memory allocated by ALLOCATE_LOCAL.  Omission of this
+ *    step may be harmless on some platforms, but will result in
+ *    memory leaks or worse on others.
+ *
+ * Before including this file, you should define two macros,
+ * ALLOCATE_LOCAL_FALLBACK and DEALLOCATE_LOCAL_FALLBACK, that have the
+ * same characteristics as ALLOCATE_LOCAL and DEALLOCATE_LOCAL.  The
+ * header uses the fallbacks if it doesn't know a "better" way to define
+ * ALLOCATE_LOCAL and DEALLOCATE_LOCAL.  Typical usage would be:
+ *
+ *    #define ALLOCATE_LOCAL_FALLBACK(_size) malloc(_size)
+ *    #define DEALLOCATE_LOCAL_FALLBACK(_ptr) free(_ptr)
+ *    #include "Xalloca.h"
+ */
+
+#ifndef XALLOCA_H
+#define XALLOCA_H 1
+
+#ifndef INCLUDE_ALLOCA_H
+/* Need to add more here to match Imake *.cf's */
+# if defined(HAVE_ALLOCA_H) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+#  define INCLUDE_ALLOCA_H
+# endif
+#endif
+
+#ifdef INCLUDE_ALLOCA_H
+#  include <alloca.h>
+#endif
+
+#ifndef NO_ALLOCA
+/*
+ * os-dependent definition of local allocation and deallocation
+ * If you want something other than (DE)ALLOCATE_LOCAL_FALLBACK
+ * for ALLOCATE/DEALLOCATE_LOCAL then you add that in here.
+ */
+
+
+#  ifdef __GNUC__
+#    ifndef alloca
+#      define alloca __builtin_alloca
+#    endif /* !alloca */
+#    define ALLOCATE_LOCAL(size) alloca((int)(size))
+#  else /* ! __GNUC__ */
+
+/*
+ * warning: old mips alloca (pre 2.10) is unusable, new one is built in
+ * Test is easy, the new one is named __builtin_alloca and comes
+ * from alloca.h which #defines alloca.
+ */
+#      if defined(__sun) || defined(alloca)
+/*
+ * Some System V boxes extract alloca.o from /lib/libPW.a; if you
+ * decide that you don't want to use alloca, you might want to fix it here.
+ */
+/* alloca might be a macro taking one arg (hi, Sun!), so give it one. */
+#        if !defined(__cplusplus)
+#          define __Xnullarg		/* as nothing */
+           extern void *alloca(__Xnullarg);
+#        endif
+#        define ALLOCATE_LOCAL(size) alloca((int)(size))
+#      endif /* who does alloca */
+#  endif /* __GNUC__ */
+
+#endif /* NO_ALLOCA */
+
+#if !defined(ALLOCATE_LOCAL)
+#  if defined(ALLOCATE_LOCAL_FALLBACK) && defined(DEALLOCATE_LOCAL_FALLBACK)
+#    define ALLOCATE_LOCAL(_size)  ALLOCATE_LOCAL_FALLBACK(_size)
+#    define DEALLOCATE_LOCAL(_ptr) DEALLOCATE_LOCAL_FALLBACK(_ptr)
+#  else /* no fallbacks supplied; error */
+#    define ALLOCATE_LOCAL(_size)  ALLOCATE_LOCAL_FALLBACK undefined!
+#    define DEALLOCATE_LOCAL(_ptr) DEALLOCATE_LOCAL_FALLBACK undefined!
+#  endif /* defined(ALLOCATE_LOCAL_FALLBACK && DEALLOCATE_LOCAL_FALLBACK) */
+#else
+#  if !defined(DEALLOCATE_LOCAL)
+#    define DEALLOCATE_LOCAL(_ptr) do {} while(0)
+#  endif
+#endif /* defined(ALLOCATE_LOCAL) */
+
+#endif /* XALLOCA_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xprotostr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xprotostr.h
@@ -0,0 +1,77 @@
+#ifndef XPROTOSTRUCTS_H
+#define XPROTOSTRUCTS_H
+
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+#include <X11/Xmd.h>
+
+/* Used by PolySegment */
+
+typedef struct _xSegment {
+    INT16 x1 B16, y1 B16, x2 B16, y2 B16;
+} xSegment;
+
+/* POINT */
+
+typedef struct _xPoint {
+	INT16		x B16, y B16;
+} xPoint;
+
+typedef struct _xRectangle {
+    INT16 x B16, y B16;
+    CARD16  width B16, height B16;
+} xRectangle;
+
+/*  ARC  */
+
+typedef struct _xArc {
+    INT16 x B16, y B16;
+    CARD16   width B16, height B16;
+    INT16   angle1 B16, angle2 B16;
+} xArc;
+
+#endif /* XPROTOSTRUCTS_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xmd.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xmd.h
@@ -0,0 +1,185 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+#ifndef XMD_H
+# define XMD_H 1
+/*
+ *  Xmd.h: MACHINE DEPENDENT DECLARATIONS.
+ */
+
+/*
+ * Special per-machine configuration flags.
+ */
+# if defined(__sun) && defined(__SVR4)
+#  include <sys/isa_defs.h> /* Solaris: defines _LP64 if necessary */
+# endif
+
+# if defined (_LP64) || defined(__LP64__) || \
+     defined(__alpha) || defined(__alpha__) || \
+     defined(__ia64__) || defined(ia64) || \
+     defined(__sparc64__) || \
+     defined(__s390x__) || \
+     defined(__amd64__) || defined(amd64) || \
+     defined(__powerpc64__)
+#  define LONG64				/* 32/64-bit architecture */
+# endif
+
+/*
+ * Stuff to handle large architecture machines; the constants were generated
+ * on a 32-bit machine and must correspond to the protocol.
+ */
+# ifdef WORD64
+#  define MUSTCOPY
+# endif /* WORD64 */
+
+
+/*
+ * Definition of macro used to set constants for size of network structures;
+ * machines with preprocessors that can't handle all of the sz_ symbols
+ * can define this macro to be sizeof(x) if and only if their compiler doesn't
+ * pad out structures (esp. the xTextElt structure which contains only two
+ * one-byte fields).  Network structures should always define sz_symbols.
+ *
+ * The sz_ prefix is used instead of something more descriptive so that the
+ * symbols are no more than 32 characters long (which causes problems for some
+ * compilers and preprocessors).
+ *
+ * The extra indirection is to get macro arguments to expand correctly before
+ * the concatenation, rather than afterward.
+ */
+# define _SIZEOF(x) sz_##x
+# define SIZEOF(x) _SIZEOF(x)
+
+/*
+ * Bitfield suffixes for the protocol structure elements, if you
+ * need them.  Note that bitfields are not guaranteed to be signed
+ * (or even unsigned) according to ANSI C.
+ */
+# ifdef WORD64
+typedef long INT64;
+typedef unsigned long CARD64;
+#  define B32 :32
+#  define B16 :16
+#  ifdef UNSIGNEDBITFIELDS
+typedef unsigned int INT32;
+typedef unsigned int INT16;
+#  else
+typedef signed int INT32;
+typedef signed int INT16;
+#  endif
+# else
+#  define B32
+#  define B16
+#  ifdef LONG64
+typedef long INT64;
+typedef int INT32;
+#  else
+typedef long INT32;
+#  endif
+typedef short INT16;
+# endif
+
+typedef signed char    INT8;
+
+# ifdef LONG64
+typedef unsigned long CARD64;
+typedef unsigned int CARD32;
+# else
+typedef unsigned long CARD32;
+# endif
+# if !defined(WORD64) && !defined(LONG64)
+typedef unsigned long long CARD64;
+# endif
+typedef unsigned short CARD16;
+typedef unsigned char  CARD8;
+
+typedef CARD32		BITS32;
+typedef CARD16		BITS16;
+
+typedef CARD8		BYTE;
+typedef CARD8		BOOL;
+
+/*
+ * definitions for sign-extending bitfields on 64-bit architectures
+ */
+# if defined(WORD64) && defined(UNSIGNEDBITFIELDS)
+#  define cvtINT8toInt(val)   (((val) & 0x00000080) ? ((val) | 0xffffffffffffff00) : (val))
+#  define cvtINT16toInt(val)  (((val) & 0x00008000) ? ((val) | 0xffffffffffff0000) : (val))
+#  define cvtINT32toInt(val)  (((val) & 0x80000000) ? ((val) | 0xffffffff00000000) : (val))
+#  define cvtINT8toShort(val)  cvtINT8toInt(val)
+#  define cvtINT16toShort(val) cvtINT16toInt(val)
+#  define cvtINT32toShort(val) cvtINT32toInt(val)
+#  define cvtINT8toLong(val)  cvtINT8toInt(val)
+#  define cvtINT16toLong(val) cvtINT16toInt(val)
+#  define cvtINT32toLong(val) cvtINT32toInt(val)
+# else
+#  define cvtINT8toInt(val) (val)
+#  define cvtINT16toInt(val) (val)
+#  define cvtINT32toInt(val) (val)
+#  define cvtINT8toShort(val) (val)
+#  define cvtINT16toShort(val) (val)
+#  define cvtINT32toShort(val) (val)
+#  define cvtINT8toLong(val) (val)
+#  define cvtINT16toLong(val) (val)
+#  define cvtINT32toLong(val) (val)
+# endif /* WORD64 and UNSIGNEDBITFIELDS */
+
+
+
+# ifdef MUSTCOPY
+/*
+ * This macro must not cast or else pointers will get aligned and be wrong
+ */
+#  define NEXTPTR(p,t)  (((char *) p) + SIZEOF(t))
+# else /* else not MUSTCOPY, this is used for 32-bit machines */
+/*
+ * this version should leave result of type (t *), but that should only be
+ * used when not in MUSTCOPY
+ */
+#  define NEXTPTR(p,t) (((t *)(p)) + 1)
+# endif /* MUSTCOPY - used machines whose C structs don't line up with proto */
+
+#endif /* XMD_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xatom.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/Xatom.h
@@ -0,0 +1,79 @@
+#ifndef XATOM_H
+#define XATOM_H 1
+
+/* THIS IS A GENERATED FILE
+ *
+ * Do not change!  Changing this file implies a protocol change!
+ */
+
+#define XA_PRIMARY ((Atom) 1)
+#define XA_SECONDARY ((Atom) 2)
+#define XA_ARC ((Atom) 3)
+#define XA_ATOM ((Atom) 4)
+#define XA_BITMAP ((Atom) 5)
+#define XA_CARDINAL ((Atom) 6)
+#define XA_COLORMAP ((Atom) 7)
+#define XA_CURSOR ((Atom) 8)
+#define XA_CUT_BUFFER0 ((Atom) 9)
+#define XA_CUT_BUFFER1 ((Atom) 10)
+#define XA_CUT_BUFFER2 ((Atom) 11)
+#define XA_CUT_BUFFER3 ((Atom) 12)
+#define XA_CUT_BUFFER4 ((Atom) 13)
+#define XA_CUT_BUFFER5 ((Atom) 14)
+#define XA_CUT_BUFFER6 ((Atom) 15)
+#define XA_CUT_BUFFER7 ((Atom) 16)
+#define XA_DRAWABLE ((Atom) 17)
+#define XA_FONT ((Atom) 18)
+#define XA_INTEGER ((Atom) 19)
+#define XA_PIXMAP ((Atom) 20)
+#define XA_POINT ((Atom) 21)
+#define XA_RECTANGLE ((Atom) 22)
+#define XA_RESOURCE_MANAGER ((Atom) 23)
+#define XA_RGB_COLOR_MAP ((Atom) 24)
+#define XA_RGB_BEST_MAP ((Atom) 25)
+#define XA_RGB_BLUE_MAP ((Atom) 26)
+#define XA_RGB_DEFAULT_MAP ((Atom) 27)
+#define XA_RGB_GRAY_MAP ((Atom) 28)
+#define XA_RGB_GREEN_MAP ((Atom) 29)
+#define XA_RGB_RED_MAP ((Atom) 30)
+#define XA_STRING ((Atom) 31)
+#define XA_VISUALID ((Atom) 32)
+#define XA_WINDOW ((Atom) 33)
+#define XA_WM_COMMAND ((Atom) 34)
+#define XA_WM_HINTS ((Atom) 35)
+#define XA_WM_CLIENT_MACHINE ((Atom) 36)
+#define XA_WM_ICON_NAME ((Atom) 37)
+#define XA_WM_ICON_SIZE ((Atom) 38)
+#define XA_WM_NAME ((Atom) 39)
+#define XA_WM_NORMAL_HINTS ((Atom) 40)
+#define XA_WM_SIZE_HINTS ((Atom) 41)
+#define XA_WM_ZOOM_HINTS ((Atom) 42)
+#define XA_MIN_SPACE ((Atom) 43)
+#define XA_NORM_SPACE ((Atom) 44)
+#define XA_MAX_SPACE ((Atom) 45)
+#define XA_END_SPACE ((Atom) 46)
+#define XA_SUPERSCRIPT_X ((Atom) 47)
+#define XA_SUPERSCRIPT_Y ((Atom) 48)
+#define XA_SUBSCRIPT_X ((Atom) 49)
+#define XA_SUBSCRIPT_Y ((Atom) 50)
+#define XA_UNDERLINE_POSITION ((Atom) 51)
+#define XA_UNDERLINE_THICKNESS ((Atom) 52)
+#define XA_STRIKEOUT_ASCENT ((Atom) 53)
+#define XA_STRIKEOUT_DESCENT ((Atom) 54)
+#define XA_ITALIC_ANGLE ((Atom) 55)
+#define XA_X_HEIGHT ((Atom) 56)
+#define XA_QUAD_WIDTH ((Atom) 57)
+#define XA_WEIGHT ((Atom) 58)
+#define XA_POINT_SIZE ((Atom) 59)
+#define XA_RESOLUTION ((Atom) 60)
+#define XA_COPYRIGHT ((Atom) 61)
+#define XA_NOTICE ((Atom) 62)
+#define XA_FONT_NAME ((Atom) 63)
+#define XA_FAMILY_NAME ((Atom) 64)
+#define XA_FULL_NAME ((Atom) 65)
+#define XA_CAP_HEIGHT ((Atom) 66)
+#define XA_WM_CLASS ((Atom) 67)
+#define XA_WM_TRANSIENT_FOR ((Atom) 68)
+
+#define XA_LAST_PREDEFINED ((Atom) 68)
+#endif /* XATOM_H */
Index: src/VBox/Additions/x11/x11include/xproto-7.0.18/README
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xproto-7.0.18/README
@@ -0,0 +1,10 @@
+The contents of this directory were extracted from the contents of the
+archive xproto-7.0.18.tar.bz2, as downloaded from ftp.x.org, using the
+following shell script:
+
+mkdir $PATH_VBOX/src/VBox/Additions/x11/x11include/xproto-7.0.18/X11
+cp *.h PATH_VBOX/src/VBox/Additions/x11/x11include/xproto-7.0.18/X11
+for i in *.h.in
+  do
+    cp $i src/VBox/Additions/x11/x11include/xproto-7.0.18/X11/`basename $i .in`
+  done
Index: src/VBox/Additions/x11/x11include/xorg-server-1.8.0/edid.h
===================================================================
--- src/VBox/Additions/x11/x11include/xorg-server-1.8.0/edid.h.orig
+++ src/VBox/Additions/x11/x11include/xorg-server-1.8.0/edid.h
@@ -602,10 +602,10 @@ struct cea_audio_block {
 };
 
 struct cea_vendor_block_hdmi {
-  Uchar  portB:4;
-  Uchar  portA:4;
-  Uchar  portD:4;
-  Uchar  portC:4;
+  __extension__ Uchar portB:4;
+  __extension__ Uchar portA:4;
+  __extension__ Uchar portD:4;
+  __extension__ Uchar portC:4;
   Uchar  support_flags;
   Uchar  max_tmds_clock;
   Uchar  latency_present;
@@ -620,29 +620,29 @@ struct cea_vendor_block {
   union {
       struct cea_vendor_block_hdmi hdmi;
       /* any other vendor blocks we know about */
-  };
+  } dummy;
 };
 
 struct cea_speaker_block
 {
-  Uchar FLR:1;
-  Uchar LFE:1;
-  Uchar FC:1;
-  Uchar RLR:1;
-  Uchar RC:1;
-  Uchar FLRC:1;
-  Uchar RLRC:1;
-  Uchar FLRW:1;
-  Uchar FLRH:1;
-  Uchar TC:1;
-  Uchar FCH:1;
-  Uchar Resv:5;
-  Uchar ResvByte;
+  __extension__ Uchar FLR:1;
+  __extension__ Uchar LFE:1;
+  __extension__ Uchar FC:1;
+  __extension__ Uchar RLR:1;
+  __extension__ Uchar RC:1;
+  __extension__ Uchar FLRC:1;
+  __extension__ Uchar RLRC:1;
+  __extension__ Uchar FLRW:1;
+  __extension__ Uchar FLRH:1;
+  __extension__ Uchar TC:1;
+  __extension__ Uchar FCH:1;
+  __extension__ Uchar Resv:5;
+  __extension__ Uchar ResvByte;
 };
 
 struct cea_data_block {
-  Uchar len:5;
-  Uchar tag:3;
+  __extension__ Uchar len:5;
+  __extension__ Uchar tag:3;
   union{
     struct cea_video_block video;
     struct cea_audio_block audio;
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/set.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/set.h
@@ -0,0 +1,147 @@
+/*
+
+Copyright 1995, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/*
+	  A Set Abstract Data Type (ADT) for the RECORD Extension
+			   David P. Wiggins
+			       7/25/95
+
+    The RECORD extension server code needs to maintain sets of numbers
+    that designate protocol message types.  In most cases the interval of
+    numbers starts at 0 and does not exceed 255, but in a few cases (minor
+    opcodes of extension requests) the maximum is 65535.  This disparity
+    suggests that a single set representation may not be suitable for all
+    sets, especially given that server memory is precious.  We introduce a
+    set ADT to hide implementation differences so that multiple
+    simultaneous set representations can exist.  A single interface is
+    presented to the set user regardless of the implementation in use for
+    a particular set.
+
+    The existing RECORD SI appears to require only four set operations:
+    create (given a list of members), destroy, see if a particular number
+    is a member of the set, and iterate over the members of a set.  Though
+    many more set operations are imaginable, to keep the code space down,
+    we won't provide any more operations than are needed.
+
+    The following types and functions/macros define the ADT.
+*/
+
+/* an interval of set members */
+typedef struct {
+    CARD16 first;
+    CARD16 last;
+} RecordSetInterval;
+
+typedef struct _RecordSetRec *RecordSetPtr; /* primary set type */
+
+typedef void *RecordSetIteratePtr;
+
+/* table of function pointers for set operations.
+   set users should never declare a variable of this type.
+*/
+typedef struct {
+    void (*DestroySet)(
+    RecordSetPtr pSet
+);
+    unsigned long (*IsMemberOfSet)(
+    RecordSetPtr pSet,
+    int possible_member
+);
+    RecordSetIteratePtr (*IterateSet)(
+    RecordSetPtr pSet,
+    RecordSetIteratePtr pIter,
+    RecordSetInterval *interval
+);
+} RecordSetOperations;
+
+/* "base class" for sets.
+   set users should never declare a variable of this type.
+ */
+typedef struct _RecordSetRec {
+    RecordSetOperations *ops;
+} RecordSetRec;
+
+RecordSetPtr RecordCreateSet(
+    RecordSetInterval *intervals,
+    int nintervals,
+    void *pMem,
+    int memsize
+);
+/*
+    RecordCreateSet creates and returns a new set having members specified
+    by intervals and nintervals.  nintervals is the number of RecordSetInterval
+    structures pointed to by intervals.  The elements belonging to the new
+    set are determined as follows.  For each RecordSetInterval structure, the
+    elements between first and last inclusive are members of the new set.
+    If a RecordSetInterval's first field is greater than its last field, the
+    results are undefined.  It is valid to create an empty set (nintervals ==
+    0).  If RecordCreateSet returns NULL, the set could not be created due
+    to resource constraints.
+*/
+
+int RecordSetMemoryRequirements(
+    RecordSetInterval * /*pIntervals*/,
+    int /*nintervals*/,
+    int * /*alignment*/
+);
+
+#define RecordDestroySet(_pSet) \
+	/* void */ (*_pSet->ops->DestroySet)(/* RecordSetPtr */ _pSet)
+/*
+    RecordDestroySet frees all resources used by _pSet.  _pSet should not be
+    used after it is destroyed.
+*/
+
+#define RecordIsMemberOfSet(_pSet, _m) \
+  /* unsigned long */ (*_pSet->ops->IsMemberOfSet)(/* RecordSetPtr */ _pSet, \
+						   /* int */ _m) 
+/*
+    RecordIsMemberOfSet returns a non-zero value if _m is a member of
+    _pSet, else it returns zero.
+*/
+
+#define RecordIterateSet(_pSet, _pIter, _interval) \
+ /* RecordSetIteratePtr */ (*_pSet->ops->IterateSet)(/* RecordSetPtr */ _pSet,\
+	/* RecordSetIteratePtr */ _pIter, /* RecordSetInterval */ _interval)
+/*
+    RecordIterateSet returns successive intervals of members of _pSet.  If
+    _pIter is NULL, the first interval of set members is copied into _interval.
+    The return value should be passed as _pIter in the next call to
+    RecordIterateSet to obtain the next interval.  When the return value is
+    NULL, there were no more intervals in the set, and nothing is copied into
+    the _interval parameter.  Intervals appear in increasing numerical order
+    with no overlap between intervals.  As such, the list of intervals produced
+    by RecordIterateSet may not match the list of intervals that were passed
+    in RecordCreateSet.  Typical usage:
+
+	pIter = NULL;
+	while (pIter = RecordIterateSet(pSet, pIter, &interval))
+	{
+	    process interval;
+	}
+*/
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_util.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_util.h
@@ -0,0 +1,53 @@
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef __GLX_INDIRECT_UTIL_H__
+#define __GLX_INDIRECT_UTIL_H__
+
+extern GLint __glGetBooleanv_variable_size( GLenum e );
+
+extern void * __glXGetAnswerBuffer( __GLXclientState * cl,
+    size_t required_size, void * local_buffer, size_t local_size,
+    unsigned alignment );
+
+extern void __glXSendReply( ClientPtr client, const void * data,
+    size_t elements, size_t element_size, GLboolean always_array,
+    CARD32 retval );
+
+extern void __glXSendReplySwap( ClientPtr client, const void * data,
+    size_t elements, size_t element_size, GLboolean always_array,
+    CARD32 retval );
+
+struct __glXDispatchInfo;
+
+extern void *__glXGetProtocolDecodeFunction(
+    const struct __glXDispatchInfo *dispatch_info, int opcode,
+    int swapped_version);
+
+extern int __glXGetProtocolSizeData(
+    const struct __glXDispatchInfo *dispatch_info, int opcode,
+    __GLXrenderSizeData *data);
+
+#endif /* __GLX_INDIRECT_UTIL_H__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setmode.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setmode.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETMODE_H
+#define SETMODE_H 1
+
+int SProcXSetDeviceMode(ClientPtr	/* client */
+    );
+
+int ProcXSetDeviceMode(ClientPtr	/* client */
+    );
+
+void SRepXSetDeviceMode(ClientPtr /* client */ ,
+			int /* size */ ,
+			xSetDeviceModeReply *	/* rep */
+    );
+
+#endif /* SETMODE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxdummy.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxdummy.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to dummy input device support.  \see dmxdummy.c */
+
+#ifndef _DMXDUMMY_H_
+#define _DMXDUMMY_H_
+
+extern void dmxDummyMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void dmxDummyKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixfontstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixfontstr.h
@@ -0,0 +1,93 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXFONTSTRUCT_H
+#define DIXFONTSTRUCT_H
+
+#include "servermd.h"
+#include "dixfont.h"
+#include <X11/fonts/fontstruct.h>
+#include "closure.h"
+#include <X11/Xproto.h> /* for xQueryFontReply */
+
+#define FONTCHARSET(font)	  (font)
+#define FONTMAXBOUNDS(font,field) (font)->info.maxbounds.field
+#define FONTMINBOUNDS(font,field) (font)->info.minbounds.field
+#define TERMINALFONT(font)	  (font)->info.terminalFont
+#define FONTASCENT(font)	  (font)->info.fontAscent
+#define FONTDESCENT(font)	  (font)->info.fontDescent
+#define FONTGLYPHS(font)	  0
+#define FONTCONSTMETRICS(font)	  (font)->info.constantMetrics
+#define FONTCONSTWIDTH(font)	  (font)->info.constantWidth
+#define FONTALLEXIST(font)	  (font)->info.allExist
+#define FONTFIRSTCOL(font)	  (font)->info.firstCol
+#define FONTLASTCOL(font)	  (font)->info.lastCol
+#define FONTFIRSTROW(font)	  (font)->info.firstRow
+#define FONTLASTROW(font)	  (font)->info.lastRow
+#define FONTDEFAULTCH(font)	  (font)->info.defaultCh
+#define FONTINKMIN(font)	  (&((font)->info.ink_minbounds))
+#define FONTINKMAX(font)	  (&((font)->info.ink_maxbounds))
+#define FONTPROPS(font)		  (font)->info.props
+#define FONTGLYPHBITS(base,pci)	  ((unsigned char *) (pci)->bits)
+#define FONTINFONPROPS(font)	  (font)->info.nprops
+
+/* some things haven't changed names, but we'll be careful anyway */
+
+#define FONTREFCNT(font)	  (font)->refcnt
+
+/*
+ * for linear char sets
+ */
+#define N1dChars(pfont)	(FONTLASTCOL(pfont) - FONTFIRSTCOL(pfont) + 1)
+
+/*
+ * for 2D char sets
+ */
+#define N2dChars(pfont)	(N1dChars(pfont) * \
+			 (FONTLASTROW(pfont) - FONTFIRSTROW(pfont) + 1))
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES -1
+#endif
+
+#if GLYPHPADBYTES == 0 || GLYPHPADBYTES == 1
+#define	GLYPHWIDTHBYTESPADDED(pci)	(GLYPHWIDTHBYTES(pci))
+#define	PADGLYPHWIDTHBYTES(w)		(((w)+7)>>3)
+#endif
+
+#if GLYPHPADBYTES == 2
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+1) & ~0x1)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+1) & ~0x1)
+#endif
+
+#if GLYPHPADBYTES == 4
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+3) & ~0x3)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+3) & ~0x3)
+#endif
+
+#if GLYPHPADBYTES == 8 /* for a cray? */
+#define	GLYPHWIDTHBYTESPADDED(pci)	((GLYPHWIDTHBYTES(pci)+7) & ~0x7)
+#define	PADGLYPHWIDTHBYTES(w)		(((((w)+7)>>3)+7) & ~0x7)
+#endif
+
+#endif				/* DIXFONTSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/renderedge.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/renderedge.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright © 2004 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _RENDEREDGE_H_
+#define _RENDEREDGE_H_
+
+#include "picturestr.h"
+
+#define MAX_ALPHA(n)	((1 << (n)) - 1)
+#define N_Y_FRAC(n)	((n) == 1 ? 1 : (1 << ((n)/2)) - 1)
+#define N_X_FRAC(n)	((1 << ((n)/2)) + 1)
+
+#define STEP_Y_SMALL(n)	(xFixed1 / N_Y_FRAC(n))
+#define STEP_Y_BIG(n)	(xFixed1 - (N_Y_FRAC(n) - 1) * STEP_Y_SMALL(n))
+
+#define Y_FRAC_FIRST(n)	(STEP_Y_SMALL(n) / 2)
+#define Y_FRAC_LAST(n)	(Y_FRAC_FIRST(n) + (N_Y_FRAC(n) - 1) * STEP_Y_SMALL(n))
+
+#define STEP_X_SMALL(n)	(xFixed1 / N_X_FRAC(n))
+#define STEP_X_BIG(n)	(xFixed1 - (N_X_FRAC(n) - 1) * STEP_X_SMALL(n))
+
+#define X_FRAC_FIRST(n)	(STEP_X_SMALL(n) / 2)
+#define X_FRAC_LAST(n)	(X_FRAC_FIRST(n) + (N_X_FRAC(n) - 1) * STEP_X_SMALL(n))
+
+#define RenderSamplesX(x,n)	((n) == 1 ? 0 : (xFixedFrac (x) + X_FRAC_FIRST(n)) / STEP_X_SMALL(n))
+
+/*
+ * An edge structure.  This represents a single polygon edge
+ * and can be quickly stepped across small or large gaps in the
+ * sample grid
+ */
+typedef pixman_edge_t RenderEdge;
+
+/*
+ * Step across a small sample grid gap
+ */
+#define RenderEdgeStepSmall(edge) { \
+    edge->x += edge->stepx_small;   \
+    edge->e += edge->dx_small;	    \
+    if (edge->e > 0)		    \
+    {				    \
+	edge->e -= edge->dy;	    \
+	edge->x += edge->signdx;    \
+    }				    \
+}
+
+/*
+ * Step across a large sample grid gap
+ */
+#define RenderEdgeStepBig(edge) {   \
+    edge->x += edge->stepx_big;	    \
+    edge->e += edge->dx_big;	    \
+    if (edge->e > 0)		    \
+    {				    \
+	edge->e -= edge->dy;	    \
+	edge->x += edge->signdx;    \
+    }				    \
+}
+
+extern _X_EXPORT xFixed
+RenderSampleCeilY (xFixed y, int bpp);
+
+extern _X_EXPORT xFixed
+RenderSampleFloorY (xFixed y, int bpp);
+
+extern _X_EXPORT void
+RenderEdgeStep (RenderEdge *e, int n);
+
+extern _X_EXPORT void
+RenderEdgeInit (RenderEdge	*e,
+		int		bpp,
+		xFixed		y_start,
+		xFixed		x_top,
+		xFixed		y_top,
+		xFixed		x_bot,
+		xFixed		y_bot);
+
+extern _X_EXPORT void
+RenderLineFixedEdgeInit (RenderEdge *e,
+			 int	    bpp,
+			 xFixed	    y,
+			 xLineFixed *line,
+			 int	    x_off,
+			 int	    y_off);
+
+#endif /* _RENDEREDGE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/allowev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/allowev.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef ALLOWEV_H
+#define ALLOWEV_H 1
+
+int SProcXAllowDeviceEvents(ClientPtr	/* client */
+    );
+
+int ProcXAllowDeviceEvents(ClientPtr	/* client */
+    );
+
+#endif /* ALLOWEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cw.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cw.h
@@ -0,0 +1,171 @@
+/*
+ * Copyright © 2004 Eric Anholt
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Eric Anholt not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Eric Anholt makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * ERIC ANHOLT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL ERIC ANHOLT BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "gcstruct.h"
+#include "picturestr.h"
+#include "privates.h"
+
+/*
+ * One of these structures is allocated per GC that gets used with a window with
+ * backing pixmap.
+ */
+
+typedef struct {
+    GCPtr	    pBackingGC;	    /* Copy of the GC but with graphicsExposures
+				     * set FALSE and the clientClip set to
+				     * clip output to the valid regions of the
+				     * backing pixmap. */
+    unsigned long   serialNumber;   /* clientClip computed time */
+    unsigned long   stateChanges;   /* changes in parent gc since last copy */
+    GCOps	    *wrapOps;	    /* wrapped ops */
+    GCFuncs	    *wrapFuncs;	    /* wrapped funcs */
+} cwGCRec, *cwGCPtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwGCKeyRec;
+#define cwGCKey (&cwGCKeyRec)
+
+#define getCwGC(pGC) ((cwGCPtr)dixLookupPrivate(&(pGC)->devPrivates, cwGCKey))
+#define setCwGC(pGC,p) dixSetPrivate(&(pGC)->devPrivates, cwGCKey, p)
+
+/*
+ * One of these structures is allocated per Picture that gets used with a
+ * window with a backing pixmap
+ */
+
+typedef struct {
+    PicturePtr	    pBackingPicture;
+    unsigned long   serialNumber;
+    unsigned long   stateChanges;
+} cwPictureRec, *cwPicturePtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwPictureKeyRec;
+#define cwPictureKey (&cwPictureKeyRec)
+
+#define getCwPicture(pPicture) (pPicture->pDrawable ? \
+    (cwPicturePtr)dixLookupPrivate(&(pPicture)->devPrivates, cwPictureKey) : 0)
+#define setCwPicture(pPicture,p) dixSetPrivate(&(pPicture)->devPrivates, cwPictureKey, p)
+
+extern _X_EXPORT DevPrivateKeyRec cwWindowKeyRec;
+#define cwWindowKey (&cwWindowKeyRec)
+
+#define cwWindowPrivate(pWin) dixLookupPrivate(&(pWin)->devPrivates, cwWindowKey)
+#define getCwPixmap(pWindow)	    ((PixmapPtr) cwWindowPrivate(pWindow))
+#define setCwPixmap(pWindow,pPixmap) \
+    dixSetPrivate(&(pWindow)->devPrivates, cwWindowKey, pPixmap)
+
+#define cwDrawableIsRedirWindow(pDraw)					\
+	((pDraw)->type == DRAWABLE_WINDOW &&				\
+	 getCwPixmap((WindowPtr) (pDraw)) != NULL)
+
+typedef struct {
+    /*
+     * screen func wrappers
+     */
+    CloseScreenProcPtr		CloseScreen;
+    GetImageProcPtr		GetImage;
+    GetSpansProcPtr		GetSpans;
+    CreateGCProcPtr		CreateGC;
+
+    CopyWindowProcPtr		CopyWindow;
+
+    GetWindowPixmapProcPtr	GetWindowPixmap;
+    SetWindowPixmapProcPtr	SetWindowPixmap;
+    
+    DestroyPictureProcPtr	DestroyPicture;
+    ChangePictureClipProcPtr	ChangePictureClip;
+    DestroyPictureClipProcPtr	DestroyPictureClip;
+    
+    ChangePictureProcPtr	ChangePicture;
+    ValidatePictureProcPtr	ValidatePicture;
+
+    CompositeProcPtr		Composite;
+    CompositeRectsProcPtr	CompositeRects;
+
+    TrapezoidsProcPtr		Trapezoids;
+    TrianglesProcPtr		Triangles;
+    TriStripProcPtr		TriStrip;
+    TriFanProcPtr		TriFan;
+
+    RasterizeTrapezoidProcPtr	RasterizeTrapezoid;
+} cwScreenRec, *cwScreenPtr;
+
+extern _X_EXPORT DevPrivateKeyRec cwScreenKeyRec;
+#define cwScreenKey (&cwScreenKeyRec)
+
+#define getCwScreen(pScreen) ((cwScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, cwScreenKey))
+#define setCwScreen(pScreen,p) dixSetPrivate(&(pScreen)->devPrivates, cwScreenKey, p)
+
+#define CW_OFFSET_XYPOINTS(ppt, npt) do { \
+    DDXPointPtr _ppt = (DDXPointPtr)(ppt); \
+    int _i; \
+    for (_i = 0; _i < npt; _i++) { \
+	_ppt[_i].x += dst_off_x; \
+	_ppt[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_RECTS(prect, nrect) do { \
+    int _i; \
+    for (_i = 0; _i < nrect; _i++) { \
+	(prect)[_i].x += dst_off_x; \
+	(prect)[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_ARCS(parc, narc) do { \
+    int _i; \
+    for (_i = 0; _i < narc; _i++) { \
+	(parc)[_i].x += dst_off_x; \
+	(parc)[_i].y += dst_off_y; \
+    } \
+} while (0)
+
+#define CW_OFFSET_XY_DST(x, y) do { \
+    (x) = (x) + dst_off_x; \
+    (y) = (y) + dst_off_y; \
+} while (0)
+
+#define CW_OFFSET_XY_SRC(x, y) do { \
+    (x) = (x) + src_off_x; \
+    (y) = (y) + src_off_y; \
+} while (0)
+
+/* cw.c */
+extern _X_EXPORT DrawablePtr
+cwGetBackingDrawable(DrawablePtr pDrawable, int *x_off, int *y_off);
+
+/* cw_render.c */
+
+extern _X_EXPORT void
+cwInitializeRender (ScreenPtr pScreen);
+
+extern _X_EXPORT void
+cwFiniRender (ScreenPtr pScreen);
+
+/* cw.c */
+
+extern _X_EXPORT void
+miInitializeCompositeWrapper(ScreenPtr pScreen);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glyphstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glyphstr.h
@@ -0,0 +1,151 @@
+/*
+ *
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _GLYPHSTR_H_
+#define _GLYPHSTR_H_
+
+#include <X11/extensions/renderproto.h>
+#include "picture.h"
+#include "screenint.h"
+#include "regionstr.h"
+#include "miscstruct.h"
+#include "privates.h"
+
+#define GlyphFormat1	0
+#define GlyphFormat4	1
+#define GlyphFormat8	2
+#define GlyphFormat16	3
+#define GlyphFormat32	4
+#define GlyphFormatNum	5
+
+typedef struct _Glyph {
+    CARD32	    refcnt;
+    PrivateRec	*devPrivates;
+    unsigned char   sha1[20];
+    CARD32	    size; /* info + bitmap */
+    xGlyphInfo	    info;
+    /* per-screen pixmaps follow */
+} GlyphRec, *GlyphPtr;
+
+#define GlyphPicture(glyph) ((PicturePtr *) ((glyph) + 1))
+
+typedef struct _GlyphRef {
+    CARD32	signature;
+    GlyphPtr	glyph;
+} GlyphRefRec, *GlyphRefPtr;
+
+#define DeletedGlyph	((GlyphPtr) 1)
+
+typedef struct _GlyphHashSet {
+    CARD32	entries;
+    CARD32	size;
+    CARD32	rehash;
+} GlyphHashSetRec, *GlyphHashSetPtr;
+
+typedef struct _GlyphHash {
+    GlyphRefPtr	    table;
+    GlyphHashSetPtr hashSet;
+    CARD32	    tableEntries;
+} GlyphHashRec, *GlyphHashPtr;
+
+typedef struct _GlyphSet {
+    CARD32	    refcnt;
+    PictFormatPtr   format;
+    int		    fdepth;
+    GlyphHashRec    hash;
+    int             maxPrivate;
+    PrivateRec      *devPrivates;
+} GlyphSetRec, *GlyphSetPtr;
+
+#define GlyphSetGetPrivate(pGlyphSet,k)					\
+    dixLookupPrivate(&(pGlyphSet)->devPrivates, k)
+
+#define GlyphSetSetPrivate(pGlyphSet,k,ptr)				\
+    dixSetPrivate(&(pGlyphSet)->devPrivates, k, ptr)
+
+typedef struct _GlyphList {
+    INT16	    xOff;
+    INT16	    yOff;
+    CARD8	    len;
+    PictFormatPtr   format;
+} GlyphListRec, *GlyphListPtr;
+
+extern _X_EXPORT GlyphHashSetPtr
+FindGlyphHashSet (CARD32 filled);
+
+extern _X_EXPORT void
+GlyphUninit (ScreenPtr pScreen);
+
+extern _X_EXPORT GlyphHashSetPtr
+FindGlyphHashSet (CARD32 filled);
+
+extern _X_EXPORT GlyphRefPtr
+FindGlyphRef (GlyphHashPtr	hash,
+	      CARD32		signature,
+	      Bool		match,
+	      unsigned char	sha1[20]);
+
+extern _X_EXPORT GlyphPtr
+FindGlyphByHash (unsigned char sha1[20], int format);
+
+extern _X_EXPORT int
+HashGlyph (xGlyphInfo    *gi,
+	   CARD8	 *bits,
+	   unsigned long size,
+	   unsigned char sha1[20]);
+
+extern _X_EXPORT void
+FreeGlyph (GlyphPtr glyph, int format);
+
+extern _X_EXPORT void
+AddGlyph (GlyphSetPtr glyphSet, GlyphPtr glyph, Glyph id);
+
+extern _X_EXPORT Bool
+DeleteGlyph (GlyphSetPtr glyphSet, Glyph id);
+
+extern _X_EXPORT GlyphPtr
+FindGlyph (GlyphSetPtr glyphSet, Glyph id);
+
+extern _X_EXPORT GlyphPtr
+AllocateGlyph (xGlyphInfo *gi, int format);
+
+extern _X_EXPORT Bool
+AllocateGlyphHash (GlyphHashPtr hash, GlyphHashSetPtr hashSet);
+
+extern _X_EXPORT Bool
+ResizeGlyphHash (GlyphHashPtr hash, CARD32 change, Bool global);
+
+extern _X_EXPORT Bool
+ResizeGlyphSet (GlyphSetPtr glyphSet, CARD32 change);
+
+extern _X_EXPORT GlyphSetPtr
+AllocateGlyphSet (int fdepth, PictFormatPtr format);
+
+extern _X_EXPORT int
+FreeGlyphSet (pointer   value,
+	      XID       gid);
+
+
+
+#endif /* _GLYPHSTR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getfocus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getfocus.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETFOCUS_H
+#define GETFOCUS_H 1
+
+int SProcXGetDeviceFocus(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceFocus(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceFocus(ClientPtr /* client */ ,
+			 int /* size */ ,
+			 xGetDeviceFocusReply *	/* rep */
+    );
+
+#endif /* GETFOCUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/unpack.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/unpack.h
@@ -0,0 +1,230 @@
+#ifndef __GLX_unpack_h__
+#define __GLX_unpack_h__
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#define __GLX_PAD(s) (((s)+3) & (GLuint)~3)
+
+/*
+** Fetch the context-id out of a SingleReq request pointed to by pc.
+*/
+#define __GLX_GET_SINGLE_CONTEXT_TAG(pc) (((xGLXSingleReq*)pc)->contextTag)
+#define __GLX_GET_VENDPRIV_CONTEXT_TAG(pc) (((xGLXVendorPrivateReq*)pc)->contextTag)
+
+/*
+** Fetch a double from potentially unaligned memory.
+*/
+#ifdef __GLX_ALIGN64
+#define __GLX_MEM_COPY(dst,src,n)	memcpy(dst,src,n)
+#define __GLX_GET_DOUBLE(dst,src)	__GLX_MEM_COPY(&dst,src,8)
+#else
+#define __GLX_GET_DOUBLE(dst,src)	(dst) = *((GLdouble*)(src))
+#endif
+
+extern void __glXMemInit(void);
+
+extern xGLXSingleReply __glXReply;
+
+#define __GLX_BEGIN_REPLY(size) \
+  	__glXReply.length = __GLX_PAD(size) >> 2;	\
+  	__glXReply.type = X_Reply; 			\
+  	__glXReply.sequenceNumber = client->sequence;
+
+#define __GLX_SEND_HEADER() \
+	WriteToClient( client, sz_xGLXSingleReply, (char *)&__glXReply);
+
+#define __GLX_PUT_RETVAL(a) \
+  	__glXReply.retval = (a);
+  
+#define __GLX_PUT_SIZE(a) \
+  	__glXReply.size = (a);
+
+#define __GLX_PUT_RENDERMODE(m) \
+        __glXReply.pad3 = (m)
+
+/*
+** Get a buffer to hold returned data, with the given alignment.  If we have
+** to realloc, allocate size+align, in case the pointer has to be bumped for
+** alignment.  The answerBuffer should already be aligned.
+**
+** NOTE: the cast (long)res below assumes a long is large enough to hold a
+** pointer.
+*/
+#define __GLX_GET_ANSWER_BUFFER(res,cl,size,align)			 \
+    if ((size) > sizeof(answerBuffer)) {				 \
+	int bump;							 \
+	if ((cl)->returnBufSize < (size)+(align)) {			 \
+	    (cl)->returnBuf = (GLbyte*)realloc((cl)->returnBuf,		 \
+						(size)+(align));         \
+	    if (!(cl)->returnBuf) {					 \
+		return BadAlloc;					 \
+	    }								 \
+	    (cl)->returnBufSize = (size)+(align);			 \
+	}								 \
+	res = (char*)cl->returnBuf;					 \
+	bump = (long)(res) % (align);					 \
+	if (bump) res += (align) - (bump);				 \
+    } else {								 \
+	res = (char *)answerBuffer;					 \
+    }
+
+#define __GLX_PUT_BYTE() \
+  	*(GLbyte *)&__glXReply.pad3 = *(GLbyte *)answer
+	  
+#define __GLX_PUT_SHORT() \
+  	*(GLshort *)&__glXReply.pad3 = *(GLshort *)answer
+	  
+#define __GLX_PUT_INT() \
+  	*(GLint *)&__glXReply.pad3 = *(GLint *)answer
+	  
+#define __GLX_PUT_FLOAT() \
+  	*(GLfloat *)&__glXReply.pad3 = *(GLfloat *)answer
+	  
+#define __GLX_PUT_DOUBLE() \
+  	*(GLdouble *)&__glXReply.pad3 = *(GLdouble *)answer
+	  
+#define __GLX_SEND_BYTE_ARRAY(len) \
+	WriteToClient(client, __GLX_PAD((len)*__GLX_SIZE_INT8), (char *)answer)
+
+#define __GLX_SEND_SHORT_ARRAY(len) \
+	WriteToClient(client, __GLX_PAD((len)*__GLX_SIZE_INT16), (char *)answer)
+  
+#define __GLX_SEND_INT_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_INT32, (char *)answer)
+  
+#define __GLX_SEND_FLOAT_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_FLOAT32, (char *)answer)
+  
+#define __GLX_SEND_DOUBLE_ARRAY(len) \
+	WriteToClient(client, (len)*__GLX_SIZE_FLOAT64, (char *)answer)
+
+
+#define __GLX_SEND_VOID_ARRAY(len)  __GLX_SEND_BYTE_ARRAY(len)
+#define __GLX_SEND_UBYTE_ARRAY(len)  __GLX_SEND_BYTE_ARRAY(len)
+#define __GLX_SEND_USHORT_ARRAY(len) __GLX_SEND_SHORT_ARRAY(len)
+#define __GLX_SEND_UINT_ARRAY(len)  __GLX_SEND_INT_ARRAY(len)
+
+/*
+** PERFORMANCE NOTE:
+** Machine dependent optimizations abound here; these swapping macros can
+** conceivably be replaced with routines that do the job faster.
+*/
+#define __GLX_DECLARE_SWAP_VARIABLES \
+	GLbyte sw
+
+#define __GLX_DECLARE_SWAP_ARRAY_VARIABLES \
+  	GLbyte *swapPC;		\
+  	GLbyte *swapEnd
+
+
+#define __GLX_SWAP_INT(pc) 			\
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[3]; 	\
+  	((GLbyte *)(pc))[3] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[2]; 	\
+  	((GLbyte *)(pc))[2] = sw;	
+
+#define __GLX_SWAP_SHORT(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[1]; 	\
+  	((GLbyte *)(pc))[1] = sw; 	
+
+#define __GLX_SWAP_DOUBLE(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[7]; 	\
+  	((GLbyte *)(pc))[7] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[6]; 	\
+  	((GLbyte *)(pc))[6] = sw;			\
+  	sw = ((GLbyte *)(pc))[2]; 		\
+  	((GLbyte *)(pc))[2] = ((GLbyte *)(pc))[5]; 	\
+  	((GLbyte *)(pc))[5] = sw;			\
+  	sw = ((GLbyte *)(pc))[3]; 		\
+  	((GLbyte *)(pc))[3] = ((GLbyte *)(pc))[4]; 	\
+  	((GLbyte *)(pc))[4] = sw;	
+
+#define __GLX_SWAP_FLOAT(pc) \
+  	sw = ((GLbyte *)(pc))[0]; 		\
+  	((GLbyte *)(pc))[0] = ((GLbyte *)(pc))[3]; 	\
+  	((GLbyte *)(pc))[3] = sw; 		\
+  	sw = ((GLbyte *)(pc))[1]; 		\
+  	((GLbyte *)(pc))[1] = ((GLbyte *)(pc))[2]; 	\
+  	((GLbyte *)(pc))[2] = sw;	
+
+#define __GLX_SWAP_INT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_INT32;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_INT(swapPC);		\
+	    swapPC += __GLX_SIZE_INT32;		\
+	}
+	
+#define __GLX_SWAP_SHORT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_INT16;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_SHORT(swapPC);		\
+	    swapPC += __GLX_SIZE_INT16;		\
+	}
+	
+#define __GLX_SWAP_DOUBLE_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_FLOAT64;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_DOUBLE(swapPC);		\
+	    swapPC += __GLX_SIZE_FLOAT64;	\
+	}
+    
+#define __GLX_SWAP_FLOAT_ARRAY(pc, count) \
+  	swapPC = ((GLbyte *)(pc));		\
+  	swapEnd = ((GLbyte *)(pc)) + (count)*__GLX_SIZE_FLOAT32;\
+  	while (swapPC < swapEnd) {		\
+	    __GLX_SWAP_FLOAT(swapPC);		\
+	    swapPC += __GLX_SIZE_FLOAT32;	\
+	}
+
+#define __GLX_SWAP_REPLY_HEADER() \
+  	__GLX_SWAP_SHORT(&__glXReply.sequenceNumber); \
+  	__GLX_SWAP_INT(&__glXReply.length);
+
+#define __GLX_SWAP_REPLY_RETVAL() \
+  	__GLX_SWAP_INT(&__glXReply.retval)
+
+#define __GLX_SWAP_REPLY_SIZE() \
+  	__GLX_SWAP_INT(&__glXReply.size)
+
+#endif /* !__GLX_unpack_h__ */
+
+
+
+
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/swaprep.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/swaprep.h
@@ -0,0 +1,292 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREP_H
+#define SWAPREP_H 1
+
+extern _X_EXPORT void Swap32Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    CARD32 * /* pbuf */);
+
+extern _X_EXPORT void CopySwap32Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    CARD32 * /* pbuf */);
+
+extern _X_EXPORT void CopySwap16Write(
+    ClientPtr /* pClient */,
+    int /* size */,
+    short * /* pbuf */);
+
+extern _X_EXPORT void SGenericReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGenericReply * /* pRep */);
+
+extern _X_EXPORT void SGetWindowAttributesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetWindowAttributesReply * /* pRep */);
+
+extern _X_EXPORT void SGetGeometryReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetGeometryReply * /* pRep */);
+
+extern _X_EXPORT void SQueryTreeReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryTreeReply * /* pRep */);
+
+extern _X_EXPORT void SInternAtomReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xInternAtomReply * /* pRep */);
+
+extern _X_EXPORT void SGetAtomNameReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetAtomNameReply * /* pRep */);
+
+extern _X_EXPORT void SGetPropertyReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPropertyReply * /* pRep */);
+
+extern _X_EXPORT void SListPropertiesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListPropertiesReply * /* pRep */);
+
+extern _X_EXPORT void SGetSelectionOwnerReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetSelectionOwnerReply * /* pRep */);
+
+extern _X_EXPORT void SQueryPointerReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryPointerReply * /* pRep */);
+
+extern _X_EXPORT void SwapTimeCoordWrite(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xTimecoord * /* pRep */);
+
+extern _X_EXPORT void SGetMotionEventsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetMotionEventsReply * /* pRep */);
+
+extern _X_EXPORT void STranslateCoordsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xTranslateCoordsReply * /* pRep */);
+
+extern _X_EXPORT void SGetInputFocusReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetInputFocusReply * /* pRep */);
+
+extern _X_EXPORT void SQueryKeymapReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryKeymapReply * /* pRep */);
+
+extern _X_EXPORT void SQueryFontReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryFontReply * /* pRep */);
+
+extern _X_EXPORT void SQueryTextExtentsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryTextExtentsReply * /* pRep */);
+
+extern _X_EXPORT void SListFontsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListFontsReply * /* pRep */);
+
+extern _X_EXPORT void SListFontsWithInfoReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListFontsWithInfoReply * /* pRep */);
+
+extern _X_EXPORT void SGetFontPathReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetFontPathReply * /* pRep */);
+
+extern _X_EXPORT void SGetImageReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetImageReply * /* pRep */);
+
+extern _X_EXPORT void SListInstalledColormapsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListInstalledColormapsReply * /* pRep */);
+
+extern _X_EXPORT void SAllocColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorReply * /* pRep */);
+
+extern _X_EXPORT void SAllocNamedColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocNamedColorReply * /* pRep */);
+
+extern _X_EXPORT void SAllocColorCellsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorCellsReply * /* pRep */);
+
+extern _X_EXPORT void SAllocColorPlanesReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xAllocColorPlanesReply * /* pRep */);
+
+extern _X_EXPORT void SQColorsExtend(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xrgb * /* prgb */);
+
+extern _X_EXPORT void SQueryColorsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryColorsReply * /* pRep */);
+
+extern _X_EXPORT void SLookupColorReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xLookupColorReply * /* pRep */);
+
+extern _X_EXPORT void SQueryBestSizeReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xQueryBestSizeReply * /* pRep */);
+
+extern _X_EXPORT void SListExtensionsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListExtensionsReply * /* pRep */);
+
+extern _X_EXPORT void SGetKeyboardMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetKeyboardMappingReply * /* pRep */);
+
+extern _X_EXPORT void SGetPointerMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPointerMappingReply * /* pRep */);
+
+extern _X_EXPORT void SGetModifierMappingReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetModifierMappingReply * /* pRep */);
+
+extern _X_EXPORT void SGetKeyboardControlReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetKeyboardControlReply * /* pRep */);
+
+extern _X_EXPORT void SGetPointerControlReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetPointerControlReply * /* pRep */);
+
+extern _X_EXPORT void SGetScreenSaverReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xGetScreenSaverReply * /* pRep */);
+
+extern _X_EXPORT void SLHostsExtend(
+    ClientPtr /* pClient */,
+    int /* size */,
+    char * /* buf */);
+
+extern _X_EXPORT void SListHostsReply(
+    ClientPtr /* pClient */,
+    int /* size */,
+    xListHostsReply * /* pRep */);
+
+extern _X_EXPORT void SErrorEvent(
+    xError * /* from */,
+    xError * /* to */);
+
+extern _X_EXPORT void SwapConnSetupInfo(
+    char * /* pInfo */,
+    char * /* pInfoTBase */);
+
+extern _X_EXPORT void WriteSConnectionInfo(
+    ClientPtr /* pClient */,
+    unsigned long /* size */,
+    char * /* pInfo */);
+
+extern _X_EXPORT void SwapConnSetupPrefix(
+    xConnSetupPrefix * /* pcspFrom */,
+    xConnSetupPrefix * /* pcspTo */);
+
+extern _X_EXPORT void WriteSConnSetupPrefix(
+    ClientPtr /* pClient */,
+    xConnSetupPrefix * /* pcsp */);
+
+#undef SWAPREP_PROC
+#define SWAPREP_PROC(func) extern _X_EXPORT void func(xEvent * /* from */, xEvent * /* to */)
+
+SWAPREP_PROC(SCirculateEvent);
+SWAPREP_PROC(SClientMessageEvent);
+SWAPREP_PROC(SColormapEvent);
+SWAPREP_PROC(SConfigureNotifyEvent);
+SWAPREP_PROC(SConfigureRequestEvent);
+SWAPREP_PROC(SCreateNotifyEvent);
+SWAPREP_PROC(SDestroyNotifyEvent);
+SWAPREP_PROC(SEnterLeaveEvent);
+SWAPREP_PROC(SExposeEvent);
+SWAPREP_PROC(SFocusEvent);
+SWAPREP_PROC(SGraphicsExposureEvent);
+SWAPREP_PROC(SGravityEvent);
+SWAPREP_PROC(SKeyButtonPtrEvent);
+SWAPREP_PROC(SKeymapNotifyEvent);
+SWAPREP_PROC(SMapNotifyEvent);
+SWAPREP_PROC(SMapRequestEvent);
+SWAPREP_PROC(SMappingEvent);
+SWAPREP_PROC(SNoExposureEvent);
+SWAPREP_PROC(SPropertyEvent);
+SWAPREP_PROC(SReparentEvent);
+SWAPREP_PROC(SResizeRequestEvent);
+SWAPREP_PROC(SSelectionClearEvent);
+SWAPREP_PROC(SSelectionNotifyEvent);
+SWAPREP_PROC(SSelectionRequestEvent);
+SWAPREP_PROC(SUnmapNotifyEvent);
+SWAPREP_PROC(SVisibilityEvent);
+
+#undef SWAPREP_PROC
+
+#endif /* SWAPREP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/eventconvert.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/eventconvert.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _EVENTCONVERT_H_
+#include <X11/X.h>
+#include <X11/extensions/XIproto.h>
+#include "input.h"
+#include "events.h"
+
+#define FP1616(integral, frac) ((integral) * (1 << 16) + (frac) * (1 << 16))
+
+_X_EXPORT int EventToCore(InternalEvent *event, xEvent *core);
+_X_EXPORT int EventToXI(InternalEvent *ev, xEvent **xi, int *count);
+_X_EXPORT int EventToXI2(InternalEvent *ev, xEvent **xi);
+_X_INTERNAL int GetCoreType(InternalEvent* ev);
+_X_INTERNAL int GetXIType(InternalEvent* ev);
+_X_INTERNAL int GetXI2Type(InternalEvent* ev);
+
+#endif /* _EVENTCONVERT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxarg.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxarg.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to argument handling functions.  \see dmxarg.c */
+
+#ifndef _DMXARG_H_
+#define _DMXARG_H_
+
+typedef struct _dmxArg *dmxArg;
+
+extern dmxArg     dmxArgCreate(void);
+extern void       dmxArgFree(dmxArg a);
+extern void       dmxArgAdd(dmxArg a, const char *string);
+extern const char *dmxArgV(dmxArg a, int item);
+extern int        dmxArgC(dmxArg a);
+extern dmxArg     dmxArgParse(const char *string);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/decode.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/decode.h
@@ -0,0 +1,88 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for instruction decoding logic.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_DECODE_H
+#define __X86EMU_DECODE_H
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+/* Instruction Decoding Stuff */
+
+#define FETCH_DECODE_MODRM(mod,rh,rl) 	fetch_decode_modrm(&mod,&rh,&rl)
+#define DECODE_RM_BYTE_REGISTER(r)    	decode_rm_byte_register(r)
+#define DECODE_RM_WORD_REGISTER(r)    	decode_rm_word_register(r)
+#define DECODE_RM_LONG_REGISTER(r)    	decode_rm_long_register(r)
+#define DECODE_CLEAR_SEGOVR()         	M.x86.mode &= ~SYSMODE_CLRMASK
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+void 	x86emu_intr_raise (u8 type);
+void    fetch_decode_modrm (int *mod,int *regh,int *regl);
+u8      fetch_byte_imm (void);
+u16     fetch_word_imm (void);
+u32     fetch_long_imm (void);
+u8      fetch_data_byte (uint offset);
+u8      fetch_data_byte_abs (uint segment, uint offset);
+u16     fetch_data_word (uint offset);
+u16     fetch_data_word_abs (uint segment, uint offset);
+u32     fetch_data_long (uint offset);
+u32     fetch_data_long_abs (uint segment, uint offset);
+void    store_data_byte (uint offset, u8 val);
+void    store_data_byte_abs (uint segment, uint offset, u8 val);
+void    store_data_word (uint offset, u16 val);
+void    store_data_word_abs (uint segment, uint offset, u16 val);
+void    store_data_long (uint offset, u32 val);
+void    store_data_long_abs (uint segment, uint offset, u32 val);
+u8* 	decode_rm_byte_register(int reg);
+u16* 	decode_rm_word_register(int reg);
+u32* 	decode_rm_long_register(int reg);
+u16* 	decode_rm_seg_register(int reg);
+u32	decode_rm00_address(int rm);
+u32	decode_rm01_address(int rm);
+u32	decode_rm10_address(int rm);
+u32	decode_sib_address(int sib, int mod);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_DECODE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxextension.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxextension.h
@@ -0,0 +1,118 @@
+/*
+ * Copyright 2003-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Author:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DMX extension support.  These routines are called by
+ * function in Xserver/Xext/dmx.c.  \see dmxextension.c */
+
+#ifndef _DMXEXTENSION_H_
+#define _DMXEXTENSION_H_
+
+/** Screen attributes.  Used by #ProcDMXGetScreenAttributes and
+ * \a ProcDMXChangeScreensAttributes. */
+typedef struct {
+    const char   *displayName;
+    int          logicalScreen;
+
+    unsigned int screenWindowWidth;    /* displayName's coordinate system */
+    unsigned int screenWindowHeight;   /* displayName's coordinate system */
+    int          screenWindowXoffset;  /* displayName's coordinate system */
+    int          screenWindowYoffset;  /* displayName's coordinate system */
+
+    unsigned int rootWindowWidth;      /* screenWindow's coordinate system */
+    unsigned int rootWindowHeight;     /* screenWindow's coordinate system */
+    int          rootWindowXoffset;    /* screenWindow's coordinate system */
+    int          rootWindowYoffset;    /* screenWindow's coordinate system */
+
+    int          rootWindowXorigin;    /* global coordinate system */
+    int          rootWindowYorigin;    /* global coordinate system */
+} DMXScreenAttributesRec, *DMXScreenAttributesPtr;
+
+/** Window attributes.  Used by #ProcDMXGetWindowAttributes. */
+typedef struct {
+    int          screen;
+    Window       window;
+    xRectangle   pos;
+    xRectangle   vis;
+} DMXWindowAttributesRec, *DMXWindowAttributesPtr;
+
+/** Desktop attributes.  Used by #ProcDMXGetDesktopAttributes and
+ * #ProcDMXChangeDesktopAttributes. */
+typedef struct {
+    int          width;
+    int          height;
+    int          shiftX;
+    int          shiftY;
+} DMXDesktopAttributesRec, *DMXDesktopAttributesPtr;
+
+/** Input attributes.  Used by #ProcDMXGetInputAttributes. */
+typedef struct {
+    const char   *name;
+    int          inputType;
+    int          physicalScreen;
+    int          physicalId;
+    int          isCore;
+    int          sendsCore;
+    int          detached;
+} DMXInputAttributesRec, *DMXInputAttributesPtr;
+
+
+extern unsigned long dmxGetNumScreens(void);
+extern void          dmxForceWindowCreation(WindowPtr pWindow);
+extern void          dmxFlushPendingSyncs(void);
+extern Bool          dmxGetScreenAttributes(int physical,
+                                            DMXScreenAttributesPtr attr);
+extern Bool          dmxGetWindowAttributes(WindowPtr pWindow,
+                                            DMXWindowAttributesPtr attr);
+extern void          dmxGetDesktopAttributes(DMXDesktopAttributesPtr attr);
+extern int           dmxGetInputCount(void);
+extern int           dmxGetInputAttributes(int deviceId,
+                                           DMXInputAttributesPtr attr);
+extern int           dmxAddInput(DMXInputAttributesPtr attr, int *deviceId);
+extern int           dmxRemoveInput(int deviceId);
+
+extern int           dmxConfigureScreenWindows(int nscreens,
+					       CARD32 *screens,
+					       DMXScreenAttributesPtr attribs,
+					       int *errorScreen);
+
+extern int           dmxConfigureDesktop(DMXDesktopAttributesPtr attribs);
+
+/* dmxUpdateScreenResources exposed for dmxCreateWindow in dmxwindow.c */
+extern void          dmxUpdateScreenResources(ScreenPtr pScreen,
+                                              int x, int y, int w, int h);
+
+extern int           dmxAttachScreen(int idx, DMXScreenAttributesPtr attr);
+extern int           dmxDetachScreen(int idx);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getdctl.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getdctl.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETDCTL_H
+#define GETDCTL_H 1
+
+int SProcXGetDeviceControl(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceControl(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceControl(ClientPtr /* client */ ,
+			   int /* size */ ,
+			   xGetDeviceControlReply *	/* rep */
+    );
+
+#endif /* GETDCTL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glthread.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glthread.h
@@ -0,0 +1,319 @@
+/*
+ * Mesa 3-D graphics library
+ * Version:  6.5.2
+ *
+ * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/*
+ * Thread support for gl dispatch.
+ *
+ * Initial version by John Stone (j.stone@acm.org) (johns@cs.umr.edu)
+ *                and Christoph Poliwoda (poliwoda@volumegraphics.com)
+ * Revised by Keith Whitwell
+ * Adapted for new gl dispatcher by Brian Paul
+ *
+ *
+ *
+ * DOCUMENTATION
+ *
+ * This thread module exports the following types:
+ *   _glthread_TSD     Thread-specific data area
+ *   _glthread_Thread  Thread datatype
+ *   _glthread_Mutex   Mutual exclusion lock
+ *
+ * Macros:
+ *   _glthread_DECLARE_STATIC_MUTEX(name)   Declare a non-local mutex
+ *   _glthread_INIT_MUTEX(name)             Initialize a mutex
+ *   _glthread_LOCK_MUTEX(name)             Lock a mutex
+ *   _glthread_UNLOCK_MUTEX(name)           Unlock a mutex
+ *
+ * Functions:
+ *   _glthread_GetID(v)      Get integer thread ID
+ *   _glthread_InitTSD()     Initialize thread-specific data
+ *   _glthread_GetTSD()      Get thread-specific data
+ *   _glthread_SetTSD()      Set thread-specific data
+ *
+ */
+
+/*
+ * If this file is accidentally included by a non-threaded build,
+ * it should not cause the build to fail, or otherwise cause problems.
+ * In general, it should only be included when needed however.
+ */
+
+#ifndef GLTHREAD_H
+#define GLTHREAD_H
+
+
+#if defined(USE_MGL_NAMESPACE)
+#define _glapi_Dispatch _mglapi_Dispatch
+#endif
+
+
+
+#if (defined(PTHREADS) || defined(SOLARIS_THREADS) ||\
+     defined(WIN32_THREADS) || defined(USE_XTHREADS) || defined(BEOS_THREADS)) \
+    && !defined(THREADS)
+# define THREADS
+#endif
+
+#ifdef VMS
+#include <GL/vms_x_fix.h>
+#endif
+
+/*
+ * POSIX threads. This should be your choice in the Unix world
+ * whenever possible.  When building with POSIX threads, be sure
+ * to enable any compiler flags which will cause the MT-safe
+ * libc (if one exists) to be used when linking, as well as any
+ * header macros for MT-safe errno, etc.  For Solaris, this is the -mt
+ * compiler flag.  On Solaris with gcc, use -D_REENTRANT to enable
+ * proper compiling for MT-safe libc etc.
+ */
+#if defined(PTHREADS)
+#include <pthread.h> /* POSIX threads headers */
+
+typedef struct {
+   pthread_key_t  key;
+   int initMagic;
+} _glthread_TSD;
+
+typedef pthread_t _glthread_Thread;
+
+typedef pthread_mutex_t _glthread_Mutex;
+
+#define _glthread_DECLARE_STATIC_MUTEX(name) \
+   static _glthread_Mutex name = PTHREAD_MUTEX_INITIALIZER
+
+#define _glthread_INIT_MUTEX(name) \
+   pthread_mutex_init(&(name), NULL)
+
+#define _glthread_DESTROY_MUTEX(name) \
+   pthread_mutex_destroy(&(name))
+
+#define _glthread_LOCK_MUTEX(name) \
+   (void) pthread_mutex_lock(&(name))
+
+#define _glthread_UNLOCK_MUTEX(name) \
+   (void) pthread_mutex_unlock(&(name))
+
+#endif /* PTHREADS */
+
+
+
+
+/*
+ * Solaris threads. Use only up to Solaris 2.4.
+ * Solaris 2.5 and higher provide POSIX threads.
+ * Be sure to compile with -mt on the Solaris compilers, or
+ * use -D_REENTRANT if using gcc.
+ */
+#ifdef SOLARIS_THREADS
+#include <thread.h>
+
+typedef struct {
+   thread_key_t key;
+   mutex_t      keylock;
+   int          initMagic;
+} _glthread_TSD;
+
+typedef thread_t _glthread_Thread;
+
+typedef mutex_t _glthread_Mutex;
+
+/* XXX need to really implement mutex-related macros */
+#define _glthread_DECLARE_STATIC_MUTEX(name)  static _glthread_Mutex name = 0
+#define _glthread_INIT_MUTEX(name)  (void) name
+#define _glthread_DESTROY_MUTEX(name) (void) name
+#define _glthread_LOCK_MUTEX(name)  (void) name
+#define _glthread_UNLOCK_MUTEX(name)  (void) name
+
+#endif /* SOLARIS_THREADS */
+
+
+
+
+/*
+ * Windows threads. Should work with Windows NT and 95.
+ * IMPORTANT: Link with multithreaded runtime library when THREADS are
+ * used!
+ */
+#ifdef WIN32_THREADS
+#include <windows.h>
+
+typedef struct {
+   DWORD key;
+   int   initMagic;
+} _glthread_TSD;
+
+typedef HANDLE _glthread_Thread;
+
+typedef CRITICAL_SECTION _glthread_Mutex;
+
+#define _glthread_DECLARE_STATIC_MUTEX(name)  /*static*/ _glthread_Mutex name = {0,0,0,0,0,0}
+#define _glthread_INIT_MUTEX(name)  InitializeCriticalSection(&name)
+#define _glthread_DESTROY_MUTEX(name)  DeleteCriticalSection(&name)
+#define _glthread_LOCK_MUTEX(name)  EnterCriticalSection(&name)
+#define _glthread_UNLOCK_MUTEX(name)  LeaveCriticalSection(&name)
+
+#endif /* WIN32_THREADS */
+
+
+
+
+/*
+ * XFree86 has its own thread wrapper, Xthreads.h
+ * We wrap it again for GL.
+ */
+#ifdef USE_XTHREADS
+#include <X11/Xthreads.h>
+
+typedef struct {
+   xthread_key_t key;
+   int initMagic;
+} _glthread_TSD;
+
+typedef xthread_t _glthread_Thread;
+
+typedef xmutex_rec _glthread_Mutex;
+
+#ifdef XMUTEX_INITIALIZER
+#define _glthread_DECLARE_STATIC_MUTEX(name) \
+   static _glthread_Mutex name = XMUTEX_INITIALIZER
+#else
+#define _glthread_DECLARE_STATIC_MUTEX(name) \
+   static _glthread_Mutex name
+#endif
+
+#define _glthread_INIT_MUTEX(name) \
+   xmutex_init(&(name))
+
+#define _glthread_DESTROY_MUTEX(name) \
+   xmutex_clear(&(name))
+
+#define _glthread_LOCK_MUTEX(name) \
+   (void) xmutex_lock(&(name))
+
+#define _glthread_UNLOCK_MUTEX(name) \
+   (void) xmutex_unlock(&(name))
+
+#endif /* USE_XTHREADS */
+
+
+
+/*
+ * BeOS threads. R5.x required.
+ */
+#ifdef BEOS_THREADS
+
+#include <kernel/OS.h>
+#include <support/TLS.h>
+
+typedef struct {
+   int32        key;
+   int          initMagic;
+} _glthread_TSD;
+
+typedef thread_id _glthread_Thread;
+
+/* Use Benaphore, aka speeder semaphore */
+typedef struct {
+    int32   lock;
+    sem_id  sem;
+} benaphore;
+typedef benaphore _glthread_Mutex;
+
+#define _glthread_DECLARE_STATIC_MUTEX(name)  static _glthread_Mutex name = { 0, 0 }
+#define _glthread_INIT_MUTEX(name)    	name.sem = create_sem(0, #name"_benaphore"), name.lock = 0
+#define _glthread_DESTROY_MUTEX(name) 	delete_sem(name.sem), name.lock = 0
+#define _glthread_LOCK_MUTEX(name)    	if (name.sem == 0) _glthread_INIT_MUTEX(name); \
+									  	if (atomic_add(&(name.lock), 1) >= 1) acquire_sem(name.sem)
+#define _glthread_UNLOCK_MUTEX(name)  	if (atomic_add(&(name.lock), -1) > 1) release_sem(name.sem)
+
+#endif /* BEOS_THREADS */
+
+
+
+#ifndef THREADS
+
+/*
+ * THREADS not defined
+ */
+
+typedef int _glthread_TSD;
+
+typedef int _glthread_Thread;
+
+typedef int _glthread_Mutex;
+
+#define _glthread_DECLARE_STATIC_MUTEX(name)  static _glthread_Mutex name = 0
+
+#define _glthread_INIT_MUTEX(name)  (void) name
+
+#define _glthread_DESTROY_MUTEX(name)  (void) name
+
+#define _glthread_LOCK_MUTEX(name)  (void) name
+
+#define _glthread_UNLOCK_MUTEX(name)  (void) name
+
+#endif /* THREADS */
+
+
+
+/*
+ * Platform independent thread specific data API.
+ */
+
+extern unsigned long
+_glthread_GetID(void);
+
+
+extern void
+_glthread_InitTSD(_glthread_TSD *);
+
+
+extern void *
+_glthread_GetTSD(_glthread_TSD *);
+
+
+extern void
+_glthread_SetTSD(_glthread_TSD *, void *);
+
+#if defined(GLX_USE_TLS)
+
+extern __thread struct _glapi_table * _glapi_tls_Dispatch
+    __attribute__((tls_model("initial-exec")));
+
+#define GET_DISPATCH() _glapi_tls_Dispatch
+
+#elif !defined(GL_CALL)
+# if defined(THREADS)
+#  define GET_DISPATCH() \
+   ((__builtin_expect( _glapi_Dispatch != NULL, 1 )) \
+       ? _glapi_Dispatch : _glapi_get_dispatch())
+# else
+#  define GET_DISPATCH() _glapi_Dispatch
+# endif /* defined(THREADS) */
+#endif  /* ndef GL_CALL */
+
+
+#endif /* THREADS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86.h
@@ -0,0 +1,357 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains declarations for public XFree86 functions and variables,
+ * and definitions of public macros.
+ *
+ * "public" means available to video drivers.
+ */
+
+#ifndef _XF86_H
+#define _XF86_H
+
+#if HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#elif HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "xf86str.h"
+#include "xf86Opt.h"
+#include <X11/Xfuncproto.h>
+#include <stdarg.h>
+#ifdef RANDR
+#include <X11/extensions/randr.h>
+#endif
+
+#include "propertyst.h"
+
+/* General parameters */
+extern _X_EXPORT int xf86DoConfigure;
+extern _X_EXPORT int xf86DoShowOptions;
+extern _X_EXPORT Bool xf86DoConfigurePass1;
+
+extern _X_EXPORT DevPrivateKeyRec xf86ScreenKeyRec;
+#define xf86ScreenKey (&xf86ScreenKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec xf86CreateRootWindowKeyRec;
+#define xf86CreateRootWindowKey (&xf86CreateRootWindowKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec xf86PixmapKeyRec;
+#define xf86PixmapKey (&xf86PixmapKeyRec)
+
+extern _X_EXPORT ScrnInfoPtr *xf86Screens;	/* List of pointers to ScrnInfoRecs */
+extern _X_EXPORT const unsigned char byte_reversed[256];
+extern _X_EXPORT Bool fbSlotClaimed;
+#if (defined(__sparc__) || defined(__sparc)) && !defined(__OpenBSD__)
+extern _X_EXPORT Bool sbusSlotClaimed;
+#endif
+extern _X_EXPORT confDRIRec xf86ConfigDRI;
+extern _X_EXPORT Bool xf86inSuspend;
+extern _X_EXPORT Bool xf86DRI2Enabled(void);
+
+extern _X_EXPORT Bool VTSwitchEnabled;	/* kbd driver */
+
+#define XF86SCRNINFO(p) ((ScrnInfoPtr)dixLookupPrivate(&(p)->devPrivates, \
+						       xf86ScreenKey))
+#define XF86FLIP_PIXELS() \
+	do { \
+	    if (xf86GetFlipPixels()) { \
+		pScreen->whitePixel = (pScreen->whitePixel) ? 0 : 1; \
+		pScreen->blackPixel = (pScreen->blackPixel) ? 0 : 1; \
+	   } \
+	while (0)
+
+#define BOOLTOSTRING(b) ((b) ? "TRUE" : "FALSE")
+
+#define PIX24TOBPP(p) (((p) == Pix24Use24) ? 24 : \
+			(((p) == Pix24Use32) ? 32 : 0))
+
+/* Function Prototypes */
+#ifndef _NO_XF86_PROTOTYPES
+
+/* PCI related */
+#include <pciaccess.h>
+extern _X_EXPORT Bool pciSlotClaimed;
+
+extern _X_EXPORT Bool xf86CheckPciSlot(const struct pci_device *);
+extern _X_EXPORT int xf86ClaimPciSlot(struct pci_device *, DriverPtr drvp,
+                                      int chipset, GDevPtr dev, Bool active);
+extern _X_EXPORT void xf86UnclaimPciSlot(struct pci_device *);
+extern _X_EXPORT Bool xf86ParsePciBusString(const char *busID, int *bus,
+                                            int *device, int *func);
+extern _X_EXPORT Bool xf86ComparePciBusString(const char *busID, int bus,
+                                              int device, int func);
+extern _X_EXPORT void xf86FormatPciBusNumber(int busnum, char *buffer);
+extern _X_EXPORT Bool xf86IsPrimaryPci(struct pci_device * pPci);
+extern _X_EXPORT Bool xf86CheckPciMemBase(struct pci_device * pPci,
+                                          memType base);
+extern _X_EXPORT struct pci_device * xf86GetPciInfoForEntity(int entityIndex);
+extern _X_EXPORT int xf86MatchPciInstances(const char *driverName,
+        int vendorID, SymTabPtr chipsets, PciChipsets *PCIchipsets,
+        GDevPtr *devList, int numDevs, DriverPtr drvp, int **foundEntities);
+extern _X_EXPORT ScrnInfoPtr xf86ConfigPciEntity(ScrnInfoPtr pScrn,
+        int scrnFlag, int entityIndex,PciChipsets *p_chip, void *dummy,
+        EntityProc init, EntityProc enter, EntityProc leave, pointer private);
+/* Obsolete! don't use */
+extern _X_EXPORT Bool xf86ConfigActivePciEntity(ScrnInfoPtr pScrn,
+        int entityIndex,PciChipsets *p_chip, void *dummy, EntityProc init,
+        EntityProc enter, EntityProc leave, pointer private);
+
+/* xf86Bus.c */
+
+extern _X_EXPORT int  xf86GetFbInfoForScreen(int scrnIndex);
+extern _X_EXPORT int xf86ClaimFbSlot(DriverPtr drvp, int chipset, GDevPtr dev, Bool active);
+extern _X_EXPORT int xf86ClaimNoSlot(DriverPtr drvp, int chipset, GDevPtr dev, Bool active);
+extern _X_EXPORT Bool xf86DriverHasEntities(DriverPtr drvp);
+extern _X_EXPORT void xf86AddEntityToScreen(ScrnInfoPtr pScrn, int entityIndex);
+extern _X_EXPORT void xf86SetEntityInstanceForScreen(ScrnInfoPtr pScrn, int entityIndex,
+				    int instance);
+extern _X_EXPORT int xf86GetNumEntityInstances(int entityIndex);
+extern _X_EXPORT GDevPtr xf86GetDevFromEntity(int entityIndex, int instance);
+extern _X_EXPORT void xf86RemoveEntityFromScreen(ScrnInfoPtr pScrn, int entityIndex);
+extern _X_EXPORT EntityInfoPtr xf86GetEntityInfo(int entityIndex);
+extern _X_EXPORT Bool xf86SetEntityFuncs(int entityIndex, EntityProc init,
+			EntityProc enter, EntityProc leave, pointer);
+extern _X_EXPORT Bool xf86IsEntityPrimary(int entityIndex);
+extern _X_EXPORT void xf86EnterServerState(xf86State state);
+extern _X_EXPORT ScrnInfoPtr xf86FindScreenForEntity(int entityIndex);
+
+extern _X_EXPORT int xf86GetLastScrnFlag(int entityIndex);
+extern _X_EXPORT void xf86SetLastScrnFlag(int entityIndex, int scrnIndex);
+extern _X_EXPORT Bool xf86IsEntityShared(int entityIndex);
+extern _X_EXPORT void xf86SetEntityShared(int entityIndex);
+extern _X_EXPORT Bool xf86IsEntitySharable(int entityIndex);
+extern _X_EXPORT void xf86SetEntitySharable(int entityIndex);
+extern _X_EXPORT Bool xf86IsPrimInitDone(int entityIndex);
+extern _X_EXPORT void xf86SetPrimInitDone(int entityIndex);
+extern _X_EXPORT void xf86ClearPrimInitDone(int entityIndex);
+extern _X_EXPORT int xf86AllocateEntityPrivateIndex(void);
+extern _X_EXPORT DevUnion *xf86GetEntityPrivate(int entityIndex, int privIndex);
+
+/* xf86Configure.c */
+extern _X_EXPORT GDevPtr xf86AddBusDeviceToConfigure(const char *driver, BusType bus,
+				    void *busData, int chipset);
+
+/* xf86Cursor.c */
+
+extern _X_EXPORT void xf86LockZoom(ScreenPtr pScreen, int lock);
+extern _X_EXPORT void xf86InitViewport(ScrnInfoPtr pScr);
+extern _X_EXPORT void xf86SetViewport(ScreenPtr pScreen, int x, int y);
+extern _X_EXPORT void xf86ZoomViewport(ScreenPtr pScreen, int zoom);
+extern _X_EXPORT Bool xf86SwitchMode(ScreenPtr pScreen, DisplayModePtr mode);
+extern _X_EXPORT void *xf86GetPointerScreenFuncs(void);
+extern _X_EXPORT void xf86InitOrigins(void);
+extern _X_EXPORT void xf86ReconfigureLayout(void);
+
+/* xf86cvt.c */
+extern _X_EXPORT DisplayModePtr xf86CVTMode(int HDisplay, int VDisplay, float VRefresh,
+                           Bool Reduced, Bool Interlaced);
+
+/* xf86DPMS.c */
+
+extern _X_EXPORT Bool xf86DPMSInit(ScreenPtr pScreen, DPMSSetProcPtr set, int flags);
+
+#ifdef DPMSExtension
+extern _X_EXPORT int DPMSSet(ClientPtr client, int level);
+extern _X_EXPORT Bool DPMSSupported(void);
+#endif
+
+
+/* xf86DGA.c */
+
+#ifdef XFreeXDGA
+extern _X_EXPORT Bool DGAInit(ScreenPtr pScreen, DGAFunctionPtr funcs, DGAModePtr modes,
+			int num);
+extern _X_EXPORT Bool DGAReInitModes(ScreenPtr pScreen, DGAModePtr modes, int num);
+extern _X_EXPORT xf86SetDGAModeProc xf86SetDGAMode;
+#endif
+
+/* xf86Events.c */
+
+extern _X_EXPORT void SetTimeSinceLastInputEvent(void);
+extern _X_EXPORT pointer xf86AddInputHandler(int fd, InputHandlerProc proc, pointer data);
+extern _X_EXPORT int xf86RemoveInputHandler(pointer handler);
+extern _X_EXPORT void xf86DisableInputHandler(pointer handler);
+extern _X_EXPORT void xf86EnableInputHandler(pointer handler);
+extern _X_EXPORT pointer xf86AddGeneralHandler(int fd, InputHandlerProc proc, pointer data);
+extern _X_EXPORT int xf86RemoveGeneralHandler(pointer handler);
+extern _X_EXPORT void xf86DisableGeneralHandler(pointer handler);
+extern _X_EXPORT void xf86EnableGeneralHandler(pointer handler);
+extern _X_EXPORT void xf86InterceptSignals(int *signo);
+extern _X_EXPORT void xf86InterceptSigIll(void (*sigillhandler)(void));
+extern _X_EXPORT Bool xf86EnableVTSwitch(Bool new);
+extern _X_EXPORT void xf86ProcessActionEvent(ActionEvent action, void *arg);
+extern _X_EXPORT void xf86PrintBacktrace(void);
+
+/* xf86Helper.c */
+
+extern _X_EXPORT void xf86AddDriver(DriverPtr driver, pointer module, int flags);
+extern _X_EXPORT void xf86DeleteDriver(int drvIndex);
+extern _X_EXPORT ScrnInfoPtr xf86AllocateScreen(DriverPtr drv, int flags);
+extern _X_EXPORT void xf86DeleteScreen(int scrnIndex, int flags);
+extern _X_EXPORT int xf86AllocateScrnInfoPrivateIndex(void);
+extern _X_EXPORT Bool xf86AddPixFormat(ScrnInfoPtr pScrn, int depth, int bpp, int pad);
+extern _X_EXPORT Bool xf86SetDepthBpp(ScrnInfoPtr scrp, int depth, int bpp, int fbbpp,
+		     int depth24flags);
+extern _X_EXPORT void xf86PrintDepthBpp(ScrnInfoPtr scrp);
+extern _X_EXPORT Bool xf86SetWeight(ScrnInfoPtr scrp, rgb weight, rgb mask);
+extern _X_EXPORT Bool xf86SetDefaultVisual(ScrnInfoPtr scrp, int visual);
+extern _X_EXPORT Bool xf86SetGamma(ScrnInfoPtr scrp, Gamma newGamma);
+extern _X_EXPORT void xf86SetDpi(ScrnInfoPtr pScrn, int x, int y);
+extern _X_EXPORT void xf86SetBlackWhitePixels(ScreenPtr pScreen);
+extern _X_EXPORT void xf86EnableDisableFBAccess(int scrnIndex, Bool enable);
+extern _X_EXPORT void xf86VDrvMsgVerb(int scrnIndex, MessageType type, int verb,
+		     const char *format, va_list args);
+extern _X_EXPORT void xf86DrvMsgVerb(int scrnIndex, MessageType type, int verb,
+		    const char *format, ...) _X_ATTRIBUTE_PRINTF(4,5);
+extern _X_EXPORT void xf86DrvMsg(int scrnIndex, MessageType type, const char *format, ...)
+		_X_ATTRIBUTE_PRINTF(3,4);
+extern _X_EXPORT void xf86MsgVerb(MessageType type, int verb, const char *format, ...)
+		_X_ATTRIBUTE_PRINTF(3,4);
+extern _X_EXPORT void xf86Msg(MessageType type, const char *format, ...) _X_ATTRIBUTE_PRINTF(2,3);
+extern _X_EXPORT void xf86ErrorFVerb(int verb, const char *format, ...) _X_ATTRIBUTE_PRINTF(2,3);
+extern _X_EXPORT void xf86ErrorF(const char *format, ...) _X_ATTRIBUTE_PRINTF(1,2);
+extern _X_EXPORT const char *xf86TokenToString(SymTabPtr table, int token);
+extern _X_EXPORT int xf86StringToToken(SymTabPtr table, const char *string);
+extern _X_EXPORT void xf86ShowClocks(ScrnInfoPtr scrp, MessageType from);
+extern _X_EXPORT void xf86PrintChipsets(const char *drvname, const char *drvmsg,
+		       SymTabPtr chips);
+extern _X_EXPORT int xf86MatchDevice(const char *drivername, GDevPtr **driversectlist);
+extern _X_EXPORT void xf86GetClocks(ScrnInfoPtr pScrn, int num,
+		   Bool (*ClockFunc)(ScrnInfoPtr, int),
+		   void (*ProtectRegs)(ScrnInfoPtr, Bool),
+		   void (*BlankScreen)(ScrnInfoPtr, Bool),
+		   IOADDRESS vertsyncreg, int maskval,
+		   int knownclkindex, int knownclkvalue);
+extern _X_EXPORT const char *xf86GetVisualName(int visual);
+extern _X_EXPORT int xf86GetVerbosity(void);
+extern _X_EXPORT Pix24Flags xf86GetPix24(void);
+extern _X_EXPORT int xf86GetDepth(void);
+extern _X_EXPORT rgb xf86GetWeight(void);
+extern _X_EXPORT Gamma xf86GetGamma(void);
+extern _X_EXPORT Bool xf86GetFlipPixels(void);
+extern _X_EXPORT const char *xf86GetServerName(void);
+extern _X_EXPORT Bool xf86ServerIsExiting(void);
+extern _X_EXPORT Bool xf86ServerIsResetting(void);
+extern _X_EXPORT Bool xf86ServerIsInitialising(void);
+extern _X_EXPORT Bool xf86ServerIsOnlyDetecting(void);
+extern _X_EXPORT Bool xf86CaughtSignal(void);
+extern _X_EXPORT Bool xf86GetVidModeAllowNonLocal(void);
+extern _X_EXPORT Bool xf86GetVidModeEnabled(void);
+extern _X_EXPORT Bool xf86GetModInDevAllowNonLocal(void);
+extern _X_EXPORT Bool xf86GetModInDevEnabled(void);
+extern _X_EXPORT Bool xf86GetAllowMouseOpenFail(void);
+extern _X_EXPORT Bool xf86IsPc98(void);
+extern _X_EXPORT void xf86DisableRandR(void);
+extern _X_EXPORT CARD32 xorgGetVersion(void);
+extern _X_EXPORT CARD32 xf86GetModuleVersion(pointer module);
+extern _X_EXPORT pointer xf86LoadDrvSubModule(DriverPtr drv, const char *name);
+extern _X_EXPORT pointer xf86LoadSubModule(ScrnInfoPtr pScrn, const char *name);
+extern _X_EXPORT pointer xf86LoadOneModule(char *name, pointer optlist);
+extern _X_EXPORT void xf86UnloadSubModule(pointer mod);
+extern _X_EXPORT Bool xf86LoaderCheckSymbol(const char *name);
+extern _X_EXPORT void xf86SetBackingStore(ScreenPtr pScreen);
+extern _X_EXPORT void xf86SetSilkenMouse(ScreenPtr pScreen);
+extern _X_EXPORT pointer xf86FindXvOptions(int scrnIndex, int adapt_index, char *port_name,
+			  char **adaptor_name, pointer *adaptor_options);
+extern _X_EXPORT void xf86GetOS(const char **name, int *major, int *minor, int *teeny);
+extern _X_EXPORT ScrnInfoPtr xf86ConfigFbEntity(ScrnInfoPtr pScrn, int scrnFlag,
+			       int entityIndex, EntityProc init,
+			       EntityProc enter, EntityProc leave,
+			       pointer private);
+
+extern _X_EXPORT Bool xf86IsScreenPrimary(int scrnIndex);
+extern _X_EXPORT int  xf86RegisterRootWindowProperty(int ScrnIndex, Atom	property, Atom type,
+				    int format, unsigned long len,
+				    pointer value);
+extern _X_EXPORT Bool xf86IsUnblank(int mode);
+
+/* xf86Init.c */
+
+extern _X_EXPORT PixmapFormatPtr xf86GetPixFormat(ScrnInfoPtr pScrn, int depth);
+extern _X_EXPORT int xf86GetBppFromDepth(ScrnInfoPtr pScrn, int depth);
+
+/* xf86Mode.c */
+
+extern _X_EXPORT int xf86GetNearestClock(ScrnInfoPtr scrp, int freq, Bool allowDiv2,
+			int DivFactor, int MulFactor, int *divider);
+extern _X_EXPORT const char *xf86ModeStatusToString(ModeStatus status);
+extern _X_EXPORT ModeStatus xf86LookupMode(ScrnInfoPtr scrp, DisplayModePtr modep,
+			  ClockRangePtr clockRanges, LookupModeFlags strategy);
+extern _X_EXPORT ModeStatus xf86CheckModeForMonitor(DisplayModePtr mode, MonPtr monitor);
+extern _X_EXPORT ModeStatus xf86InitialCheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode,
+					 ClockRangePtr clockRanges,
+					 LookupModeFlags strategy,
+					 int maxPitch, int virtualX,
+					 int virtualY);
+extern _X_EXPORT ModeStatus xf86CheckModeForDriver(ScrnInfoPtr scrp, DisplayModePtr mode,
+				  int flags);
+extern _X_EXPORT int xf86ValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
+		      char **modeNames, ClockRangePtr clockRanges,
+		      int *linePitches, int minPitch, int maxPitch,
+		      int minHeight, int maxHeight, int pitchInc,
+		      int virtualX, int virtualY, int apertureSize,
+		      LookupModeFlags strategy);
+extern _X_EXPORT void xf86DeleteMode(DisplayModePtr *modeList, DisplayModePtr mode);
+extern _X_EXPORT void xf86PruneDriverModes(ScrnInfoPtr scrp);
+extern _X_EXPORT void xf86SetCrtcForModes(ScrnInfoPtr scrp, int adjustFlags);
+extern _X_EXPORT void xf86PrintModes(ScrnInfoPtr scrp);
+extern _X_EXPORT void xf86ShowClockRanges(ScrnInfoPtr scrp, ClockRangePtr clockRanges);
+extern _X_EXPORT double xf86ModeHSync(const DisplayModeRec *mode);
+extern _X_EXPORT double xf86ModeVRefresh(const DisplayModeRec *mode);
+extern _X_EXPORT void xf86SetModeDefaultName(DisplayModePtr mode);
+extern _X_EXPORT void xf86SetModeCrtc(DisplayModePtr p, int adjustFlags);
+extern _X_EXPORT DisplayModePtr xf86DuplicateMode(const DisplayModeRec *pMode);
+extern _X_EXPORT DisplayModePtr xf86DuplicateModes(ScrnInfoPtr pScrn, DisplayModePtr modeList);
+extern _X_EXPORT Bool xf86ModesEqual(const DisplayModeRec *pMode1,
+		    const DisplayModeRec *pMode2);
+extern _X_EXPORT void xf86PrintModeline(int scrnIndex,DisplayModePtr mode);
+extern _X_EXPORT DisplayModePtr xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new);
+
+/* xf86Option.c */
+
+extern _X_EXPORT void xf86CollectOptions(ScrnInfoPtr pScrn, pointer extraOpts);
+
+
+/* xf86RandR.c */
+#ifdef RANDR
+extern _X_EXPORT Bool xf86RandRInit (ScreenPtr    pScreen);
+extern _X_EXPORT Rotation xf86GetRotation(ScreenPtr pScreen);
+extern _X_EXPORT Bool xf86RandRSetNewVirtualAndDimensions(ScreenPtr pScreen,
+			int newvirtX, int newvirtY,
+			int newmmWidth, int newmmHeight, Bool resetMode);
+#endif
+
+/* xf86VidModeExtentionInit.c */
+
+extern _X_EXPORT Bool VidModeExtensionInit(ScreenPtr pScreen);
+
+#endif /* _NO_XF86_PROTOTYPES */
+
+#endif /* _XF86_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbgeom.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbgeom.h
@@ -0,0 +1,631 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBGEOM_H_
+#define	_XKBGEOM_H_
+
+#include "xkbstr.h"
+
+#define XkbAddGeomKeyAlias 		SrvXkbAddGeomKeyAlias
+#define XkbAddGeomColor 		SrvXkbAddGeomColor
+#define XkbAddGeomDoodad		SrvXkbAddGeomDoodad
+#define XkbAddGeomKey			SrvXkbAddGeomKey
+#define XkbAddGeomOutline		SrvXkbAddGeomOutline
+#define XkbAddGeomOverlay		SrvXkbAddGeomOverlay
+#define XkbAddGeomOverlayRow		SrvXkbAddGeomOverlayRow
+#define	XkbAddGeomOverlayKey		SrvXkbAddGeomOverlayKey
+#define XkbAddGeomProperty		SrvXkbAddGeomProperty
+#define XkbAddGeomRow			SrvXkbAddGeomRow
+#define XkbAddGeomSection		SrvXkbAddGeomSection
+#define XkbAddGeomShape			SrvXkbAddGeomShape
+#define XkbAllocGeomKeyAliases		SrvXkbAllocGeomKeyAliases
+#define XkbAllocGeomColors		SrvXkbAllocGeomColors
+#define XkbAllocGeomDoodads		SrvXkbAllocGeomDoodads
+#define XkbAllocGeomKeys		SrvXkbAllocGeomKeys
+#define XkbAllocGeomOutlines		SrvXkbAllocGeomOutlines
+#define XkbAllocGeomPoints		SrvXkbAllocGeomPoints
+#define XkbAllocGeomProps		SrvXkbAllocGeomProps
+#define XkbAllocGeomRows		SrvXkbAllocGeomRows
+#define XkbAllocGeomSectionDoodads	SrvXkbAllocGeomSectionDoodads
+#define XkbAllocGeomSections		SrvXkbAllocGeomSections
+#define	XkbAllocGeomOverlays		SrvXkbAllocGeomOverlays
+#define	XkbAllocGeomOverlayRows		SrvXkbAllocGeomOverlayRows
+#define	XkbAllocGeomOverlayKeys		SrvXkbAllocGeomOverlayKeys
+#define XkbAllocGeomShapes		SrvXkbAllocGeomShapes
+#define XkbAllocGeometry		SrvXkbAllocGeometry
+#define XkbFreeGeomKeyAliases		SrvXkbFreeGeomKeyAliases
+#define XkbFreeGeomColors		SrvXkbFreeGeomColors
+#define XkbFreeGeomDoodads		SrvXkbFreeGeomDoodads
+#define XkbFreeGeomProperties		SrvXkbFreeGeomProperties
+#define	XkbFreeGeomOverlayKeys		SrvXkbFreeGeomOverlayKeys
+#define	XkbFreeGeomOverlayRows		SrvXkbFreeGeomOverlayRows
+#define	XkbFreeGeomOverlays		SrvXkbFreeGeomOverlays
+#define	XkbFreeGeomKeys			SrvXkbFreeGeomKeys
+#define	XkbFreeGeomRows			SrvXkbFreeGeomRows
+#define XkbFreeGeomSections		SrvXkbFreeGeomSections
+#define	XkbFreeGeomPoints		SrvXkbFreeGeomPoints
+#define	XkbFreeGeomOutlines		SrvXkbFreeGeomOutlines
+#define XkbFreeGeomShapes		SrvXkbFreeGeomShapes
+#define XkbFreeGeometry			SrvXkbFreeGeometry
+
+typedef	struct _XkbProperty {
+	char	*name;
+	char	*value;
+} XkbPropertyRec,*XkbPropertyPtr;
+
+typedef struct _XkbColor {
+	unsigned int 	pixel;
+	char *		spec;
+} XkbColorRec,*XkbColorPtr;
+
+typedef	struct _XkbPoint {
+	short	x;
+	short	y;
+} XkbPointRec, *XkbPointPtr;
+
+typedef struct	_XkbBounds {
+	short	x1,y1;
+	short	x2,y2;
+} XkbBoundsRec, *XkbBoundsPtr;
+#define	XkbBoundsWidth(b)	(((b)->x2)-((b)->x1))
+#define	XkbBoundsHeight(b)	(((b)->y2)-((b)->y1))
+
+typedef struct _XkbOutline {
+	unsigned short	num_points;
+	unsigned short	sz_points;
+	unsigned short	corner_radius;
+	XkbPointPtr	points;
+} XkbOutlineRec, *XkbOutlinePtr;
+
+typedef struct _XkbShape {
+	Atom	 	 name;
+	unsigned short	 num_outlines;
+	unsigned short	 sz_outlines;
+	XkbOutlinePtr	 outlines;
+	XkbOutlinePtr	 approx;
+	XkbOutlinePtr	 primary;
+	XkbBoundsRec	 bounds;
+} XkbShapeRec, *XkbShapePtr;
+#define	XkbOutlineIndex(s,o)	((int)((o)-&(s)->outlines[0]))
+
+typedef struct _XkbShapeDoodad {
+	Atom		 name;
+	unsigned char	 type;
+	unsigned char	 priority;
+	short		 top;
+	short		 left;
+	short	 	 angle;
+	unsigned short	 color_ndx;
+	unsigned short	 shape_ndx;
+} XkbShapeDoodadRec, *XkbShapeDoodadPtr;
+#define	XkbShapeDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
+#define	XkbShapeDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
+#define	XkbSetShapeDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetShapeDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbTextDoodad {
+	Atom		 name;
+	unsigned char	 type;
+	unsigned char	 priority;
+	short	 	 top;
+	short	 	 left;
+	short	 	 angle;
+	short	 	 width;
+	short		 height;
+	unsigned short	 color_ndx;
+	char *		 text;
+	char *		 font;
+} XkbTextDoodadRec, *XkbTextDoodadPtr;
+#define	XkbTextDoodadColor(g,d)	(&(g)->colors[(d)->color_ndx])
+#define	XkbSetTextDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+
+typedef struct _XkbIndicatorDoodad {
+	Atom		 name;
+	unsigned char	 type;
+	unsigned char	 priority;
+	short	 	 top;
+	short	 	 left;
+	short		 angle;
+	unsigned short	 shape_ndx;
+	unsigned short	 on_color_ndx;
+	unsigned short	 off_color_ndx;
+} XkbIndicatorDoodadRec, *XkbIndicatorDoodadPtr;
+#define	XkbIndicatorDoodadShape(g,d)	(&(g)->shapes[(d)->shape_ndx])
+#define	XkbIndicatorDoodadOnColor(g,d)	(&(g)->colors[(d)->on_color_ndx])
+#define	XkbIndicatorDoodadOffColor(g,d)	(&(g)->colors[(d)->off_color_ndx])
+#define	XkbSetIndicatorDoodadOnColor(g,d,c) \
+				((d)->on_color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetIndicatorDoodadOffColor(g,d,c) \
+				((d)->off_color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetIndicatorDoodadShape(g,d,s) \
+				((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbLogoDoodad {
+	Atom		 name;
+	unsigned char	 type;
+	unsigned char	 priority;
+	short		 top;
+	short		 left;
+	short	 	 angle;
+	unsigned short	 color_ndx;
+	unsigned short	 shape_ndx;
+	char *		 logo_name;
+} XkbLogoDoodadRec, *XkbLogoDoodadPtr;
+#define	XkbLogoDoodadColor(g,d)		(&(g)->colors[(d)->color_ndx])
+#define	XkbLogoDoodadShape(g,d)		(&(g)->shapes[(d)->shape_ndx])
+#define	XkbSetLogoDoodadColor(g,d,c)	((d)->color_ndx= (c)-&(g)->colors[0])
+#define	XkbSetLogoDoodadShape(g,d,s)	((d)->shape_ndx= (s)-&(g)->shapes[0])
+
+typedef struct _XkbAnyDoodad {
+	Atom		 name;
+	unsigned char	 type;
+	unsigned char	 priority;
+	short	 	 top;
+	short	 	 left;
+	short		 angle;
+} XkbAnyDoodadRec, *XkbAnyDoodadPtr;
+
+typedef union _XkbDoodad {
+	XkbAnyDoodadRec		any;
+	XkbShapeDoodadRec	shape;
+	XkbTextDoodadRec	text;
+	XkbIndicatorDoodadRec	indicator;
+	XkbLogoDoodadRec	logo;
+} XkbDoodadRec, *XkbDoodadPtr;
+
+#define	XkbUnknownDoodad	0
+#define	XkbOutlineDoodad	1
+#define	XkbSolidDoodad		2
+#define	XkbTextDoodad		3
+#define	XkbIndicatorDoodad	4
+#define	XkbLogoDoodad		5
+
+typedef struct _XkbKey {
+	XkbKeyNameRec	 name;
+	short		 gap;
+	unsigned char	 shape_ndx;
+	unsigned char	 color_ndx;
+} XkbKeyRec, *XkbKeyPtr;
+#define	XkbKeyShape(g,k)	(&(g)->shapes[(k)->shape_ndx])
+#define	XkbKeyColor(g,k)	(&(g)->colors[(k)->color_ndx])
+#define	XkbSetKeyShape(g,k,s)	((k)->shape_ndx= (s)-&(g)->shapes[0])
+#define	XkbSetKeyColor(g,k,c)	((k)->color_ndx= (c)-&(g)->colors[0])
+
+typedef struct _XkbRow {
+	short	 	top;
+	short	 	left;
+	unsigned short	num_keys;
+	unsigned short	sz_keys;
+	int		vertical;
+	XkbKeyPtr	keys;
+	XkbBoundsRec	bounds;
+} XkbRowRec, *XkbRowPtr;
+
+typedef struct _XkbSection {
+	Atom		 name;
+	unsigned char	 priority;
+	short	 	 top;
+	short	 	 left;
+	unsigned short	 width;
+	unsigned short	 height;
+	short	 	 angle;
+	unsigned short	 num_rows;
+	unsigned short	 num_doodads;
+	unsigned short	 num_overlays;
+	unsigned short	 sz_rows;
+	unsigned short	 sz_doodads;
+	unsigned short	 sz_overlays;
+	XkbRowPtr	 rows;
+	XkbDoodadPtr	 doodads;
+	XkbBoundsRec	 bounds;
+	struct _XkbOverlay *overlays;
+} XkbSectionRec, *XkbSectionPtr;
+
+typedef	struct _XkbOverlayKey {
+	XkbKeyNameRec	over;
+	XkbKeyNameRec	under;
+} XkbOverlayKeyRec,*XkbOverlayKeyPtr;
+
+typedef struct _XkbOverlayRow {
+	unsigned short		row_under;
+	unsigned short		num_keys;
+	unsigned short		sz_keys;
+	XkbOverlayKeyPtr	keys;
+} XkbOverlayRowRec,*XkbOverlayRowPtr;
+
+typedef struct _XkbOverlay {
+	Atom			name;
+	XkbSectionPtr		section_under;
+	unsigned short		num_rows;
+	unsigned short		sz_rows;
+	XkbOverlayRowPtr	rows;
+	XkbBoundsPtr		bounds;
+} XkbOverlayRec,*XkbOverlayPtr;
+
+typedef struct _XkbGeometry {
+	Atom		 name;
+	unsigned short	 width_mm;
+	unsigned short	 height_mm;
+	char *		 label_font;
+	XkbColorPtr	 label_color;
+	XkbColorPtr	 base_color;
+	unsigned short	 sz_properties;
+	unsigned short	 sz_colors;
+	unsigned short	 sz_shapes;
+	unsigned short   sz_sections;
+	unsigned short	 sz_doodads;
+	unsigned short	 sz_key_aliases;
+	unsigned short	 num_properties;
+	unsigned short	 num_colors;
+	unsigned short	 num_shapes;
+	unsigned short	 num_sections;
+	unsigned short	 num_doodads;
+	unsigned short	 num_key_aliases;
+	XkbPropertyPtr	 properties;
+	XkbColorPtr	 colors;
+	XkbShapePtr	 shapes;
+	XkbSectionPtr	 sections;
+	XkbDoodadPtr	 doodads;
+	XkbKeyAliasPtr	 key_aliases;
+} XkbGeometryRec;
+#define	XkbGeomColorIndex(g,c)	((int)((c)-&(g)->colors[0]))
+
+#define	XkbGeomPropertiesMask	(1<<0)
+#define	XkbGeomColorsMask	(1<<1)
+#define	XkbGeomShapesMask	(1<<2)
+#define	XkbGeomSectionsMask	(1<<3)
+#define	XkbGeomDoodadsMask	(1<<4)
+#define	XkbGeomKeyAliasesMask	(1<<5)
+#define	XkbGeomAllMask		(0x3f)
+
+typedef struct _XkbGeometrySizes {
+	unsigned int	which;
+	unsigned short	num_properties;
+	unsigned short	num_colors;
+	unsigned short	num_shapes;
+	unsigned short	num_sections;
+	unsigned short	num_doodads;
+	unsigned short	num_key_aliases;
+} XkbGeometrySizesRec,*XkbGeometrySizesPtr;
+
+extern	XkbPropertyPtr
+XkbAddGeomProperty(
+    XkbGeometryPtr	/* geom */,
+    char *		/* name */,
+    char *		/* value */
+);
+
+extern	XkbKeyAliasPtr
+XkbAddGeomKeyAlias(
+    XkbGeometryPtr	/* geom */,
+    char *		/* alias */,
+    char *		/* real */
+);
+
+extern	XkbColorPtr
+XkbAddGeomColor(
+    XkbGeometryPtr	/* geom */,
+    char *		/* spec */,
+    unsigned int	/* pixel */
+);
+
+extern	XkbOutlinePtr
+XkbAddGeomOutline(
+    XkbShapePtr		/* shape */,
+    int			/* sz_points */
+);
+
+extern XkbShapePtr
+XkbAddGeomShape(
+    XkbGeometryPtr	/* geom */,
+    Atom		/* name */,
+    int			/* sz_outlines */
+);
+
+extern XkbKeyPtr
+XkbAddGeomKey(
+    XkbRowPtr		/* row */
+);
+
+extern XkbRowPtr
+XkbAddGeomRow(
+    XkbSectionPtr	/* section */,
+    int			/* sz_keys */
+);
+
+extern XkbSectionPtr
+XkbAddGeomSection(
+    XkbGeometryPtr	/* geom */,
+    Atom		/* name */,
+    int			/* sz_rows */,
+    int			/* sz_doodads */,
+    int			/* sz_overlays */
+);
+
+extern XkbOverlayPtr
+XkbAddGeomOverlay(
+    XkbSectionPtr	/* section */,
+    Atom		/* name */,
+    int			/* sz_rows */
+);
+
+extern XkbOverlayRowPtr
+XkbAddGeomOverlayRow(
+    XkbOverlayPtr	/* overlay */,
+    int			/* row_under */,
+    int			/* sz_keys */
+);
+
+extern XkbOverlayKeyPtr
+XkbAddGeomOverlayKey(
+    XkbOverlayPtr	/* overlay */,
+    XkbOverlayRowPtr	/* row */,
+    char *		/* over */,
+    char *		/* under */
+);
+
+extern XkbDoodadPtr
+XkbAddGeomDoodad(
+    XkbGeometryPtr	/* geom */,
+    XkbSectionPtr	/* section */,
+    Atom		/* name */
+);
+
+
+extern void
+XkbFreeGeomKeyAliases(
+    XkbGeometryPtr	/* geom */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomColors(
+    XkbGeometryPtr	/* geom */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomDoodads(
+    XkbDoodadPtr	/* doodads */,
+    int			/* nDoodads */,
+    Bool		/* freeAll */
+);
+
+
+extern void
+XkbFreeGeomProperties(
+    XkbGeometryPtr	/* geom */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomOverlayKeys(
+    XkbOverlayRowPtr	/* row */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomOverlayRows(
+    XkbOverlayPtr	/* overlay */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomOverlays(
+    XkbSectionPtr	/* section */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomKeys(
+    XkbRowPtr		/* row */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomRows(
+    XkbSectionPtr	/* section */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomSections(
+    XkbGeometryPtr	/* geom */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+
+extern void
+XkbFreeGeomPoints(
+    XkbOutlinePtr	/* outline */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomOutlines(
+    XkbShapePtr		/* shape */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeomShapes(
+    XkbGeometryPtr	/* geom */,
+    int			/* first */,
+    int			/* count */,
+    Bool		/* freeAll */
+);
+
+extern void
+XkbFreeGeometry(
+    XkbGeometryPtr	/* geom */,
+    unsigned int	/* which */,
+    Bool		/* freeMap */
+);
+
+extern Status
+XkbAllocGeomProps(
+    XkbGeometryPtr	/* geom */,
+    int			/* nProps */
+);
+
+extern Status
+XkbAllocGeomKeyAliases(
+    XkbGeometryPtr	/* geom */,
+    int			/* nAliases */
+);
+
+extern Status
+XkbAllocGeomColors(
+    XkbGeometryPtr	/* geom */,
+    int			/* nColors */
+);
+
+extern Status
+XkbAllocGeomShapes(
+    XkbGeometryPtr	/* geom */,
+    int			/* nShapes */
+);
+
+extern Status
+XkbAllocGeomSections(
+    XkbGeometryPtr	/* geom */,
+    int			/* nSections */
+);
+
+extern Status
+XkbAllocGeomOverlays(
+    XkbSectionPtr	/* section */,
+    int			/* num_needed */
+);
+
+extern Status
+XkbAllocGeomOverlayRows(
+    XkbOverlayPtr	/* overlay */,
+    int			/* num_needed */
+);
+
+extern Status
+XkbAllocGeomOverlayKeys(
+    XkbOverlayRowPtr	/* row */,
+    int			/* num_needed */
+);
+
+extern Status
+XkbAllocGeomDoodads(
+    XkbGeometryPtr	/* geom */,
+    int			/* nDoodads */
+);
+
+extern Status
+XkbAllocGeomSectionDoodads(
+    XkbSectionPtr	/* section */,
+    int			/* nDoodads */
+);
+
+extern Status
+XkbAllocGeomOutlines(
+    XkbShapePtr		/* shape */,
+    int			/* nOL */
+);
+
+extern Status
+XkbAllocGeomRows(
+    XkbSectionPtr	/* section */,
+    int			/* nRows */
+);
+
+extern Status
+XkbAllocGeomPoints(
+    XkbOutlinePtr	/* ol */,
+    int			/* nPts */
+);
+
+extern Status
+XkbAllocGeomKeys(
+    XkbRowPtr		/* row */,
+    int			/* nKeys */
+);
+
+extern	Status
+XkbAllocGeometry(
+	XkbDescPtr		/* xkb */,
+	XkbGeometrySizesPtr	/* sizes */
+);
+
+extern	Bool
+XkbComputeShapeTop(
+	XkbShapePtr		/* shape */,
+	XkbBoundsPtr		/* bounds */
+);
+
+extern	Bool
+XkbComputeShapeBounds(
+	XkbShapePtr		/* shape */
+);
+
+extern	Bool
+XkbComputeRowBounds(
+	XkbGeometryPtr		/* geom */,
+	XkbSectionPtr		/* section */,
+	XkbRowPtr		/* row */
+);
+
+extern	Bool
+XkbComputeSectionBounds(
+	XkbGeometryPtr		/* geom */,
+	XkbSectionPtr		/* section */
+);
+
+extern	char *
+XkbFindOverlayForKey(
+	XkbGeometryPtr		/* geom */,
+	XkbSectionPtr		/* wanted */,
+	char *			/* under */
+);
+
+#endif /* _XKBGEOM_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ChkNotMaskEv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ChkNotMaskEv.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for #XCheckNotMaskEvent function.  \see ChkNotMaskEv.c */
+
+#ifndef _CHKNOTMASKEV_H_
+#define _CHKNOTMASKEV_H_
+extern Bool XCheckNotMaskEvent (Display *dpy, long mask, XEvent *event);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gcstruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gcstruct.h
@@ -0,0 +1,326 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+
+
+#ifndef GCSTRUCT_H
+#define GCSTRUCT_H
+
+#include "gc.h"
+
+#include "regionstr.h"
+#include "region.h"
+#include "pixmap.h"
+#include "screenint.h"
+#include "privates.h"
+#include <X11/Xprotostr.h>
+
+#define GCAllBits ((1 << (GCLastBit + 1)) - 1)
+
+/*
+ * functions which modify the state of the GC
+ */
+
+typedef struct _GCFuncs {
+    void	(* ValidateGC)(
+		GCPtr /*pGC*/,
+		unsigned long /*stateChanges*/,
+		DrawablePtr /*pDrawable*/);
+
+    void	(* ChangeGC)(
+		GCPtr /*pGC*/,
+		unsigned long /*mask*/);
+
+    void	(* CopyGC)(
+		GCPtr /*pGCSrc*/,
+		unsigned long /*mask*/,
+		GCPtr /*pGCDst*/);
+
+    void	(* DestroyGC)(
+		GCPtr /*pGC*/);
+
+    void	(* ChangeClip)(
+		GCPtr /*pGC*/,
+		int /*type*/,
+		pointer /*pvalue*/,
+		int /*nrects*/);
+
+    void	(* DestroyClip)(
+		GCPtr /*pGC*/);
+
+    void	(* CopyClip)(
+		GCPtr /*pgcDst*/,
+		GCPtr /*pgcSrc*/);
+    DevUnion	devPrivate;
+} GCFuncs;
+
+/*
+ * graphics operations invoked through a GC
+ */
+
+typedef struct _GCOps {
+    void	(* FillSpans)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nInit*/,
+		DDXPointPtr /*pptInit*/,
+		int * /*pwidthInit*/,
+		int /*fSorted*/);
+
+    void	(* SetSpans)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		char * /*psrc*/,
+		DDXPointPtr /*ppt*/,
+		int * /*pwidth*/,
+		int /*nspans*/,
+		int /*fSorted*/);
+
+    void	(* PutImage)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*depth*/,
+		int /*x*/,
+		int /*y*/,
+		int /*w*/,
+		int /*h*/,
+		int /*leftPad*/,
+		int /*format*/,
+		char * /*pBits*/);
+
+    RegionPtr	(* CopyArea)(
+		DrawablePtr /*pSrc*/,
+		DrawablePtr /*pDst*/,
+		GCPtr /*pGC*/,
+		int /*srcx*/,
+		int /*srcy*/,
+		int /*w*/,
+		int /*h*/,
+		int /*dstx*/,
+		int /*dsty*/);
+
+    RegionPtr	(* CopyPlane)(
+		DrawablePtr /*pSrcDrawable*/,
+		DrawablePtr /*pDstDrawable*/,
+		GCPtr /*pGC*/,
+		int /*srcx*/,
+		int /*srcy*/,
+		int /*width*/,
+		int /*height*/,
+		int /*dstx*/,
+		int /*dsty*/,
+		unsigned long /*bitPlane*/);
+    void	(* PolyPoint)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*mode*/,
+		int /*npt*/,
+		DDXPointPtr /*pptInit*/);
+
+    void	(* Polylines)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*mode*/,
+		int /*npt*/,
+		DDXPointPtr /*pptInit*/);
+
+    void	(* PolySegment)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nseg*/,
+		xSegment * /*pSegs*/);
+
+    void	(* PolyRectangle)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nrects*/,
+		xRectangle * /*pRects*/);
+
+    void	(* PolyArc)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*narcs*/,
+		xArc * /*parcs*/);
+
+    void	(* FillPolygon)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*shape*/,
+		int /*mode*/,
+		int /*count*/,
+		DDXPointPtr /*pPts*/);
+
+    void	(* PolyFillRect)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*nrectFill*/,
+		xRectangle * /*prectInit*/);
+
+    void	(* PolyFillArc)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*narcs*/,
+		xArc * /*parcs*/);
+
+    int		(* PolyText8)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		char * /*chars*/);
+
+    int		(* PolyText16)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		unsigned short * /*chars*/);
+
+    void	(* ImageText8)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		char * /*chars*/);
+
+    void	(* ImageText16)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		int /*count*/,
+		unsigned short * /*chars*/);
+
+    void	(* ImageGlyphBlt)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		unsigned int /*nglyph*/,
+		CharInfoPtr * /*ppci*/,
+		pointer /*pglyphBase*/);
+
+    void	(* PolyGlyphBlt)(
+		DrawablePtr /*pDrawable*/,
+		GCPtr /*pGC*/,
+		int /*x*/,
+		int /*y*/,
+		unsigned int /*nglyph*/,
+		CharInfoPtr * /*ppci*/,
+		pointer /*pglyphBase*/);
+
+    void	(* PushPixels)(
+		GCPtr /*pGC*/,
+		PixmapPtr /*pBitMap*/,
+		DrawablePtr /*pDst*/,
+		int /*w*/,
+		int /*h*/,
+		int /*x*/,
+		int /*y*/);
+
+    DevUnion	devPrivate;
+} GCOps;
+
+/* there is padding in the bit fields because the Sun compiler doesn't
+ * force alignment to 32-bit boundaries.  losers.
+ */
+typedef struct _GC {
+    ScreenPtr		pScreen;		
+    unsigned char	depth;    
+    unsigned char	alu;
+    unsigned short	lineWidth;          
+    unsigned short	dashOffset;
+    unsigned short	numInDashList;
+    unsigned char	*dash;
+    unsigned int	lineStyle : 2;
+    unsigned int	capStyle : 2;
+    unsigned int	joinStyle : 2;
+    unsigned int	fillStyle : 2;
+    unsigned int	fillRule : 1;
+    unsigned int 	arcMode : 1;
+    unsigned int	subWindowMode : 1;
+    unsigned int	graphicsExposures : 1;
+    unsigned int	clientClipType : 2; /* CT_<kind> */
+    unsigned int	miTranslate:1; /* should mi things translate? */
+    unsigned int	tileIsPixel:1; /* tile is solid pixel */
+    unsigned int	fExpose:1;     /* Call exposure handling */
+    unsigned int	freeCompClip:1;  /* Free composite clip */
+    unsigned int	scratch_inuse:1; /* is this GC in a pool for reuse? */
+    unsigned int	unused:13; /* see comment above */
+    unsigned long	planemask;
+    unsigned long	fgPixel;
+    unsigned long	bgPixel;
+    /*
+     * alas -- both tile and stipple must be here as they
+     * are independently specifiable
+     */
+    PixUnion		tile;
+    PixmapPtr		stipple;
+    DDXPointRec		patOrg;		/* origin for (tile, stipple) */
+    struct _Font	*font;
+    DDXPointRec		clipOrg;
+    DDXPointRec		lastWinOrg;	/* position of window last validated */
+    pointer		clientClip;
+    unsigned long	stateChanges;	/* masked with GC_<kind> */
+    unsigned long       serialNumber;
+    GCFuncs		*funcs;
+    GCOps		*ops;
+    PrivateRec		*devPrivates;
+    /*
+     * The following were moved here from private storage to allow device-
+     * independent access to them from screen wrappers.
+     * --- 1997.11.03  Marc Aurele La France (tsi@xfree86.org)
+     */
+    PixmapPtr		pRotatedPixmap; /* tile/stipple rotated for alignment */
+    RegionPtr		pCompositeClip;
+    /* fExpose & freeCompClip defined above */
+} GC;
+
+#endif /* GCSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda9850.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda9850.h
@@ -0,0 +1,38 @@
+#ifndef __TDA9850_H__
+#define __TDA9850_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+	I2CDevRec d;
+	
+	int mux;
+	int stereo;
+	int sap;
+	Bool mute;
+	Bool sap_mute;
+	} TDA9850Rec, *TDA9850Ptr;
+
+#define TDA9850_ADDR_1   0xB4
+
+#define xf86_Detect_tda9850	Detect_tda9850
+extern _X_EXPORT TDA9850Ptr Detect_tda9850(I2CBusPtr b, I2CSlaveAddr addr);
+#define xf86_tda9850_init	tda9850_init
+extern _X_EXPORT Bool tda9850_init(TDA9850Ptr t);
+#define xf86_tda9850_setaudio	tda9850_setaudio
+extern _X_EXPORT void tda9850_setaudio(TDA9850Ptr t);
+#define xf86_tda9850_mute	tda9850_mute
+extern _X_EXPORT void tda9850_mute(TDA9850Ptr t, Bool mute);
+#define xf86_tda9850_sap_mute	tda9850_sap_mute
+extern _X_EXPORT void tda9850_sap_mute(TDA9850Ptr t, Bool sap_mute);
+#define xf86_tda9850_getstatus	tda9850_getstatus
+extern _X_EXPORT CARD16 tda9850_getstatus(TDA9850Ptr t);
+
+#define TDA9850SymbolsList  \
+		"Detect_tda9850", \
+		"tda9850_init", \
+		"tda9850_setaudio", \
+		"tda9850_mute", \
+		"tda9850_sap_mute"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/opendev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/opendev.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef OPENDEV_H
+#define OPENDEV_H 1
+
+int SProcXOpenDevice(ClientPtr	/* client */
+    );
+
+int ProcXOpenDevice(ClientPtr	/* client */
+    );
+
+void SRepXOpenDevice(ClientPtr /* client */ ,
+		     int /* size */ ,
+		     xOpenDeviceReply *	/* rep */
+    );
+
+#endif /* OPENDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/securitysrv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/securitysrv.h
@@ -0,0 +1,83 @@
+/*
+Copyright 1996, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+*/
+
+/* Xserver internals for Security extension - moved here from
+   _SECURITY_SERVER section of <X11/extensions/security.h> */
+
+#ifndef _SECURITY_SRV_H
+#define _SECURITY_SRV_H
+
+/* Allow client side portions of <X11/extensions/security.h> to compile */
+#ifndef Status
+# define Status int
+# define NEED_UNDEF_Status
+#endif
+#ifndef Display
+# define Display void
+# define NEED_UNDEF_Display
+#endif
+
+#include <X11/extensions/secur.h>
+
+#ifdef NEED_UNDEF_Status
+# undef Status
+# undef NEED_UNDEF_Status
+#endif
+#ifdef NEED_UNDEF_Display
+# undef Display
+# undef NEED_UNDEF_Display
+#endif
+
+
+#include "input.h"    /* for DeviceIntPtr */
+#include "property.h" /* for PropertyPtr */
+#include "pixmap.h"   /* for DrawablePtr */
+#include "resource.h" /* for RESTYPE */
+
+/* resource type to pass in LookupIDByType for authorizations */
+extern RESTYPE SecurityAuthorizationResType;
+
+/* this is what we store for an authorization */
+typedef struct {
+    XID id;			/* resource ID */
+    CARD32 timeout;	/* how long to live in seconds after refcnt == 0 */
+    unsigned int trustLevel;	/* trusted/untrusted */
+    XID group;			/* see embedding extension */
+    unsigned int refcnt;	/* how many clients connected with this auth */
+    unsigned int secondsRemaining; /* overflow time amount for >49 days */
+    OsTimerPtr timer;		/* timer for this auth */
+    struct _OtherClients *eventClients; /* clients wanting events */
+} SecurityAuthorizationRec, *SecurityAuthorizationPtr;
+
+typedef struct {
+    XID group;	/* the group that was sent in GenerateAuthorization */
+    Bool valid; /* did anyone recognize it? if so, set to TRUE */
+} SecurityValidateGroupInfoRec;
+
+/* Give this value or higher to the -audit option to get security messages */
+#define SECURITY_AUDIT_LEVEL 4
+
+#endif /* _SECURITY_SRV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/events.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/events.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef EVENTS_H
+#define EVENTS_H
+typedef struct _DeviceEvent DeviceEvent;
+typedef struct _DeviceChangedEvent DeviceChangedEvent;
+#if XFreeXDGA
+typedef struct _DGAEvent DGAEvent;
+#endif
+typedef struct _RawDeviceEvent RawDeviceEvent;
+#ifdef XQUARTZ
+typedef struct _XQuartzEvent XQuartzEvent;
+#endif
+typedef union _InternalEvent InternalEvent;
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/x86emui.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/x86emui.h
@@ -0,0 +1,102 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for system specific functions. These functions
+*				are always compiled and linked in the OS depedent libraries,
+*				and never in a binary portable driver.
+*
+****************************************************************************/
+
+
+#ifndef __X86EMU_X86EMUI_H
+#define __X86EMU_X86EMUI_H
+
+/* If we are compiling in C++ mode, we can compile some functions as
+ * inline to increase performance (however the code size increases quite
+ * dramatically in this case).
+ */
+
+#if	defined(__cplusplus) && !defined(_NO_INLINE)
+#define	_INLINE	inline
+#else
+#define	_INLINE static
+#endif
+
+/* Get rid of unused parameters in C++ compilation mode */
+
+#ifdef __cplusplus
+#define	X86EMU_UNUSED(v)
+#else
+#define	X86EMU_UNUSED(v)	v
+#endif
+
+#include "x86emu.h"
+#include "x86emu/regs.h"
+#include "x86emu/debug.h"
+#include "x86emu/decode.h"
+#include "x86emu/ops.h"
+#include "x86emu/prim_ops.h"
+#include "x86emu/fpu.h"
+#include "x86emu/fpu_regs.h"
+
+#ifndef NO_SYS_HEADERS
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif                                                                                           
+/*--------------------------- Inline Functions ----------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+extern u8  	(X86APIP sys_rdb)(u32 addr);
+extern u16 	(X86APIP sys_rdw)(u32 addr);
+extern u32 	(X86APIP sys_rdl)(u32 addr);
+extern void (X86APIP sys_wrb)(u32 addr,u8 val);
+extern void (X86APIP sys_wrw)(u32 addr,u16 val);
+extern void (X86APIP sys_wrl)(u32 addr,u32 val);
+
+extern u8  	(X86APIP sys_inb)(X86EMU_pioAddr addr);
+extern u16 	(X86APIP sys_inw)(X86EMU_pioAddr addr);
+extern u32 	(X86APIP sys_inl)(X86EMU_pioAddr addr);
+extern void (X86APIP sys_outb)(X86EMU_pioAddr addr,u8 val);
+extern void (X86APIP sys_outw)(X86EMU_pioAddr addr,u16 val);
+extern void	(X86APIP sys_outl)(X86EMU_pioAddr addr,u32 val);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_X86EMUI_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbpict.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbpict.h
@@ -0,0 +1,484 @@
+/*
+ *
+ * Copyright © 2000 Keith Packard, member of The XFree86 Project, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _FBPICT_H_
+#define _FBPICT_H_
+
+#include "renderedge.h"
+
+
+#if defined(__GNUC__)
+#define INLINE __inline__
+#else
+#define INLINE
+#endif
+
+#define FbIntMult(a,b,t) ( (t) = (a) * (b) + 0x80, ( ( ( (t)>>8 ) + (t) )>>8 ) )
+#define FbIntDiv(a,b)	 (((CARD16) (a) * 255) / (b))
+
+#define FbGet8(v,i)   ((CARD16) (CARD8) ((v) >> i))
+
+/*
+ * There are two ways of handling alpha -- either as a single unified value or
+ * a separate value for each component, hence each macro must have two
+ * versions.  The unified alpha version has a 'U' at the end of the name,
+ * the component version has a 'C'.  Similarly, functions which deal with
+ * this difference will have two versions using the same convention.
+ */
+
+#define FbOverU(x,y,i,a,t) ((t) = FbIntMult(FbGet8(y,i),(a),(t)) + FbGet8(x,i),\
+			   (CARD32) ((CARD8) ((t) | (0 - ((t) >> 8)))) << (i))
+
+#define FbOverC(x,y,i,a,t) ((t) = FbIntMult(FbGet8(y,i),FbGet8(a,i),(t)) + FbGet8(x,i),\
+			    (CARD32) ((CARD8) ((t) | (0 - ((t) >> 8)))) << (i))
+
+#define FbInU(x,i,a,t) ((CARD32) FbIntMult(FbGet8(x,i),(a),(t)) << (i))
+
+#define FbInC(x,i,a,t) ((CARD32) FbIntMult(FbGet8(x,i),FbGet8(a,i),(t)) << (i))
+
+#define FbGen(x,y,i,ax,ay,t,u,v) ((t) = (FbIntMult(FbGet8(y,i),ay,(u)) + \
+					 FbIntMult(FbGet8(x,i),ax,(v))),\
+				  (CARD32) ((CARD8) ((t) | \
+						     (0 - ((t) >> 8)))) << (i))
+
+#define FbAdd(x,y,i,t)	((t) = FbGet8(x,i) + FbGet8(y,i), \
+			 (CARD32) ((CARD8) ((t) | (0 - ((t) >> 8)))) << (i))
+
+
+#define Alpha(x) ((x) >> 24)
+#define Red(x) (((x) >> 16) & 0xff)
+#define Green(x) (((x) >> 8) & 0xff)
+#define Blue(x) ((x) & 0xff)
+
+/**
+ * Returns TRUE if the fbComposeGetSolid can be used to get a single solid
+ * color representing every source sampling location of the picture.
+ */
+static INLINE Bool
+fbCanGetSolid(PicturePtr pict)
+{
+    if (pict->pDrawable == NULL ||
+	pict->pDrawable->width != 1 ||
+	pict->pDrawable->height != 1)
+    {
+	return FALSE;
+    }
+    if (pict->repeat != RepeatNormal)
+	return FALSE;
+
+    switch (pict->format) {
+    case PICT_a8r8g8b8:
+    case PICT_x8r8g8b8:
+    case PICT_a8b8g8r8:
+    case PICT_x8b8g8r8:
+    case PICT_b8g8r8a8:
+    case PICT_b8g8r8x8:
+    case PICT_r8g8b8:
+    case PICT_b8g8r8:
+    case PICT_r5g6b5:
+    case PICT_b5g6r5:
+	return TRUE;
+    default:
+	return FALSE;
+    }
+}
+
+#define fbComposeGetSolid(pict, bits, fmt) { \
+    FbBits	*__bits__; \
+    FbStride	__stride__; \
+    int		__bpp__; \
+    int		__xoff__,__yoff__; \
+\
+    fbGetDrawable((pict)->pDrawable,__bits__,__stride__,__bpp__,__xoff__,__yoff__); \
+    switch (__bpp__) { \
+    case 32: \
+	(bits) = READ((CARD32 *) __bits__); \
+	break; \
+    case 24: \
+	(bits) = Fetch24 ((CARD8 *) __bits__); \
+	break; \
+    case 16: \
+	(bits) = READ((CARD16 *) __bits__); \
+	(bits) = cvt0565to0888(bits); \
+	break; \
+    case 8: \
+	(bits) = READ((CARD8 *) __bits__); \
+	(bits) = (bits) << 24; \
+	break; \
+    case 1: \
+	(bits) = READ((CARD32 *) __bits__);			\
+	(bits) = FbLeftStipBits((bits),1) ? 0xff000000 : 0x00000000;\
+	break; \
+    default: \
+	return; \
+    } \
+    /* If necessary, convert RGB <--> BGR. */ \
+    if (PICT_FORMAT_TYPE((pict)->format) != PICT_FORMAT_TYPE(fmt)) \
+    { \
+	(bits) = (((bits) & 0xff000000) | \
+		  (((bits) & 0x00ff0000) >> 16) | \
+		  (((bits) & 0x0000ff00) >>  0) | \
+		  (((bits) & 0x000000ff) << 16)); \
+    } \
+    /* manage missing src alpha */ \
+    if ((pict)->pFormat->direct.alphaMask == 0) \
+	(bits) |= 0xff000000; \
+    fbFinishAccess ((pict)->pDrawable); \
+}
+
+#define fbComposeGetStart(pict,x,y,type,stride,line,mul) {\
+    FbBits	*__bits__; \
+    FbStride	__stride__; \
+    int		__bpp__; \
+    int		__xoff__,__yoff__; \
+\
+    fbGetDrawable((pict)->pDrawable,__bits__,__stride__,__bpp__,__xoff__,__yoff__); \
+    (stride) = __stride__ * sizeof (FbBits) / sizeof (type); \
+    (line) = ((type *) __bits__) + (stride) * ((y) + __yoff__) + (mul) * ((x) + __xoff__); \
+}
+#define cvt8888to0565(s)    ((((s) >> 3) & 0x001f) | \
+			     (((s) >> 5) & 0x07e0) | \
+			     (((s) >> 8) & 0xf800))
+#define cvt0565to0888(s)    (((((s) << 3) & 0xf8) | (((s) >> 2) & 0x7)) | \
+			     ((((s) << 5) & 0xfc00) | (((s) >> 1) & 0x300)) | \
+			     ((((s) << 8) & 0xf80000) | (((s) << 3) & 0x70000)))
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define Fetch24(a)  ((unsigned long) (a) & 1 ? \
+		     ((READ(a) << 16) | READ((CARD16 *) ((a)+1))) : \
+		     ((READ((CARD16 *) (a)) << 8) | READ((a)+2)))
+#define Store24(a,v) ((unsigned long) (a) & 1 ? \
+		      (WRITE(a, (CARD8) ((v) >> 16)), \
+		       WRITE((CARD16 *) ((a)+1), (CARD16) (v))) : \
+		      (WRITE((CARD16 *) (a), (CARD16) ((v) >> 8)), \
+		       WRITE((a)+2, (CARD8) (v))))
+#else
+#define Fetch24(a)  ((unsigned long) (a) & 1 ? \
+		     (READ(a) | (READ((CARD16 *) ((a)+1)) << 8)) : \
+		     (READ((CARD16 *) (a)) | (READ((a)+2) << 16)))
+#define Store24(a,v) ((unsigned long) (a) & 1 ? \
+		      (WRITE(a, (CARD8) (v)), \
+		       WRITE((CARD16 *) ((a)+1), (CARD16) ((v) >> 8))) : \
+		      (WRITE((CARD16 *) (a), (CARD16) (v)),\
+		       WRITE((a)+2, (CARD8) ((v) >> 16))))
+#endif
+		      
+/*
+   The methods below use some tricks to be able to do two color
+   components at the same time.
+*/
+
+/*
+  x_c = (x_c * a) / 255
+*/
+#define FbByteMul(x, a) do {                                      \
+        CARD32 t = ((x & 0xff00ff) * a) + 0x800080;               \
+        t = (t + ((t >> 8) & 0xff00ff)) >> 8;                     \
+        t &= 0xff00ff;                                            \
+                                                                  \
+        x = (((x >> 8) & 0xff00ff) * a) + 0x800080;               \
+        x = (x + ((x >> 8) & 0xff00ff));                          \
+        x &= 0xff00ff00;                                          \
+        x += t;                                                   \
+    } while (0)
+
+/*
+  x_c = (x_c * a) / 255 + y
+*/
+#define FbByteMulAdd(x, a, y) do {                                \
+        CARD32 t = ((x & 0xff00ff) * a) + 0x800080;               \
+        t = (t + ((t >> 8) & 0xff00ff)) >> 8;                     \
+        t &= 0xff00ff;                                            \
+        t += y & 0xff00ff;                                        \
+        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                   \
+        t &= 0xff00ff;                                            \
+                                                                  \
+        x = (((x >> 8) & 0xff00ff) * a) + 0x800080;                 \
+        x = (x + ((x >> 8) & 0xff00ff)) >> 8;                       \
+        x &= 0xff00ff;                                              \
+        x += (y >> 8) & 0xff00ff;                                   \
+        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                     \
+        x &= 0xff00ff;                                              \
+        x <<= 8;                                                    \
+        x += t;                                                     \
+    } while (0)
+
+/*
+  x_c = (x_c * a + y_c * b) / 255
+*/
+#define FbByteAddMul(x, a, y, b) do {                                   \
+        CARD32 t;                                                       \
+        CARD32 r = (x >> 24) * a + (y >> 24) * b + 0x80;                \
+        r += (r >> 8);                                                  \
+        r >>= 8;                                                        \
+                                                                        \
+        t = (x & 0xff00) * a + (y & 0xff00) * b;                        \
+        t += (t >> 8) + 0x8000;                                         \
+        t >>= 16;                                                       \
+                                                                        \
+        t |= r << 16;                                                   \
+        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
+        t &= 0xff00ff;                                                  \
+        t <<= 8;                                                        \
+                                                                        \
+        r = ((x >> 16) & 0xff) * a + ((y >> 16) & 0xff) * b + 0x80;     \
+        r += (r >> 8);                                                  \
+        r >>= 8;                                                        \
+                                                                        \
+        x = (x & 0xff) * a + (y & 0xff) * b + 0x80;                     \
+        x += (x >> 8);                                                  \
+        x >>= 8;                                                        \
+        x |= r << 16;                                                   \
+        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                         \
+        x &= 0xff00ff;                                                  \
+        x |= t;                                                         \
+} while (0)
+
+/*
+  x_c = (x_c * a + y_c *b) / 256
+*/
+#define FbByteAddMul_256(x, a, y, b) do {                               \
+        CARD32 t = (x & 0xff00ff) * a + (y & 0xff00ff) * b;             \
+        t >>= 8;                                                        \
+        t &= 0xff00ff;                                                  \
+                                                                        \
+        x = ((x >> 8) & 0xff00ff) * a + ((y >> 8) & 0xff00ff) * b;      \
+        x &= 0xff00ff00;                                                \
+        x += t;                                                         \
+} while (0)
+/*
+  x_c = (x_c * a_c) / 255
+*/
+#define FbByteMulC(x, a) do {                           \
+        CARD32 t;                                       \
+        CARD32 r = (x & 0xff) * (a & 0xff);             \
+        r |= (x & 0xff0000) * ((a >> 16) & 0xff);       \
+	r += 0x800080;					\
+        r = (r + ((r >> 8) & 0xff00ff)) >> 8;           \
+        r &= 0xff00ff;                                  \
+                                                        \
+        x >>= 8;                                        \
+        t = (x & 0xff) * ((a >> 8) & 0xff);             \
+        t |= (x & 0xff0000) * (a >> 24);                \
+        t += 0x800080;                                  \
+        t = t + ((t >> 8) & 0xff00ff);                  \
+        x = r | (t & 0xff00ff00);                       \
+                                                        \
+    } while (0)
+
+/*
+  x_c = (x_c * a) / 255 + y
+*/
+#define FbByteMulAddC(x, a, y) do {                                 \
+        CARD32 t;                                                   \
+        CARD32 r = (x & 0xff) * (a & 0xff);                         \
+        r |= (x & 0xff0000) * ((a >> 16) & 0xff);                   \
+	r += 0x800080;						    \
+	r = (r + ((r >> 8) & 0xff00ff)) >> 8;			    \
+        r &= 0xff00ff;                                              \
+        r += y & 0xff00ff;                                          \
+        r |= 0x1000100 - ((r >> 8) & 0xff00ff);                     \
+        r &= 0xff00ff;                                              \
+                                                                    \
+        x >>= 8;                                                       \
+        t = (x & 0xff) * ((a >> 8) & 0xff);                            \
+        t |= (x & 0xff0000) * (a >> 24);                               \
+	t += 0x800080;                                                 \
+        t = (t + ((t >> 8) & 0xff00ff)) >> 8;			       \
+        t &= 0xff00ff;                                                 \
+        t += (y >> 8) & 0xff00ff;                                      \
+        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                        \
+        t &= 0xff00ff;                                                 \
+        x = r | (t << 8);                                              \
+    } while (0)
+
+/*
+  x_c = (x_c * a_c + y_c * b) / 255
+*/
+#define FbByteAddMulC(x, a, y, b) do {                                  \
+        CARD32 t;                                                       \
+        CARD32 r = (x >> 24) * (a >> 24) + (y >> 24) * b;               \
+        r += (r >> 8) + 0x80;                                           \
+        r >>= 8;                                                        \
+                                                                        \
+        t = (x & 0xff00) * ((a >> 8) & 0xff) + (y & 0xff00) * b;        \
+        t += (t >> 8) + 0x8000;                                         \
+        t >>= 16;                                                       \
+                                                                        \
+        t |= r << 16;                                                   \
+        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
+        t &= 0xff00ff;                                                  \
+        t <<= 8;                                                        \
+                                                                        \
+        r = ((x >> 16) & 0xff) * ((a >> 16) & 0xff) + ((y >> 16) & 0xff) * b + 0x80; \
+        r += (r >> 8);                                                  \
+        r >>= 8;                                                        \
+                                                                        \
+        x = (x & 0xff) * (a & 0xff) + (y & 0xff) * b + 0x80;            \
+        x += (x >> 8);                                                  \
+        x >>= 8;                                                        \
+        x |= r << 16;                                                   \
+        x |= 0x1000100 - ((x >> 8) & 0xff00ff);                         \
+        x &= 0xff00ff;                                                  \
+        x |= t;                                                         \
+    } while (0)
+ 
+/*
+  x_c = min(x_c + y_c, 255)
+*/
+#define FbByteAdd(x, y) do {                                            \
+        CARD32 t;                                                       \
+        CARD32 r = (x & 0xff00ff) + (y & 0xff00ff);                     \
+        r |= 0x1000100 - ((r >> 8) & 0xff00ff);                         \
+        r &= 0xff00ff;                                                  \
+                                                                        \
+        t = ((x >> 8) & 0xff00ff) + ((y >> 8) & 0xff00ff);              \
+        t |= 0x1000100 - ((t >> 8) & 0xff00ff);                         \
+        r |= (t & 0xff00ff) << 8;                                       \
+        x = r;                                                          \
+    } while (0)
+
+#define div_255(x) (((x) + 0x80 + (((x) + 0x80) >> 8)) >> 8)
+
+#if defined(__i386__) && defined(__GNUC__)
+#define FASTCALL __attribute__((regparm(3)))
+#else
+#define FASTCALL
+#endif
+
+typedef struct _FbComposeData {
+    CARD8	op;
+    PicturePtr	src;
+    PicturePtr	mask;
+    PicturePtr	dest;
+    INT16	xSrc;
+    INT16	ySrc;
+    INT16	xMask;
+    INT16	yMask;
+    INT16	xDest;
+    INT16	yDest;
+    CARD16	width;
+    CARD16	height;
+} FbComposeData;
+
+extern _X_EXPORT void
+fbCompositeRect (const FbComposeData *data, CARD32 *scanline_buffer);
+
+typedef FASTCALL void (*CombineMaskU) (CARD32 *src, const CARD32 *mask, int width);
+typedef FASTCALL void (*CombineFuncU) (CARD32 *dest, const CARD32 *src, int width);
+typedef FASTCALL void (*CombineFuncC) (CARD32 *dest, CARD32 *src, CARD32 *mask, int width);
+
+typedef struct _FbComposeFunctions {
+    CombineFuncU *combineU;
+    CombineFuncC *combineC;
+    CombineMaskU combineMaskU;
+} FbComposeFunctions;
+
+/* fbcompose.c */
+
+extern _X_EXPORT void
+fbCompositeGeneral (CARD8	op,
+		    PicturePtr	pSrc,
+		    PicturePtr	pMask,
+		    PicturePtr	pDst,
+		    INT16	xSrc,
+		    INT16	ySrc,
+		    INT16	xMask,
+		    INT16	yMask,
+		    INT16	xDst,
+		    INT16	yDst,
+		    CARD16	width,
+		    CARD16	height);
+
+/* fbpict.c */
+extern _X_EXPORT void
+fbComposite (CARD8      op,
+	     PicturePtr pSrc,
+	     PicturePtr pMask,
+	     PicturePtr pDst,
+	     INT16      xSrc,
+	     INT16      ySrc,
+	     INT16      xMask,
+	     INT16      yMask,
+	     INT16      xDst,
+	     INT16      yDst,
+	     CARD16     width,
+	     CARD16     height);
+
+typedef void	(*CompositeFunc) (CARD8      op,
+				  PicturePtr pSrc,
+				  PicturePtr pMask,
+				  PicturePtr pDst,
+				  INT16      xSrc,
+				  INT16      ySrc,
+				  INT16      xMask,
+                                  INT16      yMask,
+				  INT16      xDst,
+				  INT16      yDst,
+				  CARD16     width,
+				  CARD16     height);
+
+extern _X_EXPORT void
+fbWalkCompositeRegion (CARD8 op,
+		       PicturePtr pSrc,
+		       PicturePtr pMask,
+		       PicturePtr pDst,
+		       INT16 xSrc,
+		       INT16 ySrc,
+		       INT16 xMask,
+		       INT16 yMask,
+		       INT16 xDst,
+		       INT16 yDst,
+		       CARD16 width,
+		       CARD16 height,
+		       Bool srcRepeat,
+		       Bool maskRepeat,
+		       CompositeFunc compositeRect);
+
+/* fbtrap.c */
+
+extern _X_EXPORT void
+fbAddTraps (PicturePtr	pPicture,
+	    INT16	xOff,
+	    INT16	yOff,
+	    int		ntrap,
+	    xTrap	*traps);
+
+extern _X_EXPORT void
+fbRasterizeTrapezoid (PicturePtr    alpha,
+		      xTrapezoid    *trap,
+		      int	    x_off,
+		      int	    y_off);
+
+extern _X_EXPORT void
+fbAddTriangles (PicturePtr  pPicture,
+		INT16	    xOff,
+		INT16	    yOff,
+		int	    ntri,
+		xTriangle   *tris);
+
+#endif /* _FBPICT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaa.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaa.h
@@ -0,0 +1,1396 @@
+
+#ifndef _XAA_H
+#define _XAA_H
+
+#define XAA_VERSION_MAJOR   1
+#define XAA_VERSION_MINOR   2
+#define XAA_VERSION_RELEASE 1
+
+/*
+
+   ******** OPERATION SPECIFIC FLAGS *********
+
+   **** solid/dashed line flags ****
+ 
+---------               --------
+23           LINE_PATTERN_LSBFIRST_MSBJUSTIFIED
+22           LINE_PATTERN_LSBFIRST_LSBJUSTIFIED
+21           LINE_PATTERN_MSBFIRST_MSBJUSTIFIED
+20           LINE_PATTERN_MSBFIRST_LSBJUSTIFIED
+19           LINE_PATTERN_POWER_OF_2_ONLY
+18           LINE_LIMIT_COORDS
+17                         .
+16                         .
+---------               -------
+
+   **** screen to screen copy flags ****
+
+---------               --------
+23           ONLY_LEFT_TO_RIGHT_BITBLT
+22           ONLY_TWO_BITBLT_DIRECTIONS
+21                         .
+20                         .
+19                         .
+18                         .
+17                         .
+16                         .
+---------               -------
+
+   ****  clipping flags ****
+
+---------               --------
+23                         .
+22           HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND
+21           HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY
+20           HARDWARE_CLIP_MONO_8x8_FILL
+19           HARDWARE_CLIP_COLOR_8x8_FILL    
+18           HARDWARE_CLIP_SOLID_FILL
+17           HARDWARE_CLIP_DASHED_LINE
+16           HARDWARE_CLIP_SOLID_LINE
+---------               -------
+
+
+   ****  hardware pattern flags ****
+
+---------               --------
+23                         .
+22                         .
+21           HARDWARE_PATTERN_SCREEN_ORIGIN
+20                         .
+19                         .
+18                         .
+17           HARDWARE_PATTERN_PROGRAMMED_ORIGIN
+16           HARDWARE_PATTERN_PROGRAMMED_BITS
+---------               -------
+
+   ****  write pixmap flags ****
+
+---------               --------
+23                         .
+22                         .
+21                         .
+20                         .
+19                         .
+18                         .
+17                         .
+16           CONVERT_32BPP_TO_24BPP
+---------               -------
+
+
+   ******** GENERIC FLAGS *********
+
+---------               -------
+15           SYNC_AFTER_COLOR_EXPAND
+14           CPU_TRANSFER_PAD_QWORD
+13                         .
+12           LEFT_EDGE_CLIPPING_NEGATIVE_X
+11	     LEFT_EDGE_CLIPPING
+10	     CPU_TRANSFER_BASE_FIXED
+ 9           BIT_ORDER_IN_BYTE_MSBFIRST           
+ 8           TRANSPARENCY_GXCOPY_ONLY
+---------               -------
+ 7           NO_TRANSPARENCY
+ 6           TRANSPARENCY_ONLY
+ 5           ROP_NEEDS_SOURCE
+ 4           TRIPLE_BITS_24BPP
+ 3           RGB_EQUAL
+ 2           NO_PLANEMASK
+ 1           NO_GXCOPY
+ 0           GXCOPY_ONLY
+---------               -------
+
+
+*/
+
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "xf86str.h"
+#include "regionstr.h"
+#include "xf86fbman.h"
+
+#include "picturestr.h"
+
+/* Flags */
+#define PIXMAP_CACHE			0x00000001
+#define MICROSOFT_ZERO_LINE_BIAS	0x00000002
+#define OFFSCREEN_PIXMAPS		0x00000004
+#define LINEAR_FRAMEBUFFER		0x00000008
+
+
+/* GC fg, bg, and planemask restrictions */
+#define GXCOPY_ONLY			0x00000001
+#define NO_GXCOPY			0x00000002
+#define NO_PLANEMASK			0x00000004
+#define RGB_EQUAL			0x00000008
+#define TRIPLE_BITS_24BPP		0x00000010
+#define ROP_NEEDS_SOURCE		0x00000020
+
+/* transparency restrictions */
+#define TRANSPARENCY_ONLY		0x00000040
+#define NO_TRANSPARENCY			0x00000080
+#define TRANSPARENCY_GXCOPY_ONLY     	0x00000100
+
+/* bit order restrictions */
+#define BIT_ORDER_IN_BYTE_MSBFIRST	0x00000200
+#define BIT_ORDER_IN_BYTE_LSBFIRST	0x00000000
+
+/* transfer base restriction */
+#define CPU_TRANSFER_BASE_FIXED		0x00000400
+
+/* skipleft restrictions */
+#define LEFT_EDGE_CLIPPING		0x00000800
+#define LEFT_EDGE_CLIPPING_NEGATIVE_X	0x00001000
+
+/* data padding */
+#define CPU_TRANSFER_PAD_DWORD		0x00000000
+#define CPU_TRANSFER_PAD_QWORD		0x00004000
+#define SCANLINE_PAD_DWORD		0x00000000
+
+#define SYNC_AFTER_COLOR_EXPAND		0x00008000
+#define SYNC_AFTER_IMAGE_WRITE		SYNC_AFTER_COLOR_EXPAND
+
+/* hardware pattern */
+#define HARDWARE_PATTERN_PROGRAMMED_BITS	0x00010000
+#define HARDWARE_PATTERN_PROGRAMMED_ORIGIN	0x00020000
+#define HARDWARE_PATTERN_SCREEN_ORIGIN		0x00200000
+
+/* copyarea flags */
+#define ONLY_TWO_BITBLT_DIRECTIONS	0x00400000
+#define ONLY_LEFT_TO_RIGHT_BITBLT	0x00800000
+
+/* line flags */
+#define LINE_PATTERN_LSBFIRST_MSBJUSTIFIED	0x00800000
+#define LINE_PATTERN_LSBFIRST_LSBJUSTIFIED	0x00400000
+#define LINE_PATTERN_MSBFIRST_MSBJUSTIFIED	0x00200000
+#define LINE_PATTERN_MSBFIRST_LSBJUSTIFIED	0x00100000
+#define LINE_PATTERN_POWER_OF_2_ONLY		0x00080000
+#define LINE_LIMIT_COORDS			0x00040000
+
+/* clipping flags */
+#define HARDWARE_CLIP_SCREEN_TO_SCREEN_COLOR_EXPAND	0x00400000
+#define HARDWARE_CLIP_SCREEN_TO_SCREEN_COPY		0x00200000
+#define HARDWARE_CLIP_MONO_8x8_FILL			0x00100000
+#define HARDWARE_CLIP_COLOR_8x8_FILL			0x00080000
+#define HARDWARE_CLIP_SOLID_FILL			0x00040000
+#define HARDWARE_CLIP_DASHED_LINE			0x00020000
+#define HARDWARE_CLIP_SOLID_LINE			0x00010000
+
+#define HARDWARE_CLIP_LINE				0x00000000
+
+
+/* image write flags */
+#define CONVERT_32BPP_TO_24BPP			0x00010000
+
+/* pixmap cache flags */
+#define CACHE_MONO_8x8			0x00000001
+#define CACHE_COLOR_8x8			0x00000002
+#define DO_NOT_BLIT_STIPPLES		0x00000004
+#define DO_NOT_TILE_MONO_DATA		0x00000008	
+#define DO_NOT_TILE_COLOR_DATA		0x00000010
+
+
+#define DEGREES_0	0
+#define DEGREES_90	1
+#define DEGREES_180	2
+#define DEGREES_270	3
+
+#define OMIT_LAST	1
+
+/* render flags */
+
+#define XAA_RENDER_POWER_OF_2_TILE_ONLY	0x00000008
+#define XAA_RENDER_NO_SRC_ALPHA		0x00000004
+#define XAA_RENDER_IMPRECISE_ONLY	0x00000002	
+#define XAA_RENDER_NO_TILE		0x00000001		
+
+#define XAA_RENDER_REPEAT		0x00000001
+
+typedef void (* ValidateGCProcPtr)(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+typedef struct {
+    unsigned char *bits;
+    int width;
+    int height;
+    int yoff;
+    int srcwidth;
+    int start;
+    int end;
+} NonTEGlyphInfo, *NonTEGlyphPtr;
+
+
+typedef struct {
+   int x;
+   int y;
+   int w;
+   int h;
+   int orig_w;
+   int orig_h;
+   unsigned long serialNumber;
+   int pat0;
+   int pat1;
+   int fg;
+   int bg;
+   int trans_color;
+   DDXPointPtr offsets;
+   DevUnion devPrivate;
+} XAACacheInfoRec, *XAACacheInfoPtr;
+
+
+typedef struct _PixmapLink {
+  PixmapPtr pPix;
+  struct _PixmapLink *next;
+  FBAreaPtr area;
+} PixmapLink, *PixmapLinkPtr;
+
+typedef struct _XAAInfoRec {
+   ScrnInfoPtr pScrn;
+   int Flags;
+
+   void (*Sync)(
+	ScrnInfoPtr pScrn
+   );
+   
+   /* Restore Accel State is a driver callback that is used
+    * when another screen on the same device has been active.
+    * This allows multihead on a single device to work.
+    * If The entityProp has IS_SHARED_ACCEL defined then this
+    * function is required.
+    */
+   
+   void (*RestoreAccelState)(
+	ScrnInfoPtr pScrn
+   );
+
+   /***************** Low Level *****************/
+
+/* Blits */
+   void (*SetupForScreenToScreenCopy)(
+	ScrnInfoPtr pScrn,
+	int xdir, int ydir,
+	int rop,
+	unsigned int planemask,
+	int trans_color
+   );
+   int ScreenToScreenCopyFlags;
+
+   void (*SubsequentScreenToScreenCopy)(
+	ScrnInfoPtr pScrn,
+	int xsrc, int ysrc,
+	int xdst, int ydst,
+	int w, int h
+   );
+
+   
+/* Solid fills */
+   void (*SetupForSolidFill)(
+	ScrnInfoPtr pScrn,
+	int color,
+	int rop,
+	unsigned int planemask
+   );    
+   int SolidFillFlags;  
+
+   void (*SubsequentSolidFillRect)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h
+   );    
+
+   void (*SubsequentSolidFillTrap)(
+	ScrnInfoPtr pScrn,
+	int y, int h, 
+	int left, int dxL, int dyL, int eL,
+	int right, int dxR, int dyR, int eR
+   );
+
+
+/* Solid lines */
+
+   void (*SetupForSolidLine)(
+	ScrnInfoPtr pScrn,
+	int color,
+	int rop,
+	unsigned int planemask
+   );    
+   int SolidLineFlags;  
+
+   void (*SubsequentSolidTwoPointLine)(
+	ScrnInfoPtr pScrn,
+	int xa, int ya, int xb, int yb, int flags
+   );   
+
+   void (*SubsequentSolidBresenhamLine)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int absmaj, int absmin, int err, int len, int octant
+   );   
+   int SolidBresenhamLineErrorTermBits;
+
+   void (*SubsequentSolidHorVertLine)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int len, int dir
+   );   
+
+/* Dashed lines */
+
+   void (*SetupForDashedLine)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask,
+	int length,
+	unsigned char *pattern
+   );    
+   int DashedLineFlags; 
+   int DashPatternMaxLength; 
+
+   void (*SubsequentDashedTwoPointLine)(
+	ScrnInfoPtr pScrn,
+	int xa, int ya, int xb, int yb, int flags, int phase
+   );   
+
+   void (*SubsequentDashedBresenhamLine)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int absmaj, int absmin, int err, int len, int flags,
+	int phase
+   );   
+   int DashedBresenhamLineErrorTermBits;
+
+/* Clipper */
+
+   void (*SetClippingRectangle) (
+	ScrnInfoPtr pScrn,
+	int left, int top, int right, int bottom
+   );
+   int ClippingFlags;
+
+   void (*DisableClipping)(ScrnInfoPtr pScrn);
+
+/* 8x8 mono pattern fills */
+   void (*SetupForMono8x8PatternFill)(
+	ScrnInfoPtr pScrn,
+	int patx, int paty,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask
+   );
+   int Mono8x8PatternFillFlags; 
+
+   void (*SubsequentMono8x8PatternFillRect)(
+	ScrnInfoPtr pScrn,
+	int patx, int paty,
+	int x, int y, int w, int h
+   );
+
+   void (*SubsequentMono8x8PatternFillTrap)(
+	ScrnInfoPtr pScrn,
+        int patx, int paty,
+	int y, int h, 
+	int left, int dxL, int dyL, int eL,
+	int right, int dxR, int dyR, int eR
+   );
+
+/* 8x8 color pattern fills */
+
+   void (*SetupForColor8x8PatternFill)(
+	ScrnInfoPtr pScrn,
+	int patx, int paty,
+	int rop,
+	unsigned int planemask,
+	int transparency_color
+   );
+   int Color8x8PatternFillFlags; 
+
+   void (*SubsequentColor8x8PatternFillRect)(
+	ScrnInfoPtr pScrn,
+	int patx, int paty,
+	int x, int y, int w, int h
+   );
+
+   void (*SubsequentColor8x8PatternFillTrap)(
+	ScrnInfoPtr pScrn,
+        int patx, int paty,
+	int y, int h, 
+	int left, int dxL, int dyL, int eL,
+	int right, int dxR, int dyR, int eR
+   );
+
+
+/* Color expansion */
+
+   void (*SetupForCPUToScreenColorExpandFill)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask
+   );     
+   int CPUToScreenColorExpandFillFlags;  
+
+   void (*SubsequentCPUToScreenColorExpandFill)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int skipleft
+   );
+
+   unsigned char *ColorExpandBase;
+   int ColorExpandRange;
+
+
+/* Scanline color expansion  */
+
+   void (*SetupForScanlineCPUToScreenColorExpandFill)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask
+   );  
+   int ScanlineCPUToScreenColorExpandFillFlags;
+
+   void (*SubsequentScanlineCPUToScreenColorExpandFill)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int skipleft
+   );
+
+   void (*SubsequentColorExpandScanline)(
+	ScrnInfoPtr pScrn,
+	int bufno
+   );
+
+   int NumScanlineColorExpandBuffers;
+   unsigned char **ScanlineColorExpandBuffers;
+
+/* Screen to screen color expansion */
+
+   void (*SetupForScreenToScreenColorExpandFill) (
+	ScrnInfoPtr pScrn,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask
+   );
+   int ScreenToScreenColorExpandFillFlags;
+
+   void (*SubsequentScreenToScreenColorExpandFill)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int srcx, int srcy, int skipleft
+   );
+   
+
+/*  Image transfers */
+
+   void (*SetupForImageWrite)(
+	ScrnInfoPtr pScrn,
+	int rop,
+	unsigned int planemask,
+	int transparency_color,
+	int bpp, int depth
+   );
+   int ImageWriteFlags;
+
+   void (*SubsequentImageWriteRect)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int skipleft
+   );
+   unsigned char *ImageWriteBase;
+   int ImageWriteRange;
+	
+/*  Scanline Image transfers */
+
+   void (*SetupForScanlineImageWrite)(
+	ScrnInfoPtr pScrn,
+	int rop,
+	unsigned int planemask,
+	int transparency_color,
+	int bpp, int depth
+   );
+   int ScanlineImageWriteFlags;
+
+   void (*SubsequentScanlineImageWriteRect)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	int skipleft
+   );
+
+   void (*SubsequentImageWriteScanline) (
+	ScrnInfoPtr pScrn,
+	int bufno
+   );
+   
+   int NumScanlineImageWriteBuffers;
+   unsigned char **ScanlineImageWriteBuffers;
+
+  /* Image Reads - OBSOLETE AND NOT USED */
+
+   void (*SetupForImageRead) (
+	ScrnInfoPtr pScrn,
+	int bpp, int depth
+   );
+   int ImageReadFlags;
+
+   unsigned char *ImageReadBase;
+   int ImageReadRange;
+
+   void (*SubsequentImageReadRect)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h
+   );  
+
+
+   /***************** Mid Level *****************/
+   void (*ScreenToScreenBitBlt)(
+	ScrnInfoPtr pScrn,
+	int nbox,
+	DDXPointPtr pptSrc,
+        BoxPtr pbox,
+	int xdir, int ydir,
+	int alu,
+	unsigned int planmask
+   );
+   int ScreenToScreenBitBltFlags;
+
+   void (*WriteBitmap) (
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned char *src,
+    	int srcwidth,
+    	int skipleft,
+	int fg, int bg,
+	int rop,
+	unsigned int planemask
+   );
+   int WriteBitmapFlags;
+
+   void (*FillSolidRects)(
+	ScrnInfoPtr pScrn,
+	int fg, int rop,
+        unsigned int planemask,
+	int nBox,
+	BoxPtr pBox 
+   );
+   int FillSolidRectsFlags;
+
+   void (*FillMono8x8PatternRects)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+        unsigned int planemask,
+	int nBox,
+	BoxPtr pBox, 
+	int pat0, int pat1,
+	int xorg, int yorg
+   );
+   int FillMono8x8PatternRectsFlags;
+
+   void (*FillColor8x8PatternRects)(
+	ScrnInfoPtr pScrn,
+	int rop,
+        unsigned int planemask,
+	int nBox,
+	BoxPtr pBox,
+	int xorg, int yorg,
+	XAACacheInfoPtr pCache
+   );
+   int FillColor8x8PatternRectsFlags;
+
+   void (*FillCacheBltRects)(
+	ScrnInfoPtr pScrn,
+	int rop,
+        unsigned int planemask,
+	int nBox,
+	BoxPtr pBox,
+	int xorg, int yorg,
+	XAACacheInfoPtr pCache
+   );
+   int FillCacheBltRectsFlags;
+
+   void (*FillColorExpandRects)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+        unsigned int planemask,
+	int nBox,
+	BoxPtr pBox,
+	int xorg, int yorg,
+	PixmapPtr pPix
+   );
+   int FillColorExpandRectsFlags;
+
+   void (*FillCacheExpandRects)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+	unsigned int planemask,
+	int nBox,
+	BoxPtr pBox,
+	int xorg, int yorg,
+	PixmapPtr pPix
+   );
+   int FillCacheExpandRectsFlags;
+
+   void (*FillImageWriteRects)(
+	ScrnInfoPtr pScrn,
+	int rop,
+	unsigned int planemask,
+	int nBox,
+	BoxPtr pBox,
+	int xorg, int yorg,
+	PixmapPtr pPix
+   );
+   int FillImageWriteRectsFlags;
+   
+
+   void (*FillSolidSpans)(
+	ScrnInfoPtr pScrn,
+	int fg, int rop,
+        unsigned int planemask,
+	int n,
+	DDXPointPtr points,
+	int *widths,
+	int fSorted 
+   );
+   int FillSolidSpansFlags;
+
+   void (*FillMono8x8PatternSpans)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+        unsigned int planemask,
+	int n,
+	DDXPointPtr points,
+	int *widths,
+	int fSorted, 
+	int pat0, int pat1,
+	int xorg, int yorg
+   );
+   int FillMono8x8PatternSpansFlags;
+
+   void (*FillColor8x8PatternSpans)(
+	ScrnInfoPtr pScrn,
+	int rop,
+        unsigned int planemask,
+	int n,
+	DDXPointPtr points,
+	int *widths,
+	int fSorted,
+	XAACacheInfoPtr pCache,
+	int xorg, int yorg
+   );
+   int FillColor8x8PatternSpansFlags;
+
+   void (*FillCacheBltSpans)(
+	ScrnInfoPtr pScrn,
+	int rop,
+        unsigned int planemask,
+	int n,
+	DDXPointPtr points,
+	int *widths,
+	int fSorted,
+	XAACacheInfoPtr pCache,
+	int xorg, int yorg
+   );
+   int FillCacheBltSpansFlags;
+
+   void (*FillColorExpandSpans)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+        unsigned int planemask,
+	int n,
+	DDXPointPtr points,
+	int *widths,
+	int fSorted,
+	int xorg, int yorg,
+	PixmapPtr pPix
+   );
+   int FillColorExpandSpansFlags;
+
+   void (*FillCacheExpandSpans)(
+	ScrnInfoPtr pScrn,
+	int fg, int bg, int rop,
+	unsigned int planemask,
+	int n,
+	DDXPointPtr ppt,
+	int *pwidth,
+	int fSorted,
+	int xorg, int yorg,
+	PixmapPtr pPix
+   );
+   int FillCacheExpandSpansFlags;
+
+   void (*TEGlyphRenderer)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h, int skipleft, int startline, 
+	unsigned int **glyphs, int glyphWidth,
+	int fg, int bg, int rop, unsigned planemask
+   );
+   int TEGlyphRendererFlags;
+
+   void (*NonTEGlyphRenderer)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int n,
+	NonTEGlyphPtr glyphs,
+	BoxPtr pbox,
+	int fg, int rop,
+	unsigned int planemask
+   );
+   int NonTEGlyphRendererFlags;
+
+   void (*WritePixmap) (
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned char *src,
+    	int srcwidth,
+	int rop,
+	unsigned int planemask,
+	int transparency_color,
+	int bpp, int depth
+   );
+   int WritePixmapFlags;
+
+   void (*ReadPixmap) (
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned char *dst,	
+	int dstwidth,
+	int bpp, int depth
+   );
+   int ReadPixmapFlags;
+
+   /***************** GC Level *****************/
+   RegionPtr (*CopyArea)(
+	DrawablePtr pSrcDrawable,
+	DrawablePtr pDstDrawable,
+	GC *pGC,
+	int srcx, int srcy,
+	int width, int height,
+	int dstx, int dsty
+   );
+   int CopyAreaFlags;
+
+   RegionPtr (*CopyPlane)(
+	DrawablePtr pSrc,
+	DrawablePtr pDst,
+	GCPtr pGC,
+	int srcx, int srcy,
+	int width, int height,
+	int dstx, int dsty,
+	unsigned long bitPlane
+   );
+   int CopyPlaneFlags;
+
+   void (*PushPixelsSolid) (
+	GCPtr	pGC,
+	PixmapPtr pBitMap,
+	DrawablePtr pDrawable,
+	int dx, int dy, 
+	int xOrg, int yOrg
+   );
+   int PushPixelsFlags; 
+
+   /** PolyFillRect **/
+
+   void (*PolyFillRectSolid)(
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int nrectFill, 	
+	xRectangle *prectInit
+   );  
+   int PolyFillRectSolidFlags;
+
+   void (*PolyFillRectStippled)(
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int nrectFill, 	
+	xRectangle *prectInit
+   );  
+   int PolyFillRectStippledFlags;
+
+   void (*PolyFillRectOpaqueStippled)(
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int nrectFill, 	
+	xRectangle *prectInit
+   );  
+   int PolyFillRectOpaqueStippledFlags;
+
+   void (*PolyFillRectTiled)(
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int nrectFill, 	
+	xRectangle *prectInit
+   );  
+   int PolyFillRectTiledFlags;
+
+   /** FillSpans **/   
+
+   void (*FillSpansSolid)(
+	DrawablePtr	pDraw,
+	GCPtr		pGC,
+	int		nInit,
+	DDXPointPtr 	ppt,
+	int		*pwidth,
+	int		fSorted 
+   );
+   int FillSpansSolidFlags;
+
+   void (*FillSpansStippled)(
+	DrawablePtr	pDraw,
+	GCPtr		pGC,
+	int		nInit,
+	DDXPointPtr 	ppt,
+	int		*pwidth,
+	int		fSorted 
+   );
+   int FillSpansStippledFlags;
+
+   void (*FillSpansOpaqueStippled)(
+	DrawablePtr	pDraw,
+	GCPtr		pGC,
+	int		nInit,
+	DDXPointPtr 	ppt,
+	int		*pwidth,
+	int		fSorted 
+   );
+   int FillSpansOpaqueStippledFlags;
+
+   void (*FillSpansTiled)(
+	DrawablePtr	pDraw,
+	GCPtr		pGC,
+	int		nInit,
+	DDXPointPtr 	ppt,
+	int		*pwidth,
+	int		fSorted 
+   );
+   int FillSpansTiledFlags;
+
+   int (*PolyText8TE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	char *chars
+   );
+   int PolyText8TEFlags;
+
+   int (*PolyText16TE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	unsigned short *chars
+   );
+   int PolyText16TEFlags;
+
+   void (*ImageText8TE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	char *chars
+   );
+   int ImageText8TEFlags;
+
+   void (*ImageText16TE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	unsigned short *chars
+   );
+   int ImageText16TEFlags;
+
+   void (*ImageGlyphBltTE) (
+	DrawablePtr pDrawable,
+	GCPtr pGC,
+	int xInit, int yInit,
+	unsigned int nglyph,
+	CharInfoPtr *ppci,
+	pointer pglyphBase 
+   );
+   int ImageGlyphBltTEFlags;
+
+   void (*PolyGlyphBltTE) (
+	DrawablePtr pDrawable,
+	GCPtr pGC,
+	int xInit, int yInit,
+	unsigned int nglyph,
+	CharInfoPtr *ppci,
+	pointer pglyphBase 
+   );
+   int PolyGlyphBltTEFlags;
+
+   int (*PolyText8NonTE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	char *chars
+   );
+   int PolyText8NonTEFlags;
+
+   int (*PolyText16NonTE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	unsigned short *chars
+   );
+   int PolyText16NonTEFlags;
+
+   void (*ImageText8NonTE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	char *chars
+   );
+   int ImageText8NonTEFlags;
+
+   void (*ImageText16NonTE) (
+	DrawablePtr pDraw,
+	GCPtr pGC,
+	int x, int y,
+	int count,
+	unsigned short *chars
+   );
+   int ImageText16NonTEFlags;
+
+   void (*ImageGlyphBltNonTE) (
+	DrawablePtr pDrawable,
+	GCPtr pGC,
+	int xInit, int yInit,
+	unsigned int nglyph,
+	CharInfoPtr *ppci,
+	pointer pglyphBase 
+   );
+   int ImageGlyphBltNonTEFlags;
+
+   void (*PolyGlyphBltNonTE) (
+	DrawablePtr pDrawable,
+	GCPtr pGC,
+	int xInit, int yInit,
+	unsigned int nglyph,
+	CharInfoPtr *ppci,
+	pointer pglyphBase 
+   );
+   int PolyGlyphBltNonTEFlags;
+
+   void (*PolyRectangleThinSolid)(
+	DrawablePtr  pDrawable,
+	GCPtr        pGC,    
+	int	     nRectsInit,
+	xRectangle  *pRectsInit 
+   );
+   int PolyRectangleThinSolidFlags;
+
+   void (*PolylinesWideSolid)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		mode,
+	int 		npt,
+	DDXPointPtr pPts
+   );
+   int PolylinesWideSolidFlags;
+
+   void (*PolylinesThinSolid)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		mode,
+	int 		npt,
+	DDXPointPtr pPts
+   );
+   int PolylinesThinSolidFlags;
+
+   void (*PolySegmentThinSolid)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		nseg,
+	xSegment	*pSeg
+   );
+   int PolySegmentThinSolidFlags;
+
+   void (*PolylinesThinDashed)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		mode,
+	int 		npt,
+	DDXPointPtr pPts
+   );
+   int PolylinesThinDashedFlags;
+
+   void (*PolySegmentThinDashed)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		nseg,
+	xSegment	*pSeg
+   );
+   int PolySegmentThinDashedFlags;
+
+   void (*FillPolygonSolid)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		shape,
+	int		mode,
+	int		count,
+	DDXPointPtr	ptsIn 
+   );
+   int FillPolygonSolidFlags;
+
+   void (*FillPolygonStippled)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		shape,
+	int		mode,
+	int		count,
+	DDXPointPtr	ptsIn 
+   );
+   int FillPolygonStippledFlags;
+
+   void (*FillPolygonOpaqueStippled)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		shape,
+	int		mode,
+	int		count,
+	DDXPointPtr	ptsIn 
+   );
+   int FillPolygonOpaqueStippledFlags;
+
+   void (*FillPolygonTiled)(
+	DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		shape,
+	int		mode,
+	int		count,
+	DDXPointPtr	ptsIn 
+   );
+   int FillPolygonTiledFlags;
+
+   void (*PolyFillArcSolid)(
+	DrawablePtr	pDraw,
+	GCPtr		pGC,
+	int		narcs,
+	xArc		*parcs
+   );
+   int PolyFillArcSolidFlags;
+
+   void (*PutImage)(
+	DrawablePtr pDraw,
+	GCPtr       pGC,
+	int         depth, 
+	int	    x, 
+	int         y, 
+	int	    w, 
+	int	    h,
+	int         leftPad,
+	int         format,
+	char        *pImage
+   );
+   int PutImageFlags;
+   
+   /* Validation masks */
+
+   unsigned long FillSpansMask;
+   ValidateGCProcPtr ValidateFillSpans;
+   unsigned long SetSpansMask;
+   ValidateGCProcPtr ValidateSetSpans;
+   unsigned long PutImageMask;
+   ValidateGCProcPtr ValidatePutImage;
+   unsigned long CopyAreaMask;
+   ValidateGCProcPtr ValidateCopyArea;
+   unsigned long CopyPlaneMask;
+   ValidateGCProcPtr ValidateCopyPlane;
+   unsigned long PolyPointMask;
+   ValidateGCProcPtr ValidatePolyPoint;
+   unsigned long PolylinesMask;
+   ValidateGCProcPtr ValidatePolylines;
+   unsigned long PolySegmentMask;
+   ValidateGCProcPtr ValidatePolySegment;
+   unsigned long PolyRectangleMask;
+   ValidateGCProcPtr ValidatePolyRectangle;
+   unsigned long PolyArcMask;
+   ValidateGCProcPtr ValidatePolyArc;
+   unsigned long FillPolygonMask;
+   ValidateGCProcPtr ValidateFillPolygon;
+   unsigned long PolyFillRectMask;
+   ValidateGCProcPtr ValidatePolyFillRect;
+   unsigned long PolyFillArcMask;
+   ValidateGCProcPtr ValidatePolyFillArc;
+   unsigned long PolyText8Mask;
+   ValidateGCProcPtr ValidatePolyText8;
+   unsigned long PolyText16Mask;
+   ValidateGCProcPtr ValidatePolyText16;
+   unsigned long ImageText8Mask;
+   ValidateGCProcPtr ValidateImageText8;
+   unsigned long ImageText16Mask;
+   ValidateGCProcPtr ValidateImageText16;
+   unsigned long PolyGlyphBltMask;
+   ValidateGCProcPtr ValidatePolyGlyphBlt;
+   unsigned long ImageGlyphBltMask;
+   ValidateGCProcPtr ValidateImageGlyphBlt;
+   unsigned long PushPixelsMask;
+   ValidateGCProcPtr ValidatePushPixels;
+
+   void (*ComputeDash)(GCPtr pGC);
+
+   /* Pixmap Cache */
+
+   int  PixmapCacheFlags;
+   Bool UsingPixmapCache;
+   Bool CanDoMono8x8;
+   Bool CanDoColor8x8;
+
+   void (*InitPixmapCache)(
+	ScreenPtr pScreen, 
+	RegionPtr areas,
+	pointer data
+   );
+   void (*ClosePixmapCache)(
+	ScreenPtr pScreen
+   );
+
+   int (*StippledFillChooser)(GCPtr pGC);
+   int (*OpaqueStippledFillChooser)(GCPtr pGC);
+   int (*TiledFillChooser)(GCPtr pGC);
+
+   int  CachePixelGranularity;
+   int  MaxCacheableTileWidth;
+   int  MaxCacheableTileHeight;
+   int  MaxCacheableStippleWidth;
+   int  MaxCacheableStippleHeight;
+
+   XAACacheInfoPtr (*CacheTile)(
+	ScrnInfoPtr Scrn, PixmapPtr pPix
+   );
+   XAACacheInfoPtr (*CacheStipple)(
+	ScrnInfoPtr Scrn, PixmapPtr pPix, 
+	int fg, int bg
+   );
+   XAACacheInfoPtr (*CacheMonoStipple)(
+	ScrnInfoPtr Scrn, PixmapPtr pPix
+   );
+   XAACacheInfoPtr (*CacheMono8x8Pattern)(
+	ScrnInfoPtr Scrn, int pat0, int pat1
+   );
+   XAACacheInfoPtr (*CacheColor8x8Pattern)(
+	ScrnInfoPtr Scrn, PixmapPtr pPix, 
+	int fg, int bg
+   );
+
+
+   int MonoPatternPitch;
+   int CacheWidthMono8x8Pattern;
+   int CacheHeightMono8x8Pattern;
+
+   int ColorPatternPitch;
+   int CacheWidthColor8x8Pattern;
+   int CacheHeightColor8x8Pattern;
+
+   int CacheColorExpandDensity;
+
+   void (*WriteBitmapToCache) (
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned char *src,
+    	int srcwidth,
+	int fg, int bg
+   );
+   void (*WritePixmapToCache) (
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned char *src,
+    	int srcwidth,
+	int bpp, int depth
+   );
+   void (*WriteMono8x8PatternToCache)(
+	ScrnInfoPtr pScrn, 
+	XAACacheInfoPtr pCache
+   );
+   void (*WriteColor8x8PatternToCache)(
+	ScrnInfoPtr pScrn, 
+	PixmapPtr pPix, 
+	XAACacheInfoPtr pCache
+   );
+   
+   char* PixmapCachePrivate;
+
+   /* Miscellaneous */
+
+   GC ScratchGC;
+   int PreAllocSize;
+   unsigned char *PreAllocMem;
+
+   CharInfoPtr CharInfo[255];
+   NonTEGlyphInfo GlyphInfo[255];
+
+   unsigned int FullPlanemask; /* deprecated */
+
+   PixmapLinkPtr OffscreenPixmaps;
+   int maxOffPixWidth;
+   int maxOffPixHeight;   
+
+   XAACacheInfoRec ScratchCacheInfoRec;
+
+   BoxPtr ClipBox;
+
+   Bool NeedToSync;
+
+   char *dgaSaves;
+
+   /* These can be supplied to override the defaults */
+
+   GetImageProcPtr GetImage;
+   GetSpansProcPtr GetSpans;
+   CopyWindowProcPtr CopyWindow;
+   BackingStoreSaveAreasProcPtr SaveAreas;
+   BackingStoreRestoreAreasProcPtr RestoreAreas;
+
+   unsigned int offscreenDepths;
+   Bool offscreenDepthsInitialized;
+
+   CARD32 FullPlanemasks[32];
+
+   Bool (*Composite) (
+   	CARD8      op,
+        PicturePtr pSrc,
+        PicturePtr pMask,
+        PicturePtr pDst,
+        INT16      xSrc,
+        INT16      ySrc,
+        INT16      xMask,
+        INT16      yMask,
+        INT16      xDst,
+        INT16      yDst,
+        CARD16     width,
+        CARD16     height
+   );
+
+   Bool (*Glyphs) (
+        CARD8         op,
+        PicturePtr    pSrc,
+        PicturePtr    pDst,
+        PictFormatPtr maskFormat,
+        INT16         xSrc,
+        INT16         ySrc,
+        int           nlist,
+        GlyphListPtr  list,
+        GlyphPtr      *glyphs
+   );
+
+   /* The old SetupForCPUToScreenAlphaTexture function is no longer used because
+    * it doesn't pass in enough information to write a conforming
+    * implementation.  See SetupForCPUToScreenAlphaTexture2.
+    */
+   Bool (*SetupForCPUToScreenAlphaTexture) (
+	ScrnInfoPtr	pScrn,
+	int		op,
+	CARD16		red,
+	CARD16		green,
+	CARD16		blue,
+	CARD16		alpha,
+	int		alphaType,
+	CARD8		*alphaPtr,
+	int		alphaPitch,
+	int		width,
+	int		height,
+	int		flags
+   );
+   void (*SubsequentCPUToScreenAlphaTexture) (
+	ScrnInfoPtr	pScrn,
+	int		dstx,
+	int		dsty,
+	int		srcx,
+	int		srcy,
+	int		width,
+	int		height
+   );
+   int CPUToScreenAlphaTextureFlags;
+   CARD32 * CPUToScreenAlphaTextureFormats;
+
+   /* The old SetupForCPUToScreenTexture function is no longer used because
+    * it doesn't pass in enough information to write a conforming
+    * implementation.  See SetupForCPUToScreenTexture2.
+    */
+   Bool (*SetupForCPUToScreenTexture) (
+	ScrnInfoPtr	pScrn,
+	int		op,
+	int		texType,
+	CARD8		*texPtr,
+	int		texPitch,
+	int		width,
+	int		height,
+	int		flags
+   );
+   void (*SubsequentCPUToScreenTexture) (
+	ScrnInfoPtr	pScrn,
+	int		dstx,
+	int		dsty,
+	int		srcx,
+	int		srcy,
+	int		width,
+	int		height
+   );
+   int CPUToScreenTextureFlags;
+   CARD32 * CPUToScreenTextureFormats;
+
+
+   /* these were added for 4.3.0 */
+   BoxRec SolidLineLimits;
+   BoxRec DashedLineLimits;
+
+   /* These were added for X.Org 6.8.0 */
+   Bool (*SetupForCPUToScreenAlphaTexture2) (
+	ScrnInfoPtr	pScrn,
+	int		op,
+	CARD16		red,
+	CARD16		green,
+	CARD16		blue,
+	CARD16		alpha,
+	CARD32		maskFormat,
+	CARD32		dstFormat,
+	CARD8		*alphaPtr,
+	int		alphaPitch,
+	int		width,
+	int		height,
+	int		flags
+   );
+   CARD32 *CPUToScreenAlphaTextureDstFormats;
+
+   Bool (*SetupForCPUToScreenTexture2) (
+	ScrnInfoPtr	pScrn,
+	int		op,
+	CARD32		srcFormat,
+	CARD32		dstFormat,
+	CARD8		*texPtr,
+	int		texPitch,
+	int		width,
+	int		height,
+	int		flags
+   );
+   CARD32 *CPUToScreenTextureDstFormats;
+} XAAInfoRec, *XAAInfoRecPtr;
+
+#define SET_SYNC_FLAG(infoRec)	(infoRec)->NeedToSync = TRUE
+
+
+extern _X_EXPORT Bool
+XAAInit(
+    ScreenPtr pScreen,
+    XAAInfoRecPtr infoRec
+);
+
+extern _X_EXPORT XAAInfoRecPtr XAACreateInfoRec(void);
+
+extern _X_EXPORT void
+XAADestroyInfoRec(
+    XAAInfoRecPtr infoRec
+);
+
+typedef void (*DepthChangeFuncPtr) (ScrnInfoPtr pScrn, int depth);
+
+extern _X_EXPORT Bool
+XAAInitDualFramebufferOverlay(
+   ScreenPtr pScreen, 
+   DepthChangeFuncPtr callback
+);
+
+#endif /* _XAA_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgfctl.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgfctl.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGFCTL_H
+#define CHGFCTL_H 1
+
+int SProcXChangeFeedbackControl(ClientPtr	/* client */
+    );
+
+int ProcXChangeFeedbackControl(ClientPtr	/* client */
+    );
+
+#endif /* CHGFCTL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgkmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgkmap.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGKMAP_H
+#define CHGKMAP_H 1
+
+int SProcXChangeDeviceKeyMapping(ClientPtr	/* client */
+    );
+
+int ProcXChangeDeviceKeyMapping(ClientPtr	/* client */
+    );
+
+#endif /* CHGKMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fi1236.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fi1236.h
@@ -0,0 +1,111 @@
+#ifndef __FI1236_H__
+#define __FI1236_H__
+
+#include "xf86i2c.h"
+
+/* why someone has defined NUM someplace else is beyoung me.. */
+#undef NUM
+
+typedef struct {
+	CARD32 fcar;           /* 16 * fcar_Mhz */
+	CARD32 min_freq;       /* 16 * min_freq_Mhz */
+	CARD32 max_freq;       /* 16 * max_freq_Mhz */
+	
+	CARD32 threshold1;     /* 16 * Value_Mhz */
+	CARD32 threshold2;     /* 16 * Value_Mhz */
+	
+	CARD8  band_low;
+	CARD8  band_mid;
+	CARD8  band_high;
+	CARD8  control;
+	} FI1236_parameters;
+
+
+typedef struct {
+	/* what we want */
+	/* all frequencies are in Mhz */
+	double f_rf;	/* frequency to tune to */
+	double f_if1;   /* first intermediate frequency */
+	double f_if2;   /* second intermediate frequency */
+	double f_ref;   /* reference frequency */
+	double f_ifbw;  /* bandwidth */
+	double f_step;  /* step */
+	
+	/* what we compute */
+	double f_lo1;
+	double f_lo2;
+	int LO1I;
+	int LO2I;
+	int SEL;
+	int STEP;
+	int NUM;
+	} MT2032_parameters;
+
+typedef struct {
+	I2CDevRec  d;
+	int type;
+
+	void* afc_source;    /* The AFC source may be another chip like TDA988x */
+	
+	int afc_delta;
+	CARD32 original_frequency;
+	Bool afc_timer_installed;
+	int afc_count;
+	int last_afc_hint;
+	
+	double video_if;
+	FI1236_parameters parm;
+	int xogc; /* for MT2032 */
+	
+	struct {
+		CARD8   div1;
+		CARD8   div2;
+		CARD8   control;
+		CARD8   band;
+		CARD8	  aux;	/* this is for MK3 tuners */
+		} tuner_data;
+	} FI1236Rec, *FI1236Ptr;
+
+#define TUNER_TYPE_FI1236              0
+#define TUNER_TYPE_FI1216              1
+#define TUNER_TYPE_TEMIC_FN5AL         2
+#define TUNER_TYPE_MT2032	       3
+#define TUNER_TYPE_FI1246              4
+#define TUNER_TYPE_FI1256              5
+#define TUNER_TYPE_FI1236W             6
+#define TUNER_TYPE_FM1216ME            7
+
+#define FI1236_ADDR(a)        ((a)->d.SlaveAddr)
+
+#define FI1236_ADDR_1	     0xC6
+#define FI1236_ADDR_2        0xC0
+
+#define TUNER_TUNED   0
+#define TUNER_JUST_BELOW 1
+#define TUNER_JUST_ABOVE -1
+#define TUNER_OFF      4
+#define TUNER_STILL_TUNING      5
+
+
+void FI1236_tune(FI1236Ptr f, CARD32 frequency);
+
+#define FI1236SymbolsList  \
+		"Detect_FI1236", \
+		"FI1236_set_tuner_type", \
+		"TUNER_set_frequency"
+
+#define xf86_Detect_FI1236		Detect_FI1236
+extern _X_EXPORT FI1236Ptr Detect_FI1236(I2CBusPtr b, I2CSlaveAddr addr);
+#define xf86_FI1236_set_tuner_type	FI1236_set_tuner_type
+extern _X_EXPORT void FI1236_set_tuner_type(FI1236Ptr f, int type);
+#define xf86_TUNER_set_frequency	TUNER_set_frequency
+extern _X_EXPORT void TUNER_set_frequency(FI1236Ptr f, CARD32 frequency);
+
+#define xf86_FI1236_AFC			FI1236_AFC
+extern _X_EXPORT int FI1236_AFC(FI1236Ptr f);
+#define xf86_TUNER_get_afc_hint		TUNER_get_afc_hint
+extern _X_EXPORT int TUNER_get_afc_hint(FI1236Ptr f);
+#define xf86_fi1236_dump_status		fi1236_dump_status
+extern _X_EXPORT void fi1236_dump_status(FI1236Ptr f);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/list.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/list.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright © 2010 Intel Corporation
+ * Copyright © 2010 Francisco Jerez <currojerez@riseup.net>
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef _LIST_H_
+#define _LIST_H_
+
+/* classic doubly-link circular list */
+struct list {
+    struct list *next, *prev;
+};
+
+static void
+list_init(struct list *list)
+{
+    list->next = list->prev = list;
+}
+
+static inline void
+__list_add(struct list *entry,
+	    struct list *prev,
+	    struct list *next)
+{
+    next->prev = entry;
+    entry->next = next;
+    entry->prev = prev;
+    prev->next = entry;
+}
+
+static inline void
+list_add(struct list *entry, struct list *head)
+{
+    __list_add(entry, head, head->next);
+}
+
+static inline void
+__list_del(struct list *prev, struct list *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+
+static inline void
+list_del(struct list *entry)
+{
+    __list_del(entry->prev, entry->next);
+    list_init(entry);
+}
+
+static inline Bool
+list_is_empty(struct list *head)
+{
+    return head->next == head;
+}
+
+#ifndef container_of
+#define container_of(ptr, type, member) \
+    (type *)((char *)(ptr) - (char *) &((type *)0)->member)
+#endif
+
+#define list_entry(ptr, type, member) \
+    container_of(ptr, type, member)
+
+#define list_first_entry(ptr, type, member) \
+    list_entry((ptr)->next, type, member)
+
+#define __container_of(ptr, sample, member)				\
+    (void *)((char *)(ptr)						\
+	     - ((char *)&(sample)->member - (char *)(sample)))
+
+#define list_for_each_entry(pos, head, member)				\
+    for (pos = __container_of((head)->next, pos, member);		\
+	 &pos->member != (head);					\
+	 pos = __container_of(pos->member.next, pos, member))
+
+#define list_for_each_entry_safe(pos, tmp, head, member)		\
+    for (pos = __container_of((head)->next, pos, member),		\
+	 tmp = __container_of(pos->member.next, pos, member);		\
+	 &pos->member != (head);					\
+	 pos = tmp, tmp = __container_of(pos->member.next, tmp, member))
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cursor.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cursor.h
@@ -0,0 +1,140 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CURSOR_H
+#define CURSOR_H 
+
+#include "misc.h"
+#include "screenint.h"
+#include "window.h"
+#include "privates.h"
+
+#define NullCursor ((CursorPtr)NULL)
+
+/* Provide support for alpha composited cursors */
+#define ARGB_CURSOR
+
+struct _DeviceIntRec;
+
+typedef struct _Cursor *CursorPtr;
+typedef struct _CursorMetric *CursorMetricPtr;
+
+extern _X_EXPORT DevPrivateKeyRec cursorScreenDevPriv[MAXSCREENS];
+#define CursorScreenKey(pScreen) (cursorScreenDevPriv + (pScreen)->myNum)
+
+extern _X_EXPORT CursorPtr rootCursor;
+
+extern _X_EXPORT int FreeCursor(
+    pointer /*pCurs*/,
+    XID /*cid*/);
+
+extern _X_EXPORT int AllocARGBCursor(
+    unsigned char* /*psrcbits*/,
+    unsigned char* /*pmaskbits*/,
+    CARD32* /*argb*/,
+    CursorMetricPtr /*cm*/,
+    unsigned /*foreRed*/,
+    unsigned /*foreGreen*/,
+    unsigned /*foreBlue*/,
+    unsigned /*backRed*/,
+    unsigned /*backGreen*/,
+    unsigned /*backBlue*/,
+    CursorPtr* /*ppCurs*/,
+    ClientPtr /*client*/,
+    XID /*cid*/);
+
+extern _X_EXPORT int AllocGlyphCursor(
+    Font /*source*/,
+    unsigned int /*sourceChar*/,
+    Font /*mask*/,
+    unsigned int /*maskChar*/,
+    unsigned /*foreRed*/,
+    unsigned /*foreGreen*/,
+    unsigned /*foreBlue*/,
+    unsigned /*backRed*/,
+    unsigned /*backGreen*/,
+    unsigned /*backBlue*/,
+    CursorPtr* /*ppCurs*/,
+    ClientPtr /*client*/,
+    XID /*cid*/);
+
+extern _X_EXPORT CursorPtr CreateRootCursor(
+    char* /*pfilename*/,
+    unsigned int /*glyph*/);
+
+extern _X_EXPORT int ServerBitsFromGlyph(
+    FontPtr /*pfont*/,
+    unsigned int /*ch*/,
+    CursorMetricPtr /*cm*/,
+    unsigned char ** /*ppbits*/);
+
+extern _X_EXPORT Bool CursorMetricsFromGlyph(
+    FontPtr /*pfont*/,
+    unsigned /*ch*/,
+    CursorMetricPtr /*cm*/);
+
+extern _X_EXPORT void CheckCursorConfinement(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void NewCurrentScreen(
+    struct _DeviceIntRec* /*pDev*/,
+    ScreenPtr /*newScreen*/,
+    int /*x*/,
+    int /*y*/);
+
+extern _X_EXPORT Bool PointerConfinedToScreen(struct _DeviceIntRec* /* pDev */);
+
+extern _X_EXPORT void GetSpritePosition(
+    struct _DeviceIntRec* /* pDev */,
+    int * /*px*/,
+    int * /*py*/);
+
+#ifdef PANORAMIX
+extern _X_EXPORT int XineramaGetCursorScreen(struct _DeviceIntRec* pDev);
+#endif /* PANORAMIX */
+
+#endif /* CURSOR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxfont.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxfont.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for font-related functions.  \see dmxfont.c */
+
+#ifndef DMXFONT_H
+#define DMXFONT_H
+
+#include <X11/fonts/fontstruct.h>
+
+/** Font private area. */
+typedef struct _dmxFontPriv {
+    int          refcnt;
+    XFontStruct **font;
+} dmxFontPrivRec, *dmxFontPrivPtr;
+
+extern void dmxInitFonts(void);
+extern void dmxResetFonts(void);
+
+extern Bool dmxRealizeFont(ScreenPtr pScreen, FontPtr pFont);
+extern Bool dmxUnrealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern Bool dmxBELoadFont(ScreenPtr pScreen, FontPtr pFont);
+extern Bool dmxBEFreeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern int dmxFontPrivateIndex;
+
+#endif /* DMXFONT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Config.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Config.h
@@ -0,0 +1,72 @@
+
+/*
+ * Copyright (c) 1997-2000 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86_config_h
+#define _xf86_config_h
+
+#include "xf86Optrec.h"
+#include "xf86Parser.h"
+#include "xf86str.h"
+
+#ifdef HAVE_PARSER_DECLS
+/*
+ * global structure that holds the result of parsing the config file
+ */
+extern _X_EXPORT XF86ConfigPtr xf86configptr;
+#endif
+
+typedef enum _ConfigStatus {
+    CONFIG_OK = 0,
+    CONFIG_PARSE_ERROR,
+    CONFIG_NOFILE
+} ConfigStatus;
+
+typedef struct _ModuleDefault {
+    char *name;
+    Bool toLoad;
+    XF86OptionPtr load_opt;
+} ModuleDefault;
+
+/*
+ * prototypes
+ */
+char ** xf86ModulelistFromConfig(pointer **);
+char ** xf86DriverlistFromConfig(void);
+char ** xf86DriverlistFromCompile(void);
+char ** xf86InputDriverlistFromConfig(void);
+Bool xf86BuiltinInputDriver(const char *);
+ConfigStatus xf86HandleConfigFile(Bool);
+
+Bool xf86AutoConfig(void);
+GDevPtr autoConfigDevice(GDevPtr preconf_device);
+
+#endif /* _xf86_config_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxparse.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxparse.h
@@ -0,0 +1,297 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to DMX configuration file parser.  \see dmxparse.c */
+
+#ifndef _DMXPARSE_H_
+#define _DMXPARSE_H_
+
+#include <stdio.h>              /* For FILE */
+
+/** Stores tokens not stored in other structures (e.g., keywords and ;) */
+typedef struct _DMXConfigToken {
+    int                      token;
+    int                      line;
+    const char               *comment;
+} DMXConfigToken, *DMXConfigTokenPtr;
+
+/** Stores parsed strings. */
+typedef struct _DMXConfigString {
+    int                      token;
+    int                      line;
+    const char               *comment;
+    const char               *string;
+    struct _DMXConfigString  *next;
+} DMXConfigString, *DMXConfigStringPtr;
+
+/** Stores parsed numbers. */
+typedef struct _DMXConfigNumber {
+    int                      token;
+    int                      line;
+    const char               *comment;
+    int                      number;
+} DMXConfigNumber, *DMXConfigNumberPtr;
+
+/** Stores parsed pairs (e.g., x y) */
+typedef struct _DMXConfigPair {
+    int                      token;
+    int                      line;
+    const char               *comment;
+    int                      x;
+    int                      y;
+    int                      xsign;
+    int                      ysign;
+} DMXConfigPair, *DMXConfigPairPtr;
+
+/** Stores parsed comments not stored with a token. */
+typedef struct _DMXConfigComment {
+    int                      token;
+    int                      line;
+    const char               *comment;
+} DMXConfigComment, *DMXConfigCommentPtr;
+
+typedef enum {
+    dmxConfigComment,
+    dmxConfigVirtual,
+    dmxConfigDisplay,
+    dmxConfigWall,
+    dmxConfigOption,
+    dmxConfigParam
+} DMXConfigType;
+
+/** Stores a geometry specification. */
+typedef struct _DMXConfigPartDim {
+    DMXConfigPairPtr         dim;
+    DMXConfigPairPtr         offset;
+} DMXConfigPartDim, *DMXConfigPartDimPtr;
+
+/** Stores a pair of geometry specifications. */
+typedef struct _DMXConfigFullDim {
+    DMXConfigPartDimPtr      scrn;
+    DMXConfigPartDimPtr      root;
+} DMXConfigFullDim, *DMXConfigFullDimPtr;
+
+/** Stores parsed display information. */
+typedef struct _DMXConfigDisplay {
+                                /* Summary information */
+    const char               *name;
+                                /* Screen Window Geometry */
+    int                      scrnWidth, scrnHeight;
+    int                      scrnX, scrnY;
+    int                      scrnXSign, scrnYSign;
+                                /* Root Window Geometry */
+    int                      rootWidth, rootHeight;
+    int                      rootX, rootY;
+    int                      rootXSign, rootYSign;
+                                /* Origin in global space */
+    int                      rootXOrigin, rootYOrigin;
+    
+                                /* Raw configuration information */
+    DMXConfigTokenPtr        start;
+    DMXConfigStringPtr       dname;
+    DMXConfigFullDimPtr      dim;
+    DMXConfigPairPtr         origin;
+    DMXConfigTokenPtr        end;
+} DMXConfigDisplay, *DMXConfigDisplayPtr;
+
+/** Stores parsed wall information. */
+typedef struct _DMXConfigWall {
+                                /* Summary information */
+    int                      width, height; /* dimensions of displays */
+    int                      xwall, ywall; /* dimensions of wall, in tiles */
+
+    
+                                /* Raw configuration informaiton */
+    DMXConfigTokenPtr        start;
+    DMXConfigPairPtr         wallDim;
+    DMXConfigPairPtr         displayDim;
+    DMXConfigStringPtr       nameList;
+    DMXConfigTokenPtr        end;
+} DMXConfigWall, *DMXConfigWallPtr;
+
+/** Stores parsed option information. */
+typedef struct _DMXConfigOption {
+                                /* Summary information */
+    char                     *string;
+    
+                                /* Raw configuration informaiton */
+    DMXConfigTokenPtr        start;
+    DMXConfigStringPtr       option;
+    DMXConfigTokenPtr        end;
+} DMXConfigOption, *DMXConfigOptionPtr;
+
+/** Stores parsed param information. */
+typedef struct _DMXConfigParam {
+    int                      argc;
+    const char               **argv;
+    
+    DMXConfigTokenPtr        start;
+    DMXConfigTokenPtr        open;
+    DMXConfigStringPtr       param;
+    DMXConfigTokenPtr        close;
+    DMXConfigTokenPtr        end; /* Either open/close OR end */
+    struct _DMXConfigParam   *next;
+} DMXConfigParam, *DMXConfigParamPtr;
+
+/** Stores options under an entry (subentry). */
+typedef struct _DMXConfigSub {
+    DMXConfigType             type;
+    DMXConfigCommentPtr       comment;
+    DMXConfigDisplayPtr       display;
+    DMXConfigWallPtr          wall;
+    DMXConfigOptionPtr        option;
+    DMXConfigParamPtr         param;
+    struct _DMXConfigSub      *next;
+} DMXConfigSub, *DMXConfigSubPtr;
+
+/** Stores parsed virtual information. */
+typedef struct _DMXConfigVirtual {
+                                /* Summary information */
+    const char                *name;
+    int                       width, height;
+
+                                /* Raw configuration information */
+    DMXConfigTokenPtr         start;
+    DMXConfigStringPtr        vname;
+    DMXConfigPairPtr          dim;
+    DMXConfigTokenPtr         open;
+    DMXConfigSubPtr           subentry;
+    DMXConfigTokenPtr         close;
+} DMXConfigVirtual, *DMXConfigVirtualPtr;
+
+/** Heads entry storage. */
+typedef struct _DMXConfigEntry {
+    DMXConfigType            type;
+    DMXConfigCommentPtr      comment;
+    DMXConfigVirtualPtr      virtual;
+    struct _DMXConfigEntry   *next;
+} DMXConfigEntry, *DMXConfigEntryPtr;
+
+extern DMXConfigEntryPtr   dmxConfigEntry;
+
+extern int                 yylex(void);
+extern int                 yydebug;
+extern void                yyerror(const char *message);
+
+extern void                dmxConfigLog(const char *format, ...);
+extern void                *dmxConfigAlloc(unsigned long bytes);
+extern void                *dmxConfigRealloc(void *orig,
+                                             unsigned long orig_bytes,
+                                             unsigned long bytes);
+extern const char          *dmxConfigCopyString(const char *string,
+                                                int length);
+extern void                dmxConfigFree(void *area);
+extern DMXConfigTokenPtr   dmxConfigCreateToken(int token, int line,
+                                                const char *comment);
+extern void                dmxConfigFreeToken(DMXConfigTokenPtr p);
+extern DMXConfigStringPtr  dmxConfigCreateString(int token, int line,
+                                                 const char *comment,
+                                                 const char *string);
+extern void                dmxConfigFreeString(DMXConfigStringPtr p);
+extern DMXConfigNumberPtr  dmxConfigCreateNumber(int token, int line,
+                                                 const char *comment,
+                                                 int number);
+extern void                dmxConfigFreeNumber(DMXConfigNumberPtr p);
+extern DMXConfigPairPtr    dmxConfigCreatePair(int token, int line,
+                                               const char *comment,
+                                               int x, int y,
+                                               int xsign, int ysign);
+extern void                dmxConfigFreePair(DMXConfigPairPtr p);
+extern DMXConfigCommentPtr dmxConfigCreateComment(int token, int line,
+                                                  const char *comment);
+extern void                dmxConfigFreeComment(DMXConfigCommentPtr p);
+extern DMXConfigPartDimPtr dmxConfigCreatePartDim(DMXConfigPairPtr pDim,
+                                                  DMXConfigPairPtr pOffset);
+extern void                dmxConfigFreePartDim(DMXConfigPartDimPtr p);
+extern DMXConfigFullDimPtr dmxConfigCreateFullDim(DMXConfigPartDimPtr pScrn,
+                                                  DMXConfigPartDimPtr pRoot);
+extern void                dmxConfigFreeFullDim(DMXConfigFullDimPtr p);
+extern DMXConfigDisplayPtr dmxConfigCreateDisplay(DMXConfigTokenPtr pStart,
+                                                  DMXConfigStringPtr pName,
+                                                  DMXConfigFullDimPtr pDim,
+                                                  DMXConfigPairPtr pOrigin,
+                                                  DMXConfigTokenPtr pEnd);
+extern void                dmxConfigFreeDisplay(DMXConfigDisplayPtr p);
+extern DMXConfigWallPtr    dmxConfigCreateWall(DMXConfigTokenPtr pStart,
+                                               DMXConfigPairPtr pWallDim,
+                                               DMXConfigPairPtr pDisplayDim,
+                                               DMXConfigStringPtr pNameList,
+                                               DMXConfigTokenPtr pEnd);
+extern void                dmxConfigFreeWall(DMXConfigWallPtr p);
+extern DMXConfigOptionPtr  dmxConfigCreateOption(DMXConfigTokenPtr pStart,
+                                                 DMXConfigStringPtr pOption,
+                                                 DMXConfigTokenPtr pEnd);
+extern void                dmxConfigFreeOption(DMXConfigOptionPtr p);
+extern DMXConfigParamPtr   dmxConfigCreateParam(DMXConfigTokenPtr pStart,
+                                                DMXConfigTokenPtr pOpen,
+                                                DMXConfigStringPtr pParam,
+                                                DMXConfigTokenPtr pClose,
+                                                DMXConfigTokenPtr pEnd);
+extern void                dmxConfigFreeParam(DMXConfigParamPtr p);
+extern const char          **dmxConfigLookupParam(DMXConfigParamPtr p,
+                                                  const char *key,
+                                                  int *argc);
+extern DMXConfigSubPtr     dmxConfigCreateSub(DMXConfigType type,
+                                              DMXConfigCommentPtr comment,
+                                              DMXConfigDisplayPtr display,
+                                              DMXConfigWallPtr wall,
+                                              DMXConfigOptionPtr option,
+                                              DMXConfigParamPtr param);
+extern void                dmxConfigFreeSub(DMXConfigSubPtr sub);
+extern DMXConfigSubPtr     dmxConfigSubComment(DMXConfigCommentPtr comment);
+extern DMXConfigSubPtr     dmxConfigSubDisplay(DMXConfigDisplayPtr display);
+extern DMXConfigSubPtr     dmxConfigSubWall(DMXConfigWallPtr wall);
+extern DMXConfigSubPtr     dmxConfigSubOption(DMXConfigOptionPtr option);
+extern DMXConfigSubPtr     dmxConfigSubParam(DMXConfigParamPtr param);
+extern DMXConfigSubPtr     dmxConfigAddSub(DMXConfigSubPtr head,
+                                           DMXConfigSubPtr sub);
+extern DMXConfigVirtualPtr dmxConfigCreateVirtual(DMXConfigTokenPtr pStart,
+                                                  DMXConfigStringPtr pName,
+                                                  DMXConfigPairPtr pDim,
+                                                  DMXConfigTokenPtr pOpen,
+                                                  DMXConfigSubPtr pSubentry,
+                                                  DMXConfigTokenPtr pClose);
+extern void                dmxConfigFreeVirtual(DMXConfigVirtualPtr virtual);
+extern DMXConfigEntryPtr   dmxConfigCreateEntry(DMXConfigType type,
+                                                DMXConfigCommentPtr comment,
+                                                DMXConfigVirtualPtr virtual);
+extern void                dmxConfigFreeEntry(DMXConfigEntryPtr entry);
+extern DMXConfigEntryPtr   dmxConfigAddEntry(DMXConfigEntryPtr head,
+                                             DMXConfigType type,
+                                             DMXConfigCommentPtr comment,
+                                             DMXConfigVirtualPtr virtual);
+extern DMXConfigEntryPtr   dmxConfigEntryComment(DMXConfigCommentPtr comment);
+extern DMXConfigEntryPtr   dmxConfigEntryVirtual(DMXConfigVirtualPtr virtual);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/colormapst.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/colormapst.h
@@ -0,0 +1,134 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+*/
+
+#ifndef CMAPSTRUCT_H
+#define CMAPSTRUCT_H 1
+
+#include <X11/Xarch.h>
+
+#include "colormap.h"
+#include "screenint.h"
+#include "privates.h"
+
+/* Shared color -- the color is used by AllocColorPlanes */
+typedef struct
+{
+    unsigned short color;
+    short  refcnt;
+} SHAREDCOLOR;
+
+/* LOCO -- a local color for a PseudoColor cell. DirectColor maps always
+ * use the first value (called red) in the structure.  What channel they
+ * are really talking about depends on which map they are in. */
+typedef struct
+{
+    unsigned short	red, green, blue;
+} LOCO;
+
+/* SHCO -- a shared color for a PseudoColor cell. Used with AllocColorPlanes.
+ * DirectColor maps always use the first value (called red) in the structure.
+ * What channel they are really talking about depends on which map they
+ * are in. */
+typedef struct 
+{
+    SHAREDCOLOR *red, *green, *blue;
+} SHCO;
+
+
+/* color map entry */
+typedef struct _CMEntry
+{
+    union
+    {
+	LOCO	local;
+	SHCO	shco;
+    } co;
+    short	refcnt;
+    Bool	fShared;
+} Entry;
+
+/*
+ * COLORMAPs can be used for either Direct or Pseudo color.  PseudoColor
+ * only needs one cell table, we arbitrarily pick red.  We keep track
+ * of that table with freeRed, numPixelsRed, and clientPixelsRed
+ *
+ * The padN variables are unfortunate ABI BC. See fdo bug #6924.
+ */
+
+typedef struct _ColormapRec
+{
+    VisualPtr	pVisual;
+    short	class;		/* PseudoColor or DirectColor */
+#if defined(_XSERVER64)
+    short	pad0;
+    XID		pad1;
+#endif
+    XID		mid;		/* client's name for colormap */
+#if defined(_XSERVER64) && (X_BYTE_ORDER == X_LITTLE_ENDIAN)
+    XID		pad2;
+#endif
+    ScreenPtr	pScreen;	/* screen map is associated with */
+    short	flags;		/* 1 = IsDefault
+				 * 2 = AllAllocated */
+    int		freeRed;
+    int		freeGreen;
+    int		freeBlue;
+    int		*numPixelsRed;	
+    int		*numPixelsGreen;	
+    int		*numPixelsBlue;	
+    Pixel	**clientPixelsRed;
+    Pixel	**clientPixelsGreen;
+    Pixel	**clientPixelsBlue;
+    Entry	*red;
+    Entry 	*green;
+    Entry	*blue;
+    pointer	devPriv;
+    PrivateRec	*devPrivates;	/* dynamic devPrivates added after devPriv
+				   already existed - must keep devPriv */
+} ColormapRec;
+	      
+#endif /* COLORMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkb.h
@@ -0,0 +1,32 @@
+#ifndef _XKB_H
+#define _XKB_H
+
+extern int ProcXkbUseExtension(ClientPtr client);
+extern int ProcXkbSelectEvents(ClientPtr client);
+extern int ProcXkbBell(ClientPtr client);
+extern int ProcXkbGetState(ClientPtr client);
+extern int ProcXkbLatchLockState(ClientPtr client);
+extern int ProcXkbGetControls(ClientPtr client);
+extern int ProcXkbSetControls(ClientPtr client);
+extern int ProcXkbGetMap(ClientPtr client);
+extern int ProcXkbSetMap(ClientPtr client);
+extern int ProcXkbGetCompatMap(ClientPtr client);
+extern int ProcXkbSetCompatMap(ClientPtr client);
+extern int ProcXkbGetIndicatorState(ClientPtr client);
+extern int ProcXkbGetIndicatorMap(ClientPtr client);
+extern int ProcXkbSetIndicatorMap(ClientPtr client);
+extern int ProcXkbGetNamedIndicator(ClientPtr client);
+extern int ProcXkbSetNamedIndicator(ClientPtr client);
+extern int ProcXkbGetNames(ClientPtr client);
+extern int ProcXkbSetNames(ClientPtr client);
+extern int ProcXkbGetGeometry(ClientPtr client);
+extern int ProcXkbSetGeometry(ClientPtr client);
+extern int ProcXkbPerClientFlags(ClientPtr client);
+extern int ProcXkbListComponents(ClientPtr client);
+extern int ProcXkbGetKbdByName(ClientPtr client);
+extern int ProcXkbGetDeviceInfo(ClientPtr client);
+extern int ProcXkbSetDeviceInfo(ClientPtr client);
+extern int ProcXkbSetDebuggingFlags(ClientPtr client);
+
+extern void XkbExtensionInit(void);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/selection.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/selection.h
@@ -0,0 +1,105 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SELECTION_H
+#define SELECTION_H 1
+
+#include "dixstruct.h"
+#include "privates.h"
+
+/*
+ *  Selection data structures 
+ */
+
+typedef struct _Selection {
+    Atom selection;
+    TimeStamp lastTimeChanged;
+    Window window;
+    WindowPtr pWin;
+    ClientPtr client;
+    struct _Selection *next;
+    PrivateRec *devPrivates;
+} Selection;
+
+
+/*
+ *  Selection API
+ */
+
+extern _X_EXPORT int dixLookupSelection(Selection **result, Atom name,
+		       ClientPtr client, Mask access_mode);
+
+extern _X_EXPORT Selection *CurrentSelections;
+
+extern _X_EXPORT CallbackListPtr SelectionCallback;
+
+typedef enum {
+    SelectionSetOwner,
+    SelectionWindowDestroy,
+    SelectionClientClose
+} SelectionCallbackKind;
+
+typedef struct {
+    struct _Selection	    *selection;
+    ClientPtr		    client;
+    SelectionCallbackKind   kind;
+} SelectionInfoRec;
+
+
+/*
+ *  Selection server internals
+ */
+
+extern _X_EXPORT void InitSelections(void);
+
+extern _X_EXPORT void DeleteWindowFromAnySelections(WindowPtr pWin);
+
+extern _X_EXPORT void DeleteClientFromAnySelections(ClientPtr client);
+
+#endif /* SELECTION_H */
+
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiquerydevice.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiquerydevice.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYDEV_H
+#define QUERYDEV_H 1
+
+#include <X11/extensions/XI2proto.h>
+
+int SProcXIQueryDevice(ClientPtr client);
+int ProcXIQueryDevice(ClientPtr client);
+void SRepXIQueryDevice(ClientPtr client, int size, xXIQueryDeviceReply *rep);
+int SizeDeviceClasses(DeviceIntPtr dev);
+int ListDeviceClasses(ClientPtr client, DeviceIntPtr dev,
+		      char* any, uint16_t* nclasses);
+int GetDeviceUse(DeviceIntPtr dev, uint16_t *attachment);
+int ListButtonInfo(DeviceIntPtr dev, xXIButtonInfo* info, Bool reportState);
+int ListKeyInfo(DeviceIntPtr dev, xXIKeyInfo* info);
+int ListValuatorInfo(DeviceIntPtr dev, xXIValuatorInfo* info,
+		     int axisnumber, Bool reportState);
+#endif /* QUERYDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miwideline.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miwideline.h
@@ -0,0 +1,120 @@
+/*
+
+Copyright 1988, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+/* Author:  Keith Packard, MIT X Consortium */
+
+#include "mispans.h"
+#include "mifpoly.h" /* for ICEIL */
+
+/*
+ * Polygon edge description for integer wide-line routines
+ */
+
+typedef struct _PolyEdge {
+    int	    height;	/* number of scanlines to process */
+    int	    x;		/* starting x coordinate */
+    int	    stepx;	/* fixed integral dx */
+    int	    signdx;	/* variable dx sign */
+    int	    e;		/* initial error term */
+    int	    dy;
+    int	    dx;
+} PolyEdgeRec, *PolyEdgePtr;
+
+#define SQSECANT 108.856472512142 /* 1/sin^2(11/2) - miter limit constant */
+
+/*
+ * types for general polygon routines
+ */
+
+typedef struct _PolyVertex {
+    double  x, y;
+} PolyVertexRec, *PolyVertexPtr;
+
+typedef struct _PolySlope {
+    int	    dx, dy;
+    double  k;	    /* x0 * dy - y0 * dx */
+} PolySlopeRec, *PolySlopePtr;
+
+/*
+ * Line face description for caps/joins
+ */
+
+typedef struct _LineFace {
+    double  xa, ya;
+    int	    dx, dy;
+    int	    x, y;
+    double  k;
+} LineFaceRec, *LineFacePtr;
+
+/*
+ * macros for polygon fillers
+ */
+
+#define MILINESETPIXEL(pDrawable, pGC, pixel, oldPixel) { \
+    oldPixel = pGC->fgPixel; \
+    if (pixel != oldPixel) { \
+	ChangeGCVal gcval; \
+	gcval.val = pixel; \
+	ChangeGC (NullClient, pGC, GCForeground, &gcval); \
+	ValidateGC (pDrawable, pGC); \
+    } \
+}
+#define MILINERESETPIXEL(pDrawable, pGC, pixel, oldPixel) { \
+    if (pixel != oldPixel) { \
+	ChangeGCVal gcval; \
+	gcval.val = oldPixel; \
+	ChangeGC (NullClient, pGC, GCForeground, &gcval); \
+	ValidateGC (pDrawable, pGC); \
+    } \
+}
+
+extern _X_EXPORT void miRoundJoinClip(
+    LineFacePtr /*pLeft*/,
+    LineFacePtr /*pRight*/,
+    PolyEdgePtr /*edge1*/,
+    PolyEdgePtr /*edge2*/,
+    int * /*y1*/,
+    int * /*y2*/,
+    Bool * /*left1*/,
+    Bool * /*left2*/
+);
+
+extern _X_EXPORT int miRoundCapClip(
+    LineFacePtr /*face*/,
+    Bool /*isInt*/,
+    PolyEdgePtr /*edge*/,
+    Bool * /*leftEdge*/
+);
+
+extern _X_EXPORT int miPolyBuildEdge(double x0, double y0, double k, int dx, int dy,
+				int xi, int yi, int left, PolyEdgePtr edge);
+extern _X_EXPORT int miPolyBuildPoly(PolyVertexPtr vertices, PolySlopePtr slopes,
+				int count, int xi, int yi, PolyEdgePtr left,
+				PolyEdgePtr right, int *pnleft, int *pnright,
+				int *h);
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaacexp.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaacexp.h
@@ -0,0 +1,127 @@
+
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <X11/Xarch.h>
+
+#ifndef FIXEDBASE
+#define CHECKRETURN(b) if(width <= ((b) * 32)) return(base + (b))
+#else
+#define CHECKRETURN(b) if(width <= ((b) * 32)) return(base)
+#endif
+
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+# define SHIFT_L(value, shift) ((value) >> (shift))
+# define SHIFT_R(value, shift) ((value) << (shift))
+#else
+# define SHIFT_L(value, shift) ((value) << (shift))
+# define SHIFT_R(value, shift) ((value) >> (shift))
+#endif
+
+#ifndef MSBFIRST
+# ifdef FIXEDBASE
+#   define WRITE_IN_BITORDER(dest, offset, data) *(dest) = data; 
+# else  
+#   define WRITE_IN_BITORDER(dest, offset, data) *(dest + offset) = data;
+# endif
+#else	
+# ifdef FIXEDBASE
+#   define WRITE_IN_BITORDER(dest, offset, data) *(dest) = SWAP_BITS_IN_BYTES(data);
+# else  
+#   define WRITE_IN_BITORDER(dest, offset, data) *(dest + offset) = SWAP_BITS_IN_BYTES(data)
+# endif
+#endif
+
+#ifdef FIXEDBASE
+# ifdef MSBFIRST
+#  define WRITE_BITS(b)   *base = SWAP_BITS_IN_BYTES(b)
+#  define WRITE_BITS1(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; }
+#  define WRITE_BITS2(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; }
+#  define WRITE_BITS3(b) { \
+	*base = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*base = byte_reversed_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_reversed_expand3[((b) & 0xFF000000) >> 24] << 8; }
+# else
+#  define WRITE_BITS(b)   *base = (b)
+#  define WRITE_BITS1(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; }
+#  define WRITE_BITS2(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; }
+#  define WRITE_BITS3(b) { \
+	*base = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*base = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*base = byte_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_expand3[((b) & 0xFF000000) >> 24] << 8; }
+# endif
+#else
+# ifdef MSBFIRST
+#  define WRITE_BITS(b)   *(base++) = SWAP_BITS_IN_BYTES(b)
+#  define WRITE_BITS1(b) { \
+	*(base++) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; }
+#  define WRITE_BITS2(b) { \
+	*(base) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	base += 2; }
+#  define WRITE_BITS3(b) { \
+	*(base) = byte_reversed_expand3[(b) & 0xFF] | \
+		byte_reversed_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_reversed_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_reversed_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*(base + 2) = byte_reversed_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_reversed_expand3[((b) & 0xFF000000) >> 24] << 8; \
+	base += 3; }
+# else
+#  define WRITE_BITS(b)   *(base++) = (b)
+#  define WRITE_BITS1(b) { \
+	*(base++) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; }
+#  define WRITE_BITS2(b) { \
+	*(base) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	base += 2; }
+#  define WRITE_BITS3(b) { \
+	*(base) = byte_expand3[(b) & 0xFF] | \
+		byte_expand3[((b) & 0xFF00) >> 8] << 24; \
+	*(base + 1) = byte_expand3[((b) & 0xFF00) >> 8] >> 8 | \
+		byte_expand3[((b) & 0xFF0000) >> 16] << 16; \
+	*(base + 2) = byte_expand3[((b) & 0xFF0000) >> 16] >> 16 | \
+		byte_expand3[((b) & 0xFF000000) >> 24] << 8; \
+	base += 3; }
+# endif
+#endif
+
+#ifdef FIXEDBASE
+# ifdef MSBFIRST
+#  define EXPNAME(x) x##MSBFirstFixedBase
+# else
+#  define EXPNAME(x) x##LSBFirstFixedBase
+# endif
+#else
+# ifdef MSBFIRST
+#  define EXPNAME(x) x##MSBFirst
+# else
+#  define EXPNAME(x) x##LSBFirst
+# endif
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/enterleave.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/enterleave.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef ENTERLEAVE_H
+#define ENTERLEAVE_H
+
+extern void DoEnterLeaveEvents(
+    DeviceIntPtr pDev,
+    int sourceid,
+    WindowPtr fromWin,
+    WindowPtr toWin,
+    int mode
+);
+
+extern void DoFocusEvents(
+    DeviceIntPtr pDev,
+    WindowPtr fromWin,
+    WindowPtr toWin,
+    int mode
+);
+
+extern void EnterLeaveEvent(
+    DeviceIntPtr mouse,
+    int type,
+    int mode,
+    int detail,
+    WindowPtr pWin,
+    Window child);
+
+extern WindowPtr CommonAncestor(
+    WindowPtr a,
+    WindowPtr b);
+
+extern void CoreEnterLeaveEvent(DeviceIntPtr mouse,
+                                int type,
+                                int mode,
+                                int detail,
+                                WindowPtr pWin,
+                                Window child);
+extern void DeviceEnterLeaveEvent(DeviceIntPtr mouse,
+                                  int sourceid,
+                                  int type,
+                                  int mode,
+                                  int detail,
+                                  WindowPtr pWin,
+                                  Window child);
+
+extern void EnterWindow(DeviceIntPtr dev,
+                        WindowPtr win,
+                        int mode);
+
+extern void LeaveWindow(DeviceIntPtr dev);
+
+extern void CoreFocusEvent(DeviceIntPtr kbd,
+                           int type,
+                           int mode,
+                           int detail,
+                           WindowPtr pWin);
+
+extern void DeviceFocusEvent(DeviceIntPtr kbd,
+                             int type,
+                             int mode,
+                             int detail,
+                             WindowPtr pWin);
+
+extern void SetFocusIn(DeviceIntPtr kbd,
+                       WindowPtr win);
+
+extern void SetFocusOut(DeviceIntPtr dev);
+#endif /* _ENTERLEAVE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/opaque.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/opaque.h
@@ -0,0 +1,78 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifndef OPAQUE_H
+#define OPAQUE_H
+
+#include <X11/Xmd.h>
+
+#include "globals.h"
+
+extern _X_EXPORT char *defaultTextFont;
+extern _X_EXPORT char *defaultCursorFont;
+extern _X_EXPORT int MaxClients;
+extern _X_EXPORT volatile char isItTimeToYield;
+extern _X_EXPORT volatile char dispatchException;
+
+/* bit values for dispatchException */
+#define DE_RESET     1
+#define DE_TERMINATE 2
+#define DE_PRIORITYCHANGE 4  /* set when a client's priority changes */
+
+extern _X_EXPORT CARD32 TimeOutValue;
+extern _X_EXPORT int ScreenSaverBlanking;
+extern _X_EXPORT int ScreenSaverAllowExposures;
+extern _X_EXPORT int defaultScreenSaverBlanking;
+extern _X_EXPORT int defaultScreenSaverAllowExposures;
+extern _X_EXPORT char *display;
+
+extern _X_EXPORT int defaultBackingStore;
+extern _X_EXPORT Bool disableBackingStore;
+extern _X_EXPORT Bool enableBackingStore;
+extern _X_EXPORT Bool PartialNetwork;
+#ifndef NOLOGOHACK
+extern _X_EXPORT int logoScreenSaver;
+#endif
+#ifdef RLIMIT_DATA
+extern _X_EXPORT int limitDataSpace;
+#endif
+#ifdef RLIMIT_STACK
+extern _X_EXPORT int limitStackSpace;
+#endif
+#ifdef RLIMIT_NOFILE
+extern _X_EXPORT int limitNoFile;
+#endif
+extern _X_EXPORT Bool defeatAccessControl;
+extern _X_EXPORT long maxBigRequestSize;
+extern _X_EXPORT Bool party_like_its_1989;
+extern _X_EXPORT Bool whiteRoot;
+
+extern _X_EXPORT Bool CoreDump;
+
+
+#endif /* OPAQUE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiX.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiX.h
@@ -0,0 +1,78 @@
+/*****************************************************************
+
+Copyright (c) 1991, 1997 Digital Equipment Corporation, Maynard, Massachusetts.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+DIGITAL EQUIPMENT CORPORATION BE LIABLE FOR ANY CLAIM, DAMAGES, INCLUDING,
+BUT NOT LIMITED TO CONSEQUENTIAL OR INCIDENTAL DAMAGES, OR OTHER LIABILITY,
+WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of Digital Equipment Corporation
+shall not be used in advertising or otherwise to promote the sale, use or other
+dealings in this Software without prior written authorization from Digital
+Equipment Corporation.
+
+******************************************************************/
+
+
+/* THIS IS NOT AN X PROJECT TEAM SPECIFICATION */
+
+/*  
+ *	PanoramiX definitions
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _PANORAMIX_H_
+#define _PANORAMIX_H_
+
+#define _PANORAMIX_SERVER
+#include <X11/extensions/panoramiXproto.h>
+#undef _PANORAMIX_SERVER
+#include "gcstruct.h"
+
+
+typedef struct _PanoramiXInfo {
+    XID id ;
+} PanoramiXInfo;
+
+typedef struct {
+    PanoramiXInfo info[MAXSCREENS];
+    RESTYPE type;
+    union {
+	struct {
+	    char   visibility;
+	    char   class;
+            char   root;
+	} win;
+	struct {
+	    Bool shared;
+	} pix;
+	struct {
+	    Bool root;
+	} pict;
+	char raw_data[4];
+    } u;
+} PanoramiXRes;
+
+#define FOR_NSCREENS_FORWARD(j) for(j = 0; j < PanoramiXNumScreens; j++)
+#define FOR_NSCREENS_BACKWARD(j) for(j = PanoramiXNumScreens - 1; j >= 0; j--)
+#define FOR_NSCREENS(j) FOR_NSCREENS_FORWARD(j)
+
+#define IS_SHARED_PIXMAP(r) (((r)->type == XRT_PIXMAP) && (r)->u.pix.shared)
+
+#endif /* _PANORAMIX_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/atKeynames.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/atKeynames.h
@@ -0,0 +1,292 @@
+/*
+ * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Thomas Roell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Thomas Roell makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _ATKEYNAMES_H
+#define _ATKEYNAMES_H
+
+#define XK_TECHNICAL
+#define	XK_KATAKANA
+#include <X11/keysym.h>
+#include <X11/XF86keysym.h>
+
+#define GLYPHS_PER_KEY	4
+#define NUM_KEYCODES	248
+#define MIN_KEYCODE     8
+#define MAX_KEYCODE     (NUM_KEYCODES + MIN_KEYCODE - 1)
+
+#define AltMask		Mod1Mask
+#define NumLockMask	Mod2Mask
+#define AltLangMask	Mod3Mask
+#define KanaMask	Mod4Mask
+#define ScrollLockMask	Mod5Mask
+
+/*
+ * NOTE: The AT/MF keyboards can generate (via the 8042) two (MF: three)
+ *       sets of scancodes. Set3 can only be generated by a MF keyboard.
+ *       Set2 sends a makecode for keypress, and the same code prefixed by a
+ *       F0 for keyrelease. This is a little bit ugly to handle. Thus we use
+ *       here for X386 the PC/XT compatible Set1. This set uses 8bit scancodes.
+ *       Bit 7 ist set if the key is released. The code E0 switches to a
+ *       different meaning to add the new MF cursorkeys, while not breaking old
+ *       applications. E1 is another special prefix. Since I assume that there
+ *       will be further versions of PC/XT scancode compatible keyboards, we
+ *       may be in trouble one day.
+ *
+ * IDEA: 1) Use Set2 on AT84 keyboards and translate it to MF Set3.
+ *       2) Use the keyboards native set and translate it to common keysyms.
+ */
+
+/*
+ * definition of the AT84/MF101/MF102 Keyboard:
+ * ============================================================
+ *       Defined             Key Cap Glyphs       Pressed value
+ *      Key Name            Main       Also       (hex)    (dec)
+ *      ----------------   ---------- -------    ------    ------
+ */
+
+#define KEY_Escape       /* Escape                0x01  */    1  
+#define KEY_1            /* 1           !         0x02  */    2 
+#define KEY_2            /* 2           @         0x03  */    3 
+#define KEY_3            /* 3           #         0x04  */    4 
+#define KEY_4            /* 4           $         0x05  */    5 
+#define KEY_5            /* 5           %         0x06  */    6 
+#define KEY_6            /* 6           ^         0x07  */    7 
+#define KEY_7            /* 7           &         0x08  */    8 
+#define KEY_8            /* 8           *         0x09  */    9 
+#define KEY_9            /* 9           (         0x0a  */   10 
+#define KEY_0            /* 0           )         0x0b  */   11 
+#define KEY_Minus        /* - (Minus)   _ (Under) 0x0c  */   12
+#define KEY_Equal        /* = (Equal)   +         0x0d  */   13 
+#define KEY_BackSpace    /* Back Space            0x0e  */   14 
+#define KEY_Tab          /* Tab                   0x0f  */   15
+#define KEY_Q            /* Q                     0x10  */   16
+#define KEY_W            /* W                     0x11  */   17
+#define KEY_E            /* E                     0x12  */   18
+#define KEY_R            /* R                     0x13  */   19
+#define KEY_T            /* T                     0x14  */   20
+#define KEY_Y            /* Y                     0x15  */   21
+#define KEY_U            /* U                     0x16  */   22
+#define KEY_I            /* I                     0x17  */   23
+#define KEY_O            /* O                     0x18  */   24
+#define KEY_P            /* P                     0x19  */   25
+#define KEY_LBrace       /* [           {         0x1a  */   26
+#define KEY_RBrace       /* ]           }         0x1b  */   27 
+#define KEY_Enter        /* Enter                 0x1c  */   28
+#define KEY_LCtrl        /* Ctrl(left)            0x1d  */   29
+#define KEY_A            /* A                     0x1e  */   30
+#define KEY_S            /* S                     0x1f  */   31
+#define KEY_D            /* D                     0x20  */   32 
+#define KEY_F            /* F                     0x21  */   33
+#define KEY_G            /* G                     0x22  */   34
+#define KEY_H            /* H                     0x23  */   35
+#define KEY_J            /* J                     0x24  */   36
+#define KEY_K            /* K                     0x25  */   37
+#define KEY_L            /* L                     0x26  */   38
+#define KEY_SemiColon    /* ;(SemiColon) :(Colon) 0x27  */   39
+#define KEY_Quote        /* ' (Apostr)  " (Quote) 0x28  */   40
+#define KEY_Tilde        /* ` (Accent)  ~ (Tilde) 0x29  */   41
+#define KEY_ShiftL       /* Shift(left)           0x2a  */   42
+#define KEY_BSlash       /* \(BckSlash) |(VertBar)0x2b  */   43
+#define KEY_Z            /* Z                     0x2c  */   44
+#define KEY_X            /* X                     0x2d  */   45
+#define KEY_C            /* C                     0x2e  */   46
+#define KEY_V            /* V                     0x2f  */   47
+#define KEY_B            /* B                     0x30  */   48
+#define KEY_N            /* N                     0x31  */   49
+#define KEY_M            /* M                     0x32  */   50
+#define KEY_Comma        /* , (Comma)   < (Less)  0x33  */   51
+#define KEY_Period       /* . (Period)  >(Greater)0x34  */   52
+#define KEY_Slash        /* / (Slash)   ?         0x35  */   53
+#define KEY_ShiftR       /* Shift(right)          0x36  */   54
+#define KEY_KP_Multiply  /* *                     0x37  */   55
+#define KEY_Alt          /* Alt(left)             0x38  */   56
+#define KEY_Space        /*   (SpaceBar)          0x39  */   57
+#define KEY_CapsLock     /* CapsLock              0x3a  */   58
+#define KEY_F1           /* F1                    0x3b  */   59
+#define KEY_F2           /* F2                    0x3c  */   60
+#define KEY_F3           /* F3                    0x3d  */   61
+#define KEY_F4           /* F4                    0x3e  */   62
+#define KEY_F5           /* F5                    0x3f  */   63
+#define KEY_F6           /* F6                    0x40  */   64
+#define KEY_F7           /* F7                    0x41  */   65
+#define KEY_F8           /* F8                    0x42  */   66
+#define KEY_F9           /* F9                    0x43  */   67
+#define KEY_F10          /* F10                   0x44  */   68
+#define KEY_NumLock      /* NumLock               0x45  */   69
+#define KEY_ScrollLock   /* ScrollLock            0x46  */   70
+#define KEY_KP_7         /* 7           Home      0x47  */   71 
+#define KEY_KP_8         /* 8           Up        0x48  */   72 
+#define KEY_KP_9         /* 9           PgUp      0x49  */   73 
+#define KEY_KP_Minus     /* - (Minus)             0x4a  */   74
+#define KEY_KP_4         /* 4           Left      0x4b  */   75
+#define KEY_KP_5         /* 5                     0x4c  */   76
+#define KEY_KP_6         /* 6           Right     0x4d  */   77
+#define KEY_KP_Plus      /* + (Plus)              0x4e  */   78
+#define KEY_KP_1         /* 1           End       0x4f  */   79
+#define KEY_KP_2         /* 2           Down      0x50  */   80
+#define KEY_KP_3         /* 3           PgDown    0x51  */   81
+#define KEY_KP_0         /* 0           Insert    0x52  */   82
+#define KEY_KP_Decimal   /* . (Decimal) Delete    0x53  */   83 
+#define KEY_SysReqest    /* SysReqest             0x54  */   84
+                         /* NOTUSED               0x55  */
+#define KEY_Less         /* < (Less)   >(Greater) 0x56  */   86
+#define KEY_F11          /* F11                   0x57  */   87
+#define KEY_F12          /* F12                   0x58  */   88
+
+#define KEY_Prefix0      /* special               0x60  */   96
+#define KEY_Prefix1      /* specail               0x61  */   97
+
+/*
+ * The 'scancodes' below are generated by the server, because the MF101/102
+ * keyboard sends them as sequence of other scancodes
+ */
+#define KEY_Home         /* Home                  0x59  */   89
+#define KEY_Up           /* Up                    0x5a  */   90
+#define KEY_PgUp         /* PgUp                  0x5b  */   91
+#define KEY_Left         /* Left                  0x5c  */   92
+#define KEY_Begin        /* Begin                 0x5d  */   93
+#define KEY_Right        /* Right                 0x5e  */   94
+#define KEY_End          /* End                   0x5f  */   95
+#define KEY_Down         /* Down                  0x60  */   96
+#define KEY_PgDown       /* PgDown                0x61  */   97
+#define KEY_Insert       /* Insert                0x62  */   98
+#define KEY_Delete       /* Delete                0x63  */   99
+#define KEY_KP_Enter     /* Enter                 0x64  */  100
+#define KEY_RCtrl        /* Ctrl(right)           0x65  */  101
+#define KEY_Pause        /* Pause                 0x66  */  102
+#define KEY_Print        /* Print                 0x67  */  103
+#define KEY_KP_Divide    /* Divide                0x68  */  104
+#define KEY_AltLang      /* AtlLang(right)        0x69  */  105
+#define KEY_Break        /* Break                 0x6a  */  106
+#define KEY_LMeta        /* Left Meta             0x6b  */  107
+#define KEY_RMeta        /* Right Meta            0x6c  */  108
+#define KEY_Menu         /* Menu                  0x6d  */  109
+#define KEY_F13          /* F13                   0x6e  */  110
+#define KEY_F14          /* F14                   0x6f  */  111
+#define KEY_F15          /* F15                   0x70  */  112
+#define KEY_HKTG         /* Hirugana/Katakana tog 0x70  */  112
+#define KEY_F16          /* F16                   0x71  */  113
+#define KEY_F17          /* F17                   0x72  */  114
+#define KEY_KP_DEC       /* KP_DEC                0x73  */  115
+#define KEY_BSlash2      /* \           _         0x73  */  115
+#define KEY_KP_Equal	 /* Equal (Keypad)        0x76  */  118
+#define KEY_XFER         /* Kanji Transfer        0x79  */  121
+#define KEY_NFER         /* No Kanji Transfer     0x7b  */  123
+#define KEY_Yen          /* Yen                   0x7d  */  125
+
+#define KEY_Power        /* Power Key             0x84  */  132
+#define KEY_Mute         /* Audio Mute            0x85  */  133
+#define KEY_AudioLower   /* Audio Lower           0x86  */  134
+#define KEY_AudioRaise   /* Audio Raise           0x87  */  135
+#define KEY_Help         /* Help                  0x88  */  136
+#define KEY_L1           /* Stop                  0x89  */  137
+#define KEY_L2           /* Again                 0x8a  */  138
+#define KEY_L3           /* Props                 0x8b  */  139
+#define KEY_L4           /* Undo                  0x8c  */  140
+#define KEY_L5           /* Front                 0x8d  */  141
+#define KEY_L6           /* Copy                  0x8e  */  142
+#define KEY_L7           /* Open                  0x8f  */  143
+#define KEY_L8           /* Paste                 0x90  */  144
+#define KEY_L9           /* Find                  0x91  */  145
+#define KEY_L10          /* Cut                   0x92  */  146
+
+/*
+ * Fake 'scancodes' in the following ranges are generated for 2-byte
+ * codes not handled elsewhere.  These correspond to most extended keys
+ * on so-called "Internet" keyboards:
+ *
+ *	0x79-0x93
+ *	0x96-0xa1
+ *	0xa3-0xac
+ *	0xb1-0xb4
+ *	0xba-0xbd
+ *	0xc2
+ *	0xcc-0xd2
+ *	0xd6-0xf7
+ */
+
+/*
+ * Remapped 'scancodes' are generated for single-byte codes in the range
+ * 0x59-0x5f,0x62-0x76.  These are used for some extra keys on some keyboards.
+ */
+
+#define KEY_0x59		0x95
+#define KEY_0x5A		0xA2
+#define KEY_0x5B		0xAD
+#define KEY_0x5C		KEY_KP_EQUAL
+#define KEY_0x5D		0xAE
+#define KEY_0x5E		0xAF
+#define KEY_0x5F		0xB0
+#define KEY_0x62		0xB5
+#define KEY_0x63		0xB6
+#define KEY_0x64		0xB7
+#define KEY_0x65		0xB8
+#define KEY_0x66		0xB9
+#define KEY_0x67		0xBE
+#define KEY_0x68		0xBF
+#define KEY_0x69		0xC0
+#define KEY_0x6A		0xC1
+#define KEY_0x6B		0xC3
+#define KEY_0x6C		0xC4
+#define KEY_0x6D		0xC5
+#define KEY_0x6E		0xC6
+#define KEY_0x6F		0xC7
+#define KEY_0x70		0xC8
+#define KEY_0x71		0xC9
+#define KEY_0x72		0xCA
+#define KEY_0x73		0xCB
+#define KEY_0x74		0xD3
+#define KEY_0x75		0xD4
+#define KEY_0x76		0xD5
+
+/* These are for "notused" and "unknown" entries in translation maps. */
+#define KEY_NOTUSED	  0
+#define KEY_UNKNOWN	255
+
+#endif /* _ATKEYNAMES_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86VGAarbiterPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86VGAarbiterPriv.h
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2009 Tiago Vignatti
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "misc.h"
+#include "xf86.h"
+#include "xf86_OSproc.h"
+#include <X11/X.h>
+#include "colormapst.h"
+#include "scrnintstr.h"
+#include "screenint.h"
+#include "gcstruct.h"
+#include "pixmapstr.h"
+#include "pixmap.h"
+#include "windowstr.h"
+#include "window.h"
+#include "xf86str.h"
+#include "mipointer.h"
+#include "mipointrst.h"
+# include "picturestr.h"
+
+
+#define WRAP_SCREEN(x,y) {pScreenPriv->x = pScreen->x; pScreen->x = y;}
+
+#define UNWRAP_SCREEN(x) pScreen->x = pScreenPriv->x
+
+#define SCREEN_PROLOG(x) pScreen->x = ((VGAarbiterScreenPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, VGAarbiterScreenKey))->x
+
+#define SCREEN_EPILOG(x,y) pScreen->x = y;
+
+#define WRAP_PICT(x,y) if (ps) {pScreenPriv->x = ps->x;\
+    ps->x = y;}
+
+#define UNWRAP_PICT(x) if (ps) {ps->x = pScreenPriv->x;}
+
+#define PICTURE_PROLOGUE(field) ps->field = \
+    ((VGAarbiterScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, \
+    VGAarbiterScreenKey))->field
+
+#define PICTURE_EPILOGUE(field, wrap) ps->field = wrap
+
+#define WRAP_SCREEN_INFO(x,y) do {pScreenPriv->x = pScrn->x; pScrn->x = y;} while(0)
+
+#define UNWRAP_SCREEN_INFO(x) pScrn->x = pScreenPriv->x
+
+#define SPRITE_PROLOG miPointerScreenPtr PointPriv = \
+    (miPointerScreenPtr)dixLookupPrivate(&pScreen->devPrivates, \
+    miPointerScreenKey); VGAarbiterScreenPtr pScreenPriv = \
+    ((VGAarbiterScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, \
+    VGAarbiterScreenKey)); PointPriv->spriteFuncs = pScreenPriv->miSprite;
+
+#define SPRITE_EPILOG pScreenPriv->miSprite = PointPriv->spriteFuncs;\
+    PointPriv->spriteFuncs  = &VGAarbiterSpriteFuncs;
+
+#define WRAP_SPRITE do { pScreenPriv->miSprite = PointPriv->spriteFuncs;\
+    	PointPriv->spriteFuncs  = &VGAarbiterSpriteFuncs; 		\
+	} while (0)
+
+#define UNWRAP_SPRITE PointPriv->spriteFuncs = pScreenPriv->miSprite
+
+#define GC_WRAP(x) pGCPriv->wrapOps = (x)->ops;\
+    pGCPriv->wrapFuncs = (x)->funcs; (x)->ops = &VGAarbiterGCOps;\
+    (x)->funcs = &VGAarbiterGCFuncs;
+
+#define GC_UNWRAP(x) VGAarbiterGCPtr  pGCPriv = \
+    (VGAarbiterGCPtr)dixLookupPrivate(&(x)->devPrivates, VGAarbiterGCKey);\
+    (x)->ops = pGCPriv->wrapOps; (x)->funcs = pGCPriv->wrapFuncs;
+
+#define GC_SCREEN register ScrnInfoPtr pScrn = \
+    xf86Screens[pGC->pScreen->myNum]
+
+#define VGAGet(x)\
+    pci_device_vgaarb_set_target(xf86Screens[pScreen->myNum]->vgaDev); \
+    pci_device_vgaarb_lock();
+
+#define VGAGet_GC(x)\
+    pci_device_vgaarb_set_target(xf86Screens[pGC->pScreen->myNum]->vgaDev); \
+    pci_device_vgaarb_lock();
+
+#define VGAPut(x)\
+    pci_device_vgaarb_unlock();
+
+#define VGAPut_GC(x)\
+    pci_device_vgaarb_unlock();
+
+
+typedef struct _VGAarbiterScreen {
+    CreateGCProcPtr             CreateGC;
+    CloseScreenProcPtr          CloseScreen;
+    ScreenBlockHandlerProcPtr   BlockHandler;
+    ScreenWakeupHandlerProcPtr  WakeupHandler;
+    GetImageProcPtr             GetImage;
+    GetSpansProcPtr             GetSpans;
+    SourceValidateProcPtr       SourceValidate;
+    CopyWindowProcPtr           CopyWindow;
+    ClearToBackgroundProcPtr    ClearToBackground;
+    CreatePixmapProcPtr         CreatePixmap;
+    SaveScreenProcPtr           SaveScreen;
+    /* Colormap */
+    StoreColorsProcPtr          StoreColors;
+    /* Cursor */
+    DisplayCursorProcPtr        DisplayCursor;
+    RealizeCursorProcPtr        RealizeCursor;
+    UnrealizeCursorProcPtr      UnrealizeCursor;
+    RecolorCursorProcPtr        RecolorCursor;
+    SetCursorPositionProcPtr    SetCursorPosition;
+    void                        (*AdjustFrame)(int,int,int,int);
+    Bool                        (*SwitchMode)(int, DisplayModePtr,int);
+    Bool                        (*EnterVT)(int, int);
+    void                        (*LeaveVT)(int, int);
+    void                        (*FreeScreen)(int, int);
+    miPointerSpriteFuncPtr      miSprite;
+    CompositeProcPtr            Composite;
+    GlyphsProcPtr               Glyphs;
+    CompositeRectsProcPtr       CompositeRects;
+} VGAarbiterScreenRec, *VGAarbiterScreenPtr;
+
+typedef struct _VGAarbiterGC {
+    GCOps                       *wrapOps;
+    GCFuncs                     *wrapFuncs;
+} VGAarbiterGCRec, *VGAarbiterGCPtr;
+
+/* Screen funcs */
+static void VGAarbiterBlockHandler(int i, pointer blockData, pointer pTimeout, pointer pReadmask);
+static void VGAarbiterWakeupHandler(int i, pointer blockData, unsigned long result, pointer pReadmask);
+static Bool VGAarbiterCloseScreen (int i, ScreenPtr pScreen);
+static void VGAarbiterGetImage (DrawablePtr pDrawable, int sx, int sy, int w,
+    int h, unsigned int format, unsigned long planemask, char *pdstLine);
+static void VGAarbiterGetSpans (DrawablePtr pDrawable, int wMax, DDXPointPtr
+    ppt, int *pwidth, int nspans, char  *pdstStart);
+static void VGAarbiterSourceValidate (DrawablePtr pDrawable, int x, int y,
+    int width, int height);
+static void VGAarbiterCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg,
+    RegionPtr prgnSrc);
+static void VGAarbiterClearToBackground (WindowPtr pWin, int x, int y, int w,
+    int h, Bool generateExposures);
+static PixmapPtr VGAarbiterCreatePixmap(ScreenPtr pScreen, int w, int h,
+    int depth, unsigned int usage_hint);
+static Bool  VGAarbiterCreateGC(GCPtr pGC);
+static Bool VGAarbiterSaveScreen(ScreenPtr pScreen, Bool unblank);
+static void VGAarbiterStoreColors (ColormapPtr pmap, int ndef, xColorItem
+    *pdefs);
+static void VGAarbiterRecolorCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
+    CursorPtr pCurs, Bool displayed);
+static Bool VGAarbiterRealizeCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
+    CursorPtr pCursor);
+static Bool VGAarbiterUnrealizeCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
+    CursorPtr pCursor);
+static Bool VGAarbiterDisplayCursor (DeviceIntPtr pDev, ScreenPtr pScreen,
+    CursorPtr pCursor);
+static Bool VGAarbiterSetCursorPosition (DeviceIntPtr pDev, ScreenPtr
+    pScreen, int x, int y, Bool generateEvent);
+static void VGAarbiterAdjustFrame(int index, int x, int y, int flags);
+static Bool VGAarbiterSwitchMode(int index, DisplayModePtr mode, int flags);
+static Bool VGAarbiterEnterVT(int index, int flags);
+static void VGAarbiterLeaveVT(int index, int flags);
+static void VGAarbiterFreeScreen(int index, int flags);
+
+/* GC funcs */
+static void VGAarbiterValidateGC(GCPtr pGC, unsigned long changes,
+    DrawablePtr pDraw);
+static void VGAarbiterChangeGC(GCPtr pGC, unsigned long mask);
+static void VGAarbiterCopyGC(GCPtr pGCSrc, unsigned long mask, GCPtr pGCDst);
+static void VGAarbiterDestroyGC(GCPtr pGC);
+static void VGAarbiterChangeClip(GCPtr pGC, int type, pointer pvalue,
+    int nrects);
+static void VGAarbiterDestroyClip(GCPtr pGC);
+static void VGAarbiterCopyClip(GCPtr pgcDst, GCPtr pgcSrc);
+
+/* GC ops */
+static void VGAarbiterFillSpans( DrawablePtr pDraw, GC *pGC, int nInit,
+    DDXPointPtr pptInit, int *pwidthInit, int fSorted);
+static void VGAarbiterSetSpans(DrawablePtr pDraw, GCPtr pGC, char *pcharsrc,
+    register DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+static void VGAarbiterPutImage(DrawablePtr pDraw, GCPtr pGC, int depth,
+    int x, int y, int w, int h, int leftPad, int format, char *pImage);
+static RegionPtr VGAarbiterCopyArea(DrawablePtr pSrc, DrawablePtr pDst,
+    GC *pGC, int srcx, int srcy, int width, int height, int dstx, int dsty);
+static RegionPtr VGAarbiterCopyPlane(DrawablePtr pSrc, DrawablePtr pDst,
+    GCPtr pGC, int srcx, int srcy, int width, int height, int dstx, int dsty,
+    unsigned long bitPlane);
+static void VGAarbiterPolyPoint(DrawablePtr pDraw, GCPtr pGC, int mode,
+    int npt, xPoint *pptInit);
+static void VGAarbiterPolylines(DrawablePtr pDraw, GCPtr pGC, int mode,
+    int npt, DDXPointPtr pptInit);
+static void VGAarbiterPolySegment(DrawablePtr pDraw, GCPtr pGC, int nseg,
+    xSegment *pSeg);
+static void VGAarbiterPolyRectangle(DrawablePtr pDraw, GCPtr pGC,
+    int nRectsInit, xRectangle *pRectsInit);
+static void VGAarbiterPolyArc(DrawablePtr pDraw, GCPtr pGC, int narcs,
+    xArc *parcs);
+static void VGAarbiterFillPolygon(DrawablePtr pDraw, GCPtr pGC, int shape,
+    int mode, int count, DDXPointPtr ptsIn);
+static void VGAarbiterPolyFillRect( DrawablePtr pDraw, GCPtr pGC,
+    int nrectFill, xRectangle *prectInit);
+static void VGAarbiterPolyFillArc(DrawablePtr pDraw, GCPtr pGC, int narcs,
+    xArc *parcs);
+static int VGAarbiterPolyText8(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+    int count, char *chars);
+static int VGAarbiterPolyText16(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+    int count, unsigned short *chars);
+static void VGAarbiterImageText8(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+    int count, char *chars);
+static void VGAarbiterImageText16(DrawablePtr pDraw, GCPtr pGC, int x, int y,
+    int count, unsigned short *chars);
+static void VGAarbiterImageGlyphBlt(DrawablePtr pDraw, GCPtr pGC, int xInit,
+    int yInit, unsigned int nglyph, CharInfoPtr *ppci, pointer pglyphBase);
+static void VGAarbiterPolyGlyphBlt(DrawablePtr pDraw, GCPtr pGC, int xInit,
+    int yInit, unsigned int nglyph, CharInfoPtr *ppci, pointer pglyphBase);
+static void VGAarbiterPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr
+    pDraw, int dx, int dy, int xOrg, int yOrg);
+
+/* miSpriteFuncs */
+static Bool VGAarbiterSpriteRealizeCursor(DeviceIntPtr pDev, ScreenPtr
+    pScreen, CursorPtr pCur);
+static Bool VGAarbiterSpriteUnrealizeCursor(DeviceIntPtr pDev, ScreenPtr
+    pScreen, CursorPtr pCur);
+static void VGAarbiterSpriteSetCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+    CursorPtr pCur, int x, int y);
+static void VGAarbiterSpriteMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+    int x, int y);
+static Bool VGAarbiterDeviceCursorInitialize(DeviceIntPtr pDev, ScreenPtr pScreen);
+static void VGAarbiterDeviceCursorCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);
+
+
+static void VGAarbiterComposite(CARD8 op, PicturePtr pSrc, PicturePtr pMask,
+    PicturePtr pDst, INT16 xSrc, INT16 ySrc, INT16 xMask, INT16 yMask,
+    INT16 xDst, INT16 yDst, CARD16 width, CARD16 height);
+static void VGAarbiterGlyphs(CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+    PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc, int nlist, GlyphListPtr
+    list, GlyphPtr *glyphs);
+static void VGAarbiterCompositeRects(CARD8 op, PicturePtr pDst, xRenderColor
+    *color, int nRect, xRectangle *rects);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxprint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxprint.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to DMX configuration file pretty-printer.  \see dmxprint.c */
+
+#ifndef _DMXPRINT_H_
+#define _DMXPRINT_H_
+
+void dmxConfigPrint(FILE *str, DMXConfigEntryPtr entry);
+void dmxConfigVirtualPrint(FILE *str, DMXConfigVirtualPtr p);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mi.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mi.h
@@ -0,0 +1,603 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MI_H
+#define MI_H
+#include <X11/X.h>
+#include "region.h"
+#include "validate.h"
+#include "window.h"
+#include "gc.h"
+#include <X11/fonts/font.h>
+#include "input.h"
+#include "cursor.h"
+#include "privates.h"
+#include "colormap.h"
+#include "events.h"
+
+#define MiBits	CARD32
+
+typedef struct _miDash *miDashPtr;
+#define EVEN_DASH	0
+#define ODD_DASH	~0
+
+/* miarc.c */
+
+extern _X_EXPORT void miPolyArc(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*narcs*/,
+    xArc * /*parcs*/
+);
+
+/* mibitblt.c */
+
+extern _X_EXPORT RegionPtr miCopyArea(
+    DrawablePtr /*pSrcDrawable*/,
+    DrawablePtr /*pDstDrawable*/,
+    GCPtr /*pGC*/,
+    int /*xIn*/,
+    int /*yIn*/,
+    int /*widthSrc*/,
+    int /*heightSrc*/,
+    int /*xOut*/,
+    int /*yOut*/
+);
+
+extern _X_EXPORT RegionPtr miCopyPlane(
+    DrawablePtr /*pSrcDrawable*/,
+    DrawablePtr /*pDstDrawable*/,
+    GCPtr /*pGC*/,
+    int /*srcx*/,
+    int /*srcy*/,
+    int /*width*/,
+    int /*height*/,
+    int /*dstx*/,
+    int /*dsty*/,
+    unsigned long /*bitPlane*/
+);
+
+extern _X_EXPORT void miGetImage(
+    DrawablePtr /*pDraw*/,
+    int /*sx*/,
+    int /*sy*/,
+    int /*w*/,
+    int /*h*/,
+    unsigned int /*format*/,
+    unsigned long /*planeMask*/,
+    char * /*pdstLine*/
+);
+
+extern _X_EXPORT void miPutImage(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*depth*/,
+    int /*x*/,
+    int /*y*/,
+    int /*w*/,
+    int /*h*/,
+    int /*leftPad*/,
+    int /*format*/,
+    char * /*pImage*/
+);
+
+/* micopy.c  */
+
+#define miGetCompositeClip(pGC) ((pGC)->pCompositeClip)
+
+typedef void	(*miCopyProc) (DrawablePtr  pSrcDrawable,
+			       DrawablePtr  pDstDrawable,
+			       GCPtr	    pGC,
+			       BoxPtr	    pDstBox,
+			       int	    nbox,
+			       int	    dx,
+			       int	    dy,
+			       Bool	    reverse,
+			       Bool	    upsidedown,
+			       Pixel	    bitplane,
+			       void	    *closure);
+
+extern _X_EXPORT void
+miCopyRegion (DrawablePtr   pSrcDrawable,
+	      DrawablePtr   pDstDrawable,
+	      GCPtr	    pGC,
+	      RegionPtr	    pDstRegion,
+	      int	    dx,
+	      int	    dy,
+	      miCopyProc    copyProc,
+	      Pixel	    bitPlane,
+	      void	    *closure);
+
+extern _X_EXPORT RegionPtr
+miDoCopy (DrawablePtr	pSrcDrawable,
+	  DrawablePtr	pDstDrawable,
+	  GCPtr		pGC,
+	  int		xIn, 
+	  int		yIn,
+	  int		widthSrc, 
+	  int		heightSrc,
+	  int		xOut, 
+	  int		yOut,
+	  miCopyProc	copyProc,
+	  Pixel		bitplane,
+	  void		*closure);
+
+/* micursor.c */
+
+extern _X_EXPORT void miRecolorCursor(
+    DeviceIntPtr /* pDev */,
+    ScreenPtr /*pScr*/,
+    CursorPtr /*pCurs*/,
+    Bool /*displayed*/
+);
+
+/* midash.c */
+
+extern _X_EXPORT void miStepDash(
+    int /*dist*/,
+    int * /*pDashIndex*/,
+    unsigned char * /*pDash*/,
+    int /*numInDashList*/,
+    int * /*pDashOffset*/
+);
+
+/* mieq.c */
+
+
+#ifndef INPUT_H
+typedef struct _DeviceRec *DevicePtr;
+#endif
+
+extern _X_EXPORT Bool mieqInit(
+    void
+);
+
+extern _X_EXPORT void mieqFini(void);
+
+extern _X_EXPORT void mieqEnqueue(
+    DeviceIntPtr /*pDev*/,
+    InternalEvent* /*e*/
+);
+
+extern _X_EXPORT void mieqSwitchScreen(
+    DeviceIntPtr /* pDev */,
+    ScreenPtr /*pScreen*/,
+    Bool /*fromDIX*/
+);
+
+extern _X_EXPORT void mieqProcessDeviceEvent(
+    DeviceIntPtr /* dev*/,
+    InternalEvent* /* event */,
+    ScreenPtr /* screen*/
+);
+
+extern _X_EXPORT void mieqProcessInputEvents(
+    void
+);
+
+extern DeviceIntPtr CopyGetMasterEvent(
+    DeviceIntPtr /* sdev */,
+    InternalEvent* /* original */,
+    InternalEvent* /* copy */
+);
+
+/**
+ * Custom input event handler. If you need to process input events in some
+ * other way than the default path, register an input event handler for the
+ * given internal event type.
+ */
+typedef void (*mieqHandler)(int screen, InternalEvent* event, DeviceIntPtr dev);
+void _X_EXPORT mieqSetHandler(int event, mieqHandler handler);
+
+/* miexpose.c */
+
+extern _X_EXPORT RegionPtr miHandleExposures(
+    DrawablePtr /*pSrcDrawable*/,
+    DrawablePtr /*pDstDrawable*/,
+    GCPtr /*pGC*/,
+    int /*srcx*/,
+    int /*srcy*/,
+    int /*width*/,
+    int /*height*/,
+    int /*dstx*/,
+    int /*dsty*/,
+    unsigned long /*plane*/
+);
+
+extern _X_EXPORT void miSendGraphicsExpose(
+    ClientPtr /*client*/,
+    RegionPtr /*pRgn*/,
+    XID /*drawable*/,
+    int /*major*/,
+    int /*minor*/
+);
+
+extern _X_EXPORT void miSendExposures(
+    WindowPtr /*pWin*/,
+    RegionPtr /*pRgn*/,
+    int /*dx*/,
+    int /*dy*/
+);
+
+extern _X_EXPORT void miWindowExposures(
+    WindowPtr /*pWin*/,
+    RegionPtr /*prgn*/,
+    RegionPtr /*other_exposed*/
+);
+
+extern _X_EXPORT void miPaintWindow(
+    WindowPtr /*pWin*/,
+    RegionPtr /*prgn*/,
+    int /*what*/
+);
+
+extern _X_EXPORT void miClearDrawable(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/
+);
+
+/* mifillrct.c */
+
+extern _X_EXPORT void miPolyFillRect(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*nrectFill*/,
+    xRectangle * /*prectInit*/
+);
+
+/* miglblt.c */
+
+extern _X_EXPORT void miPolyGlyphBlt(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    unsigned int /*nglyph*/,
+    CharInfoPtr * /*ppci*/,
+    pointer /*pglyphBase*/
+);
+
+extern _X_EXPORT void miImageGlyphBlt(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    unsigned int /*nglyph*/,
+    CharInfoPtr * /*ppci*/,
+    pointer /*pglyphBase*/
+);
+
+/* mipoly.c */
+
+extern _X_EXPORT void miFillPolygon(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*shape*/,
+    int /*mode*/,
+    int /*count*/,
+    DDXPointPtr /*pPts*/
+);
+
+/* mipolycon.c */
+
+extern _X_EXPORT Bool miFillConvexPoly(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*count*/,
+    DDXPointPtr /*ptsIn*/
+);
+
+/* mipolygen.c */
+
+extern _X_EXPORT Bool miFillGeneralPoly(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*count*/,
+    DDXPointPtr /*ptsIn*/
+);
+
+/* mipolypnt.c */
+
+extern _X_EXPORT void miPolyPoint(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*mode*/,
+    int /*npt*/,
+    xPoint * /*pptInit*/
+);
+
+/* mipolyrect.c */
+
+extern _X_EXPORT void miPolyRectangle(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*nrects*/,
+    xRectangle * /*pRects*/
+);
+
+/* mipolyseg.c */
+
+extern _X_EXPORT void miPolySegment(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*nseg*/,
+    xSegment * /*pSegs*/
+);
+
+/* mipolytext.c */
+
+extern _X_EXPORT int miPolyText8(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    int /*count*/,
+    char * /*chars*/
+);
+
+extern _X_EXPORT int miPolyText16(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    int /*count*/,
+    unsigned short * /*chars*/
+);
+
+extern _X_EXPORT void miImageText8(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    int /*count*/,
+    char * /*chars*/
+);
+
+extern _X_EXPORT void miImageText16(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*x*/,
+    int /*y*/,
+    int /*count*/,
+    unsigned short * /*chars*/
+);
+
+/* mipushpxl.c */
+
+extern _X_EXPORT void miPushPixels(
+    GCPtr /*pGC*/,
+    PixmapPtr /*pBitMap*/,
+    DrawablePtr /*pDrawable*/,
+    int /*dx*/,
+    int /*dy*/,
+    int /*xOrg*/,
+    int /*yOrg*/
+);
+
+/* miscrinit.c */
+
+extern _X_EXPORT Bool miModifyPixmapHeader(
+    PixmapPtr /*pPixmap*/,
+    int /*width*/,
+    int /*height*/,
+    int /*depth*/,
+    int /*bitsPerPixel*/,
+    int /*devKind*/,
+    pointer /*pPixData*/
+);
+
+extern _X_EXPORT Bool miCreateScreenResources(
+    ScreenPtr /*pScreen*/
+);
+
+extern _X_EXPORT Bool miScreenDevPrivateInit(
+    ScreenPtr /*pScreen*/,
+    int /*width*/,
+    pointer /*pbits*/
+);
+
+extern _X_EXPORT Bool miScreenInit(
+    ScreenPtr /*pScreen*/,
+    pointer /*pbits*/,
+    int /*xsize*/,
+    int /*ysize*/,
+    int /*dpix*/,
+    int /*dpiy*/,
+    int /*width*/,
+    int /*rootDepth*/,
+    int /*numDepths*/,
+    DepthPtr /*depths*/,
+    VisualID /*rootVisual*/,
+    int /*numVisuals*/,
+    VisualPtr /*visuals*/
+);
+
+extern _X_EXPORT DevPrivateKey miAllocateGCPrivateIndex(
+    void
+);
+
+/* mivaltree.c */
+
+extern _X_EXPORT int miShapedWindowIn(
+    RegionPtr /*universe*/,
+    RegionPtr /*bounding*/,
+    BoxPtr /*rect*/,
+    int /*x*/,
+    int /*y*/
+);
+
+typedef void 
+(*SetRedirectBorderClipProcPtr) (WindowPtr pWindow, RegionPtr pRegion);
+
+typedef RegionPtr
+(*GetRedirectBorderClipProcPtr) (WindowPtr pWindow);
+
+extern _X_EXPORT void
+miRegisterRedirectBorderClipProc (SetRedirectBorderClipProcPtr setBorderClip,
+				  GetRedirectBorderClipProcPtr getBorderClip);
+
+extern _X_EXPORT int miValidateTree(
+    WindowPtr /*pParent*/,
+    WindowPtr /*pChild*/,
+    VTKind /*kind*/
+);
+
+extern _X_EXPORT void miWideLine(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*mode*/,
+    int /*npt*/,
+    DDXPointPtr /*pPts*/
+);
+
+extern _X_EXPORT void miWideDash(
+    DrawablePtr /*pDrawable*/,
+    GCPtr /*pGC*/,
+    int /*mode*/,
+    int /*npt*/,
+    DDXPointPtr /*pPts*/
+);
+
+/* miwindow.c */
+
+extern _X_EXPORT void miClearToBackground(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/,
+    int /*w*/,
+    int /*h*/,
+    Bool /*generateExposures*/
+);
+
+extern _X_EXPORT void miMarkWindow(
+    WindowPtr /*pWin*/
+);
+
+extern _X_EXPORT Bool miMarkOverlappedWindows(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pFirst*/,
+    WindowPtr * /*ppLayerWin*/
+);
+
+extern _X_EXPORT void miHandleValidateExposures(
+    WindowPtr /*pWin*/
+);
+
+extern _X_EXPORT void miMoveWindow(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/,
+    WindowPtr /*pNextSib*/,
+    VTKind /*kind*/
+);
+
+extern _X_EXPORT void miSlideAndSizeWindow(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/,
+    unsigned int /*w*/,
+    unsigned int /*h*/,
+    WindowPtr /*pSib*/
+);
+
+extern _X_EXPORT WindowPtr miGetLayerWindow(
+    WindowPtr /*pWin*/
+);
+
+extern _X_EXPORT void miSetShape(
+    WindowPtr /*pWin*/,
+    int /*kind*/
+);
+
+extern _X_EXPORT void miChangeBorderWidth(
+    WindowPtr /*pWin*/,
+    unsigned int /*width*/
+);
+
+extern _X_EXPORT void miMarkUnrealizedWindow(
+    WindowPtr /*pChild*/,
+    WindowPtr /*pWin*/,
+    Bool /*fromConfigure*/
+);
+
+extern _X_EXPORT void miSegregateChildren(WindowPtr pWin, RegionPtr pReg, int depth);
+
+/* mizerarc.c */
+
+extern _X_EXPORT void miZeroPolyArc(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*narcs*/,
+    xArc * /*parcs*/
+);
+
+/* mizerline.c */
+
+extern _X_EXPORT void miZeroLine(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*mode*/,
+    int /*nptInit*/,
+    DDXPointRec * /*pptInit*/
+);
+
+extern _X_EXPORT void miZeroDashLine(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*mode*/,
+    int /*nptInit*/,
+    DDXPointRec * /*pptInit*/
+);
+
+extern _X_EXPORT void miPolyFillArc(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    int /*narcs*/,
+    xArc * /*parcs*/
+);
+
+#endif /* MI_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cursorstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cursorstr.h
@@ -0,0 +1,99 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CURSORSTRUCT_H
+#define CURSORSTRUCT_H 
+
+#include "cursor.h"
+#include "privates.h"
+/* 
+ * device-independent cursor storage
+ */
+
+/*
+ * source and mask point directly to the bits, which are in the server-defined
+ * bitmap format.
+ */
+typedef struct _CursorBits {
+    unsigned char *source;			/* points to bits */
+    unsigned char *mask;			/* points to bits */
+    Bool emptyMask;				/* all zeros mask */
+    unsigned short width, height, xhot, yhot;	/* metrics */
+    int refcnt;					/* can be shared */
+    PrivateRec *devPrivates;			/* set by pScr->RealizeCursor*/
+#ifdef ARGB_CURSOR
+    CARD32 *argb;				/* full-color alpha blended */
+#endif
+} CursorBits, *CursorBitsPtr;
+
+#define CURSOR_BITS_SIZE (sizeof(CursorBits) + dixPrivatesSize(PRIVATE_CURSOR_BITS))
+
+typedef struct _Cursor {
+    CursorBitsPtr bits;
+    unsigned short foreRed, foreGreen, foreBlue; /* device-independent color */
+    unsigned short backRed, backGreen, backBlue; /* device-independent color */
+    int refcnt;
+    PrivateRec *devPrivates;			/* set by pScr->RealizeCursor*/
+    XID id;
+#ifdef XFIXES
+    CARD32 serialNumber;
+    Atom name;
+#endif
+} CursorRec;
+
+#define CURSOR_REC_SIZE (sizeof(CursorRec) + dixPrivatesSize(PRIVATE_CURSOR))
+
+typedef struct _CursorMetric {
+    unsigned short width, height, xhot, yhot;
+} CursorMetricRec;
+
+typedef struct {
+    int                x, y;
+    ScreenPtr  pScreen;
+} HotSpot;
+
+#endif /* CURSORSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxvendor.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxvendor.h
@@ -0,0 +1,50 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef __GLXVENDOR_H
+#define __GLXVENDOR_H
+
+extern int __glXVForwardSingleReq( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardPipe0WithReply( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardAllWithReply( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXVForwardSingleReqSwap( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXVForwardPipe0WithReplySwap( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardPipe0WithReplySwapsv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardPipe0WithReplySwapiv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardPipe0WithReplySwapdv( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXVForwardAllWithReplySwap( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardAllWithReplySwapsv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardAllWithReplySwapiv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXVForwardAllWithReplySwapdv( __GLXclientState *cl, GLbyte *pc );
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/eventstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/eventstr.h
@@ -0,0 +1,246 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+#ifndef EVENTSTR_H
+#define EVENTSTR_H
+
+#include <events.h>
+/**
+ * @file events.h
+ * This file describes the event structures used internally by the X
+ * server during event generation and event processing.
+ *
+ * When are internal events used?
+ * Events from input devices are stored as internal events in the EQ and
+ * processed as internal events until late in the processing cycle. Only then
+ * do they switch to their respective wire events.
+ */
+
+/**
+ * Event types. Used exclusively internal to the server, not visible on the
+ * protocol.
+ *
+ * Note: Keep KeyPress to Motion aligned with the core events.
+ *       Keep ET_Raw* in the same order as KeyPress - Motion
+ */
+enum EventType {
+    ET_KeyPress = 2,
+    ET_KeyRelease,
+    ET_ButtonPress,
+    ET_ButtonRelease,
+    ET_Motion,
+    ET_Enter,
+    ET_Leave,
+    ET_FocusIn,
+    ET_FocusOut,
+    ET_ProximityIn,
+    ET_ProximityOut,
+    ET_DeviceChanged,
+    ET_Hierarchy,
+    ET_DGAEvent,
+    ET_RawKeyPress,
+    ET_RawKeyRelease,
+    ET_RawButtonPress,
+    ET_RawButtonRelease,
+    ET_RawMotion,
+    ET_XQuartz,
+    ET_Internal = 0xFF /* First byte */
+};
+
+#define CHECKEVENT(ev) if (ev && ((InternalEvent*)(ev))->any.header != 0xFF) \
+                          FatalError("Wrong event type %d.\n", \
+                                     ((InternalEvent*)(ev))->any.header);
+
+/**
+ * Used for ALL input device events internal in the server until
+ * copied into the matching protocol event.
+ *
+ * Note: We only use the device id because the DeviceIntPtr may become invalid while
+ * the event is in the EQ.
+ */
+struct _DeviceEvent
+{
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< One of EventType */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    union {
+        uint32_t button;  /**< Button number */
+        uint32_t key;     /**< Key code */
+    } detail;
+    int16_t root_x;       /**< Pos relative to root window in integral data */
+    float root_x_frac;    /**< Pos relative to root window in frac part */
+    int16_t root_y;       /**< Pos relative to root window in integral part */
+    float root_y_frac;    /**< Pos relative to root window in frac part */
+    uint8_t    buttons[(MAX_BUTTONS + 7)/8]; /**< Button mask */
+    struct {
+        uint8_t  mask[(MAX_VALUATORS + 7)/8]; /**< Valuator mask */
+        uint8_t  mode[(MAX_VALUATORS + 7)/8]; /**< Valuator mode (Abs or Rel)*/
+        uint32_t data[MAX_VALUATORS];         /**< Valuator data */
+        int32_t  data_frac[MAX_VALUATORS];    /**< Fractional part for data */
+    } valuators;
+    struct {
+        uint32_t base;    /**< XKB base modifiers */
+        uint32_t latched; /**< XKB latched modifiers */
+        uint32_t locked;  /**< XKB locked modifiers */
+        uint32_t effective;/**< XKB effective modifiers */
+    } mods;
+    struct {
+        uint8_t base;    /**< XKB base group */
+        uint8_t latched; /**< XKB latched group */
+        uint8_t locked;  /**< XKB locked group */
+        uint8_t effective;/**< XKB effective group */
+    } group;
+    Window      root; /**< Root window of the event */
+    int corestate;    /**< Core key/button state BEFORE the event */
+    int key_repeat;   /**< Internally-generated key repeat event */
+};
+
+
+/* Flags used in DeviceChangedEvent to signal if the slave has changed */
+#define DEVCHANGE_SLAVE_SWITCH 0x2
+/* Flags used in DeviceChangedEvent to signal whether the event was a
+ * pointer event or a keyboard event */
+#define DEVCHANGE_POINTER_EVENT 0x4
+#define DEVCHANGE_KEYBOARD_EVENT 0x8
+/* device capabilities changed */
+#define DEVCHANGE_DEVICE_CHANGE 0x10
+
+/**
+ * Sent whenever a device's capabilities have changed.
+ */
+struct _DeviceChangedEvent
+{
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< ET_DeviceChanged */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms */
+    int deviceid;         /**< Device whose capabilities have changed */
+    int flags;            /**< Mask of ::HAS_NEW_SLAVE,
+                               ::POINTER_EVENT, ::KEYBOARD_EVENT */
+    int masterid;         /**< MD when event was generated */
+    int sourceid;         /**< The device that caused the change */
+
+    struct {
+        int num_buttons;        /**< Number of buttons */
+        Atom names[MAX_BUTTONS];/**< Button names */
+    } buttons;
+
+    int num_valuators;          /**< Number of axes */
+    struct {
+        uint32_t min;           /**< Minimum value */
+        uint32_t max;           /**< Maximum value */
+        /* FIXME: frac parts of min/max */
+        uint32_t resolution;    /**< Resolution counts/m */
+        uint8_t mode;           /**< Relative or Absolute */
+        Atom name;              /**< Axis name */
+    } valuators[MAX_VALUATORS];
+
+    struct {
+        int min_keycode;
+        int max_keycode;
+    } keys;
+};
+
+#if XFreeXDGA
+/**
+ * DGAEvent, used by DGA to intercept and emulate input events.
+ */
+struct _DGAEvent
+{
+    unsigned char header; /**<  Always ET_Internal */
+    enum EventType type;  /**<  ET_DGAEvent */
+    int length;           /**<  Length in bytes */
+    Time time;            /**<  Time in ms */
+    int subtype;          /**<  KeyPress, KeyRelease, ButtonPress,
+                                ButtonRelease, MotionNotify */
+    int detail;           /**<  Relative x coordinate */
+    int dx;               /**<  Relative x coordinate */
+    int dy;               /**<  Relative y coordinate */
+    int screen;           /**<  Screen number this event applies to */
+    uint16_t state;       /**<  Core modifier/button state */
+};
+#endif
+
+/**
+ * Raw event, contains the data as posted by the device.
+ */
+struct _RawDeviceEvent
+{
+    unsigned char header; /**<  Always ET_Internal */
+    enum EventType type;  /**<  ET_Raw */
+    int length;           /**<  Length in bytes */
+    Time time;            /**<  Time in ms */
+    int deviceid;         /**< Device to post this event for */
+    int sourceid;         /**< The physical source device */
+    union {
+        uint32_t button;  /**< Button number */
+        uint32_t key;     /**< Key code */
+    } detail;
+    struct {
+        uint8_t  mask[(MAX_VALUATORS + 7)/8]; /**< Valuator mask */
+        int32_t  data[MAX_VALUATORS];         /**< Valuator data */
+        int32_t  data_frac[MAX_VALUATORS];    /**< Fractional part for data */
+        int32_t  data_raw[MAX_VALUATORS];     /**< Valuator data as posted */
+        int32_t  data_raw_frac[MAX_VALUATORS];/**< Fractional part for data_raw */
+    } valuators;
+};
+
+#ifdef XQUARTZ
+#define XQUARTZ_EVENT_MAXARGS 5
+struct _XQuartzEvent {
+    unsigned char header; /**< Always ET_Internal */
+    enum EventType type;  /**< Always ET_XQuartz */
+    int length;           /**< Length in bytes */
+    Time time;            /**< Time in ms. */
+    int subtype;          /**< Subtype defined by XQuartz DDX */
+    uint32_t data[XQUARTZ_EVENT_MAXARGS]; /**< Up to 5 32bit values passed to handler */
+};
+#endif
+
+/**
+ * Event type used inside the X server for input event
+ * processing.
+ */
+union _InternalEvent {
+        struct {
+            unsigned char header; /**< Always ET_Internal */
+            enum EventType type;  /**< One of ET_* */
+            int length;           /**< Length in bytes */
+            Time time;            /**< Time in ms. */
+        } any;
+        DeviceEvent device_event;
+        DeviceChangedEvent changed_event;
+#if XFreeXDGA
+        DGAEvent dga_event;
+#endif
+        RawDeviceEvent raw_event;
+#ifdef XQUARTZ
+        XQuartzEvent xquartz_event;
+#endif
+};
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xigrabdev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xigrabdev.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIGRABDEV_H
+#define XIGRABDEV_H 1
+
+int ProcXIGrabDevice(ClientPtr client);
+int SProcXIGrabDevice(ClientPtr client);
+
+int ProcXIUngrabDevice(ClientPtr client);
+int SProcXIUngrabDevice(ClientPtr client);
+
+void SRepXIGrabDevice(ClientPtr client, int size, xXIGrabDeviceReply * rep);
+
+#endif /* XIGRABDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vgaHW.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vgaHW.h
@@ -0,0 +1,235 @@
+
+
+/*
+ * Copyright (c) 1997,1998 The XFree86 Project, Inc.
+ *
+ * Loosely based on code bearing the following copyright:
+ *
+ *   Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Author: Dirk Hohndel
+ */
+
+#ifndef _VGAHW_H
+#define _VGAHW_H
+
+#include <X11/X.h>
+#include "misc.h"
+#include "input.h"
+#include "scrnintstr.h"
+#include "colormapst.h"
+
+#include "xf86str.h"
+#include "xf86Pci.h"
+
+#include "xf86DDC.h"
+
+#include "globals.h"
+#include <X11/extensions/dpmsconst.h>
+
+extern _X_EXPORT int vgaHWGetIndex(void);
+
+/*
+ * access macro
+ */
+#define VGAHWPTR(p) ((vgaHWPtr)((p)->privates[vgaHWGetIndex()].ptr))
+
+/* Standard VGA registers */
+#define VGA_ATTR_INDEX		0x3C0
+#define VGA_ATTR_DATA_W		0x3C0
+#define VGA_ATTR_DATA_R		0x3C1
+#define VGA_IN_STAT_0		0x3C2		/* read */
+#define VGA_MISC_OUT_W		0x3C2		/* write */
+#define VGA_ENABLE		0x3C3
+#define VGA_SEQ_INDEX		0x3C4
+#define VGA_SEQ_DATA		0x3C5
+#define VGA_DAC_MASK		0x3C6
+#define VGA_DAC_READ_ADDR	0x3C7
+#define VGA_DAC_WRITE_ADDR	0x3C8
+#define VGA_DAC_DATA		0x3C9
+#define VGA_FEATURE_R		0x3CA		/* read */
+#define VGA_MISC_OUT_R		0x3CC		/* read */
+#define VGA_GRAPH_INDEX		0x3CE
+#define VGA_GRAPH_DATA		0x3CF
+
+#define VGA_IOBASE_MONO		0x3B0
+#define VGA_IOBASE_COLOR	0x3D0
+
+#define VGA_CRTC_INDEX_OFFSET	0x04
+#define VGA_CRTC_DATA_OFFSET	0x05
+#define VGA_IN_STAT_1_OFFSET	0x0A		/* read */
+#define VGA_FEATURE_W_OFFSET	0x0A		/* write */
+
+/* default number of VGA registers stored internally */
+#define VGA_NUM_CRTC 25
+#define VGA_NUM_SEQ 5
+#define VGA_NUM_GFX 9
+#define VGA_NUM_ATTR 21
+
+/* Flags for vgaHWSave() and vgaHWRestore() */
+#define VGA_SR_MODE		0x01
+#define VGA_SR_FONTS		0x02
+#define VGA_SR_CMAP		0x04
+#define VGA_SR_ALL		(VGA_SR_MODE | VGA_SR_FONTS | VGA_SR_CMAP)
+
+/* Defaults for the VGA memory window */
+#define VGA_DEFAULT_PHYS_ADDR	0xA0000
+#define VGA_DEFAULT_MEM_SIZE	(64 * 1024)
+
+/*
+ * vgaRegRec contains settings of standard VGA registers.
+ */
+typedef struct {
+    unsigned char MiscOutReg;     /* */
+    unsigned char *CRTC;       /* Crtc Controller */
+    unsigned char *Sequencer;   /* Video Sequencer */
+    unsigned char *Graphics;    /* Video Graphics */
+    unsigned char *Attribute;  /* Video Atribute */
+    unsigned char DAC[768];       /* Internal Colorlookuptable */
+    unsigned char numCRTC;	/* number of CRTC registers, def=VGA_NUM_CRTC */
+    unsigned char numSequencer;	/* number of seq registers, def=VGA_NUM_SEQ */
+    unsigned char numGraphics;	/* number of gfx registers, def=VGA_NUM_GFX */
+    unsigned char numAttribute;	/* number of attr registers, def=VGA_NUM_ATTR */
+} vgaRegRec, *vgaRegPtr;
+
+typedef struct _vgaHWRec *vgaHWPtr;
+
+typedef void (*vgaHWWriteIndexProcPtr)(vgaHWPtr hwp, CARD8 indx, CARD8 value);
+typedef CARD8 (*vgaHWReadIndexProcPtr)(vgaHWPtr hwp, CARD8 indx);
+typedef void (*vgaHWWriteProcPtr)(vgaHWPtr hwp, CARD8 value);
+typedef CARD8 (*vgaHWReadProcPtr)(vgaHWPtr hwp);
+typedef void (*vgaHWMiscProcPtr)(vgaHWPtr hwp);
+
+
+/*
+ * vgaHWRec contains per-screen information required by the vgahw module.
+ *
+ * Note, the palette referred to by the paletteEnabled, enablePalette and
+ * disablePalette is the 16-entry (+overscan) EGA-compatible palette accessed
+ * via the first 17 attribute registers and not the main 8-bit palette.
+ */
+typedef struct _vgaHWRec {
+    pointer			Base;		/* Address of "VGA" memory */
+    int				MapSize;	/* Size of "VGA" memory */
+    unsigned long		MapPhys;	/* phys location of VGA mem */
+    int				IOBase;		/* I/O Base address */
+    CARD8 * 			MMIOBase;	/* Pointer to MMIO start */
+    int				MMIOOffset;	/* base + offset + vgareg
+						   = mmioreg */
+    pointer			FontInfo1;	/* save area for fonts in
+							plane 2 */ 
+    pointer			FontInfo2;	/* save area for fonts in	
+							plane 3 */ 
+    pointer			TextInfo;	/* save area for text */ 
+    vgaRegRec			SavedReg;	/* saved registers */
+    vgaRegRec			ModeReg;	/* register settings for
+							current mode */
+    Bool			ShowOverscan;
+    Bool			paletteEnabled;
+    Bool			cmapSaved;
+    ScrnInfoPtr			pScrn;
+    vgaHWWriteIndexProcPtr	writeCrtc;
+    vgaHWReadIndexProcPtr	readCrtc;
+    vgaHWWriteIndexProcPtr	writeGr;
+    vgaHWReadIndexProcPtr	readGr;
+    vgaHWReadProcPtr            readST00;
+    vgaHWReadProcPtr            readST01;
+    vgaHWReadProcPtr            readFCR;
+    vgaHWWriteProcPtr           writeFCR;
+    vgaHWWriteIndexProcPtr	writeAttr;
+    vgaHWReadIndexProcPtr	readAttr;
+    vgaHWWriteIndexProcPtr	writeSeq;
+    vgaHWReadIndexProcPtr	readSeq;
+    vgaHWWriteProcPtr		writeMiscOut;
+    vgaHWReadProcPtr		readMiscOut;
+    vgaHWMiscProcPtr		enablePalette;
+    vgaHWMiscProcPtr		disablePalette;
+    vgaHWWriteProcPtr		writeDacMask;
+    vgaHWReadProcPtr		readDacMask;
+    vgaHWWriteProcPtr		writeDacWriteAddr;
+    vgaHWWriteProcPtr		writeDacReadAddr;
+    vgaHWWriteProcPtr		writeDacData;
+    vgaHWReadProcPtr		readDacData;
+    pointer                     ddc;
+    IOADDRESS			PIOOffset;	/* offset + vgareg
+						   = pioreg */
+    vgaHWReadProcPtr		readEnable;
+    vgaHWWriteProcPtr		writeEnable;
+    struct pci_device          *dev;
+} vgaHWRec;
+
+/* Some macros that VGA drivers can use in their ChipProbe() function */
+#define VGAHW_GET_IOBASE()	((inb(VGA_MISC_OUT_R) & 0x01) ?		      \
+					 VGA_IOBASE_COLOR : VGA_IOBASE_MONO)
+
+#define OVERSCAN 0x11		/* Index of OverScan register */
+
+/* Flags that define how overscan correction should take place */
+#define KGA_FIX_OVERSCAN  1   /* overcan correction required */
+#define KGA_ENABLE_ON_ZERO 2  /* if possible enable display at beginning */
+                              /* of next scanline/frame                  */
+#define KGA_BE_TOT_DEC 4      /* always fix problem by setting blank end */
+			      /* to total - 1                            */
+#define BIT_PLANE 3		/* Which plane we write to in mono mode */
+#define BITS_PER_GUN 6
+#define COLORMAP_SIZE 256
+
+#if defined(__powerpc__) || defined(__arm__) || defined(__s390__)
+#define DACDelay(hw) /* No legacy VGA support */
+#else
+#define DACDelay(hw)							      \
+	do {								      \
+	    (void)inb((hw)->PIOOffset + (hw)->IOBase + VGA_IN_STAT_1_OFFSET); \
+	    (void)inb((hw)->PIOOffset + (hw)->IOBase + VGA_IN_STAT_1_OFFSET); \
+	} while (0)
+#endif
+
+/* Function Prototypes */
+
+/* vgaHW.c */
+
+typedef void vgaHWProtectProc(ScrnInfoPtr, Bool);
+typedef void vgaHWBlankScreenProc(ScrnInfoPtr, Bool);
+
+extern _X_EXPORT void vgaHWSetStdFuncs(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWSetMmioFuncs(vgaHWPtr hwp, CARD8 *base, int offset);
+extern _X_EXPORT void vgaHWProtect(ScrnInfoPtr pScrn, Bool on);
+extern _X_EXPORT vgaHWProtectProc *vgaHWProtectWeak(void);
+extern _X_EXPORT Bool vgaHWSaveScreen(ScreenPtr pScreen, int mode);
+extern _X_EXPORT void vgaHWBlankScreen(ScrnInfoPtr pScrn, Bool on);
+extern _X_EXPORT vgaHWBlankScreenProc *vgaHWBlankScreenWeak(void);
+extern _X_EXPORT void vgaHWSeqReset(vgaHWPtr hwp, Bool start);
+extern _X_EXPORT void vgaHWRestoreFonts(ScrnInfoPtr scrninfp, vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestoreMode(ScrnInfoPtr scrninfp, vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestoreColormap(ScrnInfoPtr scrninfp, vgaRegPtr restore);
+extern _X_EXPORT void vgaHWRestore(ScrnInfoPtr scrninfp, vgaRegPtr restore, int flags);
+extern _X_EXPORT void vgaHWSaveFonts(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSaveMode(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSaveColormap(ScrnInfoPtr scrninfp, vgaRegPtr save);
+extern _X_EXPORT void vgaHWSave(ScrnInfoPtr scrninfp, vgaRegPtr save, int flags);
+extern _X_EXPORT Bool vgaHWInit(ScrnInfoPtr scrnp, DisplayModePtr mode);
+extern _X_EXPORT Bool vgaHWSetRegCounts(ScrnInfoPtr scrp, int numCRTC, int numSequencer,
+                  	int numGraphics, int numAttribute);
+extern _X_EXPORT Bool vgaHWCopyReg(vgaRegPtr dst, vgaRegPtr src);
+extern _X_EXPORT Bool vgaHWGetHWRec(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWFreeHWRec(ScrnInfoPtr scrp);
+extern _X_EXPORT Bool vgaHWMapMem(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWUnmapMem(ScrnInfoPtr scrp);
+extern _X_EXPORT void vgaHWGetIOBase(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWLock(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWUnlock(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWEnable(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWDisable(vgaHWPtr hwp);
+extern _X_EXPORT void vgaHWDPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);
+extern _X_EXPORT Bool vgaHWHandleColormaps(ScreenPtr pScreen);
+extern _X_EXPORT void vgaHWddc1SetSpeed(ScrnInfoPtr pScrn, xf86ddcSpeed speed);
+extern _X_EXPORT CARD32 vgaHWHBlankKGA(DisplayModePtr mode, vgaRegPtr regp, int nBits,
+	       unsigned int Flags);
+extern _X_EXPORT CARD32 vgaHWVBlankKGA(DisplayModePtr mode, vgaRegPtr regp, int nBits,
+	       unsigned int Flags);
+extern _X_EXPORT Bool vgaHWAllocDefaultRegs(vgaRegPtr regp);
+
+extern _X_EXPORT DDC1SetSpeedProc vgaHWddc1SetSpeedWeak(void);
+extern _X_EXPORT SaveScreenProcPtr vgaHWSaveScreenWeak(void);
+
+#endif /* _VGAHW_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/singlesize.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/singlesize.h
@@ -0,0 +1,54 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _singlesize_h_
+#define _singlesize_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#include "indirect_size.h"
+
+extern GLint __glReadPixels_size(GLenum format, GLenum type,
+				 GLint width, GLint height);
+extern GLint __glGetMap_size(GLenum pname, GLenum query);
+extern GLint __glGetMapdv_size(GLenum target, GLenum query);
+extern GLint __glGetMapfv_size(GLenum target, GLenum query);
+extern GLint __glGetMapiv_size(GLenum target, GLenum query);
+extern GLint __glGetPixelMap_size(GLenum map);
+extern GLint __glGetPixelMapfv_size(GLenum map);
+extern GLint __glGetPixelMapuiv_size(GLenum map);
+extern GLint __glGetPixelMapusv_size(GLenum map);
+extern GLint __glGetTexImage_size(GLenum target, GLint level, GLenum format,
+				  GLenum type, GLint width, GLint height,
+				  GLint depth);
+
+#endif /* _singlesize_h_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Opt.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Opt.h
@@ -0,0 +1,117 @@
+
+/*
+ * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* Option handling things that ModuleSetup procs can use */
+
+#ifndef _XF86_OPT_H_
+#define _XF86_OPT_H_
+
+typedef struct {
+    double freq;
+    int units;
+} OptFrequency;
+
+typedef union {
+    unsigned long       num;
+    char *              str;
+    double              realnum;
+    Bool		bool;
+    OptFrequency	freq;
+} ValueUnion;
+    
+typedef enum {
+    OPTV_NONE = 0,
+    OPTV_INTEGER,
+    OPTV_STRING,                /* a non-empty string */
+    OPTV_ANYSTR,                /* Any string, including an empty one */
+    OPTV_REAL,
+    OPTV_BOOLEAN,
+    OPTV_PERCENT,
+    OPTV_FREQ
+} OptionValueType;
+
+typedef enum {
+    OPTUNITS_HZ = 1,
+    OPTUNITS_KHZ,
+    OPTUNITS_MHZ
+} OptFreqUnits;
+
+typedef struct {
+    int                 token;
+    const char*         name;
+    OptionValueType     type;
+    ValueUnion          value;
+    Bool                found;
+} OptionInfoRec, *OptionInfoPtr;
+
+extern _X_EXPORT int xf86SetIntOption(pointer optlist, const char *name, int deflt);
+extern _X_EXPORT double xf86SetRealOption(pointer optlist, const char *name, double deflt);
+extern _X_EXPORT char *xf86SetStrOption(pointer optlist, const char *name, char *deflt);
+extern _X_EXPORT int xf86SetBoolOption(pointer list, const char *name, int deflt );
+extern _X_EXPORT double xf86SetPercentOption(pointer list, const char *name, double deflt );
+extern _X_EXPORT int xf86CheckIntOption(pointer optlist, const char *name, int deflt);
+extern _X_EXPORT double xf86CheckRealOption(pointer optlist, const char *name, double deflt);
+extern _X_EXPORT char *xf86CheckStrOption(pointer optlist, const char *name, char *deflt);
+extern _X_EXPORT int xf86CheckBoolOption(pointer list, const char *name, int deflt );
+extern _X_EXPORT double xf86CheckPercentOption(pointer list, const char *name, double deflt );
+extern _X_EXPORT pointer xf86AddNewOption(pointer head, const char *name, const char *val );
+extern _X_EXPORT pointer xf86NewOption(char *name, char *value );
+extern _X_EXPORT pointer xf86NextOption(pointer list );
+extern _X_EXPORT pointer xf86OptionListCreate(const char **options, int count, int used);
+extern _X_EXPORT pointer xf86OptionListMerge(pointer head, pointer tail);
+extern _X_EXPORT void xf86OptionListFree(pointer opt);
+extern _X_EXPORT char *xf86OptionName(pointer opt);
+extern _X_EXPORT char *xf86OptionValue(pointer opt);
+extern _X_EXPORT void xf86OptionListReport(pointer parm);
+extern _X_EXPORT pointer xf86FindOption(pointer options, const char *name);
+extern _X_EXPORT char *xf86FindOptionValue(pointer options, const char *name);
+extern _X_EXPORT void xf86MarkOptionUsed(pointer option);
+extern _X_EXPORT void xf86MarkOptionUsedByName(pointer options, const char *name);
+extern _X_EXPORT Bool xf86CheckIfOptionUsed(pointer option);
+extern _X_EXPORT Bool xf86CheckIfOptionUsedByName(pointer options, const char *name);
+extern _X_EXPORT void xf86ShowUnusedOptions(int scrnIndex, pointer options);
+extern _X_EXPORT void xf86ProcessOptions(int scrnIndex, pointer options, OptionInfoPtr optinfo);
+extern _X_EXPORT OptionInfoPtr xf86TokenToOptinfo(const OptionInfoRec *table, int token);
+extern _X_EXPORT const char *xf86TokenToOptName(const OptionInfoRec *table, int token);
+extern _X_EXPORT Bool xf86IsOptionSet(const OptionInfoRec *table, int token);
+extern _X_EXPORT char *xf86GetOptValString(const OptionInfoRec *table, int token);
+extern _X_EXPORT Bool xf86GetOptValInteger(const OptionInfoRec *table, int token, int *value);
+extern _X_EXPORT Bool xf86GetOptValULong(const OptionInfoRec *table, int token, unsigned long *value);
+extern _X_EXPORT Bool xf86GetOptValReal(const OptionInfoRec *table, int token, double *value);
+extern _X_EXPORT Bool xf86GetOptValFreq(const OptionInfoRec *table, int token,
+			OptFreqUnits expectedUnits, double *value);
+extern _X_EXPORT Bool xf86GetOptValBool(const OptionInfoRec *table, int token, Bool *value);
+extern _X_EXPORT Bool xf86ReturnOptValBool(const OptionInfoRec *table, int token, Bool def);
+extern _X_EXPORT int xf86NameCmp(const char *s1, const char *s2);
+extern _X_EXPORT char *xf86NormalizeName(const char *s);
+extern _X_EXPORT pointer xf86ReplaceIntOption(pointer optlist,  const char *name, const int val);
+extern _X_EXPORT pointer xf86ReplaceRealOption(pointer optlist,  const char *name, const double val);
+extern _X_EXPORT pointer xf86ReplaceBoolOption(pointer optlist, const char *name, const Bool val);
+extern _X_EXPORT pointer xf86ReplacePercentOption(pointer optlist, const char *name, const double val);
+extern _X_EXPORT pointer xf86ReplaceStrOption(pointer optlist,  const char *name, const char* val);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mivalidate.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mivalidate.h
@@ -0,0 +1,52 @@
+/*
+
+Copyright 1993, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef MIVALIDATE_H
+#define MIVALIDATE_H
+
+#include "regionstr.h"
+
+typedef union _Validate {
+    struct BeforeValidate {
+	DDXPointRec	oldAbsCorner;	/* old window position */
+	RegionPtr	borderVisible;	/* visible region of border, */
+					/* non-null when size changes */
+	Bool		resized;	/* unclipped winSize has changed - */
+					/* don't call SaveDoomedAreas */
+    } before;
+    struct AfterValidate {
+	RegionRec	exposed;	/* exposed regions, absolute pos */
+	RegionRec	borderExposed;
+    } after;
+} ValidateRec;
+
+#endif /* MIVALIDATE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getprop.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getprop.h
@@ -0,0 +1,51 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETPROP_H
+#define GETPROP_H 1
+
+int SProcXGetDeviceDontPropagateList(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceDontPropagateList(ClientPtr	/* client */
+    );
+
+XEventClass *ClassFromMask(XEventClass * /* buf */ ,
+			   Mask /* mask */ ,
+			   int /* maskndx */ ,
+			   CARD16 * /* count */ ,
+			   int	/* mode */
+    );
+
+void SRepXGetDeviceDontPropagateList(ClientPtr /* client */ ,
+				     int /* size */ ,
+				     xGetDeviceDontPropagateListReply *	/* rep */
+    );
+
+#endif /* GETPROP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbDflts.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbDflts.h
@@ -0,0 +1,469 @@
+/* This file generated automatically by xkbcomp */
+/* DO  NOT EDIT */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DEFAULT_H
+#define DEFAULT_H 1
+
+#define GET_ATOM(d,s)	MakeAtom(s,strlen(s),1)
+#define DPYTYPE	char *
+#define NUM_KEYS	1
+
+#define	vmod_NumLock	0
+#define	vmod_Alt	1
+#define	vmod_LevelThree	2
+#define	vmod_AltGr	3
+#define	vmod_ScrollLock	4
+
+#define	vmod_NumLockMask	(1<<0)
+#define	vmod_AltMask	(1<<1)
+#define	vmod_LevelThreeMask	(1<<2)
+#define	vmod_AltGrMask	(1<<3)
+#define	vmod_ScrollLockMask	(1<<4)
+
+/* types name is "default" */
+static Atom lnames_ONE_LEVEL[1];
+
+static XkbKTMapEntryRec map_TWO_LEVEL[1]= {
+    { 1,      1, {       ShiftMask,       ShiftMask,               0 } }
+};
+static Atom lnames_TWO_LEVEL[2];
+
+static XkbKTMapEntryRec map_ALPHABETIC[2]= {
+    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
+    { 1,      0, {        LockMask,        LockMask,               0 } }
+};
+static XkbModsRec preserve_ALPHABETIC[2]= {
+    {                 0,               0,               0 },
+    {          LockMask,        LockMask,               0 }
+};
+static Atom lnames_ALPHABETIC[2];
+
+static XkbKTMapEntryRec map_KEYPAD[2]= {
+    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
+    { 0,      1, {               0,               0, vmod_NumLockMask } }
+};
+static Atom lnames_KEYPAD[2];
+
+static XkbKTMapEntryRec map_PC_BREAK[1]= {
+    { 1,      1, {     ControlMask,     ControlMask,               0 } }
+};
+static Atom lnames_PC_BREAK[2];
+
+static XkbKTMapEntryRec map_PC_SYSRQ[1]= {
+    { 0,      1, {               0,               0,    vmod_AltMask } }
+};
+static Atom lnames_PC_SYSRQ[2];
+
+static XkbKTMapEntryRec map_CTRL_ALT[1]= {
+    { 0,      1, {     ControlMask,     ControlMask,    vmod_AltMask } }
+};
+static Atom lnames_CTRL_ALT[2];
+
+static XkbKTMapEntryRec map_THREE_LEVEL[3]= {
+    { 1,      1, {       ShiftMask,       ShiftMask,               0 } },
+    { 0,      2, {               0,               0, vmod_LevelThreeMask } },
+    { 0,      2, {       ShiftMask,       ShiftMask, vmod_LevelThreeMask } }
+};
+static Atom lnames_THREE_LEVEL[3];
+
+static XkbKTMapEntryRec map_SHIFT_ALT[1]= {
+    { 0,      1, {       ShiftMask,       ShiftMask,    vmod_AltMask } }
+};
+static Atom lnames_SHIFT_ALT[2];
+
+static XkbKeyTypeRec dflt_types[]= {
+    {
+	{               0,               0,               0 },
+	1,
+	0,	NULL,	NULL,
+	None,	lnames_ONE_LEVEL
+    },
+    {
+	{       ShiftMask,       ShiftMask,               0 },
+	2,
+	1,	map_TWO_LEVEL,	NULL,
+	None,	lnames_TWO_LEVEL
+    },
+    {
+	{ ShiftMask|LockMask, ShiftMask|LockMask,               0 },
+	2,
+	2,	map_ALPHABETIC,	preserve_ALPHABETIC,
+	None,	lnames_ALPHABETIC
+    },
+    {
+	{       ShiftMask,       ShiftMask, vmod_NumLockMask },
+	2,
+	2,	map_KEYPAD,	NULL,
+	None,	lnames_KEYPAD
+    },
+    {
+	{     ControlMask,     ControlMask,               0 },
+	2,
+	1,	map_PC_BREAK,	NULL,
+	None,	lnames_PC_BREAK
+    },
+    {
+	{               0,               0,    vmod_AltMask },
+	2,
+	1,	map_PC_SYSRQ,	NULL,
+	None,	lnames_PC_SYSRQ
+    },
+    {
+	{     ControlMask,     ControlMask,    vmod_AltMask },
+	2,
+	1,	map_CTRL_ALT,	NULL,
+	None,	lnames_CTRL_ALT
+    },
+    {
+	{       ShiftMask,       ShiftMask, vmod_LevelThreeMask },
+	3,
+	3,	map_THREE_LEVEL,	NULL,
+	None,	lnames_THREE_LEVEL
+    },
+    {
+	{       ShiftMask,       ShiftMask,    vmod_AltMask },
+	2,
+	1,	map_SHIFT_ALT,	NULL,
+	None,	lnames_SHIFT_ALT
+    }
+};
+#define num_dflt_types (sizeof(dflt_types)/sizeof(XkbKeyTypeRec))
+
+
+static void
+initTypeNames(DPYTYPE dpy)
+{
+    dflt_types[0].name= GET_ATOM(dpy,"ONE_LEVEL");
+    lnames_ONE_LEVEL[0]=	GET_ATOM(dpy,"Any");
+    dflt_types[1].name= GET_ATOM(dpy,"TWO_LEVEL");
+    lnames_TWO_LEVEL[0]=	GET_ATOM(dpy,"Base");
+    lnames_TWO_LEVEL[1]=	GET_ATOM(dpy,"Shift");
+    dflt_types[2].name= GET_ATOM(dpy,"ALPHABETIC");
+    lnames_ALPHABETIC[0]=	GET_ATOM(dpy,"Base");
+    lnames_ALPHABETIC[1]=	GET_ATOM(dpy,"Caps");
+    dflt_types[3].name= GET_ATOM(dpy,"KEYPAD");
+    lnames_KEYPAD[0]=	GET_ATOM(dpy,"Base");
+    lnames_KEYPAD[1]=	GET_ATOM(dpy,"Number");
+    dflt_types[4].name= GET_ATOM(dpy,"PC_BREAK");
+    lnames_PC_BREAK[0]=	GET_ATOM(dpy,"Base");
+    lnames_PC_BREAK[1]=	GET_ATOM(dpy,"Control");
+    dflt_types[5].name= GET_ATOM(dpy,"PC_SYSRQ");
+    lnames_PC_SYSRQ[0]=	GET_ATOM(dpy,"Base");
+    lnames_PC_SYSRQ[1]=	GET_ATOM(dpy,"Alt");
+    dflt_types[6].name= GET_ATOM(dpy,"CTRL+ALT");
+    lnames_CTRL_ALT[0]=	GET_ATOM(dpy,"Base");
+    lnames_CTRL_ALT[1]=	GET_ATOM(dpy,"Ctrl+Alt");
+    dflt_types[7].name= GET_ATOM(dpy,"THREE_LEVEL");
+    lnames_THREE_LEVEL[0]=	GET_ATOM(dpy,"Base");
+    lnames_THREE_LEVEL[1]=	GET_ATOM(dpy,"Shift");
+    lnames_THREE_LEVEL[2]=	GET_ATOM(dpy,"Level3");
+    dflt_types[8].name= GET_ATOM(dpy,"SHIFT+ALT");
+    lnames_SHIFT_ALT[0]=	GET_ATOM(dpy,"Base");
+    lnames_SHIFT_ALT[1]=	GET_ATOM(dpy,"Shift+Alt");
+}
+/* compat name is "default" */
+static XkbSymInterpretRec dfltSI[69]= {
+    {    XK_ISO_Level2_Latch, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_Exactly, ShiftMask,
+         255,
+       {      XkbSA_LatchMods, { 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Eisu_Shift, 0x0000,
+         XkbSI_Exactly, LockMask,
+         255,
+       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Eisu_toggle, 0x0000,
+         XkbSI_Exactly, LockMask,
+         255,
+       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Kana_Shift, 0x0000,
+         XkbSI_Exactly, LockMask,
+         255,
+       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Kana_Lock, 0x0000,
+         XkbSI_Exactly, LockMask,
+         255,
+       {       XkbSA_NoAction, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Shift_Lock, 0x0000,
+         XkbSI_AnyOf, ShiftMask|LockMask,
+         255,
+       {       XkbSA_LockMods, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Num_Lock, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         0,
+       {       XkbSA_LockMods, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_Alt_L, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         1,
+       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Alt_R, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         1,
+       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Scroll_Lock, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         4,
+       {       XkbSA_LockMods, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Lock, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         255,
+       {        XkbSA_ISOLock, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Level3_Shift, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
+         2,
+       {        XkbSA_SetMods, { 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
+    {    XK_ISO_Level3_Latch, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOf, 0xff,
+         2,
+       {      XkbSA_LatchMods, { 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00 } } },
+    {    XK_Mode_switch, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
+         3,
+       {       XkbSA_SetGroup, { 0x05, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_1, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_End, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_2, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_Down, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_3, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_Next, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00 } } },
+    {    XK_KP_4, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Left, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_6, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Right, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_7, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_Home, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_8, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_Up, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_9, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_Prior, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {        XkbSA_MovePtr, { 0x00, 0x00, 0x01, 0xff, 0xff, 0x00, 0x00 } } },
+    {    XK_KP_5, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Begin, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_F1, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Divide, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_F2, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Multiply, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_F3, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Subtract, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x04, 0x01, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Separator, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Add, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_0, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Insert, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Decimal, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_KP_Delete, 0x0001,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Button_Dflt, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Button1, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Button2, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Button3, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_DblClick_Dflt, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_DblClick1, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_DblClick2, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_DblClick3, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {         XkbSA_PtrBtn, { 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Drag_Dflt, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Drag1, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Drag2, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_Drag3, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_LockPtrBtn, { 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_EnableKeys, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00 } } },
+    {    XK_Pointer_Accelerate, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00 } } },
+    {    XK_Pointer_DfltBtnNext, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_Pointer_DfltBtnPrev, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {     XkbSA_SetPtrDflt, { 0x00, 0x01, 0xff, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_AccessX_Enable, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {   XkbSA_LockControls, { 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00 } } },
+    {    XK_Terminate_Server, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {      XkbSA_Terminate, { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Group_Latch, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
+         3,
+       {     XkbSA_LatchGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Next_Group, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
+         3,
+       {      XkbSA_LockGroup, { 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Prev_Group, 0x0000,
+         XkbSI_LevelOneOnly|XkbSI_AnyOfOrNone, 0xff,
+         3,
+       {      XkbSA_LockGroup, { 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_First_Group, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {      XkbSA_LockGroup, { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    XK_ISO_Last_Group, 0x0000,
+         XkbSI_AnyOfOrNone, 0xff,
+         255,
+       {      XkbSA_LockGroup, { 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00 } } },
+    {    NoSymbol, 0x0000,
+         XkbSI_Exactly, LockMask,
+         255,
+       {       XkbSA_LockMods, { 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00 } } },
+    {    NoSymbol, 0x0000,
+         XkbSI_AnyOf, 0xff,
+         255,
+       {        XkbSA_SetMods, { 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } }
+};
+#define num_dfltSI (sizeof(dfltSI)/sizeof(XkbSymInterpretRec))
+
+static XkbCompatMapRec compatMap= {
+    dfltSI,
+    {   /* group compatibility */
+        {            0,            0,            0 },
+        {            0,            0, vmod_AltGrMask },
+        {            0,            0, vmod_AltGrMask },
+        {            0,            0, vmod_AltGrMask }
+    },
+    num_dfltSI, num_dfltSI
+};
+
+static void
+initIndicatorNames(DPYTYPE dpy,XkbDescPtr xkb)
+{
+    xkb->names->indicators[ 0]=	GET_ATOM(dpy,"Caps Lock");
+    xkb->names->indicators[ 1]=	GET_ATOM(dpy,"Num Lock");
+    xkb->names->indicators[ 2]=	GET_ATOM(dpy,"Shift Lock");
+    xkb->names->indicators[ 3]=	GET_ATOM(dpy,"Mouse Keys");
+    xkb->names->indicators[ 4]=	GET_ATOM(dpy,"Scroll Lock");
+    xkb->names->indicators[ 5]=	GET_ATOM(dpy,"Group 2");
+}
+#endif /* DEFAULT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/swapreq.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/swapreq.h
@@ -0,0 +1,108 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef SWAPREQ_H
+#define SWAPREQ_H 1
+
+extern _X_EXPORT void SwapColorItem(
+    xColorItem	* /* pItem */);
+
+extern _X_EXPORT void SwapConnClientPrefix(
+    xConnClientPrefix * /* pCCP */);
+
+#undef SWAPREQ_PROC
+
+#define SWAPREQ_PROC(func) extern _X_EXPORT int func(ClientPtr /* client */)
+
+SWAPREQ_PROC(SProcAllocColor);
+SWAPREQ_PROC(SProcAllocColorCells);
+SWAPREQ_PROC(SProcAllocColorPlanes);
+SWAPREQ_PROC(SProcAllocNamedColor);
+SWAPREQ_PROC(SProcChangeActivePointerGrab);
+SWAPREQ_PROC(SProcChangeGC);
+SWAPREQ_PROC(SProcChangeHosts);
+SWAPREQ_PROC(SProcChangeKeyboardControl);
+SWAPREQ_PROC(SProcChangeKeyboardMapping);
+SWAPREQ_PROC(SProcChangePointerControl);
+SWAPREQ_PROC(SProcChangeProperty);
+SWAPREQ_PROC(SProcChangeWindowAttributes);
+SWAPREQ_PROC(SProcClearToBackground);
+SWAPREQ_PROC(SProcConfigureWindow);
+SWAPREQ_PROC(SProcConvertSelection);
+SWAPREQ_PROC(SProcCopyArea);
+SWAPREQ_PROC(SProcCopyColormapAndFree);
+SWAPREQ_PROC(SProcCopyGC);
+SWAPREQ_PROC(SProcCopyPlane);
+SWAPREQ_PROC(SProcCreateColormap);
+SWAPREQ_PROC(SProcCreateCursor);
+SWAPREQ_PROC(SProcCreateGC);
+SWAPREQ_PROC(SProcCreateGlyphCursor);
+SWAPREQ_PROC(SProcCreatePixmap);
+SWAPREQ_PROC(SProcCreateWindow);
+SWAPREQ_PROC(SProcDeleteProperty);
+SWAPREQ_PROC(SProcFillPoly);
+SWAPREQ_PROC(SProcFreeColors);
+SWAPREQ_PROC(SProcGetImage);
+SWAPREQ_PROC(SProcGetMotionEvents);
+SWAPREQ_PROC(SProcGetProperty);
+SWAPREQ_PROC(SProcGrabButton);
+SWAPREQ_PROC(SProcGrabKey);
+SWAPREQ_PROC(SProcGrabKeyboard);
+SWAPREQ_PROC(SProcGrabPointer);
+SWAPREQ_PROC(SProcImageText);
+SWAPREQ_PROC(SProcInternAtom);
+SWAPREQ_PROC(SProcListFonts);
+SWAPREQ_PROC(SProcListFontsWithInfo);
+SWAPREQ_PROC(SProcLookupColor);
+SWAPREQ_PROC(SProcNoOperation);
+SWAPREQ_PROC(SProcOpenFont);
+SWAPREQ_PROC(SProcPoly);
+SWAPREQ_PROC(SProcPolyText);
+SWAPREQ_PROC(SProcPutImage);
+SWAPREQ_PROC(SProcQueryBestSize);
+SWAPREQ_PROC(SProcQueryColors);
+SWAPREQ_PROC(SProcQueryExtension);
+SWAPREQ_PROC(SProcRecolorCursor);
+SWAPREQ_PROC(SProcReparentWindow);
+SWAPREQ_PROC(SProcResourceReq);
+SWAPREQ_PROC(SProcRotateProperties);
+SWAPREQ_PROC(SProcSendEvent);
+SWAPREQ_PROC(SProcSetClipRectangles);
+SWAPREQ_PROC(SProcSetDashes);
+SWAPREQ_PROC(SProcSetFontPath);
+SWAPREQ_PROC(SProcSetInputFocus);
+SWAPREQ_PROC(SProcSetScreenSaver);
+SWAPREQ_PROC(SProcSetSelectionOwner);
+SWAPREQ_PROC(SProcSimpleReq);
+SWAPREQ_PROC(SProcStoreColors);
+SWAPREQ_PROC(SProcStoreNamedColor);
+SWAPREQ_PROC(SProcTranslateCoords);
+SWAPREQ_PROC(SProcUngrabButton);
+SWAPREQ_PROC(SProcUngrabKey);
+SWAPREQ_PROC(SProcWarpPointer);
+
+#undef SWAPREQ_PROC
+
+#endif /* SWAPREQ_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Rename.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Rename.h
@@ -0,0 +1,94 @@
+/*
+ * Copyright © 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _XF86RENAME_H_
+#define _XF86RENAME_H_
+
+#include "local_xf86Rename.h"
+
+#define xf86_cursors_fini XF86NAME(xf86_cursors_fini)
+#define xf86_cursors_init XF86NAME(xf86_cursors_init)
+#define xf86_hide_cursors XF86NAME(xf86_hide_cursors)
+#define xf86_reload_cursors XF86NAME(xf86_reload_cursors)
+#define xf86_show_cursors XF86NAME(xf86_show_cursors)
+#define xf86ConnectorGetName XF86NAME(xf86ConnectorGetName)
+#define xf86CrtcConfigInit XF86NAME(xf86CrtcConfigInit)
+#define xf86CrtcConfigPrivateIndex XF86NAME(xf86CrtcConfigPrivateIndex)
+#define xf86CrtcCreate XF86NAME(xf86CrtcCreate)
+#define xf86CrtcDestroy XF86NAME(xf86CrtcDestroy)
+#define xf86CrtcInUse XF86NAME(xf86CrtcInUse)
+#define xf86CrtcRotate XF86NAME(xf86CrtcRotate)
+#define xf86CrtcScreenInit XF86NAME(xf86CrtcScreenInit)
+#define xf86CrtcSetModeTransform XF86NAME(xf86CrtcSetModeTransform)
+#define xf86CrtcSetMode XF86NAME(xf86CrtcSetMode)
+#define xf86CrtcSetSizeRange XF86NAME(xf86CrtcSetSizeRange)
+#define xf86CVTMode XF86NAME(xf86CVTMode)
+#define xf86DDCMonitorSet XF86NAME(xf86DDCMonitorSet)
+#define xf86DisableUnusedFunctions XF86NAME(xf86DisableUnusedFunctions)
+#define xf86DPMSSet XF86NAME(xf86DPMSSet)
+#define xf86DuplicateMode XF86NAME(xf86DuplicateMode)
+#define xf86DuplicateModes XF86NAME(xf86DuplicateModes)
+#define xf86GetDefaultModes XF86NAME(xf86GetDefaultModes)
+#define xf86GetMonitorModes XF86NAME(xf86GetMonitorModes)
+#define xf86InitialConfiguration XF86NAME(xf86InitialConfiguration)
+#define xf86ModeHSync XF86NAME(xf86ModeHSync)
+#define xf86ModesAdd XF86NAME(xf86ModesAdd)
+#define xf86ModesEqual XF86NAME(xf86ModesEqual)
+#define xf86ModeVRefresh XF86NAME(xf86ModeVRefresh)
+#define xf86OutputCreate XF86NAME(xf86OutputCreate)
+#define xf86OutputDestroy XF86NAME(xf86OutputDestroy)
+#define xf86OutputGetEDID XF86NAME(xf86OutputGetEDID)
+#define xf86OutputGetEDIDModes XF86NAME(xf86OutputGetEDIDModes)
+#define xf86OutputRename XF86NAME(xf86OutputRename)
+#define xf86OutputSetEDID XF86NAME(xf86OutputSetEDID)
+#define xf86OutputUseScreenMonitor XF86NAME(xf86OutputUseScreenMonitor)
+#define xf86PrintModeline XF86NAME(xf86PrintModeline)
+#define xf86ProbeOutputModes XF86NAME(xf86ProbeOutputModes)
+#define xf86PruneInvalidModes XF86NAME(xf86PruneInvalidModes)
+#define xf86RotateCloseScreen XF86NAME(xf86RotateCloseScreen)
+#define xf86SetModeCrtc XF86NAME(xf86SetModeCrtc)
+#define xf86SetModeDefaultName XF86NAME(xf86SetModeDefaultName)
+#define xf86SetScrnInfoModes XF86NAME(xf86SetScrnInfoModes)
+#define xf86ValidateModesClocks XF86NAME(xf86ValidateModesClocks)
+#define xf86ValidateModesFlags XF86NAME(xf86ValidateModesFlags)
+#define xf86ValidateModesSize XF86NAME(xf86ValidateModesSize)
+#define xf86ValidateModesSync XF86NAME(xf86ValidateModesSync)
+#define xf86ValidateModesUserConfig XF86NAME(xf86ValidateModesUserConfig)
+#define xf86DiDGAInit XF86NAME(xf86DiDGAInit)
+#define xf86DiDGAReInit XF86NAME(xf86DiDGAReInit)
+#define xf86DDCGetModes XF86NAME(xf86DDCGetModes)
+#define xf86RandR12CreateScreenResources XF86NAME(xf86RandR12CreateScreenResources)
+#define xf86RandR12GetOriginalVirtualSize XF86NAME(xf86RandR12GetOriginalVirtualSize)
+#define xf86RandR12GetRotation XF86NAME(xf86RandR12GetRotation)
+#define xf86RandR12Init XF86NAME(xf86RandR12Init)
+#define xf86RandR12PreInit XF86NAME(xf86RandR12PreInit)
+#define xf86RandR12SetConfig XF86NAME(xf86RandR12SetConfig)
+#define xf86RandR12SetRotations XF86NAME(xf86RandR12SetRotations)
+#define xf86SaveScreen XF86NAME(xf86SaveScreen)
+#define xf86CrtcSetScreenSubpixelOrder XF86NAME(xf86CrtcSetScreenSubpixelOrder)
+#define xf86ModeWidth XF86NAME(xf86ModeWidth)
+#define xf86ModeHeight XF86NAME(xf86ModeHeight)
+#define xf86OutputFindClosestMode XF86NAME(xf86OutputFindClosestMode)
+#define xf86SetSingleMode XF86NAME(xf86SetSingleMode)
+#define xf86SetDesiredModes XF86NAME(xf86SetDesiredModes)
+
+#endif /* _XF86RENAME_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/region.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/region.h
@@ -0,0 +1,53 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef REGION_H
+#define REGION_H
+
+#include "regionstr.h"
+
+#endif /* REGION_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbfile.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbfile.h
@@ -0,0 +1,310 @@
+/************************************************************
+ Copyright (c) 1994 by Silicon Graphics Computer Systems, Inc.
+
+ Permission to use, copy, modify, and distribute this
+ software and its documentation for any purpose and without
+ fee is hereby granted, provided that the above copyright
+ notice appear in all copies and that both that copyright
+ notice and this permission notice appear in supporting
+ documentation, and that the name of Silicon Graphics not be 
+ used in advertising or publicity pertaining to distribution 
+ of the software without specific prior written permission.
+ Silicon Graphics makes no representation about the suitability 
+ of this software for any purpose. It is provided "as is"
+ without any express or implied warranty.
+ 
+ SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+ SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+ DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+ OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ ********************************************************/
+
+#ifndef _XKBFILE_H_
+#define	_XKBFILE_H_ 1
+
+#include "xkbstr.h"
+
+/***====================================================================***/
+
+#define	XkbXKMFile	0
+#define	XkbCFile	1
+#define	XkbXKBFile	2
+#define	XkbMessage	3
+
+#define	XkbMapDefined		(1<<0)
+#define	XkbStateDefined		(1<<1)
+
+typedef void	(*XkbFileAddOnFunc)(
+    FILE *		/* file */,
+    XkbDescPtr  	/* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    int			/* fileSection */,
+    void *		/* priv */
+);
+
+/***====================================================================***/
+
+#define	_XkbSuccess			0
+#define	_XkbErrMissingNames		1
+#define	_XkbErrMissingTypes		2
+#define	_XkbErrMissingReqTypes		3
+#define	_XkbErrMissingSymbols		4
+#define	_XkbErrMissingVMods		5
+#define	_XkbErrMissingIndicators	6
+#define	_XkbErrMissingCompatMap		7
+#define	_XkbErrMissingSymInterps	8
+#define	_XkbErrMissingGeometry		9
+#define	_XkbErrIllegalDoodad		10
+#define	_XkbErrIllegalTOCType		11
+#define	_XkbErrIllegalContents		12
+#define	_XkbErrEmptyFile		13
+#define	_XkbErrFileNotFound		14
+#define	_XkbErrFileCannotOpen		15
+#define	_XkbErrBadValue			16
+#define	_XkbErrBadMatch			17
+#define	_XkbErrBadTypeName		18
+#define	_XkbErrBadTypeWidth		19
+#define	_XkbErrBadFileType		20
+#define	_XkbErrBadFileVersion		21
+#define	_XkbErrBadFileFormat		22
+#define	_XkbErrBadAlloc			23
+#define	_XkbErrBadLength		24
+#define	_XkbErrXReqFailure		25
+#define	_XkbErrBadImplementation	26
+
+/***====================================================================***/
+
+_XFUNCPROTOBEGIN
+
+extern _X_EXPORT char *	XkbIndentText(
+    unsigned	/* size */
+);
+
+extern _X_EXPORT char *	XkbAtomText(
+    Atom 	/* atm */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbKeysymText(
+    KeySym	/* sym */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbStringText(
+    char *	/* str */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbKeyNameText(
+    char *	/* name */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *
+XkbModIndexText(
+    unsigned	/* ndx */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *
+XkbModMaskText(
+    unsigned	/* mask */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbVModIndexText(
+    XkbDescPtr	/* xkb */,
+    unsigned	/* ndx */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbVModMaskText(
+    XkbDescPtr	/* xkb */,
+    unsigned	/* modMask */,
+    unsigned	/* mask */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbConfigText(
+    unsigned 	/* config */,
+    unsigned 	/* format */
+);
+
+extern _X_EXPORT char *	XkbSIMatchText(
+    unsigned	/* type */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbIMWhichStateMaskText(
+    unsigned	/* use_which */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbControlsMaskText(
+    unsigned	/* ctrls */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbGeomFPText(
+    int		/* val */,
+    unsigned 	/* format */
+);
+
+extern _X_EXPORT char *	XkbDoodadTypeText(
+    unsigned	/* type */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbActionTypeText(
+    unsigned	/* type */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbActionText(
+    XkbDescPtr	/* xkb */,
+    XkbAction *	/* action */,
+    unsigned	/* format */
+);
+
+extern _X_EXPORT char *	XkbBehaviorText(
+    XkbDescPtr 		/* xkb */,
+    XkbBehavior *	/* behavior */,
+    unsigned		/* format */
+);
+
+/***====================================================================***/
+
+#define	_XkbKSLower	(1<<0)
+#define	_XkbKSUpper	(1<<1)
+
+#define	XkbKSIsLower(k)		(_XkbKSCheckCase(k)&_XkbKSLower)
+#define	XkbKSIsUpper(k)		(_XkbKSCheckCase(k)&_XkbKSUpper)
+#define XkbKSIsKeypad(k)	(((k)>=XK_KP_Space)&&((k)<=XK_KP_Equal))
+#define	XkbKSIsDeadKey(k)	\
+		(((k)>=XK_dead_grave)&&((k)<=XK_dead_semivoiced_sound))
+
+extern _X_EXPORT unsigned _XkbKSCheckCase(
+   KeySym	/* sym */
+);
+
+extern _X_EXPORT int	 XkbFindKeycodeByName(
+    XkbDescPtr	/* xkb */,
+    char *	/* name */,
+    Bool	/* use_aliases */
+);
+
+/***====================================================================***/
+
+extern _X_EXPORT Atom	XkbInternAtom(
+    char *	/* name */,
+    Bool	/* onlyIfExists */
+);
+
+/***====================================================================***/
+
+#ifdef _XKBGEOM_H_
+
+#define	XkbDW_Unknown	0
+#define	XkbDW_Doodad	1
+#define	XkbDW_Section	2
+typedef struct _XkbDrawable {
+	int		type;
+	int		priority;
+	union {
+	    XkbDoodadPtr	doodad;
+	    XkbSectionPtr	section;
+	} u;
+	struct _XkbDrawable *	next;
+} XkbDrawableRec,*XkbDrawablePtr; 
+
+#endif
+
+/***====================================================================***/
+
+extern _X_EXPORT unsigned	XkbConvertGetByNameComponents(
+    Bool		/* toXkm */,
+    unsigned 		/* orig */
+);
+
+extern _X_EXPORT Bool	XkbNameMatchesPattern(
+    char *		/* name */,
+    char *		/* pattern */
+);
+
+/***====================================================================***/
+
+extern _X_EXPORT Bool	XkbWriteXKBKeycodes(
+    FILE *		/* file */,
+    XkbDescPtr          /* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    XkbFileAddOnFunc	/* addOn */,
+    void *		/* priv */
+);
+
+extern _X_EXPORT Bool	XkbWriteXKBKeyTypes(
+    FILE *		/* file */,
+    XkbDescPtr  	/* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    XkbFileAddOnFunc	/* addOn */,
+    void *		/* priv */
+);
+
+extern _X_EXPORT Bool	XkbWriteXKBCompatMap(
+    FILE *		/* file */,
+    XkbDescPtr	/* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    XkbFileAddOnFunc	/* addOn */,
+    void *		/* priv */
+);
+
+extern _X_EXPORT Bool	XkbWriteXKBSymbols(
+    FILE *		/* file */,
+    XkbDescPtr	/* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    XkbFileAddOnFunc	/* addOn */,
+    void *		/* priv */
+);
+
+extern _X_EXPORT Bool	XkbWriteXKBGeometry(
+    FILE *		/* file */,
+    XkbDescPtr	/* result */,
+    Bool		/* topLevel */,
+    Bool		/* showImplicit */,
+    XkbFileAddOnFunc	/* addOn */,
+    void *		/* priv */
+);
+
+extern _X_EXPORT Bool	XkbWriteXKBKeymapForNames(
+    FILE *			/* file */,
+    XkbComponentNamesPtr	/* names */,
+    XkbDescPtr			/* xkb */,
+    unsigned			/* want */,
+    unsigned			/* need */
+);
+
+/***====================================================================***/
+
+extern _X_EXPORT Bool	XkmProbe(
+    FILE *		/* file */
+);
+
+extern _X_EXPORT unsigned	XkmReadFile(
+    FILE *		/* file */,
+    unsigned		/* need */,
+    unsigned		/* want */,
+    XkbDescPtr	        * /* result */
+);
+
+_XFUNCPROTOEND
+
+#endif /* _XKBFILE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/servermd.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/servermd.h
@@ -0,0 +1,334 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SERVERMD_H
+#define SERVERMD_H 1
+
+/*
+ * Note: much of this is vestigial from mfb/cfb times.  This should
+ * really be simplified even further.
+ */
+
+/*
+ * Machine dependent values:
+ * GLYPHPADBYTES should be chosen with consideration for the space-time
+ * trade-off.  Padding to 0 bytes means that there is no wasted space
+ * in the font bitmaps (both on disk and in memory), but that access of
+ * the bitmaps will cause odd-address memory references.  Padding to
+ * 2 bytes would ensure even address memory references and would
+ * be suitable for a 68010-class machine, but at the expense of wasted
+ * space in the font bitmaps.  Padding to 4 bytes would be good
+ * for real 32 bit machines, etc.  Be sure that you tell the font
+ * compiler what kind of padding you want because its defines are
+ * kept separate from this.  See server/include/font.h for how
+ * GLYPHPADBYTES is used.
+ */
+
+#ifdef __avr32__
+
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#define GLYPHPADBYTES           4
+
+#endif /* __avr32__ */ 
+
+#ifdef __arm32__
+
+#define IMAGE_BYTE_ORDER        LSBFirst
+#define BITMAP_BIT_ORDER        LSBFirst
+#define GLYPHPADBYTES           4
+
+#endif /* __arm32__ */
+
+#if defined __hppa__
+
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4	/* to make fb work */
+					/* byte boundries */
+#endif /* hpux || __hppa__ */
+
+#if defined(__powerpc__) || defined(__ppc__) || defined(__ppc64__)
+
+#define IMAGE_BYTE_ORDER        MSBFirst
+#define BITMAP_BIT_ORDER        MSBFirst
+#define GLYPHPADBYTES           4
+
+#endif /* PowerPC */
+
+#if defined(__sh__)
+
+#if defined(__BIG_ENDIAN__)
+# define IMAGE_BYTE_ORDER	MSBFirst
+# define BITMAP_BIT_ORDER	MSBFirst
+# define GLYPHPADBYTES		4
+#else
+# define IMAGE_BYTE_ORDER	LSBFirst
+# define BITMAP_BIT_ORDER	LSBFirst
+# define GLYPHPADBYTES		4
+#endif
+
+#endif /* SuperH */
+
+#if defined(__m32r__)
+
+#if defined(__BIG_ENDIAN__)
+# define IMAGE_BYTE_ORDER      MSBFirst
+# define BITMAP_BIT_ORDER      MSBFirst
+# define GLYPHPADBYTES         4
+#else
+# define IMAGE_BYTE_ORDER      LSBFirst
+# define BITMAP_BIT_ORDER      LSBFirst
+# define GLYPHPADBYTES         4
+#endif
+
+#endif /* __m32r__ */
+
+#if (defined(sun) && (defined(__sparc) || defined(sparc))) || \
+    (defined(__uxp__) && (defined(sparc) || defined(mc68000))) || \
+    defined(__sparc__) || defined(__mc68000__)
+
+#if defined(__sparc) || defined(__sparc__)
+# if !defined(sparc)
+#  define sparc 1
+# endif
+#endif
+
+#if defined(sun386) || defined(sun5)
+# define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the SUN only */
+# define BITMAP_BIT_ORDER	LSBFirst
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the SUN only */
+# define BITMAP_BIT_ORDER	MSBFirst
+#endif
+
+#define	GLYPHPADBYTES		4
+
+#endif /* sun && !(i386 && SVR4) */
+
+
+#if defined(ibm032) || defined (ibm)
+
+#ifdef __i386__
+# define IMAGE_BYTE_ORDER	LSBFirst	/* Value for PS/2 only */
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the RT only*/
+#endif
+#define BITMAP_BIT_ORDER	MSBFirst
+#define	GLYPHPADBYTES		1
+/* ibm pcc doesn't understand pragmas. */
+
+#ifdef __i386__
+#define BITMAP_SCANLINE_UNIT	8
+#endif
+
+#endif /* ibm */
+
+#if (defined(mips) || defined(__mips)) 
+
+#if defined(MIPSEL) || defined(__MIPSEL__)
+# define IMAGE_BYTE_ORDER	LSBFirst        /* Values for the PMAX only */
+# define BITMAP_BIT_ORDER	LSBFirst
+# define GLYPHPADBYTES		4
+#else
+# define IMAGE_BYTE_ORDER	MSBFirst        /* Values for the MIPS only */
+# define BITMAP_BIT_ORDER	MSBFirst
+# define GLYPHPADBYTES		4
+#endif
+
+#endif /* mips */
+
+#if defined(__alpha) || defined(__alpha__)
+# define IMAGE_BYTE_ORDER	LSBFirst	/* Values for the Alpha only */
+# define BITMAP_BIT_ORDER       LSBFirst
+# define GLYPHPADBYTES		4
+
+#endif /* alpha */
+
+#if defined (linux) && defined (__s390__)
+
+#define IMAGE_BYTE_ORDER      	MSBFirst
+#define BITMAP_BIT_ORDER      	MSBFirst
+#define GLYPHPADBYTES         	4
+
+#define BITMAP_SCANLINE_UNIT	8
+#define FAST_UNALIGNED_READ
+
+#endif /* linux/s390 */
+
+#if defined (linux) && defined (__s390x__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define GLYPHPADBYTES          4
+
+#define BITMAP_SCANLINE_UNIT	8
+#define FAST_UNALIGNED_READ
+
+#endif /* linux/s390x */
+
+
+#if defined(__ia64__) || defined(ia64)
+
+# define IMAGE_BYTE_ORDER	LSBFirst
+# define BITMAP_BIT_ORDER       LSBFirst
+# define GLYPHPADBYTES		4
+
+#endif /* ia64 */
+
+#if defined(__amd64__) || defined(amd64) || defined(__amd64)
+# define IMAGE_BYTE_ORDER	LSBFirst
+# define BITMAP_BIT_ORDER       LSBFirst
+# define GLYPHPADBYTES		4
+/* ???? */
+#endif /* AMD64 */
+
+#if	defined(SVR4) && (defined(__i386__) || defined(__i386) ) ||	\
+	defined(__alpha__) || defined(__alpha) || \
+	defined(__i386__) || \
+	defined(__s390x__) || defined(__s390__)
+  
+#ifndef IMAGE_BYTE_ORDER
+#define IMAGE_BYTE_ORDER	LSBFirst
+#endif
+
+#ifndef BITMAP_BIT_ORDER
+# define BITMAP_BIT_ORDER      LSBFirst
+#endif
+
+#ifndef GLYPHPADBYTES
+#define GLYPHPADBYTES           4
+#endif
+
+#endif /* SVR4 / BSD / i386 */
+
+#if defined (linux) && defined (__mc68000__)
+
+#define IMAGE_BYTE_ORDER       MSBFirst
+#define BITMAP_BIT_ORDER       MSBFirst
+#define GLYPHPADBYTES          4
+
+#endif /* linux/m68k */
+
+
+/* linux on ARM */
+#if defined(linux) && defined(__arm__)
+#define IMAGE_BYTE_ORDER	LSBFirst
+#define BITMAP_BIT_ORDER	LSBFirst
+#define GLYPHPADBYTES		4
+#endif
+
+/* linux on IBM S/390 */
+#if defined (linux) && defined (__s390__)
+#define IMAGE_BYTE_ORDER	MSBFirst
+#define BITMAP_BIT_ORDER	MSBFirst
+#define GLYPHPADBYTES		4
+#endif /* linux/s390 */ 
+
+/* size of buffer to use with GetImage, measured in bytes. There's obviously
+ * a trade-off between the amount of heap used and the number of times the
+ * ddx routine has to be called.
+ */
+#ifndef IMAGE_BUFSIZE
+#define IMAGE_BUFSIZE		(64*1024)
+#endif
+
+/* pad scanline to a longword */
+#ifndef BITMAP_SCANLINE_UNIT
+#define BITMAP_SCANLINE_UNIT	32
+#endif
+
+#ifndef BITMAP_SCANLINE_PAD
+#define BITMAP_SCANLINE_PAD  32
+#define LOG2_BITMAP_PAD		5
+#define LOG2_BYTES_PER_SCANLINE_PAD	2
+#endif
+
+#include <X11/Xfuncproto.h>
+/* 
+ *   This returns the number of padding units, for depth d and width w.
+ * For bitmaps this can be calculated with the macros above.
+ * Other depths require either grovelling over the formats field of the
+ * screenInfo or hardwired constants.
+ */
+
+typedef struct _PaddingInfo {
+	int     padRoundUp;	/* pixels per pad unit - 1 */
+	int	padPixelsLog2;	/* log 2 (pixels per pad unit) */
+	int     padBytesLog2;	/* log 2 (bytes per pad unit) */
+	int	notPower2;	/* bitsPerPixel not a power of 2 */
+	int	bytesPerPixel;	/* only set when notPower2 is TRUE */
+	int	bitsPerPixel;	/* bits per pixel */
+} PaddingInfo;
+extern _X_EXPORT PaddingInfo PixmapWidthPaddingInfo[];
+
+/* The only portable way to get the bpp from the depth is to look it up */
+#define BitsPerPixel(d) (PixmapWidthPaddingInfo[d].bitsPerPixel)
+
+#define PixmapWidthInPadUnits(w, d) \
+    (PixmapWidthPaddingInfo[d].notPower2 ? \
+    (((int)(w) * PixmapWidthPaddingInfo[d].bytesPerPixel +  \
+	         PixmapWidthPaddingInfo[d].bytesPerPixel) >> \
+	PixmapWidthPaddingInfo[d].padBytesLog2) : \
+    ((int)((w) + PixmapWidthPaddingInfo[d].padRoundUp) >> \
+	PixmapWidthPaddingInfo[d].padPixelsLog2))
+
+/*
+ *	Return the number of bytes to which a scanline of the given
+ * depth and width will be padded.
+ */
+#define PixmapBytePad(w, d) \
+    (PixmapWidthInPadUnits(w, d) << PixmapWidthPaddingInfo[d].padBytesLog2)
+
+#define BitmapBytePad(w) \
+    (((int)((w) + BITMAP_SCANLINE_PAD - 1) >> LOG2_BITMAP_PAD) << LOG2_BYTES_PER_SCANLINE_PAD)
+
+#define PixmapWidthInPadUnitsProto(w, d) PixmapWidthInPadUnits(w, d)
+#define PixmapBytePadProto(w, d) PixmapBytePad(w, d)
+#define BitmapBytePadProto(w) BitmapBytePad(w)
+
+#endif /* SERVERMD_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxutil.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxutil.h
@@ -0,0 +1,48 @@
+#ifndef _glxcmds_h_
+#define _glxcmds_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+extern void __glXNop(void);
+
+/* memory management */
+extern void *__glXMalloc(size_t size);
+extern void *__glXCalloc(size_t numElements, size_t elementSize);
+extern void *__glXRealloc(void *addr, size_t newSize);
+extern void __glXFree(void *ptr);
+
+/* context helper routines */
+extern __GLXcontext *__glXLookupContextByTag(__GLXclientState*, GLXContextTag);
+extern DrawablePtr __glXLookupDrawableByTag(__GLXclientState *cl, GLXContextTag tag);
+
+
+#endif /* _glxcmds_h_ */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/validate.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/validate.h
@@ -0,0 +1,40 @@
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef VALIDATE_H
+#define VALIDATE_H
+
+#include "miscstruct.h"
+#include "regionstr.h"
+
+typedef enum { VTOther, VTStack, VTMove, VTUnmap, VTMap, VTBroken } VTKind;
+
+/* union _Validate is now device dependent; see mivalidate.h for an example */
+typedef union _Validate *ValidatePtr;
+
+#define UnmapValData ((ValidatePtr)1)
+
+#endif /* VALIDATE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sarea.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sarea.h
@@ -0,0 +1,97 @@
+/**
+ * \file sarea.h 
+ * SAREA definitions.
+ * 
+ * \author Kevin E. Martin <kevin@precisioninsight.com>
+ * \author Jens Owen <jens@tungstengraphics.com>
+ * \author Rickard E. (Rik) Faith <faith@valinux.com>
+ */
+
+/*
+ * Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+ * Copyright 2000 VA Linux Systems, Inc.
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+#ifndef _SAREA_H_
+#define _SAREA_H_
+
+#include "xf86drm.h"
+
+/* SAREA area needs to be at least a page */
+#if defined(__alpha__)
+#define SAREA_MAX 			0x2000
+#elif defined(__ia64__)
+#define SAREA_MAX			0x10000		/* 64kB */
+#else
+/* Intel 830M driver needs at least 8k SAREA */
+#define SAREA_MAX			0x2000
+#endif
+
+#define SAREA_MAX_DRAWABLES 		256
+
+#define SAREA_DRAWABLE_CLAIMED_ENTRY	0x80000000
+
+/**
+ * SAREA per drawable information.
+ *
+ * \sa _XF86DRISAREA.
+ */
+typedef struct _XF86DRISAREADrawable {
+    unsigned int	stamp;
+    unsigned int	flags;
+} XF86DRISAREADrawableRec, *XF86DRISAREADrawablePtr;
+
+/**
+ * SAREA frame information.
+ *
+ * \sa  _XF86DRISAREA.
+ */
+typedef struct _XF86DRISAREAFrame {
+    unsigned int        x;
+    unsigned int        y;
+    unsigned int        width;
+    unsigned int        height;
+    unsigned int        fullscreen;
+} XF86DRISAREAFrameRec, *XF86DRISAREAFramePtr;
+
+/**
+ * SAREA definition.
+ */
+typedef struct _XF86DRISAREA {
+    /** first thing is always the DRM locking structure */
+    drmLock			lock;
+    /** \todo Use readers/writer lock for drawable_lock */
+    drmLock			drawable_lock;
+    XF86DRISAREADrawableRec	drawableTable[SAREA_MAX_DRAWABLES];
+    XF86DRISAREAFrameRec        frame;
+    drm_context_t			dummy_context;
+} XF86DRISAREARec, *XF86DRISAREAPtr;
+
+typedef struct _XF86DRILSAREA  {
+    drmLock                     lock;
+    drmLock                     otherLocks[31];
+} XF86DRILSAREARec, *XF86DRILSAREAPtr;
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxshadow.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxshadow.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *   David H. Dawes <dawes@xfree86.org>
+ *
+ */
+
+/** \file
+ * Interface for shadow framebuffer support.  \see dmxshadow.c */
+
+#ifndef DMXSHADOW_H
+#define DMXSHADOW_H
+
+#include "shadow.h"
+#include "scrnintstr.h"
+
+extern void dmxShadowUpdateProc(ScreenPtr pScreen, shadowBufPtr pBuf);
+
+#endif /* DMXSHADOW_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessConfig.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessConfig.h
@@ -0,0 +1,66 @@
+/*
+ * Platform specific rootless configuration
+ */
+/*
+ * Copyright (c) 2003 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESSCONFIG_H
+#define _ROOTLESSCONFIG_H
+
+#ifdef __APPLE__
+
+# define ROOTLESS_GLOBAL_COORDS TRUE
+# define ROOTLESS_PROTECT_ALPHA TRUE
+# define ROOTLESS_REDISPLAY_DELAY 10
+# define ROOTLESS_RESIZE_GRAVITY TRUE
+# undef  ROOTLESS_TRACK_DAMAGE
+/*# define ROOTLESSDEBUG*/
+
+/* Bit mask for alpha channel with a particular number of bits per
+   pixel. Note that we only care for 32bpp data. Mac OS X uses planar
+   alpha for 16bpp. */
+# define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)
+
+#endif /* __APPLE__ */
+
+#if defined(__CYGWIN__) || defined(WIN32)
+
+# define ROOTLESS_GLOBAL_COORDS TRUE
+# define ROOTLESS_PROTECT_ALPHA NO
+# define ROOTLESS_REDISPLAY_DELAY 10
+# undef  ROOTLESS_RESIZE_GRAVITY
+# undef  ROOTLESS_TRACK_DAMAGE
+/*# define ROOTLESSDEBUG*/
+
+# define RootlessAlphaMask(bpp) ((bpp) == 32 ? 0xFF000000 : 0)
+
+#endif /* __CYGWIN__ */
+
+#endif /* _ROOTLESSCONFIG_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gtmotion.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gtmotion.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GTMOTION_H
+#define GTMOTION_H 1
+
+int SProcXGetDeviceMotionEvents(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceMotionEvents(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceMotionEvents(ClientPtr /* client */ ,
+				int /* size */ ,
+				xGetDeviceMotionEventsReply *	/* rep */
+    );
+
+#endif /* GTMOTION_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shmint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shmint.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright © 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _SHMINT_H_
+#define _SHMINT_H_
+
+#include <X11/extensions/shmproto.h>
+
+#include "screenint.h"
+#include "pixmap.h"
+#include "gc.h"
+
+#define XSHM_PUT_IMAGE_ARGS \
+    DrawablePtr		/* dst */, \
+    GCPtr		/* pGC */, \
+    int			/* depth */, \
+    unsigned int	/* format */, \
+    int			/* w */, \
+    int			/* h */, \
+    int			/* sx */, \
+    int			/* sy */, \
+    int			/* sw */, \
+    int			/* sh */, \
+    int			/* dx */, \
+    int			/* dy */, \
+    char *		/* data */
+
+#define XSHM_CREATE_PIXMAP_ARGS \
+    ScreenPtr	/* pScreen */, \
+    int		/* width */, \
+    int		/* height */, \
+    int		/* depth */, \
+    char *	/* addr */
+
+typedef struct _ShmFuncs {
+    PixmapPtr	(* CreatePixmap)(XSHM_CREATE_PIXMAP_ARGS);
+    void	(* PutImage)(XSHM_PUT_IMAGE_ARGS);
+} ShmFuncs, *ShmFuncsPtr;
+
+extern _X_EXPORT void
+ShmRegisterFuncs(ScreenPtr pScreen, ShmFuncsPtr funcs);
+
+extern _X_EXPORT void
+ShmRegisterFbFuncs(ScreenPtr pScreen);
+
+extern _X_EXPORT RESTYPE ShmSegType;
+extern _X_EXPORT int ShmCompletionCode;
+extern _X_EXPORT int BadShmSegCode;
+
+#endif /* _SHMINT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapitable.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapitable.h
@@ -0,0 +1,815 @@
+/* DO NOT EDIT - This file generated automatically by gl_table.py (from Mesa) script */
+
+/*
+ * Copyright (C) 1999-2003  Brian Paul   All Rights Reserved.
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL, IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _GLAPI_TABLE_H_ )
+#  define _GLAPI_TABLE_H_
+
+#ifndef GLAPIENTRYP
+# ifndef GLAPIENTRY
+#  define GLAPIENTRY
+# endif
+
+# define GLAPIENTRYP GLAPIENTRY *
+#endif
+
+
+struct _glapi_table
+{
+   void (GLAPIENTRYP NewList)(GLuint list, GLenum mode); /* 0 */
+   void (GLAPIENTRYP EndList)(void); /* 1 */
+   void (GLAPIENTRYP CallList)(GLuint list); /* 2 */
+   void (GLAPIENTRYP CallLists)(GLsizei n, GLenum type, const GLvoid * lists); /* 3 */
+   void (GLAPIENTRYP DeleteLists)(GLuint list, GLsizei range); /* 4 */
+   GLuint (GLAPIENTRYP GenLists)(GLsizei range); /* 5 */
+   void (GLAPIENTRYP ListBase)(GLuint base); /* 6 */
+   void (GLAPIENTRYP Begin)(GLenum mode); /* 7 */
+   void (GLAPIENTRYP Bitmap)(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap); /* 8 */
+   void (GLAPIENTRYP Color3b)(GLbyte red, GLbyte green, GLbyte blue); /* 9 */
+   void (GLAPIENTRYP Color3bv)(const GLbyte * v); /* 10 */
+   void (GLAPIENTRYP Color3d)(GLdouble red, GLdouble green, GLdouble blue); /* 11 */
+   void (GLAPIENTRYP Color3dv)(const GLdouble * v); /* 12 */
+   void (GLAPIENTRYP Color3f)(GLfloat red, GLfloat green, GLfloat blue); /* 13 */
+   void (GLAPIENTRYP Color3fv)(const GLfloat * v); /* 14 */
+   void (GLAPIENTRYP Color3i)(GLint red, GLint green, GLint blue); /* 15 */
+   void (GLAPIENTRYP Color3iv)(const GLint * v); /* 16 */
+   void (GLAPIENTRYP Color3s)(GLshort red, GLshort green, GLshort blue); /* 17 */
+   void (GLAPIENTRYP Color3sv)(const GLshort * v); /* 18 */
+   void (GLAPIENTRYP Color3ub)(GLubyte red, GLubyte green, GLubyte blue); /* 19 */
+   void (GLAPIENTRYP Color3ubv)(const GLubyte * v); /* 20 */
+   void (GLAPIENTRYP Color3ui)(GLuint red, GLuint green, GLuint blue); /* 21 */
+   void (GLAPIENTRYP Color3uiv)(const GLuint * v); /* 22 */
+   void (GLAPIENTRYP Color3us)(GLushort red, GLushort green, GLushort blue); /* 23 */
+   void (GLAPIENTRYP Color3usv)(const GLushort * v); /* 24 */
+   void (GLAPIENTRYP Color4b)(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha); /* 25 */
+   void (GLAPIENTRYP Color4bv)(const GLbyte * v); /* 26 */
+   void (GLAPIENTRYP Color4d)(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha); /* 27 */
+   void (GLAPIENTRYP Color4dv)(const GLdouble * v); /* 28 */
+   void (GLAPIENTRYP Color4f)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); /* 29 */
+   void (GLAPIENTRYP Color4fv)(const GLfloat * v); /* 30 */
+   void (GLAPIENTRYP Color4i)(GLint red, GLint green, GLint blue, GLint alpha); /* 31 */
+   void (GLAPIENTRYP Color4iv)(const GLint * v); /* 32 */
+   void (GLAPIENTRYP Color4s)(GLshort red, GLshort green, GLshort blue, GLshort alpha); /* 33 */
+   void (GLAPIENTRYP Color4sv)(const GLshort * v); /* 34 */
+   void (GLAPIENTRYP Color4ub)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha); /* 35 */
+   void (GLAPIENTRYP Color4ubv)(const GLubyte * v); /* 36 */
+   void (GLAPIENTRYP Color4ui)(GLuint red, GLuint green, GLuint blue, GLuint alpha); /* 37 */
+   void (GLAPIENTRYP Color4uiv)(const GLuint * v); /* 38 */
+   void (GLAPIENTRYP Color4us)(GLushort red, GLushort green, GLushort blue, GLushort alpha); /* 39 */
+   void (GLAPIENTRYP Color4usv)(const GLushort * v); /* 40 */
+   void (GLAPIENTRYP EdgeFlag)(GLboolean flag); /* 41 */
+   void (GLAPIENTRYP EdgeFlagv)(const GLboolean * flag); /* 42 */
+   void (GLAPIENTRYP End)(void); /* 43 */
+   void (GLAPIENTRYP Indexd)(GLdouble c); /* 44 */
+   void (GLAPIENTRYP Indexdv)(const GLdouble * c); /* 45 */
+   void (GLAPIENTRYP Indexf)(GLfloat c); /* 46 */
+   void (GLAPIENTRYP Indexfv)(const GLfloat * c); /* 47 */
+   void (GLAPIENTRYP Indexi)(GLint c); /* 48 */
+   void (GLAPIENTRYP Indexiv)(const GLint * c); /* 49 */
+   void (GLAPIENTRYP Indexs)(GLshort c); /* 50 */
+   void (GLAPIENTRYP Indexsv)(const GLshort * c); /* 51 */
+   void (GLAPIENTRYP Normal3b)(GLbyte nx, GLbyte ny, GLbyte nz); /* 52 */
+   void (GLAPIENTRYP Normal3bv)(const GLbyte * v); /* 53 */
+   void (GLAPIENTRYP Normal3d)(GLdouble nx, GLdouble ny, GLdouble nz); /* 54 */
+   void (GLAPIENTRYP Normal3dv)(const GLdouble * v); /* 55 */
+   void (GLAPIENTRYP Normal3f)(GLfloat nx, GLfloat ny, GLfloat nz); /* 56 */
+   void (GLAPIENTRYP Normal3fv)(const GLfloat * v); /* 57 */
+   void (GLAPIENTRYP Normal3i)(GLint nx, GLint ny, GLint nz); /* 58 */
+   void (GLAPIENTRYP Normal3iv)(const GLint * v); /* 59 */
+   void (GLAPIENTRYP Normal3s)(GLshort nx, GLshort ny, GLshort nz); /* 60 */
+   void (GLAPIENTRYP Normal3sv)(const GLshort * v); /* 61 */
+   void (GLAPIENTRYP RasterPos2d)(GLdouble x, GLdouble y); /* 62 */
+   void (GLAPIENTRYP RasterPos2dv)(const GLdouble * v); /* 63 */
+   void (GLAPIENTRYP RasterPos2f)(GLfloat x, GLfloat y); /* 64 */
+   void (GLAPIENTRYP RasterPos2fv)(const GLfloat * v); /* 65 */
+   void (GLAPIENTRYP RasterPos2i)(GLint x, GLint y); /* 66 */
+   void (GLAPIENTRYP RasterPos2iv)(const GLint * v); /* 67 */
+   void (GLAPIENTRYP RasterPos2s)(GLshort x, GLshort y); /* 68 */
+   void (GLAPIENTRYP RasterPos2sv)(const GLshort * v); /* 69 */
+   void (GLAPIENTRYP RasterPos3d)(GLdouble x, GLdouble y, GLdouble z); /* 70 */
+   void (GLAPIENTRYP RasterPos3dv)(const GLdouble * v); /* 71 */
+   void (GLAPIENTRYP RasterPos3f)(GLfloat x, GLfloat y, GLfloat z); /* 72 */
+   void (GLAPIENTRYP RasterPos3fv)(const GLfloat * v); /* 73 */
+   void (GLAPIENTRYP RasterPos3i)(GLint x, GLint y, GLint z); /* 74 */
+   void (GLAPIENTRYP RasterPos3iv)(const GLint * v); /* 75 */
+   void (GLAPIENTRYP RasterPos3s)(GLshort x, GLshort y, GLshort z); /* 76 */
+   void (GLAPIENTRYP RasterPos3sv)(const GLshort * v); /* 77 */
+   void (GLAPIENTRYP RasterPos4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 78 */
+   void (GLAPIENTRYP RasterPos4dv)(const GLdouble * v); /* 79 */
+   void (GLAPIENTRYP RasterPos4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 80 */
+   void (GLAPIENTRYP RasterPos4fv)(const GLfloat * v); /* 81 */
+   void (GLAPIENTRYP RasterPos4i)(GLint x, GLint y, GLint z, GLint w); /* 82 */
+   void (GLAPIENTRYP RasterPos4iv)(const GLint * v); /* 83 */
+   void (GLAPIENTRYP RasterPos4s)(GLshort x, GLshort y, GLshort z, GLshort w); /* 84 */
+   void (GLAPIENTRYP RasterPos4sv)(const GLshort * v); /* 85 */
+   void (GLAPIENTRYP Rectd)(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2); /* 86 */
+   void (GLAPIENTRYP Rectdv)(const GLdouble * v1, const GLdouble * v2); /* 87 */
+   void (GLAPIENTRYP Rectf)(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2); /* 88 */
+   void (GLAPIENTRYP Rectfv)(const GLfloat * v1, const GLfloat * v2); /* 89 */
+   void (GLAPIENTRYP Recti)(GLint x1, GLint y1, GLint x2, GLint y2); /* 90 */
+   void (GLAPIENTRYP Rectiv)(const GLint * v1, const GLint * v2); /* 91 */
+   void (GLAPIENTRYP Rects)(GLshort x1, GLshort y1, GLshort x2, GLshort y2); /* 92 */
+   void (GLAPIENTRYP Rectsv)(const GLshort * v1, const GLshort * v2); /* 93 */
+   void (GLAPIENTRYP TexCoord1d)(GLdouble s); /* 94 */
+   void (GLAPIENTRYP TexCoord1dv)(const GLdouble * v); /* 95 */
+   void (GLAPIENTRYP TexCoord1f)(GLfloat s); /* 96 */
+   void (GLAPIENTRYP TexCoord1fv)(const GLfloat * v); /* 97 */
+   void (GLAPIENTRYP TexCoord1i)(GLint s); /* 98 */
+   void (GLAPIENTRYP TexCoord1iv)(const GLint * v); /* 99 */
+   void (GLAPIENTRYP TexCoord1s)(GLshort s); /* 100 */
+   void (GLAPIENTRYP TexCoord1sv)(const GLshort * v); /* 101 */
+   void (GLAPIENTRYP TexCoord2d)(GLdouble s, GLdouble t); /* 102 */
+   void (GLAPIENTRYP TexCoord2dv)(const GLdouble * v); /* 103 */
+   void (GLAPIENTRYP TexCoord2f)(GLfloat s, GLfloat t); /* 104 */
+   void (GLAPIENTRYP TexCoord2fv)(const GLfloat * v); /* 105 */
+   void (GLAPIENTRYP TexCoord2i)(GLint s, GLint t); /* 106 */
+   void (GLAPIENTRYP TexCoord2iv)(const GLint * v); /* 107 */
+   void (GLAPIENTRYP TexCoord2s)(GLshort s, GLshort t); /* 108 */
+   void (GLAPIENTRYP TexCoord2sv)(const GLshort * v); /* 109 */
+   void (GLAPIENTRYP TexCoord3d)(GLdouble s, GLdouble t, GLdouble r); /* 110 */
+   void (GLAPIENTRYP TexCoord3dv)(const GLdouble * v); /* 111 */
+   void (GLAPIENTRYP TexCoord3f)(GLfloat s, GLfloat t, GLfloat r); /* 112 */
+   void (GLAPIENTRYP TexCoord3fv)(const GLfloat * v); /* 113 */
+   void (GLAPIENTRYP TexCoord3i)(GLint s, GLint t, GLint r); /* 114 */
+   void (GLAPIENTRYP TexCoord3iv)(const GLint * v); /* 115 */
+   void (GLAPIENTRYP TexCoord3s)(GLshort s, GLshort t, GLshort r); /* 116 */
+   void (GLAPIENTRYP TexCoord3sv)(const GLshort * v); /* 117 */
+   void (GLAPIENTRYP TexCoord4d)(GLdouble s, GLdouble t, GLdouble r, GLdouble q); /* 118 */
+   void (GLAPIENTRYP TexCoord4dv)(const GLdouble * v); /* 119 */
+   void (GLAPIENTRYP TexCoord4f)(GLfloat s, GLfloat t, GLfloat r, GLfloat q); /* 120 */
+   void (GLAPIENTRYP TexCoord4fv)(const GLfloat * v); /* 121 */
+   void (GLAPIENTRYP TexCoord4i)(GLint s, GLint t, GLint r, GLint q); /* 122 */
+   void (GLAPIENTRYP TexCoord4iv)(const GLint * v); /* 123 */
+   void (GLAPIENTRYP TexCoord4s)(GLshort s, GLshort t, GLshort r, GLshort q); /* 124 */
+   void (GLAPIENTRYP TexCoord4sv)(const GLshort * v); /* 125 */
+   void (GLAPIENTRYP Vertex2d)(GLdouble x, GLdouble y); /* 126 */
+   void (GLAPIENTRYP Vertex2dv)(const GLdouble * v); /* 127 */
+   void (GLAPIENTRYP Vertex2f)(GLfloat x, GLfloat y); /* 128 */
+   void (GLAPIENTRYP Vertex2fv)(const GLfloat * v); /* 129 */
+   void (GLAPIENTRYP Vertex2i)(GLint x, GLint y); /* 130 */
+   void (GLAPIENTRYP Vertex2iv)(const GLint * v); /* 131 */
+   void (GLAPIENTRYP Vertex2s)(GLshort x, GLshort y); /* 132 */
+   void (GLAPIENTRYP Vertex2sv)(const GLshort * v); /* 133 */
+   void (GLAPIENTRYP Vertex3d)(GLdouble x, GLdouble y, GLdouble z); /* 134 */
+   void (GLAPIENTRYP Vertex3dv)(const GLdouble * v); /* 135 */
+   void (GLAPIENTRYP Vertex3f)(GLfloat x, GLfloat y, GLfloat z); /* 136 */
+   void (GLAPIENTRYP Vertex3fv)(const GLfloat * v); /* 137 */
+   void (GLAPIENTRYP Vertex3i)(GLint x, GLint y, GLint z); /* 138 */
+   void (GLAPIENTRYP Vertex3iv)(const GLint * v); /* 139 */
+   void (GLAPIENTRYP Vertex3s)(GLshort x, GLshort y, GLshort z); /* 140 */
+   void (GLAPIENTRYP Vertex3sv)(const GLshort * v); /* 141 */
+   void (GLAPIENTRYP Vertex4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 142 */
+   void (GLAPIENTRYP Vertex4dv)(const GLdouble * v); /* 143 */
+   void (GLAPIENTRYP Vertex4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 144 */
+   void (GLAPIENTRYP Vertex4fv)(const GLfloat * v); /* 145 */
+   void (GLAPIENTRYP Vertex4i)(GLint x, GLint y, GLint z, GLint w); /* 146 */
+   void (GLAPIENTRYP Vertex4iv)(const GLint * v); /* 147 */
+   void (GLAPIENTRYP Vertex4s)(GLshort x, GLshort y, GLshort z, GLshort w); /* 148 */
+   void (GLAPIENTRYP Vertex4sv)(const GLshort * v); /* 149 */
+   void (GLAPIENTRYP ClipPlane)(GLenum plane, const GLdouble * equation); /* 150 */
+   void (GLAPIENTRYP ColorMaterial)(GLenum face, GLenum mode); /* 151 */
+   void (GLAPIENTRYP CullFace)(GLenum mode); /* 152 */
+   void (GLAPIENTRYP Fogf)(GLenum pname, GLfloat param); /* 153 */
+   void (GLAPIENTRYP Fogfv)(GLenum pname, const GLfloat * params); /* 154 */
+   void (GLAPIENTRYP Fogi)(GLenum pname, GLint param); /* 155 */
+   void (GLAPIENTRYP Fogiv)(GLenum pname, const GLint * params); /* 156 */
+   void (GLAPIENTRYP FrontFace)(GLenum mode); /* 157 */
+   void (GLAPIENTRYP Hint)(GLenum target, GLenum mode); /* 158 */
+   void (GLAPIENTRYP Lightf)(GLenum light, GLenum pname, GLfloat param); /* 159 */
+   void (GLAPIENTRYP Lightfv)(GLenum light, GLenum pname, const GLfloat * params); /* 160 */
+   void (GLAPIENTRYP Lighti)(GLenum light, GLenum pname, GLint param); /* 161 */
+   void (GLAPIENTRYP Lightiv)(GLenum light, GLenum pname, const GLint * params); /* 162 */
+   void (GLAPIENTRYP LightModelf)(GLenum pname, GLfloat param); /* 163 */
+   void (GLAPIENTRYP LightModelfv)(GLenum pname, const GLfloat * params); /* 164 */
+   void (GLAPIENTRYP LightModeli)(GLenum pname, GLint param); /* 165 */
+   void (GLAPIENTRYP LightModeliv)(GLenum pname, const GLint * params); /* 166 */
+   void (GLAPIENTRYP LineStipple)(GLint factor, GLushort pattern); /* 167 */
+   void (GLAPIENTRYP LineWidth)(GLfloat width); /* 168 */
+   void (GLAPIENTRYP Materialf)(GLenum face, GLenum pname, GLfloat param); /* 169 */
+   void (GLAPIENTRYP Materialfv)(GLenum face, GLenum pname, const GLfloat * params); /* 170 */
+   void (GLAPIENTRYP Materiali)(GLenum face, GLenum pname, GLint param); /* 171 */
+   void (GLAPIENTRYP Materialiv)(GLenum face, GLenum pname, const GLint * params); /* 172 */
+   void (GLAPIENTRYP PointSize)(GLfloat size); /* 173 */
+   void (GLAPIENTRYP PolygonMode)(GLenum face, GLenum mode); /* 174 */
+   void (GLAPIENTRYP PolygonStipple)(const GLubyte * mask); /* 175 */
+   void (GLAPIENTRYP Scissor)(GLint x, GLint y, GLsizei width, GLsizei height); /* 176 */
+   void (GLAPIENTRYP ShadeModel)(GLenum mode); /* 177 */
+   void (GLAPIENTRYP TexParameterf)(GLenum target, GLenum pname, GLfloat param); /* 178 */
+   void (GLAPIENTRYP TexParameterfv)(GLenum target, GLenum pname, const GLfloat * params); /* 179 */
+   void (GLAPIENTRYP TexParameteri)(GLenum target, GLenum pname, GLint param); /* 180 */
+   void (GLAPIENTRYP TexParameteriv)(GLenum target, GLenum pname, const GLint * params); /* 181 */
+   void (GLAPIENTRYP TexImage1D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels); /* 182 */
+   void (GLAPIENTRYP TexImage2D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels); /* 183 */
+   void (GLAPIENTRYP TexEnvf)(GLenum target, GLenum pname, GLfloat param); /* 184 */
+   void (GLAPIENTRYP TexEnvfv)(GLenum target, GLenum pname, const GLfloat * params); /* 185 */
+   void (GLAPIENTRYP TexEnvi)(GLenum target, GLenum pname, GLint param); /* 186 */
+   void (GLAPIENTRYP TexEnviv)(GLenum target, GLenum pname, const GLint * params); /* 187 */
+   void (GLAPIENTRYP TexGend)(GLenum coord, GLenum pname, GLdouble param); /* 188 */
+   void (GLAPIENTRYP TexGendv)(GLenum coord, GLenum pname, const GLdouble * params); /* 189 */
+   void (GLAPIENTRYP TexGenf)(GLenum coord, GLenum pname, GLfloat param); /* 190 */
+   void (GLAPIENTRYP TexGenfv)(GLenum coord, GLenum pname, const GLfloat * params); /* 191 */
+   void (GLAPIENTRYP TexGeni)(GLenum coord, GLenum pname, GLint param); /* 192 */
+   void (GLAPIENTRYP TexGeniv)(GLenum coord, GLenum pname, const GLint * params); /* 193 */
+   void (GLAPIENTRYP FeedbackBuffer)(GLsizei size, GLenum type, GLfloat * buffer); /* 194 */
+   void (GLAPIENTRYP SelectBuffer)(GLsizei size, GLuint * buffer); /* 195 */
+   GLint (GLAPIENTRYP RenderMode)(GLenum mode); /* 196 */
+   void (GLAPIENTRYP InitNames)(void); /* 197 */
+   void (GLAPIENTRYP LoadName)(GLuint name); /* 198 */
+   void (GLAPIENTRYP PassThrough)(GLfloat token); /* 199 */
+   void (GLAPIENTRYP PopName)(void); /* 200 */
+   void (GLAPIENTRYP PushName)(GLuint name); /* 201 */
+   void (GLAPIENTRYP DrawBuffer)(GLenum mode); /* 202 */
+   void (GLAPIENTRYP Clear)(GLbitfield mask); /* 203 */
+   void (GLAPIENTRYP ClearAccum)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha); /* 204 */
+   void (GLAPIENTRYP ClearIndex)(GLfloat c); /* 205 */
+   void (GLAPIENTRYP ClearColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); /* 206 */
+   void (GLAPIENTRYP ClearStencil)(GLint s); /* 207 */
+   void (GLAPIENTRYP ClearDepth)(GLclampd depth); /* 208 */
+   void (GLAPIENTRYP StencilMask)(GLuint mask); /* 209 */
+   void (GLAPIENTRYP ColorMask)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha); /* 210 */
+   void (GLAPIENTRYP DepthMask)(GLboolean flag); /* 211 */
+   void (GLAPIENTRYP IndexMask)(GLuint mask); /* 212 */
+   void (GLAPIENTRYP Accum)(GLenum op, GLfloat value); /* 213 */
+   void (GLAPIENTRYP Disable)(GLenum cap); /* 214 */
+   void (GLAPIENTRYP Enable)(GLenum cap); /* 215 */
+   void (GLAPIENTRYP Finish)(void); /* 216 */
+   void (GLAPIENTRYP Flush)(void); /* 217 */
+   void (GLAPIENTRYP PopAttrib)(void); /* 218 */
+   void (GLAPIENTRYP PushAttrib)(GLbitfield mask); /* 219 */
+   void (GLAPIENTRYP Map1d)(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points); /* 220 */
+   void (GLAPIENTRYP Map1f)(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points); /* 221 */
+   void (GLAPIENTRYP Map2d)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points); /* 222 */
+   void (GLAPIENTRYP Map2f)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points); /* 223 */
+   void (GLAPIENTRYP MapGrid1d)(GLint un, GLdouble u1, GLdouble u2); /* 224 */
+   void (GLAPIENTRYP MapGrid1f)(GLint un, GLfloat u1, GLfloat u2); /* 225 */
+   void (GLAPIENTRYP MapGrid2d)(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2); /* 226 */
+   void (GLAPIENTRYP MapGrid2f)(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2); /* 227 */
+   void (GLAPIENTRYP EvalCoord1d)(GLdouble u); /* 228 */
+   void (GLAPIENTRYP EvalCoord1dv)(const GLdouble * u); /* 229 */
+   void (GLAPIENTRYP EvalCoord1f)(GLfloat u); /* 230 */
+   void (GLAPIENTRYP EvalCoord1fv)(const GLfloat * u); /* 231 */
+   void (GLAPIENTRYP EvalCoord2d)(GLdouble u, GLdouble v); /* 232 */
+   void (GLAPIENTRYP EvalCoord2dv)(const GLdouble * u); /* 233 */
+   void (GLAPIENTRYP EvalCoord2f)(GLfloat u, GLfloat v); /* 234 */
+   void (GLAPIENTRYP EvalCoord2fv)(const GLfloat * u); /* 235 */
+   void (GLAPIENTRYP EvalMesh1)(GLenum mode, GLint i1, GLint i2); /* 236 */
+   void (GLAPIENTRYP EvalPoint1)(GLint i); /* 237 */
+   void (GLAPIENTRYP EvalMesh2)(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2); /* 238 */
+   void (GLAPIENTRYP EvalPoint2)(GLint i, GLint j); /* 239 */
+   void (GLAPIENTRYP AlphaFunc)(GLenum func, GLclampf ref); /* 240 */
+   void (GLAPIENTRYP BlendFunc)(GLenum sfactor, GLenum dfactor); /* 241 */
+   void (GLAPIENTRYP LogicOp)(GLenum opcode); /* 242 */
+   void (GLAPIENTRYP StencilFunc)(GLenum func, GLint ref, GLuint mask); /* 243 */
+   void (GLAPIENTRYP StencilOp)(GLenum fail, GLenum zfail, GLenum zpass); /* 244 */
+   void (GLAPIENTRYP DepthFunc)(GLenum func); /* 245 */
+   void (GLAPIENTRYP PixelZoom)(GLfloat xfactor, GLfloat yfactor); /* 246 */
+   void (GLAPIENTRYP PixelTransferf)(GLenum pname, GLfloat param); /* 247 */
+   void (GLAPIENTRYP PixelTransferi)(GLenum pname, GLint param); /* 248 */
+   void (GLAPIENTRYP PixelStoref)(GLenum pname, GLfloat param); /* 249 */
+   void (GLAPIENTRYP PixelStorei)(GLenum pname, GLint param); /* 250 */
+   void (GLAPIENTRYP PixelMapfv)(GLenum map, GLsizei mapsize, const GLfloat * values); /* 251 */
+   void (GLAPIENTRYP PixelMapuiv)(GLenum map, GLsizei mapsize, const GLuint * values); /* 252 */
+   void (GLAPIENTRYP PixelMapusv)(GLenum map, GLsizei mapsize, const GLushort * values); /* 253 */
+   void (GLAPIENTRYP ReadBuffer)(GLenum mode); /* 254 */
+   void (GLAPIENTRYP CopyPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type); /* 255 */
+   void (GLAPIENTRYP ReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels); /* 256 */
+   void (GLAPIENTRYP DrawPixels)(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels); /* 257 */
+   void (GLAPIENTRYP GetBooleanv)(GLenum pname, GLboolean * params); /* 258 */
+   void (GLAPIENTRYP GetClipPlane)(GLenum plane, GLdouble * equation); /* 259 */
+   void (GLAPIENTRYP GetDoublev)(GLenum pname, GLdouble * params); /* 260 */
+   GLenum (GLAPIENTRYP GetError)(void); /* 261 */
+   void (GLAPIENTRYP GetFloatv)(GLenum pname, GLfloat * params); /* 262 */
+   void (GLAPIENTRYP GetIntegerv)(GLenum pname, GLint * params); /* 263 */
+   void (GLAPIENTRYP GetLightfv)(GLenum light, GLenum pname, GLfloat * params); /* 264 */
+   void (GLAPIENTRYP GetLightiv)(GLenum light, GLenum pname, GLint * params); /* 265 */
+   void (GLAPIENTRYP GetMapdv)(GLenum target, GLenum query, GLdouble * v); /* 266 */
+   void (GLAPIENTRYP GetMapfv)(GLenum target, GLenum query, GLfloat * v); /* 267 */
+   void (GLAPIENTRYP GetMapiv)(GLenum target, GLenum query, GLint * v); /* 268 */
+   void (GLAPIENTRYP GetMaterialfv)(GLenum face, GLenum pname, GLfloat * params); /* 269 */
+   void (GLAPIENTRYP GetMaterialiv)(GLenum face, GLenum pname, GLint * params); /* 270 */
+   void (GLAPIENTRYP GetPixelMapfv)(GLenum map, GLfloat * values); /* 271 */
+   void (GLAPIENTRYP GetPixelMapuiv)(GLenum map, GLuint * values); /* 272 */
+   void (GLAPIENTRYP GetPixelMapusv)(GLenum map, GLushort * values); /* 273 */
+   void (GLAPIENTRYP GetPolygonStipple)(GLubyte * mask); /* 274 */
+   const GLubyte * (GLAPIENTRYP GetString)(GLenum name); /* 275 */
+   void (GLAPIENTRYP GetTexEnvfv)(GLenum target, GLenum pname, GLfloat * params); /* 276 */
+   void (GLAPIENTRYP GetTexEnviv)(GLenum target, GLenum pname, GLint * params); /* 277 */
+   void (GLAPIENTRYP GetTexGendv)(GLenum coord, GLenum pname, GLdouble * params); /* 278 */
+   void (GLAPIENTRYP GetTexGenfv)(GLenum coord, GLenum pname, GLfloat * params); /* 279 */
+   void (GLAPIENTRYP GetTexGeniv)(GLenum coord, GLenum pname, GLint * params); /* 280 */
+   void (GLAPIENTRYP GetTexImage)(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels); /* 281 */
+   void (GLAPIENTRYP GetTexParameterfv)(GLenum target, GLenum pname, GLfloat * params); /* 282 */
+   void (GLAPIENTRYP GetTexParameteriv)(GLenum target, GLenum pname, GLint * params); /* 283 */
+   void (GLAPIENTRYP GetTexLevelParameterfv)(GLenum target, GLint level, GLenum pname, GLfloat * params); /* 284 */
+   void (GLAPIENTRYP GetTexLevelParameteriv)(GLenum target, GLint level, GLenum pname, GLint * params); /* 285 */
+   GLboolean (GLAPIENTRYP IsEnabled)(GLenum cap); /* 286 */
+   GLboolean (GLAPIENTRYP IsList)(GLuint list); /* 287 */
+   void (GLAPIENTRYP DepthRange)(GLclampd zNear, GLclampd zFar); /* 288 */
+   void (GLAPIENTRYP Frustum)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); /* 289 */
+   void (GLAPIENTRYP LoadIdentity)(void); /* 290 */
+   void (GLAPIENTRYP LoadMatrixf)(const GLfloat * m); /* 291 */
+   void (GLAPIENTRYP LoadMatrixd)(const GLdouble * m); /* 292 */
+   void (GLAPIENTRYP MatrixMode)(GLenum mode); /* 293 */
+   void (GLAPIENTRYP MultMatrixf)(const GLfloat * m); /* 294 */
+   void (GLAPIENTRYP MultMatrixd)(const GLdouble * m); /* 295 */
+   void (GLAPIENTRYP Ortho)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar); /* 296 */
+   void (GLAPIENTRYP PopMatrix)(void); /* 297 */
+   void (GLAPIENTRYP PushMatrix)(void); /* 298 */
+   void (GLAPIENTRYP Rotated)(GLdouble angle, GLdouble x, GLdouble y, GLdouble z); /* 299 */
+   void (GLAPIENTRYP Rotatef)(GLfloat angle, GLfloat x, GLfloat y, GLfloat z); /* 300 */
+   void (GLAPIENTRYP Scaled)(GLdouble x, GLdouble y, GLdouble z); /* 301 */
+   void (GLAPIENTRYP Scalef)(GLfloat x, GLfloat y, GLfloat z); /* 302 */
+   void (GLAPIENTRYP Translated)(GLdouble x, GLdouble y, GLdouble z); /* 303 */
+   void (GLAPIENTRYP Translatef)(GLfloat x, GLfloat y, GLfloat z); /* 304 */
+   void (GLAPIENTRYP Viewport)(GLint x, GLint y, GLsizei width, GLsizei height); /* 305 */
+   void (GLAPIENTRYP ArrayElement)(GLint i); /* 306 */
+   void (GLAPIENTRYP BindTexture)(GLenum target, GLuint texture); /* 307 */
+   void (GLAPIENTRYP ColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer); /* 308 */
+   void (GLAPIENTRYP DisableClientState)(GLenum array); /* 309 */
+   void (GLAPIENTRYP DrawArrays)(GLenum mode, GLint first, GLsizei count); /* 310 */
+   void (GLAPIENTRYP DrawElements)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices); /* 311 */
+   void (GLAPIENTRYP EdgeFlagPointer)(GLsizei stride, const GLvoid * pointer); /* 312 */
+   void (GLAPIENTRYP EnableClientState)(GLenum array); /* 313 */
+   void (GLAPIENTRYP IndexPointer)(GLenum type, GLsizei stride, const GLvoid * pointer); /* 314 */
+   void (GLAPIENTRYP Indexub)(GLubyte c); /* 315 */
+   void (GLAPIENTRYP Indexubv)(const GLubyte * c); /* 316 */
+   void (GLAPIENTRYP InterleavedArrays)(GLenum format, GLsizei stride, const GLvoid * pointer); /* 317 */
+   void (GLAPIENTRYP NormalPointer)(GLenum type, GLsizei stride, const GLvoid * pointer); /* 318 */
+   void (GLAPIENTRYP PolygonOffset)(GLfloat factor, GLfloat units); /* 319 */
+   void (GLAPIENTRYP TexCoordPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer); /* 320 */
+   void (GLAPIENTRYP VertexPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer); /* 321 */
+   GLboolean (GLAPIENTRYP AreTexturesResident)(GLsizei n, const GLuint * textures, GLboolean * residences); /* 322 */
+   void (GLAPIENTRYP CopyTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border); /* 323 */
+   void (GLAPIENTRYP CopyTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border); /* 324 */
+   void (GLAPIENTRYP CopyTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width); /* 325 */
+   void (GLAPIENTRYP CopyTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height); /* 326 */
+   void (GLAPIENTRYP DeleteTextures)(GLsizei n, const GLuint * textures); /* 327 */
+   void (GLAPIENTRYP GenTextures)(GLsizei n, GLuint * textures); /* 328 */
+   void (GLAPIENTRYP GetPointerv)(GLenum pname, GLvoid ** params); /* 329 */
+   GLboolean (GLAPIENTRYP IsTexture)(GLuint texture); /* 330 */
+   void (GLAPIENTRYP PrioritizeTextures)(GLsizei n, const GLuint * textures, const GLclampf * priorities); /* 331 */
+   void (GLAPIENTRYP TexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels); /* 332 */
+   void (GLAPIENTRYP TexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels); /* 333 */
+   void (GLAPIENTRYP PopClientAttrib)(void); /* 334 */
+   void (GLAPIENTRYP PushClientAttrib)(GLbitfield mask); /* 335 */
+   void (GLAPIENTRYP BlendColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha); /* 336 */
+   void (GLAPIENTRYP BlendEquation)(GLenum mode); /* 337 */
+   void (GLAPIENTRYP DrawRangeElements)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices); /* 338 */
+   void (GLAPIENTRYP ColorTable)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table); /* 339 */
+   void (GLAPIENTRYP ColorTableParameterfv)(GLenum target, GLenum pname, const GLfloat * params); /* 340 */
+   void (GLAPIENTRYP ColorTableParameteriv)(GLenum target, GLenum pname, const GLint * params); /* 341 */
+   void (GLAPIENTRYP CopyColorTable)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); /* 342 */
+   void (GLAPIENTRYP GetColorTable)(GLenum target, GLenum format, GLenum type, GLvoid * table); /* 343 */
+   void (GLAPIENTRYP GetColorTableParameterfv)(GLenum target, GLenum pname, GLfloat * params); /* 344 */
+   void (GLAPIENTRYP GetColorTableParameteriv)(GLenum target, GLenum pname, GLint * params); /* 345 */
+   void (GLAPIENTRYP ColorSubTable)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data); /* 346 */
+   void (GLAPIENTRYP CopyColorSubTable)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width); /* 347 */
+   void (GLAPIENTRYP ConvolutionFilter1D)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image); /* 348 */
+   void (GLAPIENTRYP ConvolutionFilter2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image); /* 349 */
+   void (GLAPIENTRYP ConvolutionParameterf)(GLenum target, GLenum pname, GLfloat params); /* 350 */
+   void (GLAPIENTRYP ConvolutionParameterfv)(GLenum target, GLenum pname, const GLfloat * params); /* 351 */
+   void (GLAPIENTRYP ConvolutionParameteri)(GLenum target, GLenum pname, GLint params); /* 352 */
+   void (GLAPIENTRYP ConvolutionParameteriv)(GLenum target, GLenum pname, const GLint * params); /* 353 */
+   void (GLAPIENTRYP CopyConvolutionFilter1D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width); /* 354 */
+   void (GLAPIENTRYP CopyConvolutionFilter2D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height); /* 355 */
+   void (GLAPIENTRYP GetConvolutionFilter)(GLenum target, GLenum format, GLenum type, GLvoid * image); /* 356 */
+   void (GLAPIENTRYP GetConvolutionParameterfv)(GLenum target, GLenum pname, GLfloat * params); /* 357 */
+   void (GLAPIENTRYP GetConvolutionParameteriv)(GLenum target, GLenum pname, GLint * params); /* 358 */
+   void (GLAPIENTRYP GetSeparableFilter)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span); /* 359 */
+   void (GLAPIENTRYP SeparableFilter2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column); /* 360 */
+   void (GLAPIENTRYP GetHistogram)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values); /* 361 */
+   void (GLAPIENTRYP GetHistogramParameterfv)(GLenum target, GLenum pname, GLfloat * params); /* 362 */
+   void (GLAPIENTRYP GetHistogramParameteriv)(GLenum target, GLenum pname, GLint * params); /* 363 */
+   void (GLAPIENTRYP GetMinmax)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values); /* 364 */
+   void (GLAPIENTRYP GetMinmaxParameterfv)(GLenum target, GLenum pname, GLfloat * params); /* 365 */
+   void (GLAPIENTRYP GetMinmaxParameteriv)(GLenum target, GLenum pname, GLint * params); /* 366 */
+   void (GLAPIENTRYP Histogram)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink); /* 367 */
+   void (GLAPIENTRYP Minmax)(GLenum target, GLenum internalformat, GLboolean sink); /* 368 */
+   void (GLAPIENTRYP ResetHistogram)(GLenum target); /* 369 */
+   void (GLAPIENTRYP ResetMinmax)(GLenum target); /* 370 */
+   void (GLAPIENTRYP TexImage3D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels); /* 371 */
+   void (GLAPIENTRYP TexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels); /* 372 */
+   void (GLAPIENTRYP CopyTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height); /* 373 */
+   void (GLAPIENTRYP ActiveTextureARB)(GLenum texture); /* 374 */
+   void (GLAPIENTRYP ClientActiveTextureARB)(GLenum texture); /* 375 */
+   void (GLAPIENTRYP MultiTexCoord1dARB)(GLenum target, GLdouble s); /* 376 */
+   void (GLAPIENTRYP MultiTexCoord1dvARB)(GLenum target, const GLdouble * v); /* 377 */
+   void (GLAPIENTRYP MultiTexCoord1fARB)(GLenum target, GLfloat s); /* 378 */
+   void (GLAPIENTRYP MultiTexCoord1fvARB)(GLenum target, const GLfloat * v); /* 379 */
+   void (GLAPIENTRYP MultiTexCoord1iARB)(GLenum target, GLint s); /* 380 */
+   void (GLAPIENTRYP MultiTexCoord1ivARB)(GLenum target, const GLint * v); /* 381 */
+   void (GLAPIENTRYP MultiTexCoord1sARB)(GLenum target, GLshort s); /* 382 */
+   void (GLAPIENTRYP MultiTexCoord1svARB)(GLenum target, const GLshort * v); /* 383 */
+   void (GLAPIENTRYP MultiTexCoord2dARB)(GLenum target, GLdouble s, GLdouble t); /* 384 */
+   void (GLAPIENTRYP MultiTexCoord2dvARB)(GLenum target, const GLdouble * v); /* 385 */
+   void (GLAPIENTRYP MultiTexCoord2fARB)(GLenum target, GLfloat s, GLfloat t); /* 386 */
+   void (GLAPIENTRYP MultiTexCoord2fvARB)(GLenum target, const GLfloat * v); /* 387 */
+   void (GLAPIENTRYP MultiTexCoord2iARB)(GLenum target, GLint s, GLint t); /* 388 */
+   void (GLAPIENTRYP MultiTexCoord2ivARB)(GLenum target, const GLint * v); /* 389 */
+   void (GLAPIENTRYP MultiTexCoord2sARB)(GLenum target, GLshort s, GLshort t); /* 390 */
+   void (GLAPIENTRYP MultiTexCoord2svARB)(GLenum target, const GLshort * v); /* 391 */
+   void (GLAPIENTRYP MultiTexCoord3dARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r); /* 392 */
+   void (GLAPIENTRYP MultiTexCoord3dvARB)(GLenum target, const GLdouble * v); /* 393 */
+   void (GLAPIENTRYP MultiTexCoord3fARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r); /* 394 */
+   void (GLAPIENTRYP MultiTexCoord3fvARB)(GLenum target, const GLfloat * v); /* 395 */
+   void (GLAPIENTRYP MultiTexCoord3iARB)(GLenum target, GLint s, GLint t, GLint r); /* 396 */
+   void (GLAPIENTRYP MultiTexCoord3ivARB)(GLenum target, const GLint * v); /* 397 */
+   void (GLAPIENTRYP MultiTexCoord3sARB)(GLenum target, GLshort s, GLshort t, GLshort r); /* 398 */
+   void (GLAPIENTRYP MultiTexCoord3svARB)(GLenum target, const GLshort * v); /* 399 */
+   void (GLAPIENTRYP MultiTexCoord4dARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q); /* 400 */
+   void (GLAPIENTRYP MultiTexCoord4dvARB)(GLenum target, const GLdouble * v); /* 401 */
+   void (GLAPIENTRYP MultiTexCoord4fARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q); /* 402 */
+   void (GLAPIENTRYP MultiTexCoord4fvARB)(GLenum target, const GLfloat * v); /* 403 */
+   void (GLAPIENTRYP MultiTexCoord4iARB)(GLenum target, GLint s, GLint t, GLint r, GLint q); /* 404 */
+   void (GLAPIENTRYP MultiTexCoord4ivARB)(GLenum target, const GLint * v); /* 405 */
+   void (GLAPIENTRYP MultiTexCoord4sARB)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q); /* 406 */
+   void (GLAPIENTRYP MultiTexCoord4svARB)(GLenum target, const GLshort * v); /* 407 */
+   void (GLAPIENTRYP AttachShader)(GLuint program, GLuint shader); /* 408 */
+   GLuint (GLAPIENTRYP CreateProgram)(void); /* 409 */
+   GLuint (GLAPIENTRYP CreateShader)(GLenum type); /* 410 */
+   void (GLAPIENTRYP DeleteProgram)(GLuint program); /* 411 */
+   void (GLAPIENTRYP DeleteShader)(GLuint program); /* 412 */
+   void (GLAPIENTRYP DetachShader)(GLuint program, GLuint shader); /* 413 */
+   void (GLAPIENTRYP GetAttachedShaders)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj); /* 414 */
+   void (GLAPIENTRYP GetProgramInfoLog)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog); /* 415 */
+   void (GLAPIENTRYP GetProgramiv)(GLuint program, GLenum pname, GLint * params); /* 416 */
+   void (GLAPIENTRYP GetShaderInfoLog)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog); /* 417 */
+   void (GLAPIENTRYP GetShaderiv)(GLuint shader, GLenum pname, GLint * params); /* 418 */
+   GLboolean (GLAPIENTRYP IsProgram)(GLuint program); /* 419 */
+   GLboolean (GLAPIENTRYP IsShader)(GLuint shader); /* 420 */
+   void (GLAPIENTRYP StencilFuncSeparate)(GLenum face, GLenum func, GLint ref, GLuint mask); /* 421 */
+   void (GLAPIENTRYP StencilMaskSeparate)(GLenum face, GLuint mask); /* 422 */
+   void (GLAPIENTRYP StencilOpSeparate)(GLenum face, GLenum sfail, GLenum zfail, GLenum zpass); /* 423 */
+   void (GLAPIENTRYP UniformMatrix2x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 424 */
+   void (GLAPIENTRYP UniformMatrix2x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 425 */
+   void (GLAPIENTRYP UniformMatrix3x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 426 */
+   void (GLAPIENTRYP UniformMatrix3x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 427 */
+   void (GLAPIENTRYP UniformMatrix4x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 428 */
+   void (GLAPIENTRYP UniformMatrix4x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 429 */
+   void (GLAPIENTRYP LoadTransposeMatrixdARB)(const GLdouble * m); /* 430 */
+   void (GLAPIENTRYP LoadTransposeMatrixfARB)(const GLfloat * m); /* 431 */
+   void (GLAPIENTRYP MultTransposeMatrixdARB)(const GLdouble * m); /* 432 */
+   void (GLAPIENTRYP MultTransposeMatrixfARB)(const GLfloat * m); /* 433 */
+   void (GLAPIENTRYP SampleCoverageARB)(GLclampf value, GLboolean invert); /* 434 */
+   void (GLAPIENTRYP CompressedTexImage1DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data); /* 435 */
+   void (GLAPIENTRYP CompressedTexImage2DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data); /* 436 */
+   void (GLAPIENTRYP CompressedTexImage3DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data); /* 437 */
+   void (GLAPIENTRYP CompressedTexSubImage1DARB)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data); /* 438 */
+   void (GLAPIENTRYP CompressedTexSubImage2DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data); /* 439 */
+   void (GLAPIENTRYP CompressedTexSubImage3DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data); /* 440 */
+   void (GLAPIENTRYP GetCompressedTexImageARB)(GLenum target, GLint level, GLvoid * img); /* 441 */
+   void (GLAPIENTRYP DisableVertexAttribArrayARB)(GLuint index); /* 442 */
+   void (GLAPIENTRYP EnableVertexAttribArrayARB)(GLuint index); /* 443 */
+   void (GLAPIENTRYP GetProgramEnvParameterdvARB)(GLenum target, GLuint index, GLdouble * params); /* 444 */
+   void (GLAPIENTRYP GetProgramEnvParameterfvARB)(GLenum target, GLuint index, GLfloat * params); /* 445 */
+   void (GLAPIENTRYP GetProgramLocalParameterdvARB)(GLenum target, GLuint index, GLdouble * params); /* 446 */
+   void (GLAPIENTRYP GetProgramLocalParameterfvARB)(GLenum target, GLuint index, GLfloat * params); /* 447 */
+   void (GLAPIENTRYP GetProgramStringARB)(GLenum target, GLenum pname, GLvoid * string); /* 448 */
+   void (GLAPIENTRYP GetProgramivARB)(GLenum target, GLenum pname, GLint * params); /* 449 */
+   void (GLAPIENTRYP GetVertexAttribdvARB)(GLuint index, GLenum pname, GLdouble * params); /* 450 */
+   void (GLAPIENTRYP GetVertexAttribfvARB)(GLuint index, GLenum pname, GLfloat * params); /* 451 */
+   void (GLAPIENTRYP GetVertexAttribivARB)(GLuint index, GLenum pname, GLint * params); /* 452 */
+   void (GLAPIENTRYP ProgramEnvParameter4dARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 453 */
+   void (GLAPIENTRYP ProgramEnvParameter4dvARB)(GLenum target, GLuint index, const GLdouble * params); /* 454 */
+   void (GLAPIENTRYP ProgramEnvParameter4fARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 455 */
+   void (GLAPIENTRYP ProgramEnvParameter4fvARB)(GLenum target, GLuint index, const GLfloat * params); /* 456 */
+   void (GLAPIENTRYP ProgramLocalParameter4dARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 457 */
+   void (GLAPIENTRYP ProgramLocalParameter4dvARB)(GLenum target, GLuint index, const GLdouble * params); /* 458 */
+   void (GLAPIENTRYP ProgramLocalParameter4fARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 459 */
+   void (GLAPIENTRYP ProgramLocalParameter4fvARB)(GLenum target, GLuint index, const GLfloat * params); /* 460 */
+   void (GLAPIENTRYP ProgramStringARB)(GLenum target, GLenum format, GLsizei len, const GLvoid * string); /* 461 */
+   void (GLAPIENTRYP VertexAttrib1dARB)(GLuint index, GLdouble x); /* 462 */
+   void (GLAPIENTRYP VertexAttrib1dvARB)(GLuint index, const GLdouble * v); /* 463 */
+   void (GLAPIENTRYP VertexAttrib1fARB)(GLuint index, GLfloat x); /* 464 */
+   void (GLAPIENTRYP VertexAttrib1fvARB)(GLuint index, const GLfloat * v); /* 465 */
+   void (GLAPIENTRYP VertexAttrib1sARB)(GLuint index, GLshort x); /* 466 */
+   void (GLAPIENTRYP VertexAttrib1svARB)(GLuint index, const GLshort * v); /* 467 */
+   void (GLAPIENTRYP VertexAttrib2dARB)(GLuint index, GLdouble x, GLdouble y); /* 468 */
+   void (GLAPIENTRYP VertexAttrib2dvARB)(GLuint index, const GLdouble * v); /* 469 */
+   void (GLAPIENTRYP VertexAttrib2fARB)(GLuint index, GLfloat x, GLfloat y); /* 470 */
+   void (GLAPIENTRYP VertexAttrib2fvARB)(GLuint index, const GLfloat * v); /* 471 */
+   void (GLAPIENTRYP VertexAttrib2sARB)(GLuint index, GLshort x, GLshort y); /* 472 */
+   void (GLAPIENTRYP VertexAttrib2svARB)(GLuint index, const GLshort * v); /* 473 */
+   void (GLAPIENTRYP VertexAttrib3dARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z); /* 474 */
+   void (GLAPIENTRYP VertexAttrib3dvARB)(GLuint index, const GLdouble * v); /* 475 */
+   void (GLAPIENTRYP VertexAttrib3fARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z); /* 476 */
+   void (GLAPIENTRYP VertexAttrib3fvARB)(GLuint index, const GLfloat * v); /* 477 */
+   void (GLAPIENTRYP VertexAttrib3sARB)(GLuint index, GLshort x, GLshort y, GLshort z); /* 478 */
+   void (GLAPIENTRYP VertexAttrib3svARB)(GLuint index, const GLshort * v); /* 479 */
+   void (GLAPIENTRYP VertexAttrib4NbvARB)(GLuint index, const GLbyte * v); /* 480 */
+   void (GLAPIENTRYP VertexAttrib4NivARB)(GLuint index, const GLint * v); /* 481 */
+   void (GLAPIENTRYP VertexAttrib4NsvARB)(GLuint index, const GLshort * v); /* 482 */
+   void (GLAPIENTRYP VertexAttrib4NubARB)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); /* 483 */
+   void (GLAPIENTRYP VertexAttrib4NubvARB)(GLuint index, const GLubyte * v); /* 484 */
+   void (GLAPIENTRYP VertexAttrib4NuivARB)(GLuint index, const GLuint * v); /* 485 */
+   void (GLAPIENTRYP VertexAttrib4NusvARB)(GLuint index, const GLushort * v); /* 486 */
+   void (GLAPIENTRYP VertexAttrib4bvARB)(GLuint index, const GLbyte * v); /* 487 */
+   void (GLAPIENTRYP VertexAttrib4dARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 488 */
+   void (GLAPIENTRYP VertexAttrib4dvARB)(GLuint index, const GLdouble * v); /* 489 */
+   void (GLAPIENTRYP VertexAttrib4fARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 490 */
+   void (GLAPIENTRYP VertexAttrib4fvARB)(GLuint index, const GLfloat * v); /* 491 */
+   void (GLAPIENTRYP VertexAttrib4ivARB)(GLuint index, const GLint * v); /* 492 */
+   void (GLAPIENTRYP VertexAttrib4sARB)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); /* 493 */
+   void (GLAPIENTRYP VertexAttrib4svARB)(GLuint index, const GLshort * v); /* 494 */
+   void (GLAPIENTRYP VertexAttrib4ubvARB)(GLuint index, const GLubyte * v); /* 495 */
+   void (GLAPIENTRYP VertexAttrib4uivARB)(GLuint index, const GLuint * v); /* 496 */
+   void (GLAPIENTRYP VertexAttrib4usvARB)(GLuint index, const GLushort * v); /* 497 */
+   void (GLAPIENTRYP VertexAttribPointerARB)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer); /* 498 */
+   void (GLAPIENTRYP BindBufferARB)(GLenum target, GLuint buffer); /* 499 */
+   void (GLAPIENTRYP BufferDataARB)(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage); /* 500 */
+   void (GLAPIENTRYP BufferSubDataARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data); /* 501 */
+   void (GLAPIENTRYP DeleteBuffersARB)(GLsizei n, const GLuint * buffer); /* 502 */
+   void (GLAPIENTRYP GenBuffersARB)(GLsizei n, GLuint * buffer); /* 503 */
+   void (GLAPIENTRYP GetBufferParameterivARB)(GLenum target, GLenum pname, GLint * params); /* 504 */
+   void (GLAPIENTRYP GetBufferPointervARB)(GLenum target, GLenum pname, GLvoid ** params); /* 505 */
+   void (GLAPIENTRYP GetBufferSubDataARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data); /* 506 */
+   GLboolean (GLAPIENTRYP IsBufferARB)(GLuint buffer); /* 507 */
+   GLvoid * (GLAPIENTRYP MapBufferARB)(GLenum target, GLenum access); /* 508 */
+   GLboolean (GLAPIENTRYP UnmapBufferARB)(GLenum target); /* 509 */
+   void (GLAPIENTRYP BeginQueryARB)(GLenum target, GLuint id); /* 510 */
+   void (GLAPIENTRYP DeleteQueriesARB)(GLsizei n, const GLuint * ids); /* 511 */
+   void (GLAPIENTRYP EndQueryARB)(GLenum target); /* 512 */
+   void (GLAPIENTRYP GenQueriesARB)(GLsizei n, GLuint * ids); /* 513 */
+   void (GLAPIENTRYP GetQueryObjectivARB)(GLuint id, GLenum pname, GLint * params); /* 514 */
+   void (GLAPIENTRYP GetQueryObjectuivARB)(GLuint id, GLenum pname, GLuint * params); /* 515 */
+   void (GLAPIENTRYP GetQueryivARB)(GLenum target, GLenum pname, GLint * params); /* 516 */
+   GLboolean (GLAPIENTRYP IsQueryARB)(GLuint id); /* 517 */
+   void (GLAPIENTRYP AttachObjectARB)(GLhandleARB containerObj, GLhandleARB obj); /* 518 */
+   void (GLAPIENTRYP CompileShaderARB)(GLhandleARB shader); /* 519 */
+   GLhandleARB (GLAPIENTRYP CreateProgramObjectARB)(void); /* 520 */
+   GLhandleARB (GLAPIENTRYP CreateShaderObjectARB)(GLenum shaderType); /* 521 */
+   void (GLAPIENTRYP DeleteObjectARB)(GLhandleARB obj); /* 522 */
+   void (GLAPIENTRYP DetachObjectARB)(GLhandleARB containerObj, GLhandleARB attachedObj); /* 523 */
+   void (GLAPIENTRYP GetActiveUniformARB)(GLhandleARB program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name); /* 524 */
+   void (GLAPIENTRYP GetAttachedObjectsARB)(GLhandleARB containerObj, GLsizei maxLength, GLsizei * length, GLhandleARB * infoLog); /* 525 */
+   GLhandleARB (GLAPIENTRYP GetHandleARB)(GLenum pname); /* 526 */
+   void (GLAPIENTRYP GetInfoLogARB)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog); /* 527 */
+   void (GLAPIENTRYP GetObjectParameterfvARB)(GLhandleARB obj, GLenum pname, GLfloat * params); /* 528 */
+   void (GLAPIENTRYP GetObjectParameterivARB)(GLhandleARB obj, GLenum pname, GLint * params); /* 529 */
+   void (GLAPIENTRYP GetShaderSourceARB)(GLhandleARB shader, GLsizei bufSize, GLsizei * length, GLcharARB * source); /* 530 */
+   GLint (GLAPIENTRYP GetUniformLocationARB)(GLhandleARB program, const GLcharARB * name); /* 531 */
+   void (GLAPIENTRYP GetUniformfvARB)(GLhandleARB program, GLint location, GLfloat * params); /* 532 */
+   void (GLAPIENTRYP GetUniformivARB)(GLhandleARB program, GLint location, GLint * params); /* 533 */
+   void (GLAPIENTRYP LinkProgramARB)(GLhandleARB program); /* 534 */
+   void (GLAPIENTRYP ShaderSourceARB)(GLhandleARB shader, GLsizei count, const GLcharARB ** string, const GLint * length); /* 535 */
+   void (GLAPIENTRYP Uniform1fARB)(GLint location, GLfloat v0); /* 536 */
+   void (GLAPIENTRYP Uniform1fvARB)(GLint location, GLsizei count, const GLfloat * value); /* 537 */
+   void (GLAPIENTRYP Uniform1iARB)(GLint location, GLint v0); /* 538 */
+   void (GLAPIENTRYP Uniform1ivARB)(GLint location, GLsizei count, const GLint * value); /* 539 */
+   void (GLAPIENTRYP Uniform2fARB)(GLint location, GLfloat v0, GLfloat v1); /* 540 */
+   void (GLAPIENTRYP Uniform2fvARB)(GLint location, GLsizei count, const GLfloat * value); /* 541 */
+   void (GLAPIENTRYP Uniform2iARB)(GLint location, GLint v0, GLint v1); /* 542 */
+   void (GLAPIENTRYP Uniform2ivARB)(GLint location, GLsizei count, const GLint * value); /* 543 */
+   void (GLAPIENTRYP Uniform3fARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2); /* 544 */
+   void (GLAPIENTRYP Uniform3fvARB)(GLint location, GLsizei count, const GLfloat * value); /* 545 */
+   void (GLAPIENTRYP Uniform3iARB)(GLint location, GLint v0, GLint v1, GLint v2); /* 546 */
+   void (GLAPIENTRYP Uniform3ivARB)(GLint location, GLsizei count, const GLint * value); /* 547 */
+   void (GLAPIENTRYP Uniform4fARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3); /* 548 */
+   void (GLAPIENTRYP Uniform4fvARB)(GLint location, GLsizei count, const GLfloat * value); /* 549 */
+   void (GLAPIENTRYP Uniform4iARB)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3); /* 550 */
+   void (GLAPIENTRYP Uniform4ivARB)(GLint location, GLsizei count, const GLint * value); /* 551 */
+   void (GLAPIENTRYP UniformMatrix2fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 552 */
+   void (GLAPIENTRYP UniformMatrix3fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 553 */
+   void (GLAPIENTRYP UniformMatrix4fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value); /* 554 */
+   void (GLAPIENTRYP UseProgramObjectARB)(GLhandleARB program); /* 555 */
+   void (GLAPIENTRYP ValidateProgramARB)(GLhandleARB program); /* 556 */
+   void (GLAPIENTRYP BindAttribLocationARB)(GLhandleARB program, GLuint index, const GLcharARB * name); /* 557 */
+   void (GLAPIENTRYP GetActiveAttribARB)(GLhandleARB program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name); /* 558 */
+   GLint (GLAPIENTRYP GetAttribLocationARB)(GLhandleARB program, const GLcharARB * name); /* 559 */
+   void (GLAPIENTRYP DrawBuffersARB)(GLsizei n, const GLenum * bufs); /* 560 */
+   void (GLAPIENTRYP PolygonOffsetEXT)(GLfloat factor, GLfloat bias); /* 561 */
+   void (GLAPIENTRYP GetPixelTexGenParameterfvSGIS)(GLenum pname, GLfloat * params); /* 562 */
+   void (GLAPIENTRYP GetPixelTexGenParameterivSGIS)(GLenum pname, GLint * params); /* 563 */
+   void (GLAPIENTRYP PixelTexGenParameterfSGIS)(GLenum pname, GLfloat param); /* 564 */
+   void (GLAPIENTRYP PixelTexGenParameterfvSGIS)(GLenum pname, const GLfloat * params); /* 565 */
+   void (GLAPIENTRYP PixelTexGenParameteriSGIS)(GLenum pname, GLint param); /* 566 */
+   void (GLAPIENTRYP PixelTexGenParameterivSGIS)(GLenum pname, const GLint * params); /* 567 */
+   void (GLAPIENTRYP SampleMaskSGIS)(GLclampf value, GLboolean invert); /* 568 */
+   void (GLAPIENTRYP SamplePatternSGIS)(GLenum pattern); /* 569 */
+   void (GLAPIENTRYP ColorPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer); /* 570 */
+   void (GLAPIENTRYP EdgeFlagPointerEXT)(GLsizei stride, GLsizei count, const GLboolean * pointer); /* 571 */
+   void (GLAPIENTRYP IndexPointerEXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer); /* 572 */
+   void (GLAPIENTRYP NormalPointerEXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer); /* 573 */
+   void (GLAPIENTRYP TexCoordPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer); /* 574 */
+   void (GLAPIENTRYP VertexPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer); /* 575 */
+   void (GLAPIENTRYP PointParameterfEXT)(GLenum pname, GLfloat param); /* 576 */
+   void (GLAPIENTRYP PointParameterfvEXT)(GLenum pname, const GLfloat * params); /* 577 */
+   void (GLAPIENTRYP LockArraysEXT)(GLint first, GLsizei count); /* 578 */
+   void (GLAPIENTRYP UnlockArraysEXT)(void); /* 579 */
+   void (GLAPIENTRYP CullParameterdvEXT)(GLenum pname, GLdouble * params); /* 580 */
+   void (GLAPIENTRYP CullParameterfvEXT)(GLenum pname, GLfloat * params); /* 581 */
+   void (GLAPIENTRYP SecondaryColor3bEXT)(GLbyte red, GLbyte green, GLbyte blue); /* 582 */
+   void (GLAPIENTRYP SecondaryColor3bvEXT)(const GLbyte * v); /* 583 */
+   void (GLAPIENTRYP SecondaryColor3dEXT)(GLdouble red, GLdouble green, GLdouble blue); /* 584 */
+   void (GLAPIENTRYP SecondaryColor3dvEXT)(const GLdouble * v); /* 585 */
+   void (GLAPIENTRYP SecondaryColor3fEXT)(GLfloat red, GLfloat green, GLfloat blue); /* 586 */
+   void (GLAPIENTRYP SecondaryColor3fvEXT)(const GLfloat * v); /* 587 */
+   void (GLAPIENTRYP SecondaryColor3iEXT)(GLint red, GLint green, GLint blue); /* 588 */
+   void (GLAPIENTRYP SecondaryColor3ivEXT)(const GLint * v); /* 589 */
+   void (GLAPIENTRYP SecondaryColor3sEXT)(GLshort red, GLshort green, GLshort blue); /* 590 */
+   void (GLAPIENTRYP SecondaryColor3svEXT)(const GLshort * v); /* 591 */
+   void (GLAPIENTRYP SecondaryColor3ubEXT)(GLubyte red, GLubyte green, GLubyte blue); /* 592 */
+   void (GLAPIENTRYP SecondaryColor3ubvEXT)(const GLubyte * v); /* 593 */
+   void (GLAPIENTRYP SecondaryColor3uiEXT)(GLuint red, GLuint green, GLuint blue); /* 594 */
+   void (GLAPIENTRYP SecondaryColor3uivEXT)(const GLuint * v); /* 595 */
+   void (GLAPIENTRYP SecondaryColor3usEXT)(GLushort red, GLushort green, GLushort blue); /* 596 */
+   void (GLAPIENTRYP SecondaryColor3usvEXT)(const GLushort * v); /* 597 */
+   void (GLAPIENTRYP SecondaryColorPointerEXT)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer); /* 598 */
+   void (GLAPIENTRYP MultiDrawArraysEXT)(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount); /* 599 */
+   void (GLAPIENTRYP MultiDrawElementsEXT)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid ** indices, GLsizei primcount); /* 600 */
+   void (GLAPIENTRYP FogCoordPointerEXT)(GLenum type, GLsizei stride, const GLvoid * pointer); /* 601 */
+   void (GLAPIENTRYP FogCoorddEXT)(GLdouble coord); /* 602 */
+   void (GLAPIENTRYP FogCoorddvEXT)(const GLdouble * coord); /* 603 */
+   void (GLAPIENTRYP FogCoordfEXT)(GLfloat coord); /* 604 */
+   void (GLAPIENTRYP FogCoordfvEXT)(const GLfloat * coord); /* 605 */
+   void (GLAPIENTRYP PixelTexGenSGIX)(GLenum mode); /* 606 */
+   void (GLAPIENTRYP BlendFuncSeparateEXT)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha); /* 607 */
+   void (GLAPIENTRYP FlushVertexArrayRangeNV)(void); /* 608 */
+   void (GLAPIENTRYP VertexArrayRangeNV)(GLsizei length, const GLvoid * pointer); /* 609 */
+   void (GLAPIENTRYP CombinerInputNV)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage); /* 610 */
+   void (GLAPIENTRYP CombinerOutputNV)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum); /* 611 */
+   void (GLAPIENTRYP CombinerParameterfNV)(GLenum pname, GLfloat param); /* 612 */
+   void (GLAPIENTRYP CombinerParameterfvNV)(GLenum pname, const GLfloat * params); /* 613 */
+   void (GLAPIENTRYP CombinerParameteriNV)(GLenum pname, GLint param); /* 614 */
+   void (GLAPIENTRYP CombinerParameterivNV)(GLenum pname, const GLint * params); /* 615 */
+   void (GLAPIENTRYP FinalCombinerInputNV)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage); /* 616 */
+   void (GLAPIENTRYP GetCombinerInputParameterfvNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params); /* 617 */
+   void (GLAPIENTRYP GetCombinerInputParameterivNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params); /* 618 */
+   void (GLAPIENTRYP GetCombinerOutputParameterfvNV)(GLenum stage, GLenum portion, GLenum pname, GLfloat * params); /* 619 */
+   void (GLAPIENTRYP GetCombinerOutputParameterivNV)(GLenum stage, GLenum portion, GLenum pname, GLint * params); /* 620 */
+   void (GLAPIENTRYP GetFinalCombinerInputParameterfvNV)(GLenum variable, GLenum pname, GLfloat * params); /* 621 */
+   void (GLAPIENTRYP GetFinalCombinerInputParameterivNV)(GLenum variable, GLenum pname, GLint * params); /* 622 */
+   void (GLAPIENTRYP ResizeBuffersMESA)(void); /* 623 */
+   void (GLAPIENTRYP WindowPos2dMESA)(GLdouble x, GLdouble y); /* 624 */
+   void (GLAPIENTRYP WindowPos2dvMESA)(const GLdouble * v); /* 625 */
+   void (GLAPIENTRYP WindowPos2fMESA)(GLfloat x, GLfloat y); /* 626 */
+   void (GLAPIENTRYP WindowPos2fvMESA)(const GLfloat * v); /* 627 */
+   void (GLAPIENTRYP WindowPos2iMESA)(GLint x, GLint y); /* 628 */
+   void (GLAPIENTRYP WindowPos2ivMESA)(const GLint * v); /* 629 */
+   void (GLAPIENTRYP WindowPos2sMESA)(GLshort x, GLshort y); /* 630 */
+   void (GLAPIENTRYP WindowPos2svMESA)(const GLshort * v); /* 631 */
+   void (GLAPIENTRYP WindowPos3dMESA)(GLdouble x, GLdouble y, GLdouble z); /* 632 */
+   void (GLAPIENTRYP WindowPos3dvMESA)(const GLdouble * v); /* 633 */
+   void (GLAPIENTRYP WindowPos3fMESA)(GLfloat x, GLfloat y, GLfloat z); /* 634 */
+   void (GLAPIENTRYP WindowPos3fvMESA)(const GLfloat * v); /* 635 */
+   void (GLAPIENTRYP WindowPos3iMESA)(GLint x, GLint y, GLint z); /* 636 */
+   void (GLAPIENTRYP WindowPos3ivMESA)(const GLint * v); /* 637 */
+   void (GLAPIENTRYP WindowPos3sMESA)(GLshort x, GLshort y, GLshort z); /* 638 */
+   void (GLAPIENTRYP WindowPos3svMESA)(const GLshort * v); /* 639 */
+   void (GLAPIENTRYP WindowPos4dMESA)(GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 640 */
+   void (GLAPIENTRYP WindowPos4dvMESA)(const GLdouble * v); /* 641 */
+   void (GLAPIENTRYP WindowPos4fMESA)(GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 642 */
+   void (GLAPIENTRYP WindowPos4fvMESA)(const GLfloat * v); /* 643 */
+   void (GLAPIENTRYP WindowPos4iMESA)(GLint x, GLint y, GLint z, GLint w); /* 644 */
+   void (GLAPIENTRYP WindowPos4ivMESA)(const GLint * v); /* 645 */
+   void (GLAPIENTRYP WindowPos4sMESA)(GLshort x, GLshort y, GLshort z, GLshort w); /* 646 */
+   void (GLAPIENTRYP WindowPos4svMESA)(const GLshort * v); /* 647 */
+   void (GLAPIENTRYP MultiModeDrawArraysIBM)(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride); /* 648 */
+   void (GLAPIENTRYP MultiModeDrawElementsIBM)(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride); /* 649 */
+   void (GLAPIENTRYP DeleteFencesNV)(GLsizei n, const GLuint * fences); /* 650 */
+   void (GLAPIENTRYP FinishFenceNV)(GLuint fence); /* 651 */
+   void (GLAPIENTRYP GenFencesNV)(GLsizei n, GLuint * fences); /* 652 */
+   void (GLAPIENTRYP GetFenceivNV)(GLuint fence, GLenum pname, GLint * params); /* 653 */
+   GLboolean (GLAPIENTRYP IsFenceNV)(GLuint fence); /* 654 */
+   void (GLAPIENTRYP SetFenceNV)(GLuint fence, GLenum condition); /* 655 */
+   GLboolean (GLAPIENTRYP TestFenceNV)(GLuint fence); /* 656 */
+   GLboolean (GLAPIENTRYP AreProgramsResidentNV)(GLsizei n, const GLuint * ids, GLboolean * residences); /* 657 */
+   void (GLAPIENTRYP BindProgramNV)(GLenum target, GLuint program); /* 658 */
+   void (GLAPIENTRYP DeleteProgramsNV)(GLsizei n, const GLuint * programs); /* 659 */
+   void (GLAPIENTRYP ExecuteProgramNV)(GLenum target, GLuint id, const GLfloat * params); /* 660 */
+   void (GLAPIENTRYP GenProgramsNV)(GLsizei n, GLuint * programs); /* 661 */
+   void (GLAPIENTRYP GetProgramParameterdvNV)(GLenum target, GLuint index, GLenum pname, GLdouble * params); /* 662 */
+   void (GLAPIENTRYP GetProgramParameterfvNV)(GLenum target, GLuint index, GLenum pname, GLfloat * params); /* 663 */
+   void (GLAPIENTRYP GetProgramStringNV)(GLuint id, GLenum pname, GLubyte * program); /* 664 */
+   void (GLAPIENTRYP GetProgramivNV)(GLuint id, GLenum pname, GLint * params); /* 665 */
+   void (GLAPIENTRYP GetTrackMatrixivNV)(GLenum target, GLuint address, GLenum pname, GLint * params); /* 666 */
+   void (GLAPIENTRYP GetVertexAttribPointervNV)(GLuint index, GLenum pname, GLvoid ** pointer); /* 667 */
+   void (GLAPIENTRYP GetVertexAttribdvNV)(GLuint index, GLenum pname, GLdouble * params); /* 668 */
+   void (GLAPIENTRYP GetVertexAttribfvNV)(GLuint index, GLenum pname, GLfloat * params); /* 669 */
+   void (GLAPIENTRYP GetVertexAttribivNV)(GLuint index, GLenum pname, GLint * params); /* 670 */
+   GLboolean (GLAPIENTRYP IsProgramNV)(GLuint program); /* 671 */
+   void (GLAPIENTRYP LoadProgramNV)(GLenum target, GLuint id, GLsizei len, const GLubyte * program); /* 672 */
+   void (GLAPIENTRYP ProgramParameters4dvNV)(GLenum target, GLuint index, GLuint num, const GLdouble * params); /* 673 */
+   void (GLAPIENTRYP ProgramParameters4fvNV)(GLenum target, GLuint index, GLuint num, const GLfloat * params); /* 674 */
+   void (GLAPIENTRYP RequestResidentProgramsNV)(GLsizei n, const GLuint * ids); /* 675 */
+   void (GLAPIENTRYP TrackMatrixNV)(GLenum target, GLuint address, GLenum matrix, GLenum transform); /* 676 */
+   void (GLAPIENTRYP VertexAttrib1dNV)(GLuint index, GLdouble x); /* 677 */
+   void (GLAPIENTRYP VertexAttrib1dvNV)(GLuint index, const GLdouble * v); /* 678 */
+   void (GLAPIENTRYP VertexAttrib1fNV)(GLuint index, GLfloat x); /* 679 */
+   void (GLAPIENTRYP VertexAttrib1fvNV)(GLuint index, const GLfloat * v); /* 680 */
+   void (GLAPIENTRYP VertexAttrib1sNV)(GLuint index, GLshort x); /* 681 */
+   void (GLAPIENTRYP VertexAttrib1svNV)(GLuint index, const GLshort * v); /* 682 */
+   void (GLAPIENTRYP VertexAttrib2dNV)(GLuint index, GLdouble x, GLdouble y); /* 683 */
+   void (GLAPIENTRYP VertexAttrib2dvNV)(GLuint index, const GLdouble * v); /* 684 */
+   void (GLAPIENTRYP VertexAttrib2fNV)(GLuint index, GLfloat x, GLfloat y); /* 685 */
+   void (GLAPIENTRYP VertexAttrib2fvNV)(GLuint index, const GLfloat * v); /* 686 */
+   void (GLAPIENTRYP VertexAttrib2sNV)(GLuint index, GLshort x, GLshort y); /* 687 */
+   void (GLAPIENTRYP VertexAttrib2svNV)(GLuint index, const GLshort * v); /* 688 */
+   void (GLAPIENTRYP VertexAttrib3dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z); /* 689 */
+   void (GLAPIENTRYP VertexAttrib3dvNV)(GLuint index, const GLdouble * v); /* 690 */
+   void (GLAPIENTRYP VertexAttrib3fNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z); /* 691 */
+   void (GLAPIENTRYP VertexAttrib3fvNV)(GLuint index, const GLfloat * v); /* 692 */
+   void (GLAPIENTRYP VertexAttrib3sNV)(GLuint index, GLshort x, GLshort y, GLshort z); /* 693 */
+   void (GLAPIENTRYP VertexAttrib3svNV)(GLuint index, const GLshort * v); /* 694 */
+   void (GLAPIENTRYP VertexAttrib4dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 695 */
+   void (GLAPIENTRYP VertexAttrib4dvNV)(GLuint index, const GLdouble * v); /* 696 */
+   void (GLAPIENTRYP VertexAttrib4fNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 697 */
+   void (GLAPIENTRYP VertexAttrib4fvNV)(GLuint index, const GLfloat * v); /* 698 */
+   void (GLAPIENTRYP VertexAttrib4sNV)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w); /* 699 */
+   void (GLAPIENTRYP VertexAttrib4svNV)(GLuint index, const GLshort * v); /* 700 */
+   void (GLAPIENTRYP VertexAttrib4ubNV)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w); /* 701 */
+   void (GLAPIENTRYP VertexAttrib4ubvNV)(GLuint index, const GLubyte * v); /* 702 */
+   void (GLAPIENTRYP VertexAttribPointerNV)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer); /* 703 */
+   void (GLAPIENTRYP VertexAttribs1dvNV)(GLuint index, GLsizei n, const GLdouble * v); /* 704 */
+   void (GLAPIENTRYP VertexAttribs1fvNV)(GLuint index, GLsizei n, const GLfloat * v); /* 705 */
+   void (GLAPIENTRYP VertexAttribs1svNV)(GLuint index, GLsizei n, const GLshort * v); /* 706 */
+   void (GLAPIENTRYP VertexAttribs2dvNV)(GLuint index, GLsizei n, const GLdouble * v); /* 707 */
+   void (GLAPIENTRYP VertexAttribs2fvNV)(GLuint index, GLsizei n, const GLfloat * v); /* 708 */
+   void (GLAPIENTRYP VertexAttribs2svNV)(GLuint index, GLsizei n, const GLshort * v); /* 709 */
+   void (GLAPIENTRYP VertexAttribs3dvNV)(GLuint index, GLsizei n, const GLdouble * v); /* 710 */
+   void (GLAPIENTRYP VertexAttribs3fvNV)(GLuint index, GLsizei n, const GLfloat * v); /* 711 */
+   void (GLAPIENTRYP VertexAttribs3svNV)(GLuint index, GLsizei n, const GLshort * v); /* 712 */
+   void (GLAPIENTRYP VertexAttribs4dvNV)(GLuint index, GLsizei n, const GLdouble * v); /* 713 */
+   void (GLAPIENTRYP VertexAttribs4fvNV)(GLuint index, GLsizei n, const GLfloat * v); /* 714 */
+   void (GLAPIENTRYP VertexAttribs4svNV)(GLuint index, GLsizei n, const GLshort * v); /* 715 */
+   void (GLAPIENTRYP VertexAttribs4ubvNV)(GLuint index, GLsizei n, const GLubyte * v); /* 716 */
+   void (GLAPIENTRYP AlphaFragmentOp1ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod); /* 717 */
+   void (GLAPIENTRYP AlphaFragmentOp2ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod); /* 718 */
+   void (GLAPIENTRYP AlphaFragmentOp3ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod); /* 719 */
+   void (GLAPIENTRYP BeginFragmentShaderATI)(void); /* 720 */
+   void (GLAPIENTRYP BindFragmentShaderATI)(GLuint id); /* 721 */
+   void (GLAPIENTRYP ColorFragmentOp1ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod); /* 722 */
+   void (GLAPIENTRYP ColorFragmentOp2ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod); /* 723 */
+   void (GLAPIENTRYP ColorFragmentOp3ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod); /* 724 */
+   void (GLAPIENTRYP DeleteFragmentShaderATI)(GLuint id); /* 725 */
+   void (GLAPIENTRYP EndFragmentShaderATI)(void); /* 726 */
+   GLuint (GLAPIENTRYP GenFragmentShadersATI)(GLuint range); /* 727 */
+   void (GLAPIENTRYP PassTexCoordATI)(GLuint dst, GLuint coord, GLenum swizzle); /* 728 */
+   void (GLAPIENTRYP SampleMapATI)(GLuint dst, GLuint interp, GLenum swizzle); /* 729 */
+   void (GLAPIENTRYP SetFragmentShaderConstantATI)(GLuint dst, const GLfloat * value); /* 730 */
+   void (GLAPIENTRYP PointParameteriNV)(GLenum pname, GLint param); /* 731 */
+   void (GLAPIENTRYP PointParameterivNV)(GLenum pname, const GLint * params); /* 732 */
+   void (GLAPIENTRYP ActiveStencilFaceEXT)(GLenum face); /* 733 */
+   void (GLAPIENTRYP BindVertexArrayAPPLE)(GLuint array); /* 734 */
+   void (GLAPIENTRYP DeleteVertexArraysAPPLE)(GLsizei n, const GLuint * arrays); /* 735 */
+   void (GLAPIENTRYP GenVertexArraysAPPLE)(GLsizei n, GLuint * arrays); /* 736 */
+   GLboolean (GLAPIENTRYP IsVertexArrayAPPLE)(GLuint array); /* 737 */
+   void (GLAPIENTRYP GetProgramNamedParameterdvNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params); /* 738 */
+   void (GLAPIENTRYP GetProgramNamedParameterfvNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params); /* 739 */
+   void (GLAPIENTRYP ProgramNamedParameter4dNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w); /* 740 */
+   void (GLAPIENTRYP ProgramNamedParameter4dvNV)(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v); /* 741 */
+   void (GLAPIENTRYP ProgramNamedParameter4fNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w); /* 742 */
+   void (GLAPIENTRYP ProgramNamedParameter4fvNV)(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v); /* 743 */
+   void (GLAPIENTRYP DepthBoundsEXT)(GLclampd zmin, GLclampd zmax); /* 744 */
+   void (GLAPIENTRYP BlendEquationSeparateEXT)(GLenum modeRGB, GLenum modeA); /* 745 */
+   void (GLAPIENTRYP BindFramebufferEXT)(GLenum target, GLuint framebuffer); /* 746 */
+   void (GLAPIENTRYP BindRenderbufferEXT)(GLenum target, GLuint renderbuffer); /* 747 */
+   GLenum (GLAPIENTRYP CheckFramebufferStatusEXT)(GLenum target); /* 748 */
+   void (GLAPIENTRYP DeleteFramebuffersEXT)(GLsizei n, const GLuint * framebuffers); /* 749 */
+   void (GLAPIENTRYP DeleteRenderbuffersEXT)(GLsizei n, const GLuint * renderbuffers); /* 750 */
+   void (GLAPIENTRYP FramebufferRenderbufferEXT)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer); /* 751 */
+   void (GLAPIENTRYP FramebufferTexture1DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); /* 752 */
+   void (GLAPIENTRYP FramebufferTexture2DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level); /* 753 */
+   void (GLAPIENTRYP FramebufferTexture3DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset); /* 754 */
+   void (GLAPIENTRYP GenFramebuffersEXT)(GLsizei n, GLuint * framebuffers); /* 755 */
+   void (GLAPIENTRYP GenRenderbuffersEXT)(GLsizei n, GLuint * renderbuffers); /* 756 */
+   void (GLAPIENTRYP GenerateMipmapEXT)(GLenum target); /* 757 */
+   void (GLAPIENTRYP GetFramebufferAttachmentParameterivEXT)(GLenum target, GLenum attachment, GLenum pname, GLint * params); /* 758 */
+   void (GLAPIENTRYP GetRenderbufferParameterivEXT)(GLenum target, GLenum pname, GLint * params); /* 759 */
+   GLboolean (GLAPIENTRYP IsFramebufferEXT)(GLuint framebuffer); /* 760 */
+   GLboolean (GLAPIENTRYP IsRenderbufferEXT)(GLuint renderbuffer); /* 761 */
+   void (GLAPIENTRYP RenderbufferStorageEXT)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height); /* 762 */
+   void (GLAPIENTRYP BlitFramebufferEXT)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter); /* 763 */
+   void (GLAPIENTRYP FramebufferTextureLayerEXT)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer); /* 764 */
+   void (GLAPIENTRYP StencilFuncSeparateATI)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask); /* 765 */
+   void (GLAPIENTRYP ProgramEnvParameters4fvEXT)(GLenum target, GLuint index, GLsizei count, const GLfloat * params); /* 766 */
+   void (GLAPIENTRYP ProgramLocalParameters4fvEXT)(GLenum target, GLuint index, GLsizei count, const GLfloat * params); /* 767 */
+   void (GLAPIENTRYP GetQueryObjecti64vEXT)(GLuint id, GLenum pname, GLint64EXT * params); /* 768 */
+   void (GLAPIENTRYP GetQueryObjectui64vEXT)(GLuint id, GLenum pname, GLuint64EXT * params); /* 769 */
+};
+
+#endif /* !defined( _GLAPI_TABLE_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vbeModes.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vbeModes.h
@@ -0,0 +1,90 @@
+/*
+ * Copyright © 2002 David Dawes
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the author(s) shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from
+ * the author(s).
+ *
+ * Authors: David Dawes <dawes@xfree86.org>
+ *
+ */
+
+#ifndef _VBE_MODES_H
+
+/*
+ * This is intended to be stored in the DisplayModeRec's private area.
+ * It includes all the information necessary to VBE information.
+ */
+typedef struct _VbeModeInfoData {
+    int mode;
+    VbeModeInfoBlock *data;
+    VbeCRTCInfoBlock *block;
+} VbeModeInfoData;
+
+#define V_DEPTH_1	0x001
+#define V_DEPTH_4	0x002
+#define V_DEPTH_8	0x004
+#define V_DEPTH_15	0x008
+#define V_DEPTH_16	0x010
+#define V_DEPTH_24_24	0x020
+#define V_DEPTH_24_32	0x040
+#define V_DEPTH_24	(V_DEPTH_24_24 | V_DEPTH_24_32)
+#define V_DEPTH_30	0x080
+#define V_DEPTH_32	0x100
+
+#define VBE_MODE_SUPPORTED(m)	(((m)->ModeAttributes & 0x01) != 0)
+#define VBE_MODE_COLOR(m)	(((m)->ModeAttributes & 0x08) != 0)
+#define VBE_MODE_GRAPHICS(m)	(((m)->ModeAttributes & 0x10) != 0)
+#define VBE_MODE_VGA(m)		(((m)->ModeAttributes & 0x40) == 0)
+#define VBE_MODE_LINEAR(m)	(((m)->ModeAttributes & 0x80) != 0 && \
+				 ((m)->PhysBasePtr != 0))
+
+#define VBE_MODE_USABLE(m, f)	(VBE_MODE_SUPPORTED(m) || \
+				 (f & V_MODETYPE_BAD)) && \
+				VBE_MODE_GRAPHICS(m) && \
+				(VBE_MODE_VGA(m) || VBE_MODE_LINEAR(m))
+				
+#define V_MODETYPE_VBE		0x01
+#define V_MODETYPE_VGA		0x02
+#define V_MODETYPE_BAD		0x04
+
+extern _X_EXPORT int VBEFindSupportedDepths(vbeInfoPtr pVbe, VbeInfoBlock *vbe,
+				  int *flags24, int modeTypes);
+extern _X_EXPORT DisplayModePtr VBEGetModePool(ScrnInfoPtr pScrn, vbeInfoPtr pVbe,
+					VbeInfoBlock *vbe, int modeTypes);
+extern _X_EXPORT void VBESetModeNames(DisplayModePtr pMode);
+extern _X_EXPORT void VBESetModeParameters(ScrnInfoPtr pScrn, vbeInfoPtr pVbe);
+
+
+/*
+ * Note: These are alternatives to the standard helpers.  They should
+ * usually just wrap the standard helpers.
+ */
+extern _X_EXPORT int VBEValidateModes(ScrnInfoPtr scrp, DisplayModePtr availModes,
+			    char **modeNames, ClockRangePtr clockRanges,
+			    int *linePitches, int minPitch, int maxPitch,
+			    int pitchInc, int minHeight, int maxHeight,
+			    int virtualX, int virtualY, int apertureSize,
+			    LookupModeFlags strategy);
+extern _X_EXPORT void VBEPrintModes(ScrnInfoPtr scrp);
+
+#endif /* VBE_MODES_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/wfbrename.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/wfbrename.h
@@ -0,0 +1,190 @@
+#define fb16Lane wfb16Lane
+#define fb24_32CopyMtoN wfb24_32CopyMtoN
+#define fb24_32CreateScreenResources wfb24_32CreateScreenResources
+#define fb24_32GetImage wfb24_32GetImage
+#define fb24_32GetSpans wfb24_32GetSpans
+#define fb24_32ModifyPixmapHeader wfb24_32ModifyPixmapHeader
+#define fb24_32PutZImage wfb24_32PutZImage
+#define fb24_32ReformatTile wfb24_32ReformatTile
+#define fb24_32SetSpans wfb24_32SetSpans
+#define fb32Lane wfb32Lane
+#define fb8Lane wfb8Lane
+#define fbAddTraps wfbAddTraps
+#define fbAddTriangles wfbAddTriangles
+#define fbAllocatePrivates wfbAllocatePrivates
+#define fbArc16 wfbArc16
+#define fbArc24 wfbArc24
+#define fbArc32 wfbArc32
+#define fbArc8 wfbArc8
+#define fbBlt wfbBlt
+#define fbBlt24 wfbBlt24
+#define fbBltOne wfbBltOne
+#define fbBltOne24 wfbBltOne24
+#define fbBltPlane wfbBltPlane
+#define fbBltStip wfbBltStip
+#define fbBres wfbBres
+#define fbBresDash wfbBresDash
+#define fbBresDash16 wfbBresDash16
+#define fbBresDash24 wfbBresDash24
+#define fbBresDash32 wfbBresDash32
+#define fbBresDash8 wfbBresDash8
+#define fbBresFill wfbBresFill
+#define fbBresFillDash wfbBresFillDash
+#define fbBresSolid wfbBresSolid
+#define fbBresSolid16 wfbBresSolid16
+#define fbBresSolid24 wfbBresSolid24
+#define fbBresSolid32 wfbBresSolid32
+#define fbBresSolid8 wfbBresSolid8
+#define fbChangeWindowAttributes wfbChangeWindowAttributes
+#define fbClearVisualTypes wfbClearVisualTypes
+#define fbCloseScreen wfbCloseScreen
+#define fbComposite wfbComposite
+#define fbCompositeGeneral wfbCompositeGeneral
+#define fbCompositeSolidMask_nx1xn wfbCompositeSolidMask_nx1xn
+#define fbCompositeSolidMask_nx8888x0565C wfbCompositeSolidMask_nx8888x0565C
+#define fbCompositeSolidMask_nx8888x8888C wfbCompositeSolidMask_nx8888x8888C
+#define fbCompositeSolidMask_nx8x0565 wfbCompositeSolidMask_nx8x0565
+#define fbCompositeSolidMask_nx8x0888 wfbCompositeSolidMask_nx8x0888
+#define fbCompositeSolidMask_nx8x8888 wfbCompositeSolidMask_nx8x8888
+#define fbCompositeSrc_0565x0565 wfbCompositeSrc_0565x0565
+#define fbCompositeSrc_8888x0565 wfbCompositeSrc_8888x0565
+#define fbCompositeSrc_8888x0888 wfbCompositeSrc_8888x0888
+#define fbCompositeSrc_8888x8888 wfbCompositeSrc_8888x8888
+#define fbCompositeSrcAdd_1000x1000 wfbCompositeSrcAdd_1000x1000
+#define fbCompositeSrcAdd_8000x8000 wfbCompositeSrcAdd_8000x8000
+#define fbCompositeSrcAdd_8888x8888 wfbCompositeSrcAdd_8888x8888
+#define fbCopy1toN wfbCopy1toN
+#define fbCopyArea wfbCopyArea
+#define fbCopyNto1 wfbCopyNto1
+#define fbCopyNtoN wfbCopyNtoN
+#define fbCopyPlane wfbCopyPlane
+#define fbCopyRegion wfbCopyRegion
+#define fbCopyWindow wfbCopyWindow
+#define fbCopyWindowProc wfbCopyWindowProc
+#define fbCreateDefColormap wfbCreateDefColormap
+#define fbCreateGC wfbCreateGC
+#define fbCreatePixmap wfbCreatePixmap
+#define fbCreatePixmapBpp wfbCreatePixmapBpp
+#define fbCreateWindow wfbCreateWindow
+#define fbDestroyPixmap wfbDestroyPixmap
+#define fbDestroyWindow wfbDestroyWindow
+#define fbDoCopy wfbDoCopy
+#define fbDots wfbDots
+#define fbDots16 wfbDots16
+#define fbDots24 wfbDots24
+#define fbDots32 wfbDots32
+#define fbDots8 wfbDots8
+#define fbEvenStipple wfbEvenStipple
+#define fbEvenTile wfbEvenTile
+#define fbExpandDirectColors wfbExpandDirectColors
+#define fbFill wfbFill
+#define fbFillRegionSolid wfbFillRegionSolid
+#define fbFillSpans wfbFillSpans
+#define fbFixCoordModePrevious wfbFixCoordModePrevious
+#define fbGCFuncs wfbGCFuncs
+#define fbGCOps wfbGCOps
+#define fbGCPrivateKeyRec wfbGCPrivateKeyRec
+#define fbGeneration wfbGeneration
+#define fbGetGCPrivateKey wfbGetGCPrivateKey
+#define fbGetImage wfbGetImage
+#define fbGetScreenPrivateKey wfbGetScreenPrivateKey
+#define fbGetSpans wfbGetSpans
+#define _fbGetWindowPixmap _wfbGetWindowPixmap
+#define fbWinPrivateKeyRec wfbWinPrivateKeyRec
+#define fbGetWinPrivateKey wfbGetWinPrivateKey
+#define fbGlyph16 wfbGlyph16
+#define fbGlyph24 wfbGlyph24
+#define fbGlyph32 wfbGlyph32
+#define fbGlyph8 wfbGlyph8
+#define fbGlyphIn wfbGlyphIn
+#define fbHasVisualTypes wfbHasVisualTypes
+#define fbImageGlyphBlt wfbImageGlyphBlt
+#define fbIn wfbIn
+#define fbInitializeColormap wfbInitializeColormap
+#define fbInitVisuals wfbInitVisuals
+#define fbInstallColormap wfbInstallColormap
+#define fbLaneTable wfbLaneTable
+#define fbListInstalledColormaps wfbListInstalledColormaps
+#define fbMapWindow wfbMapWindow
+#define FbMergeRopBits wFbMergeRopBits
+#define fbOddStipple wfbOddStipple
+#define fbOddTile wfbOddTile
+#define fbOver wfbOver
+#define fbOver24 wfbOver24
+#define fbOverlayCloseScreen wfbOverlayCloseScreen
+#define fbOverlayCopyWindow wfbOverlayCopyWindow
+#define fbOverlayCreateScreenResources wfbOverlayCreateScreenResources
+#define fbOverlayCreateWindow wfbOverlayCreateWindow
+#define fbOverlayFinishScreenInit wfbOverlayFinishScreenInit
+#define fbOverlayGeneration wfbOverlayGeneration
+#define fbOverlayGetScreenPrivateKey wfbOverlayGetScreenPrivateKey
+#define fbOverlayPaintKey wfbOverlayPaintKey
+#define fbOverlaySetupScreen wfbOverlaySetupScreen
+#define fbOverlayUpdateLayerRegion wfbOverlayUpdateLayerRegion
+#define fbOverlayWindowExposures wfbOverlayWindowExposures
+#define fbOverlayWindowLayer wfbOverlayWindowLayer
+#define fbPadPixmap wfbPadPixmap
+#define fbPictureInit wfbPictureInit
+#define fbPixmapToRegion wfbPixmapToRegion
+#define fbPolyArc wfbPolyArc
+#define fbPolyFillRect wfbPolyFillRect
+#define fbPolyGlyphBlt wfbPolyGlyphBlt
+#define fbPolyLine wfbPolyLine
+#define fbPolyline16 wfbPolyline16
+#define fbPolyline24 wfbPolyline24
+#define fbPolyline32 wfbPolyline32
+#define fbPolyline8 wfbPolyline8
+#define fbPolyPoint wfbPolyPoint
+#define fbPolySegment wfbPolySegment
+#define fbPolySegment16 wfbPolySegment16
+#define fbPolySegment24 wfbPolySegment24
+#define fbPolySegment32 wfbPolySegment32
+#define fbPolySegment8 wfbPolySegment8
+#define fbPositionWindow wfbPositionWindow
+#define fbPushFill wfbPushFill
+#define fbPushImage wfbPushImage
+#define fbPushPattern wfbPushPattern
+#define fbPushPixels wfbPushPixels
+#define fbPutImage wfbPutImage
+#define fbPutXYImage wfbPutXYImage
+#define fbPutZImage wfbPutZImage
+#define fbQueryBestSize wfbQueryBestSize
+#define fbRasterizeEdges wfbRasterizeEdges
+#define fbRasterizeTrapezoid wfbRasterizeTrapezoid
+#define fbRealizeFont wfbRealizeFont
+#define fbReduceRasterOp wfbReduceRasterOp
+#define fbReplicatePixel wfbReplicatePixel
+#define fbResolveColor wfbResolveColor
+#define fbRestoreAreas wfbRestoreAreas
+#define fbSaveAreas wfbSaveAreas
+#define fbScreenPrivateKeyRec wfbScreenPrivateKeyRec
+#define fbSegment wfbSegment
+#define fbSelectBres wfbSelectBres
+#define fbSetSpans wfbSetSpans
+#define fbSetupScreen wfbSetupScreen
+#define fbSetVisualTypes wfbSetVisualTypes
+#define fbSetVisualTypesAndMasks wfbSetVisualTypesAndMasks
+#define _fbSetWindowPixmap _wfbSetWindowPixmap
+#define fbSolid wfbSolid
+#define fbSolid24 wfbSolid24
+#define fbSolidBoxClipped wfbSolidBoxClipped
+#define fbStipple wfbStipple
+#define fbStipple1Bits wfbStipple1Bits
+#define fbStipple24Bits wfbStipple24Bits
+#define fbStipple2Bits wfbStipple2Bits
+#define fbStipple4Bits wfbStipple4Bits
+#define fbStipple8Bits wfbStipple8Bits
+#define fbStippleTable wfbStippleTable
+#define fbTile wfbTile
+#define fbTransparentSpan wfbTransparentSpan
+#define fbUninstallColormap wfbUninstallColormap
+#define fbUnmapWindow wfbUnmapWindow
+#define fbUnrealizeFont wfbUnrealizeFont
+#define fbValidateGC wfbValidateGC
+#define fbWalkCompositeRegion wfbWalkCompositeRegion
+#define fbWinPrivateKeyRec wfbWinPrivateKeyRec
+#define fbZeroLine wfbZeroLine
+#define fbZeroSegment wfbZeroSegment
+#define free_pixman_pict wfb_free_pixman_pict
+#define image_from_pict wfb_image_from_pict
+#define composeFunctions wfbComposeFunctions
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/protocol-versions.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/protocol-versions.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * This file specifies the server-supported protocol versions.
+ */
+#ifndef _PROTOCOL_VERSIONS_
+#define _PROTOCOL_VERSIONS_
+
+/* Apple DRI */
+#define SERVER_APPLEDRI_MAJOR_VERSION		1
+#define SERVER_APPLEDRI_MINOR_VERSION		0
+#define SERVER_APPLEDRI_PATCH_VERSION		0
+
+/* AppleWM */
+#define SERVER_APPLEWM_MAJOR_VERSION		1
+#define SERVER_APPLEWM_MINOR_VERSION		3
+#define SERVER_APPLEWM_PATCH_VERSION		0
+
+/* Composite */
+#define SERVER_COMPOSITE_MAJOR_VERSION		0
+#define SERVER_COMPOSITE_MINOR_VERSION		4
+
+/* Damage */
+#define SERVER_DAMAGE_MAJOR_VERSION		1
+#define SERVER_DAMAGE_MINOR_VERSION		1
+
+/* DMX */
+#define SERVER_DMX_MAJOR_VERSION		2
+#define SERVER_DMX_MINOR_VERSION		2
+#define SERVER_DMX_PATCH_VERSION		20040604
+
+/* Generic event extension */
+#define SERVER_GE_MAJOR_VERSION                 1
+#define SERVER_GE_MINOR_VERSION                 0
+
+/* GLX */
+#define SERVER_GLX_MAJOR_VERSION		1
+#define SERVER_GLX_MINOR_VERSION		4
+
+/* Xinerama */
+#define SERVER_PANORAMIX_MAJOR_VERSION          1
+#define SERVER_PANORAMIX_MINOR_VERSION		1
+
+/* RandR */
+#define SERVER_RANDR_MAJOR_VERSION		1
+#define SERVER_RANDR_MINOR_VERSION		3
+
+/* Record */
+#define SERVER_RECORD_MAJOR_VERSION		1
+#define SERVER_RECORD_MINOR_VERSION		13
+
+/* Render */
+#define SERVER_RENDER_MAJOR_VERSION		0
+#define SERVER_RENDER_MINOR_VERSION		11
+
+/* RandR Xinerama */
+#define SERVER_RRXINERAMA_MAJOR_VERSION		1
+#define SERVER_RRXINERAMA_MINOR_VERSION		1
+
+/* Screensaver */
+#define SERVER_SAVER_MAJOR_VERSION		1
+#define SERVER_SAVER_MINOR_VERSION		1
+
+/* Security */
+#define SERVER_SECURITY_MAJOR_VERSION		1
+#define SERVER_SECURITY_MINOR_VERSION		0
+
+/* Shape */
+#define SERVER_SHAPE_MAJOR_VERSION		1
+#define SERVER_SHAPE_MINOR_VERSION		1
+
+/* SHM */
+#define SERVER_SHM_MAJOR_VERSION		1
+#define SERVER_SHM_MINOR_VERSION		1
+
+/* Windows WM */
+#define SERVER_WINDOWSWM_MAJOR_VERSION		1
+#define SERVER_WINDOWSWM_MINOR_VERSION		0
+#define SERVER_WINDOWSWM_PATCH_VERSION		0
+
+/* Xcalibrate */
+#define SERVER_XCALIBRATE_MAJOR_VERSION		0
+#define SERVER_XCALIBRATE_MINOR_VERSION		1
+
+/* DGA */
+#define SERVER_XDGA_MAJOR_VERSION		2
+#define SERVER_XDGA_MINOR_VERSION		0
+
+/* Big Font */
+#define SERVER_XF86BIGFONT_MAJOR_VERSION	1
+#define SERVER_XF86BIGFONT_MINOR_VERSION	1
+
+/* DRI */
+#define SERVER_XF86DRI_MAJOR_VERSION		4
+#define SERVER_XF86DRI_MINOR_VERSION		1
+#define SERVER_XF86DRI_PATCH_VERSION		20040604
+
+/* Vidmode */
+#define SERVER_XF86VIDMODE_MAJOR_VERSION	2
+#define SERVER_XF86VIDMODE_MINOR_VERSION	2
+
+/* Fixes */
+#define SERVER_XFIXES_MAJOR_VERSION		4
+#define SERVER_XFIXES_MINOR_VERSION		0
+
+/* X Input */
+#define SERVER_XI_MAJOR_VERSION			2
+#define SERVER_XI_MINOR_VERSION			0
+
+/* XKB */
+#define SERVER_XKB_MAJOR_VERSION		1
+#define SERVER_XKB_MINOR_VERSION		0
+
+/* Resource */
+#define SERVER_XRES_MAJOR_VERSION		1
+#define SERVER_XRES_MINOR_VERSION		0
+
+/* XvMC */
+#define SERVER_XVMC_MAJOR_VERSION		1
+#define SERVER_XVMC_MINOR_VERSION		1
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mioverlay.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mioverlay.h
@@ -0,0 +1,32 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef __MIOVERLAY_H
+#define __MIOVERLAY_H
+
+typedef void (*miOverlayTransFunc)(ScreenPtr, int, BoxPtr);
+typedef Bool (*miOverlayInOverlayFunc)(WindowPtr);
+
+extern _X_EXPORT Bool
+miInitOverlay(
+   ScreenPtr pScreen, 
+   miOverlayInOverlayFunc inOverlay,
+   miOverlayTransFunc trans
+);
+
+extern _X_EXPORT Bool
+miOverlayGetPrivateClips(
+    WindowPtr pWin,
+    RegionPtr *borderClip,
+    RegionPtr *clipList
+);
+
+extern _X_EXPORT Bool miOverlayCollectUnderlayRegions(WindowPtr, RegionPtr*);
+extern _X_EXPORT void miOverlayComputeCompositeClip(GCPtr, WindowPtr);
+extern _X_EXPORT Bool miOverlayCopyUnderlay(ScreenPtr);
+extern _X_EXPORT void miOverlaySetTransFunction(ScreenPtr, miOverlayTransFunc);
+extern _X_EXPORT void miOverlaySetRootClip(ScreenPtr, Bool);
+
+#endif /* __MIOVERLAY_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/README
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/README
@@ -0,0 +1,10 @@
+The contents of this directory were extracted from the contents of the
+archive xorg-server-1.9.0.tar.bz2, as downloaded from ftp.x.org, using the
+following shell script:
+
+for i in `find xorg-server-1.9.0 -name '*.h' | grep -v hw/xwin \
+ | grep -v hw/xquartz | grep -v hw/kdrive | grep -v hw/xnest \
+ | grep -v hw/xprint | grep -v hw/xgl`
+  do
+    cp $i $PATH_VBOX/src/VBox/Additions/x11/x11include/xorg-server-1.9.0/
+  done
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxpixmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxpixmap.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for pixmap support.  \see dmxpixmap.c */
+
+#ifndef DMXPIXMAP_H
+#define DMXPIXMAP_H
+
+#include "pixmapstr.h"
+
+/** Pixmap private area. */
+typedef struct _dmxPixPriv {
+    Pixmap   pixmap;
+    XImage  *detachedImage;
+} dmxPixPrivRec, *dmxPixPrivPtr;
+
+
+extern Bool      dmxInitPixmap(ScreenPtr pScreen);
+
+extern PixmapPtr dmxCreatePixmap(ScreenPtr pScreen,
+				 int width, int height, int depth,
+				 unsigned usage_hint);
+extern Bool      dmxDestroyPixmap(PixmapPtr pPixmap);
+extern RegionPtr dmxBitmapToRegion(PixmapPtr pPixmap);
+
+extern void      dmxBECreatePixmap(PixmapPtr pPixmap);
+extern Bool      dmxBEFreePixmap(PixmapPtr pPixmap);
+
+/** Get pixmap private pointer. */
+#define DMX_GET_PIXMAP_PRIV(_pPix)					\
+    (dmxPixPrivPtr)dixLookupPrivate(&(_pPix)->devPrivates, dmxPixPrivateKey)
+
+#endif /* DMXPIXMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/syncsrv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/syncsrv.h
@@ -0,0 +1,177 @@
+/*
+
+Copyright 1991, 1993, 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/***********************************************************
+Copyright 1991,1993 by Digital Equipment Corporation, Maynard, Massachusetts,
+and Olivetti Research Limited, Cambridge, England.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the names of Digital or Olivetti
+not be used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL AND OLIVETTI DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL THEY BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+
+******************************************************************/
+
+#ifndef _SYNCSRV_H_
+#define _SYNCSRV_H_
+
+#define CARD64 XSyncValue /* XXX temporary! need real 64 bit values for Alpha */
+
+typedef struct _SyncCounter {
+    ClientPtr		client;	/* Owning client. 0 for system counters */
+    XSyncCounter	id;		/* resource ID */
+    CARD64		value;		/* counter value */
+    struct _SyncTriggerList *pTriglist;	/* list of triggers */
+    Bool		beingDestroyed; /* in process of going away */
+    struct _SysCounterInfo *pSysCounterInfo; /* NULL if not a system counter */
+} SyncCounter;
+
+/*
+ * The System Counter interface
+ */
+
+typedef enum {
+    XSyncCounterNeverChanges,
+    XSyncCounterNeverIncreases,
+    XSyncCounterNeverDecreases,
+    XSyncCounterUnrestricted
+} SyncCounterType;
+
+typedef struct _SysCounterInfo {
+    char	*name;
+    CARD64	resolution;
+    CARD64	bracket_greater;
+    CARD64	bracket_less;
+    SyncCounterType counterType;  /* how can this counter change */
+    void        (*QueryValue)(
+			      pointer /*pCounter*/,
+			      CARD64 * /*freshvalue*/
+);
+    void	(*BracketValues)(
+				 pointer /*pCounter*/,
+				 CARD64 * /*lessthan*/,
+				 CARD64 * /*greaterthan*/
+);
+} SysCounterInfo;
+
+
+
+typedef struct _SyncTrigger {
+    SyncCounter *pCounter;
+    CARD64	wait_value;	/* wait value */
+    unsigned int value_type;     /* Absolute or Relative */
+    unsigned int test_type;	/* transition or Comparision type */
+    CARD64	test_value;	/* trigger event threshold value */
+    Bool	(*CheckTrigger)(
+				struct _SyncTrigger * /*pTrigger*/,
+				CARD64 /*newval*/
+				);
+    void	(*TriggerFired)(
+				struct _SyncTrigger * /*pTrigger*/
+				);
+    void	(*CounterDestroyed)(
+				struct _SyncTrigger * /*pTrigger*/
+				    );
+} SyncTrigger;
+
+typedef struct _SyncTriggerList {
+    SyncTrigger *pTrigger;
+    struct _SyncTriggerList *next;
+} SyncTriggerList;
+
+typedef struct _SyncAlarmClientList {
+    ClientPtr	client;
+    XID		delete_id;
+    struct _SyncAlarmClientList *next;
+} SyncAlarmClientList;
+
+typedef struct _SyncAlarm {
+    SyncTrigger trigger;
+    ClientPtr	client;
+    XSyncAlarm 	alarm_id;
+    CARD64	delta;
+    int		events;
+    int		state;
+    SyncAlarmClientList *pEventClients;
+} SyncAlarm;
+
+typedef struct {
+    ClientPtr	client;
+    CARD32 	delete_id;
+    int		num_waitconditions;
+} SyncAwaitHeader;
+
+typedef struct {
+    SyncTrigger trigger;
+    CARD64	event_threshold;
+    SyncAwaitHeader *pHeader;
+} SyncAwait;
+
+typedef union {
+    SyncAwaitHeader header;
+    SyncAwait	    await;
+} SyncAwaitUnion;
+
+
+extern pointer SyncCreateSystemCounter(
+    char *	/* name */,
+    CARD64  	/* inital_value */,
+    CARD64  	/* resolution */,
+    SyncCounterType /* change characterization */,
+    void        (* /*QueryValue*/ ) (
+        pointer /* pCounter */,
+        CARD64 * /* pValue_return */), /* XXX prototype */
+    void        (* /*BracketValues*/) (
+        pointer /* pCounter */, 
+        CARD64 * /* pbracket_less */,
+        CARD64 * /* pbracket_greater */)
+);
+
+extern void SyncChangeCounter(
+    SyncCounter *	/* pCounter*/,
+    CARD64  		/* new_value */
+);
+
+extern void SyncDestroySystemCounter(
+    pointer pCounter
+);
+extern void InitServertime(void);
+
+extern void SyncExtensionInit(void);
+#endif /* _SYNCSRV_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdev.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEV_H
+#define UNGRDEV_H 1
+
+int SProcXUngrabDevice(ClientPtr	/* client */
+    );
+
+int ProcXUngrabDevice(ClientPtr	/* client */
+    );
+
+#endif /* UNGRDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/picture.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/picture.h
@@ -0,0 +1,231 @@
+/*
+ *
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _PICTURE_H_
+#define _PICTURE_H_
+
+#include "privates.h"
+
+#include <pixman.h>
+
+typedef struct _DirectFormat	*DirectFormatPtr;
+typedef struct _PictFormat	*PictFormatPtr;
+typedef struct _Picture		*PicturePtr;
+
+/*
+ * While the protocol is generous in format support, the
+ * sample implementation allows only packed RGB and GBR
+ * representations for data to simplify software rendering,
+ */
+#define PICT_FORMAT(bpp,type,a,r,g,b)	PIXMAN_FORMAT(bpp, type, a, r, g, b)
+
+/*
+ * gray/color formats use a visual index instead of argb
+ */
+#define PICT_VISFORMAT(bpp,type,vi)	(((bpp) << 24) |  \
+					 ((type) << 16) | \
+					 ((vi)))
+
+#define PICT_FORMAT_BPP(f)	PIXMAN_FORMAT_BPP(f)
+#define PICT_FORMAT_TYPE(f)	PIXMAN_FORMAT_TYPE(f)
+#define PICT_FORMAT_A(f)	PIXMAN_FORMAT_A(f)
+#define PICT_FORMAT_R(f)	PIXMAN_FORMAT_R(f)
+#define PICT_FORMAT_G(f)	PIXMAN_FORMAT_G(f)
+#define PICT_FORMAT_B(f)	PIXMAN_FORMAT_B(f)
+#define PICT_FORMAT_RGB(f)	PIXMAN_FORMAT_RGB(f)
+#define PICT_FORMAT_VIS(f)	PIXMAN_FORMAT_VIS(f)
+
+#define PICT_TYPE_OTHER		PIXMAN_TYPE_OTHER
+#define PICT_TYPE_A		PIXMAN_TYPE_A
+#define PICT_TYPE_ARGB		PIXMAN_TYPE_ARGB
+#define PICT_TYPE_ABGR		PIXMAN_TYPE_ABGR
+#define PICT_TYPE_COLOR		PIXMAN_TYPE_COLOR
+#define PICT_TYPE_GRAY		PIXMAN_TYPE_GRAY
+#define PICT_TYPE_BGRA		PIXMAN_TYPE_BGRA
+
+#define PICT_FORMAT_COLOR(f)	PIXMAN_FORMAT_COLOR(f)
+
+/* 32bpp formats */
+typedef enum _PictFormatShort {
+    PICT_a2r10g10b10 =	PIXMAN_a2r10g10b10,
+    PICT_x2r10g10b10 =	PIXMAN_x2r10g10b10,
+    PICT_a2b10g10r10 =	PIXMAN_a2b10g10r10,
+    PICT_x2b10g10r10 =	PIXMAN_x2b10g10r10,
+
+    PICT_a8r8g8b8 =	PIXMAN_a8r8g8b8,
+    PICT_x8r8g8b8 =	PIXMAN_x8r8g8b8,
+    PICT_a8b8g8r8 =	PIXMAN_a8b8g8r8,
+    PICT_x8b8g8r8 =	PIXMAN_x8b8g8r8,
+    PICT_b8g8r8a8 =	PIXMAN_b8g8r8a8,
+    PICT_b8g8r8x8 =	PIXMAN_b8g8r8x8,
+
+/* 24bpp formats */
+    PICT_r8g8b8 =	PIXMAN_r8g8b8,
+    PICT_b8g8r8 =	PIXMAN_b8g8r8,
+
+/* 16bpp formats */
+    PICT_r5g6b5 =	PIXMAN_r5g6b5,
+    PICT_b5g6r5 =	PIXMAN_b5g6r5,
+
+    PICT_a1r5g5b5 =	PIXMAN_a1r5g5b5,
+    PICT_x1r5g5b5 =	PIXMAN_x1r5g5b5,
+    PICT_a1b5g5r5 =	PIXMAN_a1b5g5r5,
+    PICT_x1b5g5r5 =	PIXMAN_x1b5g5r5,
+    PICT_a4r4g4b4 =	PIXMAN_a4r4g4b4,
+    PICT_x4r4g4b4 =	PIXMAN_x4r4g4b4,
+    PICT_a4b4g4r4 =	PIXMAN_a4b4g4r4,
+    PICT_x4b4g4r4 =	PIXMAN_x4b4g4r4,
+
+/* 8bpp formats */
+    PICT_a8 =		PIXMAN_a8,
+    PICT_r3g3b2 =	PIXMAN_r3g3b2,
+    PICT_b2g3r3 =	PIXMAN_b2g3r3,
+    PICT_a2r2g2b2 =	PIXMAN_a2r2g2b2,
+    PICT_a2b2g2r2 =	PIXMAN_a2b2g2r2,
+
+    PICT_c8 =		PIXMAN_c8,
+    PICT_g8 =		PIXMAN_g8,
+
+    PICT_x4a4 =		PIXMAN_x4a4,
+				    
+    PICT_x4c4 =		PIXMAN_x4c4,
+    PICT_x4g4 =		PIXMAN_x4g4,
+
+/* 4bpp formats */
+    PICT_a4 =		PIXMAN_a4,
+    PICT_r1g2b1 =	PIXMAN_r1g2b1,
+    PICT_b1g2r1 =	PIXMAN_b1g2r1,
+    PICT_a1r1g1b1 =	PIXMAN_a1r1g1b1,
+    PICT_a1b1g1r1 =	PIXMAN_a1b1g1r1,
+				    
+    PICT_c4 =		PIXMAN_c4,
+    PICT_g4 =		PIXMAN_g4,
+
+/* 1bpp formats */
+    PICT_a1 =		PIXMAN_a1,
+
+    PICT_g1 =		PIXMAN_g1
+} PictFormatShort;
+
+/*
+ * For dynamic indexed visuals (GrayScale and PseudoColor), these control the 
+ * selection of colors allocated for drawing to Pictures.  The default
+ * policy depends on the size of the colormap:
+ *
+ * Size		Default Policy
+ * ----------------------------
+ *  < 64	PolicyMono
+ *  < 256	PolicyGray
+ *  256		PolicyColor (only on PseudoColor)
+ *
+ * The actual allocation code lives in miindex.c, and so is
+ * austensibly server dependent, but that code does:
+ *
+ * PolicyMono	    Allocate no additional colors, use black and white
+ * PolicyGray	    Allocate 13 gray levels (11 cells used)
+ * PolicyColor	    Allocate a 4x4x4 cube and 13 gray levels (71 cells used)
+ * PolicyAll	    Allocate as big a cube as possible, fill with gray (all)
+ *
+ * Here's a picture to help understand how many colors are
+ * actually allocated (this is just the gray ramp):
+ *
+ *                 gray level
+ * all   0000 1555 2aaa 4000 5555 6aaa 8000 9555 aaaa bfff d555 eaaa ffff
+ * b/w   0000                                                        ffff
+ * 4x4x4                     5555                aaaa
+ * extra      1555 2aaa 4000      6aaa 8000 9555      bfff d555 eaaa
+ *
+ * The default colormap supplies two gray levels (black/white), the
+ * 4x4x4 cube allocates another two and nine more are allocated to fill
+ * in the 13 levels.  When the 4x4x4 cube is not allocated, a total of
+ * 11 cells are allocated.
+ */   
+
+#define PictureCmapPolicyInvalid    -1
+#define PictureCmapPolicyDefault    0
+#define PictureCmapPolicyMono	    1
+#define PictureCmapPolicyGray	    2
+#define PictureCmapPolicyColor	    3
+#define PictureCmapPolicyAll	    4
+
+extern _X_EXPORT int PictureCmapPolicy;
+
+extern _X_EXPORT int PictureParseCmapPolicy (const char *name);
+
+extern _X_EXPORT int RenderErrBase;
+
+/* Fixed point updates from Carl Worth, USC, Information Sciences Institute */
+
+typedef pixman_fixed_32_32_t	xFixed_32_32;
+
+typedef pixman_fixed_48_16_t	xFixed_48_16;
+
+#define MAX_FIXED_48_16		pixman_max_fixed_48_16
+#define MIN_FIXED_48_16		pixman_min_fixed_48_16
+
+typedef pixman_fixed_1_31_t	xFixed_1_31;
+typedef pixman_fixed_1_16_t	xFixed_1_16;
+typedef pixman_fixed_16_16_t	xFixed_16_16;
+
+/*
+ * An unadorned "xFixed" is the same as xFixed_16_16, 
+ * (since it's quite common in the code) 
+ */
+typedef	pixman_fixed_t	xFixed;
+#define XFIXED_BITS	16
+
+#define xFixedToInt(f)	pixman_fixed_to_int(f)
+#define IntToxFixed(i)	pixman_int_to_fixed(i)
+#define xFixedE		pixman_fixed_e
+#define xFixed1		pixman_fixed_1
+#define xFixed1MinusE	pixman_fixed_1_minus_e
+#define xFixedFrac(f)	pixman_fixed_frac(f)
+#define xFixedFloor(f)	pixman_fixed_floor(f)
+#define xFixedCeil(f)	pixman_fixed_ceil(f)
+
+#define xFixedFraction(f)	pixman_fixed_fraction(f)
+#define xFixedMod2(f)		pixman_fixed_mod2(f)
+
+/* whether 't' is a well defined not obviously empty trapezoid */
+#define xTrapezoidValid(t)  ((t)->left.p1.y != (t)->left.p2.y && \
+			     (t)->right.p1.y != (t)->right.p2.y && \
+			     (int) ((t)->bottom - (t)->top) > 0)
+
+/*
+ * Standard NTSC luminance conversions:
+ *
+ *  y = r * 0.299 + g * 0.587 + b * 0.114
+ *
+ * Approximate this for a bit more speed:
+ *
+ *  y = (r * 153 + g * 301 + b * 58) / 512
+ *
+ * This gives 17 bits of luminance; to get 15 bits, lop the low two
+ */
+
+#define CvtR8G8B8toY15(s)	(((((s) >> 16) & 0xff) * 153 + \
+				  (((s) >>  8) & 0xff) * 301 + \
+				  (((s)      ) & 0xff) * 58) >> 2)
+
+#endif /* _PICTURE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/queryst.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/queryst.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYST_H
+#define QUERYST_H 1
+
+int SProcXQueryDeviceState(ClientPtr	/* client */
+    );
+
+int ProcXQueryDeviceState(ClientPtr	/* client */
+    );
+
+void SRepXQueryDeviceState(ClientPtr /* client */ ,
+			   int /* size */ ,
+			   xQueryDeviceStateReply *	/* rep */
+    );
+
+#endif /* QUERYST_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closure.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closure.h
@@ -0,0 +1,57 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CLOSURE_H
+#define CLOSURE_H 1
+
+typedef struct _LFclosure	*LFclosurePtr;
+typedef struct _LFWIclosure	*LFWIclosurePtr;
+typedef struct _OFclosure	*OFclosurePtr;
+typedef struct _PTclosure	*PTclosurePtr;
+typedef struct _ITclosure	*ITclosurePtr;
+
+#endif /* CLOSURE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/config-backends.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/config-backends.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright © 2006-2007 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "input.h"
+
+void remove_devices(const char *backend, const char *config_info);
+BOOL device_is_duplicate(const char *config_info);
+void add_option(InputOption **options, const char *key, const char *value);
+
+#ifdef CONFIG_UDEV
+int config_udev_init(void);
+void config_udev_fini(void);
+#else
+
+# ifdef CONFIG_NEED_DBUS
+#include <dbus/dbus.h>
+
+typedef void (*config_dbus_core_connect_hook)(DBusConnection *connection,
+                                              void *data);
+typedef void (*config_dbus_core_disconnect_hook)(void *data);
+
+struct config_dbus_core_hook {
+    config_dbus_core_connect_hook connect;
+    config_dbus_core_disconnect_hook disconnect;
+    void *data;
+
+    struct config_dbus_core_hook *next;
+};
+
+int config_dbus_core_init(void);
+void config_dbus_core_fini(void);
+int config_dbus_core_add_hook(struct config_dbus_core_hook *hook);
+void config_dbus_core_remove_hook(struct config_dbus_core_hook *hook);
+# endif
+
+# ifdef CONFIG_DBUS_API
+int config_dbus_init(void);
+void config_dbus_fini(void);
+# endif
+
+# ifdef CONFIG_HAL
+int config_hal_init(void);
+void config_hal_fini(void);
+# endif
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxconfig.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxconfig.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DMX configuration file support.  \see dmxconfig.c */
+
+#ifndef _DMXCONFIG_H_
+#define _DMXCONFIG_H_
+
+#include <xkb-config.h>
+
+extern void dmxConfigStoreDisplay(const char *display);
+extern void dmxConfigStoreInput(const char *input); /* Core devices */
+extern void dmxConfigStoreXInput(const char *input); /* Non-core devices */
+extern void dmxConfigStoreFile(const char *file);
+extern void dmxConfigStoreConfig(const char *config);
+extern void dmxConfigConfigure(void);
+extern void dmxConfigSetMaxScreens(void);
+
+extern void dmxConfigSetXkbRules(const char *rules);
+extern void dmxConfigSetXkbModel(const char *model);
+extern void dmxConfigSetXkbLayout(const char *layout);
+extern void dmxConfigSetXkbVariant(const char *variant);
+extern void dmxConfigSetXkbOptions(const char *options);
+
+extern char *dmxConfigGetXkbRules(void);
+extern char *dmxConfigGetXkbModel(void);
+extern char *dmxConfigGetXkbLayout(void);
+extern char *dmxConfigGetXkbVariant(void);
+extern char *dmxConfigGetXkbOptions(void);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_dispatch.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_dispatch.h
@@ -0,0 +1,1047 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_recv.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_DISPATCH_H_ )
+#  define _INDIRECT_DISPATCH_H_
+
+#  if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))) && defined(__ELF__)
+#    define HIDDEN  __attribute__((visibility("hidden")))
+#  else
+#    define HIDDEN
+#  endif
+struct __GLXclientStateRec;
+
+extern HIDDEN void __glXDisp_MapGrid1d(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MapGrid1d(GLbyte * pc);
+extern HIDDEN void __glXDisp_MapGrid1f(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MapGrid1f(GLbyte * pc);
+extern HIDDEN int __glXDisp_NewList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_NewList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LoadIdentity(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LoadIdentity(GLbyte * pc);
+extern HIDDEN void __glXDisp_SampleCoverageARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SampleCoverageARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ConvolutionFilter1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionFilter1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_BeginQueryARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BeginQueryARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos3dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos3dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PointParameteriNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PointParameteriNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord1iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord1iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord4sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord4sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ActiveTextureARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ActiveTextureARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4ubvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4ubvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramNamedParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramNamedParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Histogram(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Histogram(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RasterPos4dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos4dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PolygonStipple(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PolygonStipple(GLbyte * pc);
+extern HIDDEN void __glXDisp_BlendEquationSeparateEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BlendEquationSeparateEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetPixelMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetPixelMapfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Color3uiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3uiv(GLbyte * pc);
+extern HIDDEN int __glXDisp_IsEnabled(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsEnabled(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib4svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4svNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_EvalCoord2fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalCoord2fv(GLbyte * pc);
+extern HIDDEN int __glXDisp_DestroyPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMapiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_SwapBuffers(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_SwapBuffers(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Indexubv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Indexubv(GLbyte * pc);
+extern HIDDEN int __glXDisp_Render(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_Render(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetQueryivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetQueryivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexImage3D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexImage3D(GLbyte * pc);
+extern HIDDEN int __glXDisp_MakeContextCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_MakeContextCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetFBConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetFBConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Color3ubv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3ubv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetQueryObjectivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetQueryObjectivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Vertex3dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex3dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexSubImage2DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexSubImage2DARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_LightModeliv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LightModeliv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib1svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs1dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs1dvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Normal3bv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Normal3bv(GLbyte * pc);
+extern HIDDEN int __glXDisp_VendorPrivate(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_VendorPrivate(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_CreateGLXPixmapWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib1fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex3iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex3iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyConvolutionFilter1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyConvolutionFilter1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_BlendColor(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BlendColor(GLbyte * pc);
+extern HIDDEN void __glXDisp_Scalef(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Scalef(GLbyte * pc);
+extern HIDDEN void __glXDisp_Normal3iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Normal3iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PassThrough(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PassThrough(GLbyte * pc);
+extern HIDDEN void __glXDisp_Viewport(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Viewport(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NusvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NusvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyTexSubImage2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyTexSubImage2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_DepthRange(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DepthRange(GLbyte * pc);
+extern HIDDEN void __glXDisp_ResetHistogram(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ResetHistogram(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramNamedParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramNamedParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_PointParameterfEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PointParameterfEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord2sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord2sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex4dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex4dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexImage3DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexImage3DARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color3sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3sv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetConvolutionParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetConvolutionParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Vertex2dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex2dv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetVisualConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVisualConfigs(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultiTexCoord1fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord1fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord3iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord3iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_CopyContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CopyContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Color3fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PointSize(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PointSize(GLbyte * pc);
+extern HIDDEN void __glXDisp_PopName(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PopName(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NbvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NbvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex4sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex4sv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexEnvfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexEnvfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LineStipple(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LineStipple(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexEnvi(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexEnvi(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetClipPlane(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetClipPlane(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttribs3dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs3dvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_LightModeli(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LightModeli(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Scaled(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Scaled(GLbyte * pc);
+extern HIDDEN void __glXDisp_CallLists(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CallLists(GLbyte * pc);
+extern HIDDEN void __glXDisp_AlphaFunc(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_AlphaFunc(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord2iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord2iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexImage1DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexImage1DARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Rotated(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rotated(GLbyte * pc);
+extern HIDDEN int __glXDisp_ReadPixels(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_ReadPixels(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_EdgeFlagv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EdgeFlagv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexParameterf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexParameterf(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexParameteri(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexParameteri(GLbyte * pc);
+extern HIDDEN int __glXDisp_DestroyContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_DrawPixels(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DrawPixels(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord2svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord2svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs3fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs3fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_GenerateMipmapEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_GenerateMipmapEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GenLists(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenLists(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MapGrid2d(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MapGrid2d(GLbyte * pc);
+extern HIDDEN void __glXDisp_MapGrid2f(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MapGrid2f(GLbyte * pc);
+extern HIDDEN void __glXDisp_Scissor(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Scissor(GLbyte * pc);
+extern HIDDEN void __glXDisp_Fogf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Fogf(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexSubImage1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexSubImage1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4usv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4usv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Fogi(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Fogi(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos3iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos3iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PixelMapfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelMapfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color3usv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3usv(GLbyte * pc);
+extern HIDDEN int __glXDisp_AreTexturesResident(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_AreTexturesResident(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_AreTexturesResidentEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_AreTexturesResidentEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_PointParameterfvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PointParameterfvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color3bv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3bv(GLbyte * pc);
+extern HIDDEN void __glXDisp_SecondaryColor3bvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3bvEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramLocalParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramLocalParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RenderbufferStorageEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RenderbufferStorageEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_ColorTable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorTable(GLbyte * pc);
+extern HIDDEN void __glXDisp_Accum(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Accum(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexImage(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ConvolutionFilter2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionFilter2D(GLbyte * pc);
+extern HIDDEN int __glXDisp_Finish(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_Finish(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ClearStencil(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClearStencil(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib3dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs4ubvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs4ubvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_ConvolutionParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos2fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos2fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord1fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord1fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramEnvParameter4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos4fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos4fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ClearIndex(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClearIndex(GLbyte * pc);
+extern HIDDEN void __glXDisp_LoadMatrixd(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LoadMatrixd(GLbyte * pc);
+extern HIDDEN void __glXDisp_PushMatrix(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PushMatrix(GLbyte * pc);
+extern HIDDEN void __glXDisp_ConvolutionParameterfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionParameterfv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexGendv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexGendv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LoadProgramNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LoadProgramNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_EndList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_EndList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_EvalCoord1fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalCoord1fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_EvalMesh2(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalMesh2(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex4fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex4fv(GLbyte * pc);
+extern HIDDEN int __glXDisp_CheckFramebufferStatusEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CheckFramebufferStatusEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetVertexAttribivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetFBConfigsSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetFBConfigsSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_CreateNewContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateNewContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMinmax(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmax(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMinmaxEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmaxEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetVertexAttribdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Normal3fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Normal3fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramEnvParameter4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4ivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4ivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_End(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_End(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs2dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs2dvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord3fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord3fvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramParameterfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_BindTexture(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BindTexture(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexSubImage2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexSubImage2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_DeleteRenderbuffersEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DeleteRenderbuffersEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexGenfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGenfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4bvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4bvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreateContextWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateContextWithConfigSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_FramebufferTexture3DEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FramebufferTexture3DEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_CopySubBufferMESA(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CopySubBufferMESA(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_BlendEquation(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BlendEquation(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetError(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetError(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexCoord3dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord3dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Indexdv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Indexdv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PushName(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PushName(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord2dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord2dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramNamedParameter4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramNamedParameter4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4fvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreateGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultiTexCoord1svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord1svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_EndQueryARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EndQueryARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_DepthMask(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DepthMask(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_StencilOp(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_StencilOp(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord3svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord3svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexEnvfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexEnvfv(GLbyte * pc);
+extern HIDDEN int __glXDisp_QueryServerString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_QueryServerString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LoadMatrixf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LoadMatrixf(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4bv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4bv(GLbyte * pc);
+extern HIDDEN void __glXDisp_SecondaryColor3usvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3usvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib2fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramLocalParameter4dvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_DeleteLists(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DeleteLists(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LogicOp(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LogicOp(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord4fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord4fv(GLbyte * pc);
+extern HIDDEN int __glXDisp_WaitX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_WaitX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SecondaryColor3uivEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3uivEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_FramebufferRenderbufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FramebufferRenderbufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib1dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1dvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GenTextures(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenTextures(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GenTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_FramebufferTexture1DEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FramebufferTexture1DEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_IsRenderbufferEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsRenderbufferEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RasterPos2sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos2sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4ubv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4ubv(GLbyte * pc);
+extern HIDDEN void __glXDisp_DrawBuffer(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DrawBuffer(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord2fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord2fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord1sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord1sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexGeniv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGeniv(GLbyte * pc);
+extern HIDDEN void __glXDisp_DepthFunc(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DepthFunc(GLbyte * pc);
+extern HIDDEN void __glXDisp_PixelMapusv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelMapusv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PointParameterivNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PointParameterivNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_BlendFunc(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BlendFunc(GLbyte * pc);
+extern HIDDEN int __glXDisp_WaitGL(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_WaitGL(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultiTexCoord3dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord3dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramNamedParameter4dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramNamedParameter4dvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_Flush(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_Flush(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Color4uiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4uiv(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos3sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos3sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_BindFramebufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BindFramebufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_PushAttrib(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PushAttrib(GLbyte * pc);
+extern HIDDEN int __glXDisp_DestroyPbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyPbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDisp_WindowPos3fvMESA(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_WindowPos3fvMESA(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib1svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1svNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_QueryExtensionsString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_QueryExtensionsString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RasterPos3fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos3fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyTexSubImage3D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyTexSubImage3D(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetColorTable(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTable(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetColorTableSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTableSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Indexiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Indexiv(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreateContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_CopyColorTable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyColorTable(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetHistogramParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogramParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetHistogramParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogramParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Frustum(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Frustum(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetString(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_CreateGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexEnvf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexEnvf(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramStringARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramStringARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultiTexCoord3ivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord3ivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib1dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1dvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_DeleteTextures(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DeleteTextures(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_DeleteTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DeleteTexturesEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetTexLevelParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexLevelParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ClearAccum(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClearAccum(GLbyte * pc);
+extern HIDDEN int __glXDisp_QueryVersion(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_QueryVersion(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetVertexAttribfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SecondaryColor3ivEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3ivEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord4iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord4iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SampleMaskSGIS(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SampleMaskSGIS(GLbyte * pc);
+extern HIDDEN void __glXDisp_ColorTableParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorTableParameteriv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4ubvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4ubvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyTexImage2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyTexImage2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_Lightfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Lightfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ClearDepth(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClearDepth(GLbyte * pc);
+extern HIDDEN void __glXDisp_ColorSubTable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorSubTable(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord4ivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord4ivARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreatePixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreatePixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Lightiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Lightiv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetQueryObjectuivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetQueryObjectuivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetTexParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GenRenderbuffersEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenRenderbuffersEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib2dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs2svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs2svNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Rectdv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rectdv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Materialiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Materialiv(GLbyte * pc);
+extern HIDDEN void __glXDisp_SecondaryColor3fvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3fvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_PolygonMode(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PolygonMode(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexSubImage1DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexSubImage1DARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib2dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2dvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetVertexAttribivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_IsQueryARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsQueryARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexGeni(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGeni(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexGenf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGenf(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexGend(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGend(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetPolygonStipple(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetPolygonStipple(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetVertexAttribfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribfvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib2svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2svNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs1fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs1fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NuivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NuivARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_DestroyWindow(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyWindow(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Color4sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4sv(GLbyte * pc);
+extern HIDDEN int __glXDisp_IsProgramNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsProgramNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_PixelZoom(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelZoom(GLbyte * pc);
+extern HIDDEN void __glXDisp_ColorTableParameterfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorTableParameterfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PixelMapuiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelMapuiv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color3dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3dv(GLbyte * pc);
+extern HIDDEN int __glXDisp_IsTexture(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsTexture(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_IsTextureEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsTextureEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_DeleteQueriesARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DeleteQueriesARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMapdv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_DestroyGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyGLXPixmap(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SamplePatternSGIS(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SamplePatternSGIS(GLbyte * pc);
+extern HIDDEN int __glXDisp_PixelStoref(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_PixelStoref(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_PrioritizeTextures(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PrioritizeTextures(GLbyte * pc);
+extern HIDDEN int __glXDisp_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib4usvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4usvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_DestroyGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DestroyGLXPbufferSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_EvalCoord2dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalCoord2dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib3svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ColorMaterial(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorMaterial(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexSubImage3DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexSubImage3DARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_IsFramebufferEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsFramebufferEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetVertexAttribdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetVertexAttribdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetSeparableFilter(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetSeparableFilter(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetSeparableFilterEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetSeparableFilterEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RequestResidentProgramsNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RequestResidentProgramsNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_FeedbackBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_FeedbackBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_RasterPos2iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos2iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexImage1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexImage1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_FrontFace(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FrontFace(GLbyte * pc);
+extern HIDDEN int __glXDisp_RenderLarge(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_RenderLarge(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_PolygonOffset(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PolygonOffset(GLbyte * pc);
+extern HIDDEN void __glXDisp_ExecuteProgramNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ExecuteProgramNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Normal3dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Normal3dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Lightf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Lightf(GLbyte * pc);
+extern HIDDEN void __glXDisp_MatrixMode(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MatrixMode(GLbyte * pc);
+extern HIDDEN void __glXDisp_FramebufferTexture2DEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FramebufferTexture2DEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetPixelMapusv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetPixelMapusv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Lighti(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Lighti(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetFramebufferAttachmentParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetFramebufferAttachmentParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_ChangeDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_ChangeDrawableAttributesSGIX(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultiTexCoord4dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord4dvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreatePbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreatePbuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetDoublev(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetDoublev(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_MultMatrixd(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultMatrixd(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultMatrixf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultMatrixf(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_TrackMatrixNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TrackMatrixNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos4sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos4sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NsvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NsvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib3fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ClearColor(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClearColor(GLbyte * pc);
+extern HIDDEN int __glXDisp_IsDirect(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsDirect(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_DeleteFramebuffersEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DeleteFramebuffersEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexEnviv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexEnviv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexSubImage3D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexSubImage3D(GLbyte * pc);
+extern HIDDEN int __glXDisp_SwapIntervalSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_SwapIntervalSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetColorTableParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTableParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetColorTableParameterfvSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTableParameterfvSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Bitmap(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Bitmap(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexLevelParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexLevelParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GenFramebuffersEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenFramebuffersEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetProgramParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramParameterdvNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Vertex2sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex2sv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetIntegerv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetIntegerv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetProgramEnvParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramEnvParameterfvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetTrackMatrixivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTrackMatrixivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib3svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3svNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexEnviv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexEnviv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_VendorPrivateWithReply(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_VendorPrivateWithReply(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SeparableFilter2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SeparableFilter2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_Map1d(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Map1d(GLbyte * pc);
+extern HIDDEN void __glXDisp_Map1f(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Map1f(GLbyte * pc);
+extern HIDDEN void __glXDisp_CompressedTexImage2DARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CompressedTexImage2DARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexImage2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexImage2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramParameters4fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramParameters4fvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramivNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_ChangeDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_ChangeDrawableAttributes(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMinmaxParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmaxParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMinmaxParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmaxParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_PixelTransferf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelTransferf(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyTexImage1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyTexImage1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos2dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos2dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Fogiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Fogiv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord1dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord1dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PixelTransferi(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PixelTransferi(GLbyte * pc);
+extern HIDDEN void __glXDisp_SecondaryColor3ubvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3ubvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib3fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Clear(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Clear(GLbyte * pc);
+extern HIDDEN void __glXDisp_ReadBuffer(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ReadBuffer(GLbyte * pc);
+extern HIDDEN void __glXDisp_ConvolutionParameteri(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionParameteri(GLbyte * pc);
+extern HIDDEN void __glXDisp_Ortho(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Ortho(GLbyte * pc);
+extern HIDDEN void __glXDisp_ListBase(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ListBase(GLbyte * pc);
+extern HIDDEN void __glXDisp_ConvolutionParameterf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ConvolutionParameterf(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetColorTableParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTableParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetColorTableParameterivSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetColorTableParameterivSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_ReleaseTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_ReleaseTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_CallList(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CallList(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs2fvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs2fvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Rectiv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rectiv(GLbyte * pc);
+extern HIDDEN void __glXDisp_SecondaryColor3dvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3dvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex2fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex2fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_BindRenderbufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BindRenderbufferEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex3sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex3sv(GLbyte * pc);
+extern HIDDEN int __glXDisp_BindTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_BindTexImageEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramLocalParameter4fvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_DeleteProgramsNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_DeleteProgramsNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_EvalMesh1(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalMesh1(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord1dvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord1dvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex2iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex2iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramStringNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramStringNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_LineWidth(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LineWidth(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib2fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexGendv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexGendv(GLbyte * pc);
+extern HIDDEN void __glXDisp_ResetMinmax(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ResetMinmax(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetConvolutionParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetConvolutionParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttribs4dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs4dvNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetMaterialfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMaterialfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_UseXFont(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_UseXFont(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ShadeModel(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ShadeModel(GLbyte * pc);
+extern HIDDEN void __glXDisp_Materialfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Materialfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord3fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord3fv(GLbyte * pc);
+extern HIDDEN void __glXDisp_FogCoordfvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FogCoordfvEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord1ivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord1ivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord2ivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord2ivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_DrawArrays(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DrawArrays(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color3iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color3iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramLocalParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramLocalParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetHistogramParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogramParameteriv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetHistogramParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogramParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Rotatef(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rotatef(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramivARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_BlendFuncSeparateEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BlendFuncSeparateEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramParameters4dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramParameters4dvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_EvalPoint2(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalPoint2(GLbyte * pc);
+extern HIDDEN void __glXDisp_EvalPoint1(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalPoint1(GLbyte * pc);
+extern HIDDEN void __glXDisp_PopMatrix(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PopMatrix(GLbyte * pc);
+extern HIDDEN int __glXDisp_MakeCurrentReadSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_MakeCurrentReadSGI(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetTexGeniv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexGeniv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_MakeCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_MakeCurrent(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Map2d(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Map2d(GLbyte * pc);
+extern HIDDEN void __glXDisp_Map2f(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Map2f(GLbyte * pc);
+extern HIDDEN void __glXDisp_ProgramStringARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ProgramStringARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetConvolutionFilter(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionFilter(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetConvolutionFilterEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetConvolutionFilterEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetCompressedTexImageARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetCompressedTexImageARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetTexGenfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexGenfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetHistogram(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogram(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetHistogramEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetHistogramEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ActiveStencilFaceEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ActiveStencilFaceEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_Materialf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Materialf(GLbyte * pc);
+extern HIDDEN void __glXDisp_Materiali(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Materiali(GLbyte * pc);
+extern HIDDEN void __glXDisp_Indexsv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Indexsv(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord4svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord4svARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_LightModelfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LightModelfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexCoord2dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord2dv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GenQueriesARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenQueriesARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_EvalCoord1dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_EvalCoord1dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Translated(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Translated(GLbyte * pc);
+extern HIDDEN void __glXDisp_Translatef(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Translatef(GLbyte * pc);
+extern HIDDEN void __glXDisp_StencilMask(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_StencilMask(GLbyte * pc);
+extern HIDDEN int __glXDisp_CreateWindow(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_CreateWindow(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetLightiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetLightiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_IsList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_IsList(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_RenderMode(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_RenderMode(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_DrawBuffersARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_DrawBuffersARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_LoadName(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LoadName(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyTexSubImage1D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyTexSubImage1D(GLbyte * pc);
+extern HIDDEN void __glXDisp_CullFace(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CullFace(GLbyte * pc);
+extern HIDDEN int __glXDisp_QueryContextInfoEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_QueryContextInfoEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttribs3svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs3svNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_StencilFunc(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_StencilFunc(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyPixels(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyPixels(GLbyte * pc);
+extern HIDDEN void __glXDisp_Rectsv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rectsv(GLbyte * pc);
+extern HIDDEN void __glXDisp_CopyConvolutionFilter2D(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyConvolutionFilter2D(GLbyte * pc);
+extern HIDDEN void __glXDisp_TexParameterfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexParameterfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4uivARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4uivARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_ClipPlane(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ClipPlane(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetPixelMapuiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetPixelMapuiv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Indexfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Indexfv(GLbyte * pc);
+extern HIDDEN int __glXDisp_QueryContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_QueryContext(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_SecondaryColor3svEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_SecondaryColor3svEXT(GLbyte * pc);
+extern HIDDEN void __glXDisp_IndexMask(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_IndexMask(GLbyte * pc);
+extern HIDDEN void __glXDisp_BindProgramNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_BindProgramNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4svARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetFloatv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetFloatv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexCoord3sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord3sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_PopAttrib(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_PopAttrib(GLbyte * pc);
+extern HIDDEN void __glXDisp_Fogfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Fogfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_InitNames(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_InitNames(GLbyte * pc);
+extern HIDDEN void __glXDisp_Normal3sv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Normal3sv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Minmax(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Minmax(GLbyte * pc);
+extern HIDDEN void __glXDisp_FogCoorddvEXT(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_FogCoorddvEXT(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetBooleanv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetBooleanv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Hint(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Hint(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib2svARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib2svARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_AreProgramsResidentNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_AreProgramsResidentNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_CopyColorSubTable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_CopyColorSubTable(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib4NubvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4NubvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttrib3dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib3dvNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex4iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex4iv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetProgramEnvParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetProgramEnvParameterdvARB(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_TexCoord4dv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_TexCoord4dv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Begin(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Begin(GLbyte * pc);
+extern HIDDEN int __glXDisp_ClientInfo(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_ClientInfo(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Rectfv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Rectfv(GLbyte * pc);
+extern HIDDEN void __glXDisp_LightModelf(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_LightModelf(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetTexParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetTexParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetLightfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetLightfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_Disable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Disable(GLbyte * pc);
+extern HIDDEN void __glXDisp_MultiTexCoord2fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_MultiTexCoord2fvARB(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetRenderbufferParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetRenderbufferParameterivEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_SelectBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_SelectBuffer(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_ColorMask(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_ColorMask(GLbyte * pc);
+extern HIDDEN void __glXDisp_RasterPos4iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_RasterPos4iv(GLbyte * pc);
+extern HIDDEN void __glXDisp_Enable(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Enable(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs4svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs4svNV(GLbyte * pc);
+extern HIDDEN int __glXDisp_GetMinmaxParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmaxParameterfv(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDisp_GetMinmaxParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GetMinmaxParameterfvEXT(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib1fvARB(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib1fvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_VertexAttribs1svNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttribs1svNV(GLbyte * pc);
+extern HIDDEN void __glXDisp_Vertex3fv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Vertex3fv(GLbyte * pc);
+extern HIDDEN int __glXDisp_GenProgramsNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN int __glXDispSwap_GenProgramsNV(struct __GLXclientStateRec *, GLbyte *);
+extern HIDDEN void __glXDisp_VertexAttrib4dvNV(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_VertexAttrib4dvNV(GLbyte * pc);
+
+#  undef HIDDEN
+
+#endif /* !defined( _INDIRECT_DISPATCH_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/protocol-common.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/protocol-common.h
@@ -0,0 +1,153 @@
+/**
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ *  Permission is hereby granted, free of charge, to any person obtaining a
+ *  copy of this software and associated documentation files (the "Software"),
+ *  to deal in the Software without restriction, including without limitation
+ *  the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ *  and/or sell copies of the Software, and to permit persons to whom the
+ *  Software is furnished to do so, subject to the following conditions:
+ *
+ *  The above copyright notice and this permission notice (including the next
+ *  paragraph) shall be included in all copies or substantial portions of the
+ *  Software.
+ *
+ *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ *  THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ *  DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "scrnintstr.h"
+#include "exevents.h"
+
+#ifndef PROTOCOL_COMMON_H
+#define PROTOCOL_COMMON_H
+
+extern int BadDevice;
+
+/* Check default values in a reply */
+#define reply_check_defaults(rep, len, type) \
+    { \
+        g_assert((len) >= sz_x##type##Reply); \
+        g_assert((rep)->repType == X_Reply); \
+        g_assert((rep)->RepType == X_##type); \
+        g_assert((rep)->sequenceNumber == CLIENT_SEQUENCE); \
+        g_assert((rep)->length >= (sz_x##type##Reply - 32)/4); \
+    }
+
+/* initialise default values for request */
+#define request_init(req, type) \
+    { \
+        (req)->reqType = 128; /* doesn't matter */ \
+        (req)->ReqType = X_##type; \
+        (req)->length = (sz_x##type##Req >> 2); \
+    }
+
+
+/* Various defines used in the tests. Some tests may use different values
+ * than these defaults */
+/* default client index */
+#define CLIENT_INDEX            1
+/* default client mask for resources and windows */
+#define CLIENT_MASK             ((CLIENT_INDEX) << CLIENTOFFSET)
+/* default client sequence number for replies */
+#define CLIENT_SEQUENCE         0x100
+/* default root window id */
+#define ROOT_WINDOW_ID          0x10
+/* default client window id */
+#define CLIENT_WINDOW_ID        0x100001
+/* invalid window ID. use for BadWindow checks. */
+#define INVALID_WINDOW_ID       0x111111
+/* initial fake sprite position */
+#define SPRITE_X                100
+#define SPRITE_Y                200
+
+
+/* Various structs used throughout the tests */
+
+
+/* The default devices struct, contains one pointer + keyboard and the
+ * matching master devices. Initialize with init_devices() if needed. */
+struct devices {
+    DeviceIntPtr vcp;
+    DeviceIntPtr vck;
+    DeviceIntPtr mouse;
+    DeviceIntPtr kbd;
+
+    int num_devices;
+    int num_master_devices;
+} devices;
+
+/**
+ * The set of default devices available in all tests if necessary.
+ */
+extern struct devices devices;
+
+/**
+ * test-specific userdata, passed into the reply handler.
+ */
+extern void *userdata;
+/**
+ * The reply handler called from WriteToClient. Set this handler if you need
+ * to check the reply values.
+ */
+void (*reply_handler)(ClientPtr client, int len, char *data, void *userdata);
+
+/**
+ * The default screen used for the windows. Initialized by init_simple().
+ */
+extern ScreenRec screen;
+/**
+ * Semi-initialized root window. initialized by init().
+ */
+extern WindowRec root;
+/**
+ * Semi-initialized top-level window. initialized by init().
+ */
+extern WindowRec window;
+
+/* various simple functions for quick setup */
+/**
+ * Initialize the above struct with default devices and return the struct.
+ * Usually not needed if you call ::init_simple.
+ */
+struct devices init_devices(void);
+/**
+ * Init a mostly zeroed out client with default values for index and mask.
+ */
+ClientRec init_client(int request_len, void *request_data);
+/**
+ * Init a mostly zeroed out window with the given window ID.
+ * Usually not needed if you call ::init_simple which sets up root and
+ * window.
+ */
+void init_window(WindowPtr window, WindowPtr parent, int id);
+/**
+ * Create a very simple setup that provides the minimum values for most
+ * tests, including a screen, the root and client window and the default
+ * device setup.
+ */
+void init_simple(void);
+
+/* Declarations for various overrides in the test files. */
+void __wrap_WriteToClient(ClientPtr client, int len, void *data);
+int __wrap_XISetEventMask(DeviceIntPtr dev, WindowPtr win, int len, unsigned char* mask);
+int __wrap_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
+int __real_dixLookupWindow(WindowPtr *win, XID id, ClientPtr client, Mask access);
+Bool __wrap_AddResource(XID id, RESTYPE type, pointer value);
+int __wrap_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
+int __real_dixLookupClient(ClientPtr *c, XID id, ClientPtr client, Mask access);
+
+
+#endif /* PROTOCOL_COMMON_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx.h
@@ -0,0 +1,390 @@
+/*
+ * Copyright 2001-2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Main header file included by all other DMX-related files.
+ */
+
+/** \mainpage
+ * - <a href="http://dmx.sourceforge.net">DMX Home Page</a>
+ * - <a href="http://sourceforge.net/projects/dmx">DMX Project Page (on
+ * Source Forge)</a>
+ * - <a href="http://dmx.sourceforge.net/dmx.html">Distributed Multihead
+ * X design</a>, the design document for DMX
+ * - <a href="http://dmx.sourceforge.net/DMXSpec.txt">Client-to-Server
+ * DMX Extension to the X Protocol</a>
+ */
+
+#ifndef DMX_H
+#define DMX_H
+
+#if HAVE_DMX_CONFIG_H
+#include <dmx-config.h>
+#endif
+
+#include "gcstruct.h"
+
+/* Handle client-side include files in one place. */
+#include "dmxclient.h"
+
+#include "globals.h"
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+#ifdef GLXEXT
+#include <GL/glx.h>
+#include <GL/glxint.h>
+#endif
+
+typedef enum {
+    PosNone = -1,
+    PosAbsolute = 0,
+    PosRightOf,
+    PosLeftOf,
+    PosAbove,
+    PosBelow,
+    PosRelative
+} PositionType;
+
+/** Provide the typedef globally, but keep the contents opaque outside
+ * of the input routines.  \see dmxinput.h */
+typedef struct _DMXInputInfo DMXInputInfo;
+
+/** Provide the typedef globally, but keep the contents opaque outside
+ * of the XSync statistic routines.  \see dmxstat.c */
+typedef struct _DMXStatInfo DMXStatInfo;
+
+/** Global structure containing information about each backend screen. */
+typedef struct _DMXScreenInfo {
+    const char   *name;           /**< Name from command line or config file */
+    int           index;          /**< Index into dmxScreens global          */
+
+    /*---------- Back-end X server information ----------*/
+
+    Display      *beDisplay;      /**< Back-end X server's display */
+    int           beWidth;        /**< Width of BE display */
+    int           beHeight;       /**< Height of BE display */
+    int           beDepth;        /**< Depth of BE display */
+    int           beBPP;          /**< Bits per pixel of BE display */
+    int           beXDPI;         /**< Horizontal dots per inch of BE */
+    int           beYDPI;         /**< Vertical dots per inch of BE */
+
+    int           beNumDepths;    /**< Number of depths on BE server */
+    int          *beDepths;       /**< Depths from BE server */
+
+    int           beNumPixmapFormats; /**< Number of pixmap formats on BE */
+    XPixmapFormatValues *bePixmapFormats; /**< Pixmap formats on BE */
+
+    int           beNumVisuals;   /**< Number of visuals on BE */
+    XVisualInfo  *beVisuals;      /**< Visuals from BE server */
+    int           beDefVisualIndex; /**< Default visual index of BE */
+
+    int           beNumDefColormaps; /**< Number of default colormaps */
+    Colormap     *beDefColormaps; /**< Default colormaps for DMX server */ 
+
+    Pixel         beBlackPixel;   /**< Default black pixel for BE */
+    Pixel         beWhitePixel;   /**< Default white pixel for BE */
+
+    /*---------- Screen window information ----------*/
+
+    Window        scrnWin;        /**< "Screen" window on backend display */
+    int           scrnX;          /**< X offset of "screen" WRT BE display */
+    int           scrnY;          /**< Y offset of "screen" WRT BE display */
+    int           scrnWidth;      /**< Width of "screen" */
+    int           scrnHeight;     /**< Height of "screen" */
+    int           scrnXSign;      /**< X offset sign of "screen" */
+    int           scrnYSign;      /**< Y offset sign of "screen" */
+
+                                  /** Default drawables for "screen" */
+    Drawable      scrnDefDrawables[MAXFORMATS];
+
+    struct _DMXScreenInfo *next;  /**< List of "screens" on same display */
+    struct _DMXScreenInfo *over;  /**< List of "screens" that overlap */
+
+    /*---------- Root window information ----------*/
+
+    Window        rootWin;        /**< "Root" window on backend display */
+    int           rootX;          /**< X offset of "root" window WRT "screen"*/
+    int           rootY;          /**< Y offset of "root" window WRT "screen"*/
+    int           rootWidth;      /**< Width of "root" window */
+    int           rootHeight;     /**< Height of "root" window */
+
+    int           rootXOrigin;    /**< Global X origin of "root" window */
+    int           rootYOrigin;    /**< Global Y origin of "root" window */
+
+    /*---------- Shadow framebuffer information ----------*/
+
+    void         *shadow;         /**< Shadow framebuffer data (if enabled) */
+    XlibGC        shadowGC;       /**< Default GC used by shadow FB code */
+    XImage       *shadowFBImage;  /**< Screen image used by shadow FB code */
+
+    /*---------- Other related information ----------*/
+
+    int           shared;         /**< Non-zero if another Xdmx is running */
+
+    Bool          WMRunningOnBE;
+
+    Cursor        noCursor;
+    Cursor        curCursor;
+                                /* Support for cursors on overlapped
+                                 * backend displays. */
+    CursorPtr     cursor;
+    int           cursorVisible;
+    int           cursorNotShared; /* for overlapping screens on a backend */
+
+    PositionType  where;            /**< Relative layout information */
+    int           whereX;           /**< Relative layout information */
+    int           whereY;           /**< Relative layout information */
+    int           whereRefScreen;   /**< Relative layout information */
+
+    int           savedTimeout;     /**< Original screen saver timeout */
+    int           dpmsCapable;      /**< Non-zero if backend is DPMS capable */
+    int           dpmsEnabled;      /**< Non-zero if DPMS enabled */
+    int           dpmsStandby;      /**< Original DPMS standby value  */
+    int           dpmsSuspend;      /**< Original DPMS suspend value  */
+    int           dpmsOff;          /**< Original DPMS off value  */
+
+    DMXStatInfo  *stat;             /**< Statistics about XSync  */
+    Bool          needsSync;        /**< True if an XSync is pending  */
+
+#ifdef GLXEXT
+                                  /** Visual information for glxProxy */
+    int           numGlxVisuals;
+    __GLXvisualConfig *glxVisuals;
+    int           glxMajorOpcode;
+    int           glxErrorBase;
+
+                                  /** FB config information for glxProxy */
+    __GLXFBConfig *fbconfigs;
+    int           numFBConfigs;
+#endif
+
+                                    /** Function pointers to wrapped screen
+				     *  functions */
+    CloseScreenProcPtr             CloseScreen;
+    SaveScreenProcPtr              SaveScreen;
+
+    CreateGCProcPtr                CreateGC;
+
+    CreateWindowProcPtr            CreateWindow;
+    DestroyWindowProcPtr           DestroyWindow;
+    PositionWindowProcPtr          PositionWindow;
+    ChangeWindowAttributesProcPtr  ChangeWindowAttributes;
+    RealizeWindowProcPtr           RealizeWindow;
+    UnrealizeWindowProcPtr         UnrealizeWindow;
+    RestackWindowProcPtr           RestackWindow;
+    WindowExposuresProcPtr         WindowExposures;
+    CopyWindowProcPtr              CopyWindow;
+
+    ResizeWindowProcPtr            ResizeWindow;
+    ReparentWindowProcPtr          ReparentWindow;
+
+    ChangeBorderWidthProcPtr       ChangeBorderWidth;
+
+    GetImageProcPtr                GetImage;
+    GetSpansProcPtr                GetSpans;
+
+    CreatePixmapProcPtr            CreatePixmap;
+    DestroyPixmapProcPtr           DestroyPixmap;
+    BitmapToRegionProcPtr          BitmapToRegion;
+
+    RealizeFontProcPtr             RealizeFont;
+    UnrealizeFontProcPtr           UnrealizeFont;
+
+    CreateColormapProcPtr          CreateColormap;
+    DestroyColormapProcPtr         DestroyColormap;
+    InstallColormapProcPtr         InstallColormap;
+    StoreColorsProcPtr             StoreColors;
+
+    SetShapeProcPtr                SetShape;
+
+    CreatePictureProcPtr           CreatePicture;
+    DestroyPictureProcPtr          DestroyPicture;
+    ChangePictureClipProcPtr       ChangePictureClip;
+    DestroyPictureClipProcPtr      DestroyPictureClip;
+    
+    ChangePictureProcPtr           ChangePicture;
+    ValidatePictureProcPtr         ValidatePicture;
+
+    CompositeProcPtr               Composite;
+    GlyphsProcPtr                  Glyphs;
+    CompositeRectsProcPtr          CompositeRects;
+
+    InitIndexedProcPtr             InitIndexed;
+    CloseIndexedProcPtr            CloseIndexed;
+    UpdateIndexedProcPtr           UpdateIndexed;
+
+    TrapezoidsProcPtr              Trapezoids;
+    TrianglesProcPtr               Triangles;
+    TriStripProcPtr                TriStrip;
+    TriFanProcPtr                  TriFan;
+} DMXScreenInfo;
+
+/* Global variables available to all Xserver/hw/dmx routines. */
+extern int              dmxNumScreens;          /**< Number of dmxScreens */
+extern DMXScreenInfo   *dmxScreens;             /**< List of outputs */
+extern int              dmxShadowFB;            /**< Non-zero if using
+                                                 * shadow frame-buffer
+                                                 * (deprecated) */
+extern XErrorEvent      dmxLastErrorEvent;      /**< Last error that
+                                                 * occurred */
+extern Bool             dmxErrorOccurred;       /**< True if an error
+                                                 * occurred */
+extern Bool             dmxOffScreenOpt;        /**< True if using off
+                                                 * screen
+                                                 * optimizations */
+extern Bool             dmxSubdividePrimitives; /**< True if using the
+                                                 * primitive subdivision
+                                                 * optimization */
+extern Bool             dmxLazyWindowCreation;  /**< True if using the
+                                                 * lazy window creation
+                                                 * optimization */
+extern Bool             dmxUseXKB;              /**< True if the XKB
+                                                 * extension should be
+                                                 * used with the backend
+                                                 * servers */
+extern int              dmxDepth;               /**< Requested depth if
+                                                 * non-zero */
+#ifdef GLXEXT
+extern Bool             dmxGLXProxy;            /**< True if glxProxy
+						 * support is enabled */
+extern Bool             dmxGLXSwapGroupSupport; /**< True if glxProxy
+						 * support for swap
+						 * groups and barriers
+						 * is enabled */
+extern Bool             dmxGLXSyncSwap;         /**< True if glxProxy
+						 * should force an XSync
+						 * request after each
+						 * swap buffers call */
+extern Bool             dmxGLXFinishSwap;       /**< True if glxProxy
+						 * should force a
+						 * glFinish request
+						 * after each swap
+						 * buffers call */
+#endif
+extern char            *dmxFontPath;            /**< NULL if no font
+						 * path is set on the
+						 * command line;
+						 * otherwise, a string
+						 * of comma separated
+						 * paths built from the
+						 * command line
+						 * specified font
+						 * paths */
+extern Bool             dmxIgnoreBadFontPaths;  /**< True if bad font
+						 * paths should be
+						 * ignored during server
+						 * init */
+extern Bool             dmxAddRemoveScreens;    /**< True if add and
+						 * remove screens support
+						 * is enabled */
+
+/** Wrap screen or GC function pointer */
+#define DMX_WRAP(_entry, _newfunc, _saved, _actual)			\
+do {									\
+    (_saved)->_entry  = (_actual)->_entry;				\
+    (_actual)->_entry = (_newfunc);					\
+} while (0)
+
+/** Unwrap screen or GC function pointer */
+#define DMX_UNWRAP(_entry, _saved, _actual)				\
+do {									\
+    (_actual)->_entry = (_saved)->_entry;				\
+} while (0)
+
+/* Define the MAXSCREENSALLOC/FREE macros, when MAXSCREENS patch has not
+ * been applied to sources. */
+#ifdef MAXSCREENS
+#define MAXSCREEN_MAKECONSTSTR1(x) #x
+#define MAXSCREEN_MAKECONSTSTR2(x) MAXSCREEN_MAKECONSTSTR1(x)
+
+#define MAXSCREEN_FAILED_TXT "Failed at ["                              \
+   MAXSCREEN_MAKECONSTSTR2(__LINE__) ":" __FILE__ "] to allocate object: "
+
+#define _MAXSCREENSALLOCF(o,size,fatal)                                 \
+    do {                                                                \
+        if (!o) {                                                       \
+            o = calloc((size), sizeof(*(o)));                          \
+            if (!o && fatal) FatalError(MAXSCREEN_FAILED_TXT #o);       \
+        }                                                               \
+    } while (0)
+#define _MAXSCREENSALLOCR(o,size,retval)                                \
+    do {                                                                \
+        if (!o) {                                                       \
+            o = calloc((size), sizeof(*(o)));                          \
+            if (!o) return retval;                                      \
+        }                                                               \
+    } while (0)
+        
+#define MAXSCREENSFREE(o)                                               \
+    do {                                                                \
+        free(o);                                                \
+        o = NULL;                                                       \
+    } while (0)
+
+#define MAXSCREENSALLOC(o)              _MAXSCREENSALLOCF(o,MAXSCREENS,  0)
+#define MAXSCREENSALLOC_FATAL(o)        _MAXSCREENSALLOCF(o,MAXSCREENS,  1)
+#define MAXSCREENSALLOC_RETURN(o,r)     _MAXSCREENSALLOCR(o,MAXSCREENS, (r))
+#define MAXSCREENSALLOCPLUSONE(o)       _MAXSCREENSALLOCF(o,MAXSCREENS+1,0)
+#define MAXSCREENSALLOCPLUSONE_FATAL(o) _MAXSCREENSALLOCF(o,MAXSCREENS+1,1)
+#define MAXSCREENSCALLOC(o,m)           _MAXSCREENSALLOCF(o,MAXSCREENS*(m),0)
+#define MAXSCREENSCALLOC_FATAL(o,m)     _MAXSCREENSALLOCF(o,MAXSCREENS*(m),1)
+#endif
+
+extern DevPrivateKeyRec dmxGCPrivateKeyRec;
+#define dmxGCPrivateKey (&dmxGCPrivateKeyRec) /**< Private index for GCs       */
+
+extern DevPrivateKeyRec dmxWinPrivateKeyRec;
+#define dmxWinPrivateKey (&dmxWinPrivateKeyRec) /**< Private index for Windows   */
+
+extern DevPrivateKeyRec dmxPixPrivateKeyRec;
+#define dmxPixPrivateKey (&dmxPixPrivateKeyRec) /**< Private index for Pixmaps   */
+
+extern int dmxFontPrivateIndex;        /**< Private index for Fonts     */
+
+extern DevPrivateKeyRec dmxScreenPrivateKeyRec;
+#define dmxScreenPrivateKey (&dmxScreenPrivateKeyRec) /**< Private index for Screens   */
+
+extern DevPrivateKeyRec dmxColormapPrivateKeyRec;
+#define dmxColormapPrivateKey (&dmxColormapPrivateKeyRec) /**< Private index for Colormaps */
+
+extern DevPrivateKeyRec dmxPictPrivateKeyRec;
+#define dmxPictPrivateKey (&dmxPictPrivateKeyRec) /**< Private index for Picts     */
+
+extern DevPrivateKeyRec dmxGlyphSetPrivateKeyRec;
+#define dmxGlyphSetPrivateKey (&dmxGlyphSetPrivateKeyRec) /**< Private index for GlyphSets */
+
+#endif /* DMX_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/gc.h
@@ -0,0 +1,167 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef GC_H
+#define GC_H 
+
+#include <X11/X.h>	/* for GContext, Mask */
+#include <X11/Xdefs.h>	/* for Bool */
+#include <X11/Xproto.h>
+#include "screenint.h"	/* for ScreenPtr */
+#include "pixmap.h"	/* for DrawablePtr */
+
+/* clientClipType field in GC */
+#define CT_NONE			0
+#define CT_PIXMAP		1
+#define CT_REGION		2
+#define CT_UNSORTED		6
+#define CT_YSORTED		10
+#define CT_YXSORTED		14
+#define CT_YXBANDED		18
+
+#define GCQREASON_VALIDATE	1
+#define GCQREASON_CHANGE	2
+#define GCQREASON_COPY_SRC	3
+#define GCQREASON_COPY_DST	4
+#define GCQREASON_DESTROY	5
+
+#define GC_CHANGE_SERIAL_BIT        (((unsigned long)1)<<31)
+#define GC_CALL_VALIDATE_BIT        (1L<<30)
+#define GCExtensionInterest   (1L<<29)
+
+#define DRAWABLE_SERIAL_BITS        (~(GC_CHANGE_SERIAL_BIT))
+
+#define MAX_SERIAL_NUM     (1L<<28)
+
+#define NEXT_SERIAL_NUMBER ((++globalSerialNumber) > MAX_SERIAL_NUM ? \
+	    (globalSerialNumber  = 1): globalSerialNumber)
+
+typedef struct _GCInterest *GCInterestPtr;
+typedef struct _GC    *GCPtr;
+typedef struct _GCOps *GCOpsPtr;
+
+extern _X_EXPORT void ValidateGC(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/);
+
+typedef union {
+    CARD32 val;
+    pointer ptr;
+} ChangeGCVal, *ChangeGCValPtr;
+
+extern int ChangeGCXIDs(
+    ClientPtr /*client*/,
+    GCPtr /*pGC*/,
+    BITS32 /*mask*/,
+    CARD32 * /*pval*/);
+
+extern _X_EXPORT int ChangeGC(
+    ClientPtr /*client*/,
+    GCPtr /*pGC*/,
+    BITS32 /*mask*/,
+    ChangeGCValPtr /*pCGCV*/);
+
+extern _X_EXPORT GCPtr CreateGC(
+    DrawablePtr /*pDrawable*/,
+    BITS32 /*mask*/,
+    XID* /*pval*/,
+    int* /*pStatus*/,
+    XID /*gcid*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int CopyGC(
+    GCPtr/*pgcSrc*/,
+    GCPtr/*pgcDst*/,
+    BITS32 /*mask*/);
+
+extern _X_EXPORT int FreeGC(
+    pointer /*pGC*/,
+    XID /*gid*/);
+
+extern _X_EXPORT GCPtr CreateScratchGC(
+    ScreenPtr /*pScreen*/,
+    unsigned /*depth*/);
+
+extern _X_EXPORT void FreeGCperDepth(
+    int /*screenNum*/);
+
+extern _X_EXPORT Bool CreateGCperDepth(
+    int /*screenNum*/);
+
+extern _X_EXPORT Bool CreateDefaultStipple(
+    int /*screenNum*/);
+
+extern _X_EXPORT void FreeDefaultStipple(
+    int /*screenNum*/);
+
+extern _X_EXPORT int SetDashes(
+    GCPtr /*pGC*/,
+    unsigned /*offset*/,
+    unsigned /*ndash*/,
+    unsigned char* /*pdash*/);
+
+extern _X_EXPORT int VerifyRectOrder(
+    int /*nrects*/,
+    xRectangle* /*prects*/,
+    int /*ordering*/);
+
+extern _X_EXPORT int SetClipRects(
+    GCPtr /*pGC*/,
+    int /*xOrigin*/,
+    int /*yOrigin*/,
+    int /*nrects*/,
+    xRectangle* /*prects*/,
+    int /*ordering*/);
+
+extern _X_EXPORT GCPtr GetScratchGC(
+    unsigned /*depth*/,
+    ScreenPtr /*pScreen*/);
+
+extern _X_EXPORT void FreeScratchGC(
+    GCPtr /*pGC*/);
+
+#endif /* GC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxlog.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxlog.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * This header is included by all files that need to use the DMX logging
+ * facilities. */
+
+#ifndef _DMXLOG_H_
+#define _DMXLOG_H_
+
+/** Logging levels -- output is tunable with #dmxSetLogLevel. */
+typedef enum {
+    dmxDebug,                   /**< Usually verbose debugging info */
+    dmxInfo,                    /**< Non-warning information */
+    dmxWarning,                 /**< A warning that may indicate DMX
+                                 * will not function as the user
+                                 * intends. */
+    dmxError,                   /**< A non-fatal error that probably
+                                 * indicates DMX will not function as
+                                 * desired.*/
+    dmxFatal                    /**< A fatal error that will cause DMX
+                                 * to shut down. */
+} dmxLogLevel;
+
+/* Logging functions used by Xserver/hw/dmx routines. */
+extern dmxLogLevel dmxSetLogLevel(dmxLogLevel newLevel);
+extern dmxLogLevel dmxGetLogLevel(void);
+extern void        dmxLog(dmxLogLevel logLevel, const char *format, ...);
+extern void        dmxLogCont(dmxLogLevel logLevel, const char *format, ...);
+extern const char  *dmxEventName(int type);
+
+#ifndef DMX_LOG_STANDALONE
+extern void dmxLogOutput(DMXScreenInfo *dmxScreen, const char *format, ...);
+extern void dmxLogOutputCont(DMXScreenInfo *dmxScreen, const char *format,
+                             ...);
+extern void dmxLogOutputWarning(DMXScreenInfo *dmxScreen, const char *format,
+                                ...);
+extern void dmxLogInput(DMXInputInfo *dmxInput, const char *format, ...);
+extern void dmxLogInputCont(DMXInputInfo *dmxInput, const char *format, ...);
+extern void dmxLogArgs(dmxLogLevel logLevel, int argc, char **argv);
+extern void dmxLogVisual(DMXScreenInfo *dmxScreen, XVisualInfo *vi,
+                         int defaultVisual);
+extern const char *dmxXInputEventName(int type);
+#endif
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/misc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/misc.h
@@ -0,0 +1,292 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+Copyright 1992, 1993 Data General Corporation;
+Copyright 1992, 1993 OMRON Corporation  
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that the
+above copyright notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting documentation, and that
+neither the name OMRON or DATA GENERAL be used in advertising or publicity
+pertaining to distribution of the software without specific, written prior
+permission of the party whose name is to be used.  Neither OMRON or 
+DATA GENERAL make any representation about the suitability of this software
+for any purpose.  It is provided "as is" without express or implied warranty.  
+
+OMRON AND DATA GENERAL EACH DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
+IN NO EVENT SHALL OMRON OR DATA GENERAL BE LIABLE FOR ANY SPECIAL, INDIRECT
+OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+OF THIS SOFTWARE.
+
+******************************************************************/
+#ifndef MISC_H
+#define MISC_H 1
+/*
+ *  X internal definitions 
+ *
+ */
+
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xmd.h>
+#include <X11/X.h>
+#include <X11/Xdefs.h>
+
+#include <stddef.h>
+
+#ifndef MAXSCREENS
+#define MAXSCREENS	16
+#endif
+#define MAXCLIENTS	256
+#define MAXEXTENSIONS   128
+#define MAXFORMATS	8
+#define MAXDEVICES	40 /* input devices */
+
+#define EXTENSION_EVENT_BASE 64
+#define EXTENSION_BASE 128
+
+typedef unsigned long PIXEL;
+typedef unsigned long ATOM;
+
+
+#ifndef TRUE
+#define TRUE 1
+#define FALSE 0
+#endif
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr; /* also in dix.h */
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef struct _xReq *xReqPtr;
+
+#include "os.h" 	/* for ALLOCATE_LOCAL and DEALLOCATE_LOCAL */
+#include <X11/Xfuncs.h> /* for bcopy, bzero, and bcmp */
+
+#define NullBox ((BoxPtr)0)
+#define MILLI_PER_MIN (1000 * 60)
+#define MILLI_PER_SECOND (1000)
+
+    /* this next is used with None and ParentRelative to tell
+       PaintWin() what to use to paint the background. Also used
+       in the macro IS_VALID_PIXMAP */
+
+#define USE_BACKGROUND_PIXEL 3
+#define USE_BORDER_PIXEL 3
+
+
+/* byte swap a 32-bit literal */
+#define lswapl(x) ((((x) & 0xff) << 24) |\
+		   (((x) & 0xff00) << 8) |\
+		   (((x) & 0xff0000) >> 8) |\
+		   (((x) >> 24) & 0xff))
+
+/* byte swap a short literal */
+#define lswaps(x) ((((x) & 0xff) << 8) | (((x) >> 8) & 0xff))
+
+#undef min
+#undef max
+
+#define min(a, b) (((a) < (b)) ? (a) : (b))
+#define max(a, b) (((a) > (b)) ? (a) : (b))
+/* abs() is a function, not a macro; include the file declaring
+ * it in case we haven't done that yet.
+ */
+#include <stdlib.h>
+#ifndef Fabs
+#define Fabs(a) ((a) > 0.0 ? (a) : -(a))	/* floating absolute value */
+#endif
+#define sign(x) ((x) < 0 ? -1 : ((x) > 0 ? 1 : 0))
+/* this assumes b > 0 */
+#define modulus(a, b, d)    if (((d) = (a) % (b)) < 0) (d) += (b)
+/*
+ * return the least significant bit in x which is set
+ *
+ * This works on 1's complement and 2's complement machines.
+ * If you care about the extra instruction on 2's complement
+ * machines, change to ((x) & (-(x)))
+ */
+#define lowbit(x) ((x) & (~(x) + 1))
+
+/* XXX Not for modules */
+#include <limits.h>
+#if !defined(MAXSHORT) || !defined(MINSHORT) || \
+    !defined(MAXINT) || !defined(MININT)
+/*
+ * Some implementations #define these through <math.h>, so preclude
+ * #include'ing it later.
+ */
+
+#include <math.h>
+#undef MAXSHORT
+#define MAXSHORT SHRT_MAX
+#undef MINSHORT
+#define MINSHORT SHRT_MIN
+#undef MAXINT
+#define MAXINT INT_MAX
+#undef MININT
+#define MININT INT_MIN
+
+#include <assert.h>
+#include <ctype.h>
+#include <stdio.h>     /* for fopen, etc... */
+
+#endif
+
+/**
+ * Calculate the number of bytes needed to hold bits.
+ * @param bits The minimum number of bits needed.
+ * @return The number of bytes needed to hold bits.
+ */
+static inline int
+bits_to_bytes(const int bits) {
+    return ((bits + 7) >> 3);
+}
+/**
+ * Calculate the number of 4-byte units needed to hold the given number of
+ * bytes.
+ * @param bytes The minimum number of bytes needed.
+ * @return The number of 4-byte units needed to hold bytes.
+ */
+static inline int
+bytes_to_int32(const int bytes) {
+    return (((bytes) + 3) >> 2);
+}
+
+/**
+ * Calculate the number of bytes (in multiples of 4) needed to hold bytes.
+ * @param bytes The minimum number of bytes needed.
+ * @return The closest multiple of 4 that is equal or higher than bytes.
+ */
+static inline int
+pad_to_int32(const int bytes) {
+    return (((bytes) + 3) & ~3);
+}
+
+extern char**
+xstrtokenize(const char *str, const char* separators);
+
+/* some macros to help swap requests, replies, and events */
+
+#define LengthRestB(stuff) \
+    ((client->req_len << 2) - sizeof(*stuff))
+
+#define LengthRestS(stuff) \
+    ((client->req_len << 1) - (sizeof(*stuff) >> 1))
+
+#define LengthRestL(stuff) \
+    (client->req_len - (sizeof(*stuff) >> 2))
+
+#define SwapRestS(stuff) \
+    SwapShorts((short *)(stuff + 1), LengthRestS(stuff))
+
+#define SwapRestL(stuff) \
+    SwapLongs((CARD32 *)(stuff + 1), LengthRestL(stuff))
+
+/* byte swap a 32-bit value */
+#define swapl(x, n) { \
+		 n = ((char *) (x))[0];\
+		 ((char *) (x))[0] = ((char *) (x))[3];\
+		 ((char *) (x))[3] = n;\
+		 n = ((char *) (x))[1];\
+		 ((char *) (x))[1] = ((char *) (x))[2];\
+		 ((char *) (x))[2] = n; }
+
+/* byte swap a short */
+#define swaps(x, n) { \
+		 n = ((char *) (x))[0];\
+		 ((char *) (x))[0] = ((char *) (x))[1];\
+		 ((char *) (x))[1] = n; }
+
+/* copy 32-bit value from src to dst byteswapping on the way */
+#define cpswapl(src, dst) { \
+                 ((char *)&(dst))[0] = ((char *) &(src))[3];\
+                 ((char *)&(dst))[1] = ((char *) &(src))[2];\
+                 ((char *)&(dst))[2] = ((char *) &(src))[1];\
+                 ((char *)&(dst))[3] = ((char *) &(src))[0]; }
+
+/* copy short from src to dst byteswapping on the way */
+#define cpswaps(src, dst) { \
+		 ((char *) &(dst))[0] = ((char *) &(src))[1];\
+		 ((char *) &(dst))[1] = ((char *) &(src))[0]; }
+
+extern _X_EXPORT void SwapLongs(
+    CARD32 *list,
+    unsigned long count);
+
+extern _X_EXPORT void SwapShorts(
+    short *list,
+    unsigned long count);
+
+extern _X_EXPORT void MakePredeclaredAtoms(void);
+
+extern _X_EXPORT int Ones(
+    unsigned long /*mask*/);
+
+typedef struct _xPoint *DDXPointPtr;
+typedef struct pixman_box16 *BoxPtr;
+typedef struct _xEvent *xEventPtr;
+typedef struct _xRectangle *xRectanglePtr;
+typedef struct _GrabRec *GrabPtr;
+
+/*  typedefs from other places - duplicated here to minimize the amount
+ *  of unnecessary junk that one would normally have to include to get
+ *  these symbols defined
+ */
+
+#ifndef _XTYPEDEF_CHARINFOPTR
+typedef struct _CharInfo *CharInfoPtr; /* also in fonts/include/font.h */
+#define _XTYPEDEF_CHARINFOPTR
+#endif
+
+extern _X_EXPORT unsigned long globalSerialNumber;
+extern _X_EXPORT unsigned long serverGeneration;
+
+#endif /* MISC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/misprite.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/misprite.h
@@ -0,0 +1,50 @@
+/*
+ * misprite.h
+ *
+ * software-sprite/sprite drawing interface spec
+ *
+ * mi versions of these routines exist.
+ */
+
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+extern Bool miSpriteInitialize(
+    ScreenPtr /*pScreen*/,
+    miPointerScreenFuncPtr /*screenFuncs*/
+);
+
+extern Bool miDCRealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool miDCUnrealizeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool miDCPutUpCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                            CursorPtr pCursor, int x, int y,
+                            unsigned long source, unsigned long mask);
+extern Bool miDCSaveUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                int x, int y, int w, int h);
+extern Bool miDCRestoreUnderCursor(DeviceIntPtr pDev, ScreenPtr pScreen,
+                                   int x, int y, int w, int h);
+extern Bool miDCDeviceInitialize(DeviceIntPtr pDev, ScreenPtr pScreen);
+extern void miDCDeviceCleanup(DeviceIntPtr pDev, ScreenPtr pScreen);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86cmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86cmap.h
@@ -0,0 +1,79 @@
+
+/*
+ * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86CMAP_H
+#define _XF86CMAP_H
+
+#include "xf86str.h"
+#include "colormapst.h"
+
+#define CMAP_PALETTED_TRUECOLOR		0x0000001
+#define CMAP_RELOAD_ON_MODE_SWITCH	0x0000002
+#define CMAP_LOAD_EVEN_IF_OFFSCREEN	0x0000004
+
+extern _X_EXPORT Bool xf86HandleColormaps(
+    ScreenPtr pScreen,
+    int maxCol,
+    int sigRGBbits,
+    xf86LoadPaletteProc *loadPalette,
+    xf86SetOverscanProc *setOverscan,
+    unsigned int flags
+);
+
+extern _X_EXPORT Bool xf86ColormapAllocatePrivates(
+    ScrnInfoPtr pScrn
+);
+
+extern _X_EXPORT int
+xf86ChangeGamma(
+   ScreenPtr pScreen,
+   Gamma newGamma
+);
+
+extern _X_EXPORT int
+xf86ChangeGammaRamp(
+   ScreenPtr pScreen,
+   int size,
+   unsigned short *red,
+   unsigned short *green,
+   unsigned short *blue
+);
+
+extern _X_EXPORT int xf86GetGammaRampSize(ScreenPtr pScreen);
+
+extern _X_EXPORT int
+xf86GetGammaRamp(
+   ScreenPtr pScreen,
+   int size,
+   unsigned short *red,
+   unsigned short *green,
+   unsigned short *blue
+);
+
+#endif /* _XF86CMAP_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shadowfb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shadowfb.h
@@ -0,0 +1,43 @@
+
+#ifndef _SHADOWFB_H
+#define _SHADOWFB_H
+
+#include "xf86str.h"
+
+/*
+ * User defined callback function.  Passed a pointer to the ScrnInfo struct,
+ * the number of dirty rectangles, and a pointer to the first dirty rectangle
+ * in the array.
+ */
+typedef void (*RefreshAreaFuncPtr)(ScrnInfoPtr, int, BoxPtr);
+
+/*
+ * ShadowFBInit initializes the shadowfb subsystem.  refreshArea is a pointer
+ * to a user supplied callback function.  This function will be called after
+ * any operation that modifies the framebuffer.  The newly dirtied rectangles
+ * are passed to the callback.
+ *
+ * Returns FALSE in the event of an error.
+ */
+extern _X_EXPORT Bool
+ShadowFBInit (
+    ScreenPtr		pScreen,
+    RefreshAreaFuncPtr  refreshArea
+);
+
+/*
+ * ShadowFBInit2 is a more featureful refinement of the original shadowfb.
+ * ShadowFBInit2 allows you to specify two callbacks, one to be called
+ * immediately before an operation that modifies the framebuffer, and another
+ * to be called immediately after.  
+ *
+ * Returns FALSE in the event of an error
+ */
+extern _X_EXPORT Bool
+ShadowFBInit2 (
+    ScreenPtr		pScreen,
+    RefreshAreaFuncPtr  preRefreshArea,
+    RefreshAreaFuncPtr  postRefreshArea
+);
+
+#endif /* _SHADOWFB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setdval.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setdval.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETDVAL_H
+#define SETDVAL_H 1
+
+int SProcXSetDeviceValuators(ClientPtr	/* client */
+    );
+
+int ProcXSetDeviceValuators(ClientPtr	/* client */
+    );
+
+void SRepXSetDeviceValuators(ClientPtr /* client */ ,
+			     int /* size */ ,
+			     xSetDeviceValuatorsReply *	/* rep */
+    );
+
+#endif /* SETDVAL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RamDacPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RamDacPriv.h
@@ -0,0 +1,13 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xf86RamDac.h"
+#include "xf86cmap.h"
+
+void RamDacGetRecPrivate(void);
+Bool RamDacGetRec(ScrnInfoPtr pScrn);
+int  RamDacGetScreenIndex(void);
+void RamDacLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
+    			LOCO *colors, VisualPtr pVisual);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiXh.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiXh.h
@@ -0,0 +1,73 @@
+
+/*
+ *	Server dispatcher function replacements
+ */
+
+extern int PanoramiXCreateWindow(ClientPtr client);
+extern int PanoramiXChangeWindowAttributes(ClientPtr client);
+extern int PanoramiXDestroyWindow(ClientPtr client);
+extern int PanoramiXDestroySubwindows(ClientPtr client);
+extern int PanoramiXChangeSaveSet(ClientPtr client);
+extern int PanoramiXReparentWindow(ClientPtr client);
+extern int PanoramiXMapWindow(ClientPtr client);
+extern int PanoramiXMapSubwindows(ClientPtr client);
+extern int PanoramiXUnmapWindow(ClientPtr client);
+extern int PanoramiXUnmapSubwindows(ClientPtr client);
+extern int PanoramiXConfigureWindow(ClientPtr client);
+extern int PanoramiXCirculateWindow(ClientPtr client);
+extern int PanoramiXGetGeometry(ClientPtr client);
+extern int PanoramiXTranslateCoords(ClientPtr client);	
+extern int PanoramiXCreatePixmap(ClientPtr client);
+extern int PanoramiXFreePixmap(ClientPtr client);
+extern int PanoramiXChangeGC(ClientPtr client);
+extern int PanoramiXCopyGC(ClientPtr client);
+extern int PanoramiXCopyColormapAndFree(ClientPtr client);
+extern int PanoramiXCreateGC(ClientPtr client);
+extern int PanoramiXSetDashes(ClientPtr client);
+extern int PanoramiXSetClipRectangles(ClientPtr client);
+extern int PanoramiXFreeGC(ClientPtr client);
+extern int PanoramiXClearToBackground(ClientPtr client);
+extern int PanoramiXCopyArea(ClientPtr client);
+extern int PanoramiXCopyPlane(ClientPtr client);
+extern int PanoramiXPolyPoint(ClientPtr client);
+extern int PanoramiXPolyLine(ClientPtr client);
+extern int PanoramiXPolySegment(ClientPtr client);
+extern int PanoramiXPolyRectangle(ClientPtr client);
+extern int PanoramiXPolyArc(ClientPtr client);
+extern int PanoramiXFillPoly(ClientPtr client);
+extern int PanoramiXPolyFillArc(ClientPtr client);
+extern int PanoramiXPolyFillRectangle(ClientPtr client);
+extern int PanoramiXPutImage(ClientPtr client);
+extern int PanoramiXGetImage(ClientPtr client);
+extern int PanoramiXPolyText8(ClientPtr client);
+extern int PanoramiXPolyText16(ClientPtr client);	
+extern int PanoramiXImageText8(ClientPtr client);
+extern int PanoramiXImageText16(ClientPtr client);
+extern int PanoramiXCreateColormap(ClientPtr client);
+extern int PanoramiXFreeColormap(ClientPtr client);
+extern int PanoramiXInstallColormap(ClientPtr client);
+extern int PanoramiXUninstallColormap(ClientPtr client);
+extern int PanoramiXAllocColor(ClientPtr client);
+extern int PanoramiXAllocNamedColor(ClientPtr client);
+extern int PanoramiXAllocColorCells(ClientPtr client);
+extern int PanoramiXStoreNamedColor(ClientPtr client);
+extern int PanoramiXFreeColors(ClientPtr client);
+extern int PanoramiXStoreColors(ClientPtr client);
+extern int PanoramiXAllocColorPlanes(ClientPtr client);
+
+#define PROC_EXTERN(pfunc)      extern int pfunc(ClientPtr)
+
+PROC_EXTERN(ProcPanoramiXQueryVersion); 
+PROC_EXTERN(ProcPanoramiXGetState); 
+PROC_EXTERN(ProcPanoramiXGetScreenCount); 
+PROC_EXTERN(ProcPanoramiXGetScreenSize); 
+ 
+PROC_EXTERN(ProcXineramaQueryScreens);
+PROC_EXTERN(ProcXineramaIsActive);
+
+extern int SProcPanoramiXDispatch(ClientPtr client);
+
+extern int connBlockScreenStart;
+extern xConnSetupPrefix connSetupPrefix;
+
+extern int (* SavedProcVector[256]) (ClientPtr client);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixaccess.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixaccess.h
@@ -0,0 +1,54 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_ACCESS_H
+#define DIX_ACCESS_H
+
+/* These are the access modes that can be passed in the last parameter
+ * to several of the dix lookup functions.  They were originally part
+ * of the Security extension, now used by XACE.
+ *
+ * You can or these values together to indicate multiple modes
+ * simultaneously.
+ */
+
+#define DixUnknownAccess	0	/* don't know intentions */
+#define DixReadAccess		(1<<0)	/* inspecting the object */
+#define DixWriteAccess		(1<<1)	/* changing the object */
+#define DixDestroyAccess	(1<<2)	/* destroying the object */
+#define DixCreateAccess		(1<<3)	/* creating the object */
+#define DixGetAttrAccess	(1<<4)	/* get object attributes */
+#define DixSetAttrAccess	(1<<5)	/* set object attributes */
+#define DixListPropAccess	(1<<6)  /* list properties of object */
+#define DixGetPropAccess	(1<<7)	/* get properties of object */
+#define DixSetPropAccess	(1<<8)	/* set properties of object */
+#define DixGetFocusAccess	(1<<9)	/* get focus of object */
+#define DixSetFocusAccess	(1<<10)	/* set focus of object */
+#define DixListAccess		(1<<11)	/* list objects */
+#define DixAddAccess		(1<<12)	/* add object */
+#define DixRemoveAccess		(1<<13)	/* remove object */
+#define DixHideAccess		(1<<14)	/* hide object */
+#define DixShowAccess		(1<<15)	/* show object */
+#define DixBlendAccess		(1<<16)	/* mix contents of objects */
+#define DixGrabAccess		(1<<17)	/* exclusive access to object */
+#define DixFreezeAccess		(1<<18)	/* freeze status of object */
+#define DixForceAccess		(1<<19)	/* force status of object */
+#define DixInstallAccess	(1<<20)	/* install object */
+#define DixUninstallAccess	(1<<21)	/* uninstall object */
+#define DixSendAccess		(1<<22)	/* send to object */
+#define DixReceiveAccess	(1<<23)	/* receive from object */
+#define DixUseAccess		(1<<24)	/* use object */
+#define DixManageAccess		(1<<25)	/* manage object */
+#define DixDebugAccess		(1<<26)	/* debug object */
+#define DixBellAccess		(1<<27)	/* audible sound */
+#define DixPostAccess		(1<<28) /* post or follow-up call */
+
+#endif /* DIX_ACCESS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda9885.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda9885.h
@@ -0,0 +1,59 @@
+#ifndef __TDA9885_H__
+#define __TDA9885_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+	I2CDevRec d;
+	
+	/* write-only parameters */
+		/* B DATA */
+	CARD8  sound_trap;
+	CARD8  auto_mute_fm;
+	CARD8  carrier_mode;
+	CARD8  modulation;
+	CARD8  forced_mute_audio;
+	CARD8  port1;
+	CARD8  port2;
+		/* C DATA */
+	CARD8  top_adjustment;
+	CARD8  deemphasis;
+	CARD8  audio_gain;
+	        /* E DATA */
+	CARD8  standard_sound_carrier;
+	CARD8  standard_video_if;
+	CARD8  minimum_gain;
+	CARD8  gating;
+	CARD8  vif_agc;
+	/* read-only values */
+	
+	CARD8  after_reset;
+	CARD8  afc_status;
+	CARD8  vif_level;
+	CARD8  afc_win;
+	CARD8  fm_carrier;
+	} TDA9885Rec, *TDA9885Ptr;
+
+#define TDA9885_ADDR_1   0x86
+#define TDA9885_ADDR_2   0x84
+#define TDA9885_ADDR_3   0x96
+#define TDA9885_ADDR_4   0x94
+
+#define xf86_Detect_tda9885		Detect_tda9885
+extern _X_EXPORT TDA9885Ptr Detect_tda9885(I2CBusPtr b, I2CSlaveAddr addr);
+#define xf86_tda9885_init		tda9885_init
+extern _X_EXPORT Bool tda9885_init(TDA9885Ptr t);
+#define xf86_tda9885_setparameters	tda9885_setparameters
+extern _X_EXPORT void tda9885_setparameters(TDA9885Ptr t);
+#define xf86_tda9885_getstatus		tda9885_getstatus
+extern _X_EXPORT void tda9885_getstatus(TDA9885Ptr t);
+#define xf86_tda9885_dumpstatus		tda9885_dumpstatus
+extern _X_EXPORT void tda9885_dumpstatus(TDA9885Ptr t);
+
+#define TDA9885SymbolsList  \
+		"Detect_tda9885", \
+		"tda9885_init", \
+		"tda9885_setaudio", \
+		"tda9885_mute"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixevents.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixevents.h
@@ -0,0 +1,91 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXEVENTS_H
+#define DIXEVENTS_H
+
+extern _X_EXPORT void SetCriticalEvent(int /* event */);
+
+extern _X_EXPORT CursorPtr GetSpriteCursor(DeviceIntPtr /*pDev*/);
+
+extern _X_EXPORT int ProcAllowEvents(ClientPtr /* client */);
+
+extern _X_EXPORT int MaybeDeliverEventsToClient(
+	WindowPtr              /* pWin */,
+	xEvent *               /* pEvents */,
+	int                    /* count */,
+	Mask                   /* filter */,
+	ClientPtr              /* dontClient */);
+
+extern _X_EXPORT int ProcWarpPointer(ClientPtr /* client */);
+
+extern _X_EXPORT int EventSelectForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */);
+
+extern _X_EXPORT int EventSuppressForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	Bool *                 /* checkOptional */);
+
+extern _X_EXPORT int ProcSetInputFocus(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcGetInputFocus(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcGrabPointer(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcChangeActivePointerGrab(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcUngrabPointer(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcGrabKeyboard(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcUngrabKeyboard(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcQueryPointer(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcSendEvent(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcUngrabKey(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcGrabKey(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcGrabButton(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcUngrabButton(ClientPtr /* client */);
+
+extern _X_EXPORT int ProcRecolorCursor(ClientPtr /* client */);
+
+#ifdef PANORAMIX
+extern _X_EXPORT void PostSyntheticMotion(DeviceIntPtr pDev,
+                                int x, 
+                                int y, 
+                                int screen,
+                                unsigned long time);
+#endif
+
+#endif /* DIXEVENTS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xv.h
@@ -0,0 +1,280 @@
+
+/*
+ * Copyright (c) 1998-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XV_H_
+#define _XF86XV_H_
+
+#include "xvdix.h"
+#include "xf86str.h"
+
+#define VIDEO_NO_CLIPPING			0x00000001
+#define VIDEO_INVERT_CLIPLIST			0x00000002
+#define VIDEO_OVERLAID_IMAGES			0x00000004
+#define VIDEO_OVERLAID_STILLS			0x00000008
+#define VIDEO_CLIP_TO_VIEWPORT			0x00000010
+
+typedef struct {
+  int id;
+  int type;
+  int byte_order;
+  unsigned char guid[16];               
+  int bits_per_pixel;
+  int format;
+  int num_planes;
+
+  /* for RGB formats only */
+  int depth;
+  unsigned int red_mask;       
+  unsigned int green_mask;   
+  unsigned int blue_mask;   
+
+  /* for YUV formats only */
+  unsigned int y_sample_bits;
+  unsigned int u_sample_bits;
+  unsigned int v_sample_bits;   
+  unsigned int horz_y_period;
+  unsigned int horz_u_period;
+  unsigned int horz_v_period;
+  unsigned int vert_y_period;
+  unsigned int vert_u_period;
+  unsigned int vert_v_period;
+  char component_order[32];
+  int scanline_order;
+} XF86ImageRec, *XF86ImagePtr; 
+
+
+typedef struct {
+  ScrnInfoPtr pScrn;
+  int id;
+  unsigned short width, height;
+  int *pitches; /* bytes */
+  int *offsets; /* in bytes from start of framebuffer */
+  DevUnion devPrivate;  
+} XF86SurfaceRec, *XF86SurfacePtr;
+
+
+typedef int (* PutVideoFuncPtr)( ScrnInfoPtr pScrn, 
+	short vid_x, short vid_y, short drw_x, short drw_y,
+	short vid_w, short vid_h, short drw_w, short drw_h,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef int (* PutStillFuncPtr)( ScrnInfoPtr pScrn, 
+	short vid_x, short vid_y, short drw_x, short drw_y,
+	short vid_w, short vid_h, short drw_w, short drw_h,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef int (* GetVideoFuncPtr)( ScrnInfoPtr pScrn, 
+	short vid_x, short vid_y, short drw_x, short drw_y,
+	short vid_w, short vid_h, short drw_w, short drw_h,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef int (* GetStillFuncPtr)( ScrnInfoPtr pScrn, 
+	short vid_x, short vid_y, short drw_x, short drw_y,
+	short vid_w, short vid_h, short drw_w, short drw_h,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef void (* StopVideoFuncPtr)(ScrnInfoPtr pScrn, pointer data, Bool Exit);
+typedef int (* SetPortAttributeFuncPtr)(ScrnInfoPtr pScrn, Atom attribute,
+	INT32 value, pointer data);
+typedef int (* GetPortAttributeFuncPtr)(ScrnInfoPtr pScrn, Atom attribute,
+	INT32 *value, pointer data);
+typedef void (* QueryBestSizeFuncPtr)(ScrnInfoPtr pScrn, Bool motion,
+	short vid_w, short vid_h, short drw_w, short drw_h, 
+	unsigned int *p_w, unsigned int *p_h, pointer data);
+typedef int (* PutImageFuncPtr)( ScrnInfoPtr pScrn, 
+	short src_x, short src_y, short drw_x, short drw_y,
+	short src_w, short src_h, short drw_w, short drw_h,
+	int image, unsigned char* buf, short width, short height, Bool Sync,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef int (* ReputImageFuncPtr)( ScrnInfoPtr pScrn, short drw_x, short drw_y,
+	RegionPtr clipBoxes, pointer data, DrawablePtr pDraw );
+typedef int (*QueryImageAttributesFuncPtr)(ScrnInfoPtr pScrn, 
+	int image, unsigned short *width, unsigned short *height, 
+	int *pitches, int *offsets);
+typedef void (*ClipNotifyFuncPtr)(ScrnInfoPtr pScrn, pointer data,
+                                  WindowPtr window, int dx, int dy);
+
+typedef enum {
+    XV_OFF,
+    XV_PENDING,
+    XV_ON
+} XvStatus;
+
+/*** this is what the driver needs to fill out ***/
+
+typedef struct {
+  int id;
+  char *name;
+  unsigned short width, height;
+  XvRationalRec rate;
+} XF86VideoEncodingRec, *XF86VideoEncodingPtr;
+
+typedef struct {
+  char 	depth;  
+  short class;
+} XF86VideoFormatRec, *XF86VideoFormatPtr;
+
+typedef struct {
+  int   flags;
+  int   min_value;
+  int   max_value;
+  char  *name;
+} XF86AttributeRec, *XF86AttributePtr;
+
+typedef struct {
+  unsigned int type; 
+  int flags;
+  char *name;
+  int nEncodings;
+  XF86VideoEncodingPtr pEncodings;  
+  int nFormats;
+  XF86VideoFormatPtr pFormats;  
+  int nPorts;
+  DevUnion *pPortPrivates;
+  int nAttributes;
+  XF86AttributePtr pAttributes;
+  int nImages;
+  XF86ImagePtr pImages;
+  PutVideoFuncPtr PutVideo;
+  PutStillFuncPtr PutStill;
+  GetVideoFuncPtr GetVideo;
+  GetStillFuncPtr GetStill;
+  StopVideoFuncPtr StopVideo;
+  SetPortAttributeFuncPtr SetPortAttribute;
+  GetPortAttributeFuncPtr GetPortAttribute;
+  QueryBestSizeFuncPtr QueryBestSize;
+  PutImageFuncPtr PutImage;
+  ReputImageFuncPtr ReputImage;
+  QueryImageAttributesFuncPtr QueryImageAttributes;
+  ClipNotifyFuncPtr ClipNotify;
+} XF86VideoAdaptorRec, *XF86VideoAdaptorPtr;
+
+typedef struct {
+  XF86ImagePtr image;
+  int flags;
+  int (*alloc_surface)(ScrnInfoPtr pScrn,
+		  int id,
+		  unsigned short width, 	
+		  unsigned short height,
+		  XF86SurfacePtr surface);
+  int (*free_surface)(XF86SurfacePtr surface);
+  int (*display) (XF86SurfacePtr surface,
+		  short vid_x, short vid_y, 
+		  short drw_x, short drw_y,
+		  short vid_w, short vid_h, 
+		  short drw_w, short drw_h,
+		  RegionPtr clipBoxes);
+  int (*stop)    (XF86SurfacePtr surface);
+  int (*getAttribute) (ScrnInfoPtr pScrn, Atom attr, INT32 *value);
+  int (*setAttribute) (ScrnInfoPtr pScrn, Atom attr, INT32 value);
+  int max_width;
+  int max_height;
+  int num_attributes;
+  XF86AttributePtr attributes;
+} XF86OffscreenImageRec, *XF86OffscreenImagePtr;
+
+extern _X_EXPORT Bool
+xf86XVScreenInit(
+   ScreenPtr pScreen, 
+   XF86VideoAdaptorPtr 	*Adaptors,
+   int num
+);
+
+typedef int (* xf86XVInitGenericAdaptorPtr)(ScrnInfoPtr pScrn,
+	XF86VideoAdaptorPtr **Adaptors);
+
+extern _X_EXPORT int
+xf86XVRegisterGenericAdaptorDriver(
+    xf86XVInitGenericAdaptorPtr InitFunc
+);
+
+extern _X_EXPORT int
+xf86XVListGenericAdaptors(
+    ScrnInfoPtr          pScrn,
+    XF86VideoAdaptorPtr  **Adaptors
+);
+
+extern _X_EXPORT Bool
+xf86XVRegisterOffscreenImages(
+   ScreenPtr pScreen,
+   XF86OffscreenImagePtr images,
+   int num
+);
+
+extern _X_EXPORT XF86OffscreenImagePtr
+xf86XVQueryOffscreenImages(
+   ScreenPtr pScreen,
+   int *num
+);
+   
+extern _X_EXPORT XF86VideoAdaptorPtr xf86XVAllocateVideoAdaptorRec(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void xf86XVFreeVideoAdaptorRec(XF86VideoAdaptorPtr ptr);
+
+extern _X_EXPORT void
+xf86XVFillKeyHelper (ScreenPtr pScreen, CARD32 key, RegionPtr clipboxes);
+
+extern _X_EXPORT void
+xf86XVFillKeyHelperDrawable (DrawablePtr pDraw, CARD32 key, RegionPtr clipboxes);
+
+extern _X_EXPORT Bool
+xf86XVClipVideoHelper(
+    BoxPtr dst,
+    INT32 *xa,
+    INT32 *xb,
+    INT32 *ya,
+    INT32 *yb,
+    RegionPtr reg,
+    INT32 width,
+    INT32 height
+);
+
+extern _X_EXPORT void
+xf86XVCopyYUV12ToPacked(
+    const void *srcy,
+    const void *srcv,
+    const void *srcu,
+    void *dst,
+    int srcPitchy,
+    int srcPitchuv,
+    int dstPitch,
+    int h,
+    int w
+);
+
+extern _X_EXPORT void
+xf86XVCopyPacked(
+    const void *src,
+    void *dst,
+    int srcPitch,
+    int dstPitch,
+    int h,
+    int w
+);
+
+extern _X_EXPORT DevPrivateKey (*XvGetScreenKeyProc)(void);
+extern _X_EXPORT unsigned long (*XvGetRTPortProc)(void);
+extern _X_EXPORT int (*XvScreenInitProc)(ScreenPtr);
+
+#endif  /* _XF86XV_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vbe.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vbe.h
@@ -0,0 +1,341 @@
+
+/*
+ *                   XFree86 vbe module
+ *               Copyright 2000 Egbert Eich
+ *
+ * The mode query/save/set/restore functions from the vesa driver 
+ * have been moved here.
+ * Copyright (c) 2000 by Conectiva S.A. (http://www.conectiva.com)
+ * Authors: Paulo César Pereira de Andrade <pcpa@conectiva.com.br> 
+ */
+
+#ifndef _VBE_H
+#define _VBE_H
+#include "xf86int10.h"
+#include "xf86DDC.h"
+
+typedef enum {
+    DDC_UNCHECKED,
+    DDC_NONE,
+    DDC_1,
+    DDC_2,
+    DDC_1_2
+}
+ddc_lvl;
+
+typedef struct {
+    xf86Int10InfoPtr pInt10;
+    int version;
+    pointer memory;
+    int real_mode_base;
+    int num_pages;
+    Bool init_int10;
+    ddc_lvl ddc;
+    Bool ddc_blank;
+} vbeInfoRec, *vbeInfoPtr;
+
+#define VBE_VERSION_MAJOR(x) *((CARD8*)(&x) + 1)
+#define VBE_VERSION_MINOR(x) (CARD8)(x)
+
+extern _X_EXPORT vbeInfoPtr VBEInit(xf86Int10InfoPtr pInt, int entityIndex);
+extern _X_EXPORT vbeInfoPtr VBEExtendedInit(xf86Int10InfoPtr pInt, int entityIndex, int Flags);
+extern _X_EXPORT void vbeFree(vbeInfoPtr pVbe);
+extern _X_EXPORT xf86MonPtr vbeDoEDID(vbeInfoPtr pVbe, pointer pDDCModule);
+
+#pragma pack(1)
+
+typedef struct vbeControllerInfoBlock {
+    CARD8 VbeSignature[4];
+    CARD16 VbeVersion;
+    CARD32 OemStringPtr;
+    CARD8 Capabilities[4];
+    CARD32 VideoModePtr;
+    CARD16 TotalMem;
+    CARD16 OemSoftwareRev;
+    CARD32 OemVendorNamePtr;
+    CARD32 OemProductNamePtr;
+    CARD32 OemProductRevPtr;
+    CARD8  Scratch[222];
+    CARD8  OemData[256];
+} vbeControllerInfoRec, *vbeControllerInfoPtr;
+
+#if defined(__GNUC__) || defined(__USLC__) || defined(__SUNPRO_C)
+#pragma pack()	/* All GCC versions recognise this syntax */
+#else
+#pragma pack(0)
+#endif
+
+#if !( defined(__GNUC__) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590)) )
+#define __attribute__(a)
+#endif
+
+typedef struct _VbeInfoBlock VbeInfoBlock;
+typedef struct _VbeModeInfoBlock VbeModeInfoBlock;
+typedef struct _VbeCRTCInfoBlock VbeCRTCInfoBlock;
+
+/*
+ * INT 0
+ */
+
+struct _VbeInfoBlock {
+    /* VESA 1.2 fields */
+    CARD8 VESASignature[4];		/* VESA */
+    CARD16 VESAVersion;			/* Higher byte major, lower byte minor */
+    /*CARD32*/char *OEMStringPtr;	/* Pointer to OEM string */
+    CARD8 Capabilities[4];		/* Capabilities of the video environment */
+
+    /*CARD32*/CARD16 *VideoModePtr;	/* pointer to supported Super VGA modes */
+
+    CARD16 TotalMemory;			/* Number of 64kb memory blocks on board */
+    /* if not VESA 2, 236 scratch bytes follow (256 bytes total size) */
+
+    /* VESA 2 fields */
+    CARD16 OemSoftwareRev;		/* VBE implementation Software revision */
+    /*CARD32*/char *OemVendorNamePtr;	/* Pointer to Vendor Name String */
+    /*CARD32*/char *OemProductNamePtr;	/* Pointer to Product Name String */
+    /*CARD32*/char *OemProductRevPtr;	/* Pointer to Product Revision String */
+    CARD8 Reserved[222];		/* Reserved for VBE implementation */
+    CARD8 OemData[256];			/* Data Area for OEM Strings */
+} __attribute__((packed));
+
+/* Return Super VGA Information */
+extern _X_EXPORT VbeInfoBlock *VBEGetVBEInfo(vbeInfoPtr pVbe);
+extern _X_EXPORT void VBEFreeVBEInfo(VbeInfoBlock *block);
+
+/*
+ * INT 1
+ */
+
+struct _VbeModeInfoBlock {
+    CARD16 ModeAttributes;		/* mode attributes */
+    CARD8 WinAAttributes;		/* window A attributes */
+    CARD8 WinBAttributes;		/* window B attributes */
+    CARD16 WinGranularity;		/* window granularity */
+    CARD16 WinSize;			/* window size */
+    CARD16 WinASegment;			/* window A start segment */
+    CARD16 WinBSegment;			/* window B start segment */
+    CARD32 WinFuncPtr;			/* real mode pointer to window function */
+    CARD16 BytesPerScanline;		/* bytes per scanline */
+
+    /* Mandatory information for VBE 1.2 and above */
+    CARD16 XResolution;			/* horizontal resolution in pixels or characters */
+    CARD16 YResolution;			/* vertical resolution in pixels or characters */
+    CARD8 XCharSize;			/* character cell width in pixels */
+    CARD8 YCharSize;			/* character cell height in pixels */
+    CARD8 NumberOfPlanes;		/* number of memory planes */
+    CARD8 BitsPerPixel;			/* bits per pixel */
+    CARD8 NumberOfBanks;		/* number of banks */
+    CARD8 MemoryModel;			/* memory model type */
+    CARD8 BankSize;			/* bank size in KB */
+    CARD8 NumberOfImages;		/* number of images */
+    CARD8 Reserved;	/* 1 */		/* reserved for page function */
+
+    /* Direct color fields (required for direct/6 and YUV/7 memory models) */
+    CARD8 RedMaskSize;			/* size of direct color red mask in bits */
+    CARD8 RedFieldPosition;		/* bit position of lsb of red mask */
+    CARD8 GreenMaskSize;		/* size of direct color green mask in bits */
+    CARD8 GreenFieldPosition;		/* bit position of lsb of green mask */
+    CARD8 BlueMaskSize;			/* size of direct color blue mask in bits */
+    CARD8 BlueFieldPosition;		/* bit position of lsb of blue mask */
+    CARD8 RsvdMaskSize;			/* size of direct color reserved mask in bits */
+    CARD8 RsvdFieldPosition;		/* bit position of lsb of reserved mask */
+    CARD8 DirectColorModeInfo;		/* direct color mode attributes */
+
+    /* Mandatory information for VBE 2.0 and above */
+    CARD32 PhysBasePtr;			/* physical address for flat memory frame buffer */
+    CARD32 Reserved32;	/* 0 */		/* Reserved - always set to 0 */
+    CARD16 Reserved16;	/* 0 */		/* Reserved - always set to 0 */
+
+    /* Mandatory information for VBE 3.0 and above */
+    CARD16 LinBytesPerScanLine;		/* bytes per scan line for linear modes */
+    CARD8 BnkNumberOfImagePages;	/* number of images for banked modes */
+    CARD8 LinNumberOfImagePages;	/* number of images for linear modes */
+    CARD8 LinRedMaskSize;		/* size of direct color red mask (linear modes) */
+    CARD8 LinRedFieldPosition;		/* bit position of lsb of red mask (linear modes) */
+    CARD8 LinGreenMaskSize;		/* size of direct color green mask (linear modes) */
+    CARD8 LinGreenFieldPosition;	/* bit position of lsb of green mask (linear modes) */
+    CARD8 LinBlueMaskSize;		/* size of direct color blue mask (linear modes) */
+    CARD8 LinBlueFieldPosition;		/* bit position of lsb of blue mask (linear modes) */
+    CARD8 LinRsvdMaskSize;		/* size of direct color reserved mask (linear modes) */
+    CARD8 LinRsvdFieldPosition;		/* bit position of lsb of reserved mask (linear modes) */
+    CARD32 MaxPixelClock;		/* maximum pixel clock (in Hz) for graphics mode */
+    CARD8 Reserved2[189];		/* remainder of VbeModeInfoBlock */
+} __attribute__((packed));
+
+/* Return VBE Mode Information */
+extern _X_EXPORT VbeModeInfoBlock *VBEGetModeInfo(vbeInfoPtr pVbe, int mode);
+extern _X_EXPORT void VBEFreeModeInfo(VbeModeInfoBlock *block);
+
+/*
+ * INT2
+ */
+
+#define CRTC_DBLSCAN	(1<<0)
+#define CRTC_INTERLACE	(1<<1)
+#define CRTC_NHSYNC	(1<<2)
+#define CRTC_NVSYNC	(1<<3)
+
+struct _VbeCRTCInfoBlock {
+    CARD16 HorizontalTotal;		/* Horizontal total in pixels */
+    CARD16 HorizontalSyncStart;		/* Horizontal sync start in pixels */
+    CARD16 HorizontalSyncEnd;		/* Horizontal sync end in pixels */
+    CARD16 VerticalTotal;		/* Vertical total in lines */
+    CARD16 VerticalSyncStart;		/* Vertical sync start in lines */
+    CARD16 VerticalSyncEnd;		/* Vertical sync end in lines */
+    CARD8 Flags;			/* Flags (Interlaced, Double Scan etc) */
+    CARD32 PixelClock;			/* Pixel clock in units of Hz */
+    CARD16 RefreshRate;			/* Refresh rate in units of 0.01 Hz */
+    CARD8 Reserved[40];			/* remainder of ModeInfoBlock */
+} __attribute__((packed));
+/* VbeCRTCInfoBlock is in the VESA 3.0 specs */
+
+extern _X_EXPORT Bool VBESetVBEMode(vbeInfoPtr pVbe, int mode, VbeCRTCInfoBlock *crtc);
+
+/*
+ * INT 3
+ */
+
+extern _X_EXPORT Bool VBEGetVBEMode(vbeInfoPtr pVbe, int *mode);
+
+/*
+ * INT 4
+ */
+
+/* Save/Restore Super VGA video state */
+/* function values are (values stored in VESAPtr):
+ *	0 := query & allocate amount of memory to save state
+ *	1 := save state
+ *	2 := restore state
+ *
+ *	function 0 called automatically if function 1 called without
+ *	a previous call to function 0.
+ */
+
+typedef enum {
+  MODE_QUERY,
+  MODE_SAVE,
+  MODE_RESTORE
+} vbeSaveRestoreFunction;
+
+extern _X_EXPORT Bool
+VBESaveRestore(vbeInfoPtr pVbe, vbeSaveRestoreFunction fuction, 
+	       pointer *memory, int *size, int *real_mode_pages);
+
+/*
+ * INT 5
+ */
+
+extern _X_EXPORT Bool
+VBEBankSwitch(vbeInfoPtr pVbe, unsigned int iBank, int window);
+
+/*
+ * INT 6
+ */
+
+typedef enum {
+  SCANWID_SET,
+  SCANWID_GET,
+  SCANWID_SET_BYTES,
+  SCANWID_GET_MAX
+} vbeScanwidthCommand;
+
+#define VBESetLogicalScanline(pVbe, width)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_SET, width, \
+					NULL, NULL, NULL)
+#define VBESetLogicalScanlineBytes(pVbe, width)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_SET_BYTES, width, \
+					NULL, NULL, NULL)
+#define VBEGetLogicalScanline(pVbe, pixels, bytes, max)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_GET, 0, \
+					pixels, bytes, max)
+#define VBEGetMaxLogicalScanline(pVbe, pixels, bytes, max)	\
+	VBESetGetLogicalScanlineLength(pVbe, SCANWID_GET_MAX, 0, \
+					pixels, bytes, max)
+extern _X_EXPORT Bool VBESetGetLogicalScanlineLength(vbeInfoPtr pVbe,
+				    vbeScanwidthCommand command, int width,
+				     int *pixels, int *bytes, int *max);
+
+/*
+ * INT 7
+ */
+
+/* 16 bit code */
+extern _X_EXPORT Bool VBESetDisplayStart(vbeInfoPtr pVbe, int x, int y, Bool wait_retrace);
+extern _X_EXPORT Bool VBEGetDisplayStart(vbeInfoPtr pVbe, int *x, int *y);
+
+/*
+ * INT 8
+ */
+
+/* if bits is 0, then it is a GET */
+extern _X_EXPORT int VBESetGetDACPaletteFormat(vbeInfoPtr pVbe, int bits);
+
+/*
+ * INT 9
+ */
+
+/*
+ *  If getting a palette, the data argument is not used. It will return
+ * the data.
+ *  If setting a palette, it will return the pointer received on success,
+ * NULL on failure.
+ */
+extern _X_EXPORT CARD32 *VBESetGetPaletteData(vbeInfoPtr pVbe, Bool set, int first, int num,
+			     CARD32 *data, Bool secondary, Bool wait_retrace);
+#define VBEFreePaletteData(data)	free(data)
+
+/*
+ * INT A
+ */
+
+typedef struct _VBEpmi {
+    int seg_tbl;
+    int tbl_off;
+    int tbl_len;
+} VBEpmi;
+
+extern _X_EXPORT VBEpmi *VBEGetVBEpmi(vbeInfoPtr pVbe);
+#define VESAFreeVBEpmi(pmi)	free(pmi)
+
+/* high level helper functions */
+
+typedef struct _vbeModeInfoRec {
+    int width;
+    int height;
+    int bpp;
+    int n;
+    struct _vbeModeInfoRec *next;
+} vbeModeInfoRec, *vbeModeInfoPtr;
+
+typedef struct {
+    CARD8 *state;
+    CARD8 *pstate;
+    int statePage;
+    int stateSize;
+    int stateMode;
+} vbeSaveRestoreRec, *vbeSaveRestorePtr;
+
+extern _X_EXPORT void
+VBEVesaSaveRestore(vbeInfoPtr pVbe, vbeSaveRestorePtr vbe_sr,
+		   vbeSaveRestoreFunction function);
+
+extern _X_EXPORT int VBEGetPixelClock(vbeInfoPtr pVbe, int mode, int Clock);
+extern _X_EXPORT Bool VBEDPMSSet(vbeInfoPtr pVbe, int mode);
+
+struct vbePanelID {
+    short hsize;
+    short vsize;
+    short fptype;
+    char redbpp;
+    char greenbpp;
+    char bluebpp;
+    char reservedbpp;
+    int reserved_offscreen_mem_size;
+    int reserved_offscreen_mem_pointer;
+    char reserved[14];
+};
+
+extern _X_EXPORT void VBEInterpretPanelID(int scrnIndex, struct vbePanelID *data);
+extern _X_EXPORT struct vbePanelID *VBEReadPanelID(vbeInfoPtr pVbe);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/loaderProcs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/loaderProcs.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 1995-1998 by Metro Link, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Metro Link, Inc. not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Metro Link, Inc. makes no
+ * representations about the suitability of this software for any purpose.
+ *  It is provided "as is" without express or implied warranty.
+ *
+ * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LOADERPROCS_H
+#define _LOADERPROCS_H
+
+#include "xf86Module.h"
+
+typedef struct module_desc {
+    struct module_desc *child;
+    struct module_desc *sib;
+    struct module_desc *parent;
+    char *name;
+    int handle;
+    ModuleSetupProc SetupProc;
+    ModuleTearDownProc TearDownProc;
+    void *TearDownData;		/* returned from SetupProc */
+    const XF86ModuleVersionInfo *VersionInfo;
+} ModuleDesc, *ModuleDescPtr;
+
+/* External API for the loader */
+
+void LoaderInit(void);
+
+ModuleDescPtr LoadDriver(const char *, const char *, int, pointer, int *,
+			 int *);
+ModuleDescPtr LoadModule(const char *, const char *, const char **,
+			 const char **, pointer, const XF86ModReqInfo *,
+			 int *, int *);
+ModuleDescPtr DuplicateModule(ModuleDescPtr mod, ModuleDescPtr parent);
+void UnloadDriver(ModuleDescPtr);
+void LoaderSetPath(const char *path);
+void LoaderSortExtensions(void);
+
+int LoaderUnload(int);
+unsigned long LoaderGetModuleVersion(ModuleDescPtr mod);
+
+void LoaderResetOptions(void);
+void LoaderSetOptions(unsigned long);
+
+/* Options for LoaderSetOptions */
+#define LDR_OPT_ABI_MISMATCH_NONFATAL		0x0001
+
+#endif /* _LOADERPROCS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvdisp.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvdisp.h
@@ -0,0 +1,2 @@
+extern void XineramifyXv(void);
+extern void XvResetProcVector(void);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxmotion.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxmotion.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to functions supporting motion events.  \see dmxmotion.c */
+
+#ifndef _DMXMOTION_H_
+#define _DMXMOTION_H_
+
+extern int  dmxPointerGetMotionBufferSize(void);
+extern int  dmxPointerGetMotionEvents(DeviceIntPtr pDevice,
+                                      xTimecoord *coords,
+                                      unsigned long start,
+                                      unsigned long stop,
+                                      ScreenPtr pScreen);
+extern void dmxPointerPutMotionEvent(DeviceIntPtr pDevice,
+                                     int firstAxis, int axesCount, int *v,
+                                     unsigned long time);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dri.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dri.h
@@ -0,0 +1,384 @@
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Jens Owen <jens@tungstengraphics.com>
+ *
+ */
+
+/* Prototypes for DRI functions */
+
+#ifndef _DRI_H_
+
+#include <pciaccess.h>
+
+#include "scrnintstr.h"
+#include "xf86dri.h"
+
+typedef int DRISyncType;
+
+#define DRI_NO_SYNC 0
+#define DRI_2D_SYNC 1
+#define DRI_3D_SYNC 2
+
+typedef int DRIContextType;
+
+typedef struct _DRIContextPrivRec DRIContextPrivRec, *DRIContextPrivPtr;
+
+typedef enum _DRIContextFlags
+{
+    DRI_CONTEXT_2DONLY    = 0x01,
+    DRI_CONTEXT_PRESERVED = 0x02,
+    DRI_CONTEXT_RESERVED  = 0x04 /* DRI Only -- no kernel equivalent */
+} DRIContextFlags;
+
+#define DRI_NO_CONTEXT 0
+#define DRI_2D_CONTEXT 1
+#define DRI_3D_CONTEXT 2
+
+typedef int DRISwapMethod;
+
+#define DRI_HIDE_X_CONTEXT 0
+#define DRI_SERVER_SWAP    1
+#define DRI_KERNEL_SWAP    2
+
+typedef int DRIWindowRequests;
+
+#define DRI_NO_WINDOWS       0
+#define DRI_3D_WINDOWS_ONLY  1
+#define DRI_ALL_WINDOWS      2
+
+
+typedef void (*ClipNotifyPtr)( WindowPtr, int, int );
+typedef void (*AdjustFramePtr)(int scrnIndex, int x, int y, int flags);
+
+
+/*
+ * These functions can be wrapped by the DRI.  Each of these have
+ * generic default funcs (initialized in DRICreateInfoRec) and can be
+ * overridden by the driver in its [driver]DRIScreenInit function.
+ */
+typedef struct {
+    ScreenWakeupHandlerProcPtr   WakeupHandler;
+    ScreenBlockHandlerProcPtr    BlockHandler;
+    WindowExposuresProcPtr       WindowExposures;
+    CopyWindowProcPtr            CopyWindow;
+    ValidateTreeProcPtr          ValidateTree;
+    PostValidateTreeProcPtr      PostValidateTree;
+    ClipNotifyProcPtr            ClipNotify;
+    AdjustFramePtr               AdjustFrame;
+} DRIWrappedFuncsRec, *DRIWrappedFuncsPtr;
+
+
+/*
+ * Prior to Xorg 6.8.99.8, the DRIInfoRec structure was implicitly versioned
+ * by the XF86DRI_*_VERSION defines in xf86dristr.h.  These numbers were also
+ * being used to version the XFree86-DRI protocol.  Bugs #3066 and #3163
+ * showed that this was inadequate.  The DRIInfoRec structure is now versioned
+ * by the DRIINFO_*_VERSION defines in this file. - ajax, 2005-05-18.
+ *
+ * Revision history:
+ * 4.1.0 and earlier: DRIQueryVersion returns XF86DRI_*_VERSION.
+ * 4.2.0: DRIQueryVersion begins returning DRIINFO_*_VERSION.
+ * 5.0.0: frameBufferPhysicalAddress changed from CARD32 to pointer.
+ */
+
+#define DRIINFO_MAJOR_VERSION   5
+#define DRIINFO_MINOR_VERSION   4
+#define DRIINFO_PATCH_VERSION   0
+
+typedef unsigned long long (*DRITexOffsetStartProcPtr)(PixmapPtr pPix);
+typedef void (*DRITexOffsetFinishProcPtr)(PixmapPtr pPix);
+
+typedef struct {
+    /* driver call back functions
+     *
+     * New fields should be added at the end for backwards compatibility.
+     * Bump the DRIINFO patch number to indicate bugfixes.
+     * Bump the DRIINFO minor number to indicate new fields.
+     * Bump the DRIINFO major number to indicate binary-incompatible changes.
+     */
+    Bool	(*CreateContext)(ScreenPtr pScreen,
+				 VisualPtr visual,
+				 drm_context_t hHWContext,
+				 void* pVisualConfigPriv,
+				 DRIContextType context);
+    void        (*DestroyContext)(ScreenPtr pScreen,
+				  drm_context_t hHWContext,
+                                  DRIContextType context);
+    void	(*SwapContext)(ScreenPtr pScreen,
+			       DRISyncType syncType,
+			       DRIContextType readContextType,
+			       void* readContextStore,
+			       DRIContextType writeContextType,
+			       void* writeContextStore);
+    void	(*InitBuffers)(WindowPtr pWin,
+			       RegionPtr prgn,
+			       CARD32 indx);
+    void	(*MoveBuffers)(WindowPtr pWin,
+			       DDXPointRec ptOldOrg,
+			       RegionPtr prgnSrc,
+			       CARD32 indx);
+    void        (*TransitionTo3d)(ScreenPtr pScreen);
+    void        (*TransitionTo2d)(ScreenPtr pScreen);
+
+    void	(*SetDrawableIndex)(WindowPtr pWin, CARD32 indx);
+    Bool        (*OpenFullScreen)(ScreenPtr pScreen);
+    Bool        (*CloseFullScreen)(ScreenPtr pScreen);
+
+    /* wrapped functions */
+    DRIWrappedFuncsRec  wrap;
+
+    /* device info */
+    char*		drmDriverName;
+    char*		clientDriverName;
+    char*		busIdString;
+    int			ddxDriverMajorVersion;
+    int			ddxDriverMinorVersion;
+    int			ddxDriverPatchVersion;
+    pointer		frameBufferPhysicalAddress;
+    long		frameBufferSize;
+    long		frameBufferStride;
+    long		SAREASize;
+    int			maxDrawableTableEntry;
+    int			ddxDrawableTableEntry;
+    long		contextSize;
+    DRISwapMethod	driverSwapMethod;
+    DRIWindowRequests	bufferRequests;
+    int			devPrivateSize;
+    void*		devPrivate;
+    Bool		createDummyCtx;
+    Bool		createDummyCtxPriv;
+
+    /* New with DRI version 4.1.0 */
+    void        (*TransitionSingleToMulti3D)(ScreenPtr pScreen);
+    void        (*TransitionMultiToSingle3D)(ScreenPtr pScreen);
+
+    /* New with DRI version 5.1.0 */
+    void        (*ClipNotify)(ScreenPtr pScreen, WindowPtr *ppWin, int num);
+
+    /* New with DRI version 5.2.0 */
+    Bool                allocSarea;
+    Bool                keepFDOpen;
+
+    /* New with DRI version 5.3.0 */
+    DRITexOffsetStartProcPtr  texOffsetStart;
+    DRITexOffsetFinishProcPtr texOffsetFinish;
+
+    /* New with DRI version 5.4.0 */
+    int			dontMapFrameBuffer;
+    drm_handle_t   	hFrameBuffer; /* Handle to framebuffer, either
+				       * mapped by DDX driver or DRI */
+    
+} DRIInfoRec, *DRIInfoPtr;
+
+
+extern _X_EXPORT Bool DRIOpenDRMMaster(ScrnInfoPtr pScrn, unsigned long sAreaSize,
+			     const char *busID,
+			     const char *drmDriverName);
+
+extern _X_EXPORT Bool DRIScreenInit(ScreenPtr pScreen,
+                          DRIInfoPtr pDRIInfo,
+                          int *pDRMFD);
+
+extern _X_EXPORT void DRICloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRIExtensionInit(void);
+
+extern _X_EXPORT void DRIReset(void);
+
+extern _X_EXPORT Bool DRIQueryDirectRenderingCapable(ScreenPtr pScreen,
+                                           Bool *isCapable);
+
+extern _X_EXPORT Bool DRIOpenConnection(ScreenPtr pScreen,
+                              drm_handle_t * hSAREA,
+                              char **busIdString);
+
+extern _X_EXPORT Bool DRIAuthConnection(ScreenPtr pScreen, drm_magic_t magic);
+
+extern _X_EXPORT Bool DRICloseConnection(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRIGetClientDriverName(ScreenPtr pScreen,
+                                   int* ddxDriverMajorVersion,
+                                   int* ddxDriverMinorVersion,
+                                   int* ddxDriverPatchVersion,
+                                   char** clientDriverName);
+
+extern _X_EXPORT Bool DRICreateContext(ScreenPtr pScreen,
+                             VisualPtr visual,
+                             XID context,
+                             drm_context_t * pHWContext);
+
+extern _X_EXPORT Bool DRIDestroyContext(ScreenPtr pScreen, XID context);
+
+extern _X_EXPORT Bool DRIContextPrivDelete(pointer pResource, XID id);
+
+extern _X_EXPORT Bool DRICreateDrawable(ScreenPtr pScreen,
+                              ClientPtr client,
+                              DrawablePtr pDrawable,
+                              drm_drawable_t * hHWDrawable);
+
+extern _X_EXPORT Bool DRIDestroyDrawable(ScreenPtr pScreen,
+			       ClientPtr client,
+                               DrawablePtr pDrawable);
+
+extern _X_EXPORT Bool DRIDrawablePrivDelete(pointer pResource,
+                                  XID id);
+
+extern _X_EXPORT Bool DRIGetDrawableInfo(ScreenPtr pScreen,
+                               DrawablePtr pDrawable,
+                               unsigned int* indx,
+                               unsigned int* stamp,
+                               int* X,
+                               int* Y,
+                               int* W,
+                               int* H,
+                               int* numClipRects,
+                               drm_clip_rect_t ** pClipRects,
+                               int* backX,
+                               int* backY,
+                               int* numBackClipRects,
+                               drm_clip_rect_t ** pBackClipRects);
+
+extern _X_EXPORT Bool DRIGetDeviceInfo(ScreenPtr pScreen,
+                             drm_handle_t * hFrameBuffer,
+                             int* fbOrigin,
+                             int* fbSize,
+                             int* fbStride,
+                             int* devPrivateSize,
+                             void** pDevPrivate);
+
+extern _X_EXPORT DRIInfoPtr DRICreateInfoRec(void);
+
+extern _X_EXPORT void DRIDestroyInfoRec(DRIInfoPtr DRIInfo);
+
+extern _X_EXPORT Bool DRIFinishScreenInit(ScreenPtr pScreen);
+
+extern _X_EXPORT void DRIWakeupHandler(pointer wakeupData,
+                             int result,
+                             pointer pReadmask);
+
+extern _X_EXPORT void DRIBlockHandler(pointer blockData,
+                            OSTimePtr pTimeout,
+                            pointer pReadmask);
+
+extern _X_EXPORT void DRIDoWakeupHandler(int screenNum,
+                               pointer wakeupData,
+                               unsigned long result,
+                               pointer pReadmask);
+
+extern _X_EXPORT void DRIDoBlockHandler(int screenNum,
+                              pointer blockData,
+                              pointer pTimeout,
+                              pointer pReadmask);
+
+extern _X_EXPORT void DRISwapContext(int drmFD,
+                           void *oldctx,
+                           void *newctx);
+
+extern _X_EXPORT void *DRIGetContextStore(DRIContextPrivPtr context);
+
+extern _X_EXPORT void DRIWindowExposures(WindowPtr pWin,
+                              RegionPtr prgn,
+                              RegionPtr bsreg);
+
+extern _X_EXPORT Bool DRIDestroyWindow(WindowPtr pWin);
+
+extern _X_EXPORT void DRICopyWindow(WindowPtr pWin,
+                          DDXPointRec ptOldOrg,
+                          RegionPtr prgnSrc);
+
+extern _X_EXPORT int DRIValidateTree(WindowPtr pParent,
+                           WindowPtr pChild,
+                           VTKind    kind);
+
+extern _X_EXPORT void DRIPostValidateTree(WindowPtr pParent,
+                                WindowPtr pChild,
+                                VTKind    kind);
+
+extern _X_EXPORT void DRIClipNotify(WindowPtr pWin,
+                          int dx,
+                          int dy);
+
+extern _X_EXPORT CARD32 DRIGetDrawableIndex(WindowPtr pWin);
+
+extern _X_EXPORT void DRIPrintDrawableLock(ScreenPtr pScreen, char *msg);
+
+extern _X_EXPORT void DRILock(ScreenPtr pScreen, int flags);
+
+extern _X_EXPORT void DRIUnlock(ScreenPtr pScreen);
+
+extern _X_EXPORT DRIWrappedFuncsRec *DRIGetWrappedFuncs(ScreenPtr pScreen);
+
+extern _X_EXPORT void *DRIGetSAREAPrivate(ScreenPtr pScreen);
+
+extern _X_EXPORT unsigned int DRIGetDrawableStamp(ScreenPtr pScreen,
+                                        CARD32 drawable_index);
+
+extern _X_EXPORT DRIContextPrivPtr DRICreateContextPriv(ScreenPtr pScreen,
+                                              drm_context_t * pHWContext,
+                                              DRIContextFlags flags);
+
+extern _X_EXPORT DRIContextPrivPtr DRICreateContextPrivFromHandle(ScreenPtr pScreen,
+                                                        drm_context_t hHWContext,
+                                                        DRIContextFlags flags);
+
+extern _X_EXPORT Bool DRIDestroyContextPriv(DRIContextPrivPtr pDRIContextPriv);
+
+extern _X_EXPORT drm_context_t DRIGetContext(ScreenPtr pScreen);
+
+extern _X_EXPORT void DRIQueryVersion(int *majorVersion,
+                            int *minorVersion,
+                            int *patchVersion);
+
+extern _X_EXPORT void DRIAdjustFrame(int scrnIndex, int x, int y, int flags);
+
+extern _X_EXPORT void DRIMoveBuffersHelper(ScreenPtr pScreen,
+                                 int dx,
+                                 int dy,
+                                 int *xdir, 
+                                 int *ydir, 
+                                 RegionPtr reg);
+
+extern _X_EXPORT char *DRICreatePCIBusID(const struct pci_device *PciInfo);
+
+extern _X_EXPORT int drmInstallSIGIOHandler(int fd, void (*f)(int, void *, void *));
+extern _X_EXPORT int drmRemoveSIGIOHandler(int fd);
+extern _X_EXPORT int DRIMasterFD(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void *DRIMasterSareaPointer(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT drm_handle_t DRIMasterSareaHandle(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void DRIGetTexOffsetFuncs(ScreenPtr pScreen,
+				 DRITexOffsetStartProcPtr *texOffsetStartFunc,
+				 DRITexOffsetFinishProcPtr *texOffsetFinishFunc);
+
+#define _DRI_H_
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxswap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxswap.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2003 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+#ifndef __GLX_swap_h__
+#define __GLX_swap_h__
+
+extern int  JoinSwapGroupSGIX(DrawablePtr pDraw, DrawablePtr pMember);
+extern int  SGSwapBuffers(__GLXclientState *cl, XID drawId, GLXContextTag tag,
+			  DrawablePtr pDraw);
+
+extern void SwapBarrierInit(void);
+extern void SwapBarrierReset(void);
+extern int  QueryMaxSwapBarriersSGIX(int screen);
+extern int  BindSwapBarrierSGIX(DrawablePtr pDraw, int barrier);
+
+#endif /* !__GLX_swap_h__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RandR12.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RandR12.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright © 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _XF86_RANDR_H_
+#define _XF86_RANDR_H_
+#include <randrstr.h>
+#include <X11/extensions/render.h>
+#if XF86_MODES_RENAME
+#include "xf86Rename.h"
+#endif
+
+extern _X_EXPORT Bool xf86RandR12CreateScreenResources (ScreenPtr pScreen);
+extern _X_EXPORT Bool xf86RandR12Init(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12CloseScreen(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12SetRotations (ScreenPtr pScreen, Rotation rotation);
+extern _X_EXPORT void xf86RandR12SetTransformSupport (ScreenPtr pScreen, Bool transforms);
+extern _X_EXPORT Bool xf86RandR12SetConfig(ScreenPtr pScreen, Rotation rotation, int rate,
+			RRScreenSizePtr pSize);
+extern _X_EXPORT Rotation xf86RandR12GetRotation(ScreenPtr pScreen);
+extern _X_EXPORT void xf86RandR12GetOriginalVirtualSize(ScrnInfoPtr pScrn, int *x, int *y);
+extern _X_EXPORT Bool xf86RandR12PreInit (ScrnInfoPtr pScrn);
+extern _X_EXPORT void xf86RandR12TellChanged (ScreenPtr pScreen);
+
+#endif /* _XF86_RANDR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cfb8_16.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/cfb8_16.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2006 Adam Jackson.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _CFB8_16_H
+#define _CFB8_16_H
+
+#include "regionstr.h"
+#include "windowstr.h"
+
+/* this has to stay misnamed for ABI reasons */
+
+extern _X_EXPORT Bool
+cfb8_16ScreenInit(ScreenPtr pScreen, pointer pbits16, pointer pbits8,
+                  int xsize, int ysize, int dpix, int dpiy,
+                  int width16, int width8);
+
+#endif /* _CFB8_16_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getmmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getmmap.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETMMAP_H
+#define GETMMAP_H 1
+
+int SProcXGetDeviceModifierMapping(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceModifierMapping(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceModifierMapping(ClientPtr /* client */ ,
+				   int /* size */ ,
+				   xGetDeviceModifierMappingReply *	/* rep */
+    );
+
+#endif /* GETMMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/i2c_def.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/i2c_def.h
@@ -0,0 +1,6 @@
+#ifndef __I2C_DEF_H__
+#define __I2C_DEF_H__
+
+#include "xf86i2c.h"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/g_disptab.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/g_disptab.h
@@ -0,0 +1,676 @@
+/* DO NOT EDIT - THIS FILE IS AUTOMATICALLY GENERATED */
+#ifndef _GLX_g_disptab_h_
+#define _GLX_g_disptab_h_
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+extern int __glXRender(__GLXclientState*, GLbyte*);
+extern int __glXRenderLarge(__GLXclientState*, GLbyte*);
+extern int __glXSendLargeCommand(__GLXclientState *cl, GLXContextTag contextTag);
+extern int __glXCreateContext(__GLXclientState*, GLbyte*);
+extern int __glXCreateNewContext(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDestroyContext(__GLXclientState*, GLbyte*);
+extern int __glXMakeCurrent(__GLXclientState*, GLbyte*);
+extern int __glXMakeContextCurrent(__GLXclientState*, GLbyte*);
+extern int __glXCreatePbuffer(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDestroyPbuffer(__GLXclientState *cl, GLbyte *pc);
+extern int __glXGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc);
+extern int __glXChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc);
+extern int __glXIsDirect(__GLXclientState*, GLbyte*);
+extern int __glXQueryVersion(__GLXclientState*, GLbyte*);
+extern int __glXWaitGL(__GLXclientState*, GLbyte*);
+extern int __glXWaitX(__GLXclientState*, GLbyte*);
+extern int __glXCopyContext(__GLXclientState*, GLbyte*);
+extern int __glXSwapBuffers(__GLXclientState*, GLbyte*);
+extern int __glXUseXFont(__GLXclientState*, GLbyte*);
+extern int __glXCreateGLXPixmap(__GLXclientState*, GLbyte*);
+extern int __glXCreatePixmap(__GLXclientState *cl, GLbyte *pc);
+extern int __glXGetVisualConfigs(__GLXclientState*, GLbyte*);
+extern int __glXDestroyGLXPixmap(__GLXclientState*, GLbyte*);
+extern int __glXVendorPrivate(__GLXclientState*, GLbyte*);
+extern int __glXVendorPrivateWithReply(__GLXclientState*, GLbyte*);
+extern int __glXQueryExtensionsString(__GLXclientState*, GLbyte*);
+extern int __glXQueryServerString(__GLXclientState*, GLbyte*);
+extern int __glXClientInfo(__GLXclientState*, GLbyte*);
+extern int __glXGetFBConfigs(__GLXclientState*, GLbyte*);
+extern int __glXCreateWindow(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDestroyWindow(__GLXclientState *cl, GLbyte *pc);
+extern int __glXQueryContext(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDisp_NewList(__GLXclientState*, GLbyte*);
+extern int __glXDisp_EndList(__GLXclientState*, GLbyte*);
+extern int __glXDisp_DeleteLists(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GenLists(__GLXclientState*, GLbyte*);
+extern int __glXDisp_FeedbackBuffer(__GLXclientState*, GLbyte*);
+extern int __glXDisp_SelectBuffer(__GLXclientState*, GLbyte*);
+extern int __glXDisp_RenderMode(__GLXclientState*, GLbyte*);
+extern int __glXDisp_Finish(__GLXclientState*, GLbyte*);
+extern int __glXDisp_PixelStoref(__GLXclientState*, GLbyte*);
+extern int __glXDisp_PixelStorei(__GLXclientState*, GLbyte*);
+extern int __glXDisp_ReadPixels(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetBooleanv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetClipPlane(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetDoublev(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetError(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetFloatv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetIntegerv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetLightfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetLightiv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMapdv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMapfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMapiv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMaterialfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMaterialiv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetPixelMapfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetPixelMapuiv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetPixelMapusv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetPolygonStipple(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetString(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexEnvfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexEnviv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexGendv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexGenfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexGeniv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexImage(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexLevelParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetTexLevelParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_IsEnabled(__GLXclientState*, GLbyte*);
+extern int __glXDisp_IsList(__GLXclientState*, GLbyte*);
+extern int __glXDisp_Flush(__GLXclientState*, GLbyte*);
+extern int __glXDisp_AreTexturesResident(__GLXclientState*, GLbyte*);
+extern int __glXDisp_DeleteTextures(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GenTextures(__GLXclientState*, GLbyte*);
+extern int __glXDisp_IsTexture(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetColorTable(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetColorTableParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetColorTableParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetConvolutionFilter(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetConvolutionParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetConvolutionParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetSeparableFilter(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetHistogram(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetHistogramParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetHistogramParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMinmax(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMinmaxParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDisp_GetMinmaxParameteriv(__GLXclientState*, GLbyte*);
+
+extern void __glXDisp_CallList(GLbyte*);
+extern void __glXDisp_CallLists(GLbyte*);
+extern void __glXDisp_ListBase(GLbyte*);
+extern void __glXDisp_Begin(GLbyte*);
+extern void __glXDisp_Bitmap(GLbyte*);
+extern void __glXDisp_Color3bv(GLbyte*);
+extern void __glXDisp_Color3dv(GLbyte*);
+extern void __glXDisp_Color3fv(GLbyte*);
+extern void __glXDisp_Color3iv(GLbyte*);
+extern void __glXDisp_Color3sv(GLbyte*);
+extern void __glXDisp_Color3ubv(GLbyte*);
+extern void __glXDisp_Color3uiv(GLbyte*);
+extern void __glXDisp_Color3usv(GLbyte*);
+extern void __glXDisp_Color4bv(GLbyte*);
+extern void __glXDisp_Color4dv(GLbyte*);
+extern void __glXDisp_Color4fv(GLbyte*);
+extern void __glXDisp_Color4iv(GLbyte*);
+extern void __glXDisp_Color4sv(GLbyte*);
+extern void __glXDisp_Color4ubv(GLbyte*);
+extern void __glXDisp_Color4uiv(GLbyte*);
+extern void __glXDisp_Color4usv(GLbyte*);
+extern void __glXDisp_EdgeFlagv(GLbyte*);
+extern void __glXDisp_End(GLbyte*);
+extern void __glXDisp_Indexdv(GLbyte*);
+extern void __glXDisp_Indexfv(GLbyte*);
+extern void __glXDisp_Indexiv(GLbyte*);
+extern void __glXDisp_Indexsv(GLbyte*);
+extern void __glXDisp_Normal3bv(GLbyte*);
+extern void __glXDisp_Normal3dv(GLbyte*);
+extern void __glXDisp_Normal3fv(GLbyte*);
+extern void __glXDisp_Normal3iv(GLbyte*);
+extern void __glXDisp_Normal3sv(GLbyte*);
+extern void __glXDisp_RasterPos2dv(GLbyte*);
+extern void __glXDisp_RasterPos2fv(GLbyte*);
+extern void __glXDisp_RasterPos2iv(GLbyte*);
+extern void __glXDisp_RasterPos2sv(GLbyte*);
+extern void __glXDisp_RasterPos3dv(GLbyte*);
+extern void __glXDisp_RasterPos3fv(GLbyte*);
+extern void __glXDisp_RasterPos3iv(GLbyte*);
+extern void __glXDisp_RasterPos3sv(GLbyte*);
+extern void __glXDisp_RasterPos4dv(GLbyte*);
+extern void __glXDisp_RasterPos4fv(GLbyte*);
+extern void __glXDisp_RasterPos4iv(GLbyte*);
+extern void __glXDisp_RasterPos4sv(GLbyte*);
+extern void __glXDisp_Rectdv(GLbyte*);
+extern void __glXDisp_Rectfv(GLbyte*);
+extern void __glXDisp_Rectiv(GLbyte*);
+extern void __glXDisp_Rectsv(GLbyte*);
+extern void __glXDisp_TexCoord1dv(GLbyte*);
+extern void __glXDisp_TexCoord1fv(GLbyte*);
+extern void __glXDisp_TexCoord1iv(GLbyte*);
+extern void __glXDisp_TexCoord1sv(GLbyte*);
+extern void __glXDisp_TexCoord2dv(GLbyte*);
+extern void __glXDisp_TexCoord2fv(GLbyte*);
+extern void __glXDisp_TexCoord2iv(GLbyte*);
+extern void __glXDisp_TexCoord2sv(GLbyte*);
+extern void __glXDisp_TexCoord3dv(GLbyte*);
+extern void __glXDisp_TexCoord3fv(GLbyte*);
+extern void __glXDisp_TexCoord3iv(GLbyte*);
+extern void __glXDisp_TexCoord3sv(GLbyte*);
+extern void __glXDisp_TexCoord4dv(GLbyte*);
+extern void __glXDisp_TexCoord4fv(GLbyte*);
+extern void __glXDisp_TexCoord4iv(GLbyte*);
+extern void __glXDisp_TexCoord4sv(GLbyte*);
+extern void __glXDisp_Vertex2dv(GLbyte*);
+extern void __glXDisp_Vertex2fv(GLbyte*);
+extern void __glXDisp_Vertex2iv(GLbyte*);
+extern void __glXDisp_Vertex2sv(GLbyte*);
+extern void __glXDisp_Vertex3dv(GLbyte*);
+extern void __glXDisp_Vertex3fv(GLbyte*);
+extern void __glXDisp_Vertex3iv(GLbyte*);
+extern void __glXDisp_Vertex3sv(GLbyte*);
+extern void __glXDisp_Vertex4dv(GLbyte*);
+extern void __glXDisp_Vertex4fv(GLbyte*);
+extern void __glXDisp_Vertex4iv(GLbyte*);
+extern void __glXDisp_Vertex4sv(GLbyte*);
+extern void __glXDisp_ClipPlane(GLbyte*);
+extern void __glXDisp_ColorMaterial(GLbyte*);
+extern void __glXDisp_CullFace(GLbyte*);
+extern void __glXDisp_Fogf(GLbyte*);
+extern void __glXDisp_Fogfv(GLbyte*);
+extern void __glXDisp_Fogi(GLbyte*);
+extern void __glXDisp_Fogiv(GLbyte*);
+extern void __glXDisp_FrontFace(GLbyte*);
+extern void __glXDisp_Hint(GLbyte*);
+extern void __glXDisp_Lightf(GLbyte*);
+extern void __glXDisp_Lightfv(GLbyte*);
+extern void __glXDisp_Lighti(GLbyte*);
+extern void __glXDisp_Lightiv(GLbyte*);
+extern void __glXDisp_LightModelf(GLbyte*);
+extern void __glXDisp_LightModelfv(GLbyte*);
+extern void __glXDisp_LightModeli(GLbyte*);
+extern void __glXDisp_LightModeliv(GLbyte*);
+extern void __glXDisp_LineStipple(GLbyte*);
+extern void __glXDisp_LineWidth(GLbyte*);
+extern void __glXDisp_Materialf(GLbyte*);
+extern void __glXDisp_Materialfv(GLbyte*);
+extern void __glXDisp_Materiali(GLbyte*);
+extern void __glXDisp_Materialiv(GLbyte*);
+extern void __glXDisp_PointSize(GLbyte*);
+extern void __glXDisp_PolygonMode(GLbyte*);
+extern void __glXDisp_PolygonStipple(GLbyte*);
+extern void __glXDisp_Scissor(GLbyte*);
+extern void __glXDisp_ShadeModel(GLbyte*);
+extern void __glXDisp_TexParameterf(GLbyte*);
+extern void __glXDisp_TexParameterfv(GLbyte*);
+extern void __glXDisp_TexParameteri(GLbyte*);
+extern void __glXDisp_TexParameteriv(GLbyte*);
+extern void __glXDisp_TexImage1D(GLbyte*);
+extern void __glXDisp_TexImage2D(GLbyte*);
+extern void __glXDisp_TexEnvf(GLbyte*);
+extern void __glXDisp_TexEnvfv(GLbyte*);
+extern void __glXDisp_TexEnvi(GLbyte*);
+extern void __glXDisp_TexEnviv(GLbyte*);
+extern void __glXDisp_TexGend(GLbyte*);
+extern void __glXDisp_TexGendv(GLbyte*);
+extern void __glXDisp_TexGenf(GLbyte*);
+extern void __glXDisp_TexGenfv(GLbyte*);
+extern void __glXDisp_TexGeni(GLbyte*);
+extern void __glXDisp_TexGeniv(GLbyte*);
+extern void __glXDisp_InitNames(GLbyte*);
+extern void __glXDisp_LoadName(GLbyte*);
+extern void __glXDisp_PassThrough(GLbyte*);
+extern void __glXDisp_PopName(GLbyte*);
+extern void __glXDisp_PushName(GLbyte*);
+extern void __glXDisp_DrawBuffer(GLbyte*);
+extern void __glXDisp_Clear(GLbyte*);
+extern void __glXDisp_ClearAccum(GLbyte*);
+extern void __glXDisp_ClearIndex(GLbyte*);
+extern void __glXDisp_ClearColor(GLbyte*);
+extern void __glXDisp_ClearStencil(GLbyte*);
+extern void __glXDisp_ClearDepth(GLbyte*);
+extern void __glXDisp_StencilMask(GLbyte*);
+extern void __glXDisp_ColorMask(GLbyte*);
+extern void __glXDisp_DepthMask(GLbyte*);
+extern void __glXDisp_IndexMask(GLbyte*);
+extern void __glXDisp_Accum(GLbyte*);
+extern void __glXDisp_Disable(GLbyte*);
+extern void __glXDisp_Enable(GLbyte*);
+extern void __glXDisp_PopAttrib(GLbyte*);
+extern void __glXDisp_PushAttrib(GLbyte*);
+extern void __glXDisp_Map1d(GLbyte*);
+extern void __glXDisp_Map1f(GLbyte*);
+extern void __glXDisp_Map2d(GLbyte*);
+extern void __glXDisp_Map2f(GLbyte*);
+extern void __glXDisp_MapGrid1d(GLbyte*);
+extern void __glXDisp_MapGrid1f(GLbyte*);
+extern void __glXDisp_MapGrid2d(GLbyte*);
+extern void __glXDisp_MapGrid2f(GLbyte*);
+extern void __glXDisp_EvalCoord1dv(GLbyte*);
+extern void __glXDisp_EvalCoord1fv(GLbyte*);
+extern void __glXDisp_EvalCoord2dv(GLbyte*);
+extern void __glXDisp_EvalCoord2fv(GLbyte*);
+extern void __glXDisp_EvalMesh1(GLbyte*);
+extern void __glXDisp_EvalPoint1(GLbyte*);
+extern void __glXDisp_EvalMesh2(GLbyte*);
+extern void __glXDisp_EvalPoint2(GLbyte*);
+extern void __glXDisp_AlphaFunc(GLbyte*);
+extern void __glXDisp_BlendFunc(GLbyte*);
+extern void __glXDisp_LogicOp(GLbyte*);
+extern void __glXDisp_StencilFunc(GLbyte*);
+extern void __glXDisp_StencilOp(GLbyte*);
+extern void __glXDisp_DepthFunc(GLbyte*);
+extern void __glXDisp_PixelZoom(GLbyte*);
+extern void __glXDisp_PixelTransferf(GLbyte*);
+extern void __glXDisp_PixelTransferi(GLbyte*);
+extern void __glXDisp_PixelMapfv(GLbyte*);
+extern void __glXDisp_PixelMapuiv(GLbyte*);
+extern void __glXDisp_PixelMapusv(GLbyte*);
+extern void __glXDisp_ReadBuffer(GLbyte*);
+extern void __glXDisp_CopyPixels(GLbyte*);
+extern void __glXDisp_DrawPixels(GLbyte*);
+extern void __glXDisp_DepthRange(GLbyte*);
+extern void __glXDisp_Frustum(GLbyte*);
+extern void __glXDisp_LoadIdentity(GLbyte*);
+extern void __glXDisp_LoadMatrixf(GLbyte*);
+extern void __glXDisp_LoadMatrixd(GLbyte*);
+extern void __glXDisp_MatrixMode(GLbyte*);
+extern void __glXDisp_MultMatrixf(GLbyte*);
+extern void __glXDisp_MultMatrixd(GLbyte*);
+extern void __glXDisp_Ortho(GLbyte*);
+extern void __glXDisp_PopMatrix(GLbyte*);
+extern void __glXDisp_PushMatrix(GLbyte*);
+extern void __glXDisp_Rotated(GLbyte*);
+extern void __glXDisp_Rotatef(GLbyte*);
+extern void __glXDisp_Scaled(GLbyte*);
+extern void __glXDisp_Scalef(GLbyte*);
+extern void __glXDisp_Translated(GLbyte*);
+extern void __glXDisp_Translatef(GLbyte*);
+extern void __glXDisp_Viewport(GLbyte*);
+extern void __glXDisp_PolygonOffset(GLbyte*);
+extern void __glXDisp_DrawArrays(GLbyte*);
+extern void __glXDisp_Indexubv(GLbyte*);
+extern void __glXDisp_ColorSubTable(GLbyte*);
+extern void __glXDisp_CopyColorSubTable(GLbyte*);
+extern void __glXDisp_ActiveTextureARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord1dvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord1fvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord1ivARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord1svARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord2dvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord2fvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord2ivARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord2svARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord3dvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord3fvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord3ivARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord3svARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord4dvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord4fvARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord4ivARB(GLbyte*);
+extern void __glXDisp_MultiTexCoord4svARB(GLbyte*);
+
+extern int __glXSwapRender(__GLXclientState*, GLbyte*);
+extern int __glXSwapRenderLarge(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreateContext(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreateNewContext(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapDestroyContext(__GLXclientState*, GLbyte*);
+extern int __glXSwapMakeCurrent(__GLXclientState*, GLbyte*);
+extern int __glXSwapMakeContextCurrent(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreatePbuffer(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapDestroyPbuffer(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapGetDrawableAttributes(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapChangeDrawableAttributes(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapIsDirect(__GLXclientState*, GLbyte*);
+extern int __glXSwapQueryVersion(__GLXclientState*, GLbyte*);
+extern int __glXSwapWaitGL(__GLXclientState*, GLbyte*);
+extern int __glXSwapWaitX(__GLXclientState*, GLbyte*);
+extern int __glXSwapCopyContext(__GLXclientState*, GLbyte*);
+extern int __glXSwapSwapBuffers(__GLXclientState*, GLbyte*);
+extern int __glXSwapUseXFont(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreateGLXPixmap(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreatePixmap(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapGetVisualConfigs(__GLXclientState*, GLbyte*);
+extern int __glXSwapDestroyGLXPixmap(__GLXclientState*, GLbyte*);
+extern int __glXSwapVendorPrivate(__GLXclientState*, GLbyte*);
+extern int __glXSwapVendorPrivateWithReply(__GLXclientState*, GLbyte*);
+extern int __glXSwapQueryExtensionsString(__GLXclientState*, GLbyte*);
+extern int __glXSwapQueryServerString(__GLXclientState*, GLbyte*);
+extern int __glXSwapClientInfo(__GLXclientState*, GLbyte*);
+extern int __glXSwapGetFBConfigs(__GLXclientState*, GLbyte*);
+extern int __glXSwapCreateWindow(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapDestroyWindow(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapQueryContext(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDispSwap_NewList(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_EndList(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_DeleteLists(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GenLists(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_FeedbackBuffer(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_SelectBuffer(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_RenderMode(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_Finish(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_PixelStoref(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_PixelStorei(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_ReadPixels(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetBooleanv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetClipPlane(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetDoublev(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetError(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetFloatv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetIntegerv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetLightfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetLightiv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMapdv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMapfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMapiv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMaterialfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMaterialiv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetPixelMapfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetPixelMapuiv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetPixelMapusv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetPolygonStipple(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetString(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexEnvfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexEnviv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexGendv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexGenfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexGeniv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexImage(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexLevelParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetTexLevelParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_IsEnabled(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_IsList(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_Flush(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_AreTexturesResident(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_DeleteTextures(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GenTextures(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_IsTexture(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetColorTable(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetColorTableParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetColorTableParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetConvolutionFilter(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetConvolutionParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetConvolutionParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetSeparableFilter(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetHistogram(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetHistogramParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetHistogramParameteriv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMinmax(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMinmaxParameterfv(__GLXclientState*, GLbyte*);
+extern int __glXDispSwap_GetMinmaxParameteriv(__GLXclientState*, GLbyte*);
+
+extern void __glXDispSwap_CallList(GLbyte*);
+extern void __glXDispSwap_CallLists(GLbyte*);
+extern void __glXDispSwap_ListBase(GLbyte*);
+extern void __glXDispSwap_Begin(GLbyte*);
+extern void __glXDispSwap_Bitmap(GLbyte*);
+extern void __glXDispSwap_Color3bv(GLbyte*);
+extern void __glXDispSwap_Color3dv(GLbyte*);
+extern void __glXDispSwap_Color3fv(GLbyte*);
+extern void __glXDispSwap_Color3iv(GLbyte*);
+extern void __glXDispSwap_Color3sv(GLbyte*);
+extern void __glXDispSwap_Color3ubv(GLbyte*);
+extern void __glXDispSwap_Color3uiv(GLbyte*);
+extern void __glXDispSwap_Color3usv(GLbyte*);
+extern void __glXDispSwap_Color4bv(GLbyte*);
+extern void __glXDispSwap_Color4dv(GLbyte*);
+extern void __glXDispSwap_Color4fv(GLbyte*);
+extern void __glXDispSwap_Color4iv(GLbyte*);
+extern void __glXDispSwap_Color4sv(GLbyte*);
+extern void __glXDispSwap_Color4ubv(GLbyte*);
+extern void __glXDispSwap_Color4uiv(GLbyte*);
+extern void __glXDispSwap_Color4usv(GLbyte*);
+extern void __glXDispSwap_EdgeFlagv(GLbyte*);
+extern void __glXDispSwap_End(GLbyte*);
+extern void __glXDispSwap_Indexdv(GLbyte*);
+extern void __glXDispSwap_Indexfv(GLbyte*);
+extern void __glXDispSwap_Indexiv(GLbyte*);
+extern void __glXDispSwap_Indexsv(GLbyte*);
+extern void __glXDispSwap_Normal3bv(GLbyte*);
+extern void __glXDispSwap_Normal3dv(GLbyte*);
+extern void __glXDispSwap_Normal3fv(GLbyte*);
+extern void __glXDispSwap_Normal3iv(GLbyte*);
+extern void __glXDispSwap_Normal3sv(GLbyte*);
+extern void __glXDispSwap_RasterPos2dv(GLbyte*);
+extern void __glXDispSwap_RasterPos2fv(GLbyte*);
+extern void __glXDispSwap_RasterPos2iv(GLbyte*);
+extern void __glXDispSwap_RasterPos2sv(GLbyte*);
+extern void __glXDispSwap_RasterPos3dv(GLbyte*);
+extern void __glXDispSwap_RasterPos3fv(GLbyte*);
+extern void __glXDispSwap_RasterPos3iv(GLbyte*);
+extern void __glXDispSwap_RasterPos3sv(GLbyte*);
+extern void __glXDispSwap_RasterPos4dv(GLbyte*);
+extern void __glXDispSwap_RasterPos4fv(GLbyte*);
+extern void __glXDispSwap_RasterPos4iv(GLbyte*);
+extern void __glXDispSwap_RasterPos4sv(GLbyte*);
+extern void __glXDispSwap_Rectdv(GLbyte*);
+extern void __glXDispSwap_Rectfv(GLbyte*);
+extern void __glXDispSwap_Rectiv(GLbyte*);
+extern void __glXDispSwap_Rectsv(GLbyte*);
+extern void __glXDispSwap_TexCoord1dv(GLbyte*);
+extern void __glXDispSwap_TexCoord1fv(GLbyte*);
+extern void __glXDispSwap_TexCoord1iv(GLbyte*);
+extern void __glXDispSwap_TexCoord1sv(GLbyte*);
+extern void __glXDispSwap_TexCoord2dv(GLbyte*);
+extern void __glXDispSwap_TexCoord2fv(GLbyte*);
+extern void __glXDispSwap_TexCoord2iv(GLbyte*);
+extern void __glXDispSwap_TexCoord2sv(GLbyte*);
+extern void __glXDispSwap_TexCoord3dv(GLbyte*);
+extern void __glXDispSwap_TexCoord3fv(GLbyte*);
+extern void __glXDispSwap_TexCoord3iv(GLbyte*);
+extern void __glXDispSwap_TexCoord3sv(GLbyte*);
+extern void __glXDispSwap_TexCoord4dv(GLbyte*);
+extern void __glXDispSwap_TexCoord4fv(GLbyte*);
+extern void __glXDispSwap_TexCoord4iv(GLbyte*);
+extern void __glXDispSwap_TexCoord4sv(GLbyte*);
+extern void __glXDispSwap_Vertex2dv(GLbyte*);
+extern void __glXDispSwap_Vertex2fv(GLbyte*);
+extern void __glXDispSwap_Vertex2iv(GLbyte*);
+extern void __glXDispSwap_Vertex2sv(GLbyte*);
+extern void __glXDispSwap_Vertex3dv(GLbyte*);
+extern void __glXDispSwap_Vertex3fv(GLbyte*);
+extern void __glXDispSwap_Vertex3iv(GLbyte*);
+extern void __glXDispSwap_Vertex3sv(GLbyte*);
+extern void __glXDispSwap_Vertex4dv(GLbyte*);
+extern void __glXDispSwap_Vertex4fv(GLbyte*);
+extern void __glXDispSwap_Vertex4iv(GLbyte*);
+extern void __glXDispSwap_Vertex4sv(GLbyte*);
+extern void __glXDispSwap_ClipPlane(GLbyte*);
+extern void __glXDispSwap_ColorMaterial(GLbyte*);
+extern void __glXDispSwap_CullFace(GLbyte*);
+extern void __glXDispSwap_Fogf(GLbyte*);
+extern void __glXDispSwap_Fogfv(GLbyte*);
+extern void __glXDispSwap_Fogi(GLbyte*);
+extern void __glXDispSwap_Fogiv(GLbyte*);
+extern void __glXDispSwap_FrontFace(GLbyte*);
+extern void __glXDispSwap_Hint(GLbyte*);
+extern void __glXDispSwap_Lightf(GLbyte*);
+extern void __glXDispSwap_Lightfv(GLbyte*);
+extern void __glXDispSwap_Lighti(GLbyte*);
+extern void __glXDispSwap_Lightiv(GLbyte*);
+extern void __glXDispSwap_LightModelf(GLbyte*);
+extern void __glXDispSwap_LightModelfv(GLbyte*);
+extern void __glXDispSwap_LightModeli(GLbyte*);
+extern void __glXDispSwap_LightModeliv(GLbyte*);
+extern void __glXDispSwap_LineStipple(GLbyte*);
+extern void __glXDispSwap_LineWidth(GLbyte*);
+extern void __glXDispSwap_Materialf(GLbyte*);
+extern void __glXDispSwap_Materialfv(GLbyte*);
+extern void __glXDispSwap_Materiali(GLbyte*);
+extern void __glXDispSwap_Materialiv(GLbyte*);
+extern void __glXDispSwap_PointSize(GLbyte*);
+extern void __glXDispSwap_PolygonMode(GLbyte*);
+extern void __glXDispSwap_PolygonStipple(GLbyte*);
+extern void __glXDispSwap_Scissor(GLbyte*);
+extern void __glXDispSwap_ShadeModel(GLbyte*);
+extern void __glXDispSwap_TexParameterf(GLbyte*);
+extern void __glXDispSwap_TexParameterfv(GLbyte*);
+extern void __glXDispSwap_TexParameteri(GLbyte*);
+extern void __glXDispSwap_TexParameteriv(GLbyte*);
+extern void __glXDispSwap_TexImage1D(GLbyte*);
+extern void __glXDispSwap_TexImage2D(GLbyte*);
+extern void __glXDispSwap_TexEnvf(GLbyte*);
+extern void __glXDispSwap_TexEnvfv(GLbyte*);
+extern void __glXDispSwap_TexEnvi(GLbyte*);
+extern void __glXDispSwap_TexEnviv(GLbyte*);
+extern void __glXDispSwap_TexGend(GLbyte*);
+extern void __glXDispSwap_TexGendv(GLbyte*);
+extern void __glXDispSwap_TexGenf(GLbyte*);
+extern void __glXDispSwap_TexGenfv(GLbyte*);
+extern void __glXDispSwap_TexGeni(GLbyte*);
+extern void __glXDispSwap_TexGeniv(GLbyte*);
+extern void __glXDispSwap_InitNames(GLbyte*);
+extern void __glXDispSwap_LoadName(GLbyte*);
+extern void __glXDispSwap_PassThrough(GLbyte*);
+extern void __glXDispSwap_PopName(GLbyte*);
+extern void __glXDispSwap_PushName(GLbyte*);
+extern void __glXDispSwap_DrawBuffer(GLbyte*);
+extern void __glXDispSwap_Clear(GLbyte*);
+extern void __glXDispSwap_ClearAccum(GLbyte*);
+extern void __glXDispSwap_ClearIndex(GLbyte*);
+extern void __glXDispSwap_ClearColor(GLbyte*);
+extern void __glXDispSwap_ClearStencil(GLbyte*);
+extern void __glXDispSwap_ClearDepth(GLbyte*);
+extern void __glXDispSwap_StencilMask(GLbyte*);
+extern void __glXDispSwap_ColorMask(GLbyte*);
+extern void __glXDispSwap_DepthMask(GLbyte*);
+extern void __glXDispSwap_IndexMask(GLbyte*);
+extern void __glXDispSwap_Accum(GLbyte*);
+extern void __glXDispSwap_Disable(GLbyte*);
+extern void __glXDispSwap_Enable(GLbyte*);
+extern void __glXDispSwap_PopAttrib(GLbyte*);
+extern void __glXDispSwap_PushAttrib(GLbyte*);
+extern void __glXDispSwap_Map1d(GLbyte*);
+extern void __glXDispSwap_Map1f(GLbyte*);
+extern void __glXDispSwap_Map2d(GLbyte*);
+extern void __glXDispSwap_Map2f(GLbyte*);
+extern void __glXDispSwap_MapGrid1d(GLbyte*);
+extern void __glXDispSwap_MapGrid1f(GLbyte*);
+extern void __glXDispSwap_MapGrid2d(GLbyte*);
+extern void __glXDispSwap_MapGrid2f(GLbyte*);
+extern void __glXDispSwap_EvalCoord1dv(GLbyte*);
+extern void __glXDispSwap_EvalCoord1fv(GLbyte*);
+extern void __glXDispSwap_EvalCoord2dv(GLbyte*);
+extern void __glXDispSwap_EvalCoord2fv(GLbyte*);
+extern void __glXDispSwap_EvalMesh1(GLbyte*);
+extern void __glXDispSwap_EvalPoint1(GLbyte*);
+extern void __glXDispSwap_EvalMesh2(GLbyte*);
+extern void __glXDispSwap_EvalPoint2(GLbyte*);
+extern void __glXDispSwap_AlphaFunc(GLbyte*);
+extern void __glXDispSwap_BlendFunc(GLbyte*);
+extern void __glXDispSwap_LogicOp(GLbyte*);
+extern void __glXDispSwap_StencilFunc(GLbyte*);
+extern void __glXDispSwap_StencilOp(GLbyte*);
+extern void __glXDispSwap_DepthFunc(GLbyte*);
+extern void __glXDispSwap_PixelZoom(GLbyte*);
+extern void __glXDispSwap_PixelTransferf(GLbyte*);
+extern void __glXDispSwap_PixelTransferi(GLbyte*);
+extern void __glXDispSwap_PixelMapfv(GLbyte*);
+extern void __glXDispSwap_PixelMapuiv(GLbyte*);
+extern void __glXDispSwap_PixelMapusv(GLbyte*);
+extern void __glXDispSwap_ReadBuffer(GLbyte*);
+extern void __glXDispSwap_CopyPixels(GLbyte*);
+extern void __glXDispSwap_DrawPixels(GLbyte*);
+extern void __glXDispSwap_DepthRange(GLbyte*);
+extern void __glXDispSwap_Frustum(GLbyte*);
+extern void __glXDispSwap_LoadIdentity(GLbyte*);
+extern void __glXDispSwap_LoadMatrixf(GLbyte*);
+extern void __glXDispSwap_LoadMatrixd(GLbyte*);
+extern void __glXDispSwap_MatrixMode(GLbyte*);
+extern void __glXDispSwap_MultMatrixf(GLbyte*);
+extern void __glXDispSwap_MultMatrixd(GLbyte*);
+extern void __glXDispSwap_Ortho(GLbyte*);
+extern void __glXDispSwap_PopMatrix(GLbyte*);
+extern void __glXDispSwap_PushMatrix(GLbyte*);
+extern void __glXDispSwap_Rotated(GLbyte*);
+extern void __glXDispSwap_Rotatef(GLbyte*);
+extern void __glXDispSwap_Scaled(GLbyte*);
+extern void __glXDispSwap_Scalef(GLbyte*);
+extern void __glXDispSwap_Translated(GLbyte*);
+extern void __glXDispSwap_Translatef(GLbyte*);
+extern void __glXDispSwap_Viewport(GLbyte*);
+extern void __glXDispSwap_PolygonOffset(GLbyte*);
+extern void __glXDispSwap_DrawArrays(GLbyte*);
+extern void __glXDispSwap_Indexubv(GLbyte*);
+extern void __glXDispSwap_ColorSubTable(GLbyte*);
+extern void __glXDispSwap_CopyColorSubTable(GLbyte*);
+extern void __glXDispSwap_ActiveTextureARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord1dvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord1fvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord1ivARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord1svARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord2dvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord2fvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord2ivARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord2svARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord3dvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord3fvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord3ivARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord3svARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord4dvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord4fvARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord4ivARB(GLbyte*);
+extern void __glXDispSwap_MultiTexCoord4svARB(GLbyte*);
+
+extern void __glXDispSwap_TexSubImage1D(GLbyte*);
+extern void __glXDispSwap_TexSubImage2D(GLbyte*);
+extern void __glXDispSwap_ConvolutionFilter1D(GLbyte*);
+extern void __glXDispSwap_ConvolutionFilter2D(GLbyte*);
+extern void __glXDispSwap_ConvolutionParameterfv(GLbyte*);
+extern void __glXDispSwap_ConvolutionParameteriv(GLbyte*);
+extern void __glXDispSwap_CopyConvolutionFilter1D(GLbyte*);
+extern void __glXDispSwap_CopyConvolutionFilter2D(GLbyte*);
+extern void __glXDispSwap_SeparableFilter2D(GLbyte*);
+extern void __glXDispSwap_TexImage3D(GLbyte*);
+extern void __glXDispSwap_TexSubImage3D(GLbyte*);
+extern void __glXDispSwap_DrawArrays(GLbyte*);
+extern void __glXDispSwap_PrioritizeTextures(GLbyte*);
+extern void __glXDispSwap_CopyTexImage1D(GLbyte*);
+extern void __glXDispSwap_CopyTexImage2D(GLbyte*);
+extern void __glXDispSwap_CopyTexSubImage1D(GLbyte*);
+extern void __glXDispSwap_CopyTexSubImage2D(GLbyte*);
+extern void __glXDispSwap_CopyTexSubImage3D(GLbyte*);
+
+#define __GLX_MIN_GLXCMD_OPCODE 1
+#define __GLX_MAX_GLXCMD_OPCODE 20
+#define __GLX_MIN_RENDER_OPCODE 1
+#define __GLX_MAX_RENDER_OPCODE 213
+#define __GLX_MIN_SINGLE_OPCODE 1
+#define __GLX_MAX_SINGLE_OPCODE 159
+#define __GLX_SINGLE_TABLE_SIZE 160
+#define __GLX_RENDER_TABLE_SIZE 214
+
+#define __GLX_MIN_RENDER_OPCODE_EXT 4096
+#define __GLX_MAX_RENDER_OPCODE_EXT 4123
+
+extern __GLXdispatchSingleProcPtr __glXSingleTable[__GLX_SINGLE_TABLE_SIZE];
+extern __GLXdispatchSingleProcPtr __glXSwapSingleTable[__GLX_SINGLE_TABLE_SIZE];
+#endif /* _GLX_g_disptab_h_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exevents.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exevents.h
@@ -0,0 +1,315 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/********************************************************************
+ * Interface of 'exevents.c'
+ */
+
+#ifndef EXEVENTS_H
+#define EXEVENTS_H
+
+#include <X11/extensions/XIproto.h>
+#include "inputstr.h"
+
+/***************************************************************
+ *              Interface available to drivers                 *
+ ***************************************************************/
+
+extern _X_EXPORT int InitProximityClassDeviceStruct(
+	DeviceIntPtr           /* dev */);
+
+extern _X_EXPORT void InitValuatorAxisStruct(
+	DeviceIntPtr           /* dev */,
+	int                    /* axnum */,
+	Atom                   /* label */,
+	int                    /* minval */,
+	int                    /* maxval */,
+	int                    /* resolution */,
+	int                    /* min_res */,
+	int                    /* max_res */);
+
+/* Input device properties */
+extern _X_EXPORT void XIDeleteAllDeviceProperties(
+        DeviceIntPtr            /* device */
+);
+
+extern _X_EXPORT int XIDeleteDeviceProperty(
+        DeviceIntPtr            /* device */,
+        Atom                    /* property */,
+        Bool                    /* fromClient */
+);
+
+extern _X_EXPORT int XIChangeDeviceProperty(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        Atom                    /* type */,
+        int                     /* format*/,
+        int                     /* mode*/,
+        unsigned long           /* len*/,
+        pointer                 /* value*/,
+        Bool                    /* sendevent*/
+        );
+
+extern _X_EXPORT int XIGetDeviceProperty(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        XIPropertyValuePtr*     /* value */
+);
+
+extern _X_EXPORT int XISetDevicePropertyDeletable(
+        DeviceIntPtr            /* dev */,
+        Atom                    /* property */,
+        Bool                    /* deletable */
+);
+
+extern _X_EXPORT long XIRegisterPropertyHandler(
+        DeviceIntPtr         dev,
+        int (*SetProperty) (DeviceIntPtr dev,
+                            Atom property,
+                            XIPropertyValuePtr prop,
+                            BOOL checkonly),
+        int (*GetProperty) (DeviceIntPtr dev,
+                            Atom property),
+        int (*DeleteProperty) (DeviceIntPtr dev,
+                               Atom property)
+);
+
+extern _X_EXPORT void XIUnregisterPropertyHandler(
+        DeviceIntPtr          dev,
+        long                  id
+);
+
+extern _X_EXPORT Atom XIGetKnownProperty(
+        char*                 name
+);
+
+extern _X_EXPORT DeviceIntPtr XIGetDevice(xEvent *ev);
+
+extern _X_EXPORT int XIPropToInt(
+        XIPropertyValuePtr val,
+        int *nelem_return,
+        int **buf_return
+);
+
+extern _X_EXPORT int XIPropToFloat(
+        XIPropertyValuePtr val,
+        int *nelem_return,
+        float **buf_return
+);
+
+/****************************************************************************
+ *                      End of driver interface                             *
+ ****************************************************************************/
+
+
+/**
+ * Attached to the devPrivates of each client. Specifies the version number as
+ * supported by the client.
+ */
+typedef struct _XIClientRec {
+        int major_version;
+        int minor_version;
+} XIClientRec, *XIClientPtr;
+
+
+typedef struct _GrabParameters {
+    int                 grabtype;               /* GRABTYPE_CORE, etc. */
+    unsigned int        ownerEvents;
+    unsigned int        this_device_mode;
+    unsigned int        other_devices_mode;
+    Window              grabWindow;
+    Window              confineTo;
+    Cursor              cursor;
+    unsigned int        modifiers;
+} GrabParameters;
+
+
+extern void
+RegisterOtherDevice (
+	DeviceIntPtr           /* device */);
+
+extern int
+UpdateDeviceState (
+	DeviceIntPtr           /* device */,
+	DeviceEvent*           /*  xE    */);
+
+extern void
+ProcessOtherEvent (
+	InternalEvent*         /* ev */,
+	DeviceIntPtr           /* other */);
+
+extern void
+DeviceFocusEvent(
+	DeviceIntPtr           /* dev */,
+	int                    /* type */,
+	int                    /* mode */,
+	int                    /* detail */,
+	WindowPtr              /* pWin */);
+
+extern int
+CheckGrabValues(
+        ClientPtr              /* client */,
+        GrabParameters*        /* param */);
+
+extern int
+GrabButton(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	DeviceIntPtr           /* modifier_device */,
+	int                    /* button */,
+        GrabParameters*        /* param */,
+        GrabType               /* grabtype */,
+	GrabMask*              /* eventMask */);
+
+extern int
+GrabKey(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	DeviceIntPtr           /* modifier_device */,
+	int                    /* key */,
+        GrabParameters*        /* param */,
+        GrabType               /* grabtype */,
+	GrabMask*              /* eventMask */);
+
+extern int
+GrabWindow(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* type */,
+	GrabParameters*        /* param */,
+	GrabMask*              /* eventMask */);
+
+extern int
+SelectForWindow(
+	DeviceIntPtr           /* dev */,
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	Mask                   /* exclusivemasks */);
+
+extern int
+AddExtensionClient (
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	int                    /* mskidx */);
+
+extern void
+RecalculateDeviceDeliverableEvents(
+	WindowPtr              /* pWin */);
+
+extern int
+InputClientGone(
+	WindowPtr              /* pWin */,
+	XID                    /* id */);
+
+extern int
+SendEvent (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* d */,
+	Window                 /* dest */,
+	Bool                   /* propagate */,
+	xEvent *               /* ev */,
+	Mask                   /* mask */,
+	int                    /* count */);
+
+extern int
+SetButtonMapping (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* nElts */,
+	BYTE *                 /* map */);
+
+extern int
+ChangeKeyMapping(
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	unsigned               /* len */,
+	int                    /* type */,
+	KeyCode                /* firstKeyCode */,
+	CARD8                  /* keyCodes */,
+	CARD8                  /* keySymsPerKeyCode */,
+	KeySym *               /* map */);
+
+extern void
+DeleteWindowFromAnyExtEvents(
+	WindowPtr              /* pWin */,
+	Bool                   /* freeResources */);
+
+extern int
+MaybeSendDeviceMotionNotifyHint (
+	deviceKeyButtonPointer * /* pEvents */,
+	Mask                   /* mask */);
+
+extern void
+CheckDeviceGrabAndHintWindow (
+	WindowPtr              /* pWin */,
+	int                    /* type */,
+	deviceKeyButtonPointer * /* xE */,
+	GrabPtr                /* grab */,
+	ClientPtr              /* client */,
+	Mask                   /* deliveryMask */);
+
+extern void
+MaybeStopDeviceHint(
+	DeviceIntPtr           /* dev */,
+	ClientPtr              /* client */);
+
+extern int
+DeviceEventSuppressForWindow(
+	WindowPtr              /* pWin */,
+	ClientPtr              /* client */,
+	Mask                   /* mask */,
+	int                    /* maskndx */);
+
+extern void
+SendEventToAllWindows(
+        DeviceIntPtr           /* dev */,
+        Mask                   /* mask */,
+        xEvent *               /* ev */,
+        int                    /* count */);
+
+extern _X_HIDDEN void XI2EventSwap(
+        xGenericEvent  *              /* from */,
+        xGenericEvent  *              /* to */);
+
+/* For an event such as MappingNotify which affects client interpretation
+ * of input events sent by device dev, should we notify the client, or
+ * would it merely be irrelevant and confusing? */
+extern int
+XIShouldNotify(ClientPtr client, DeviceIntPtr dev);
+
+extern void
+XISendDeviceChangedEvent(DeviceIntPtr device, DeviceIntPtr master,
+                         DeviceChangedEvent *dce);
+
+extern int
+XISetEventMask(DeviceIntPtr dev, WindowPtr win, ClientPtr client,
+                           unsigned int len, unsigned char* mask);
+
+extern int
+XICheckInvalidMaskBits(unsigned char *mask, int len);
+
+#endif /* EXEVENTS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_reqsize.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_reqsize.h
@@ -0,0 +1,121 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2005
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_REQSIZE_H_ )
+#  define _INDIRECT_REQSIZE_H_
+
+#  if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))) && defined(__ELF__)
+#    define HIDDEN  __attribute__((visibility("hidden")))
+#  else
+#    define HIDDEN
+#  endif
+
+#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
+
+extern PURE HIDDEN int __glXCallListsReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXBitmapReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXFogfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXFogivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXLightfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXLightivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXLightModelfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXLightModelivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMaterialfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMaterialivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPolygonStippleReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexParameterfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexParameterivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexImage1DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexImage2DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexEnvfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexEnvivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexGendvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexGenfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexGenivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMap1dReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMap1fReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMap2dReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXMap2fReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPixelMapfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPixelMapuivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPixelMapusvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDrawPixelsReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDrawArraysReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPrioritizeTexturesReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexSubImage1DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexSubImage2DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXColorTableReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXColorTableParameterfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXColorTableParameterivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXColorSubTableReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXConvolutionFilter1DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXConvolutionFilter2DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXConvolutionParameterfvReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXConvolutionParameterivReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXSeparableFilter2DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexImage3DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXTexSubImage3DReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexImage1DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexImage2DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexImage3DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexSubImage1DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexSubImage2DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexSubImage3DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramStringARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDrawBuffersARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPointParameterfvEXTReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXLoadProgramNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramParameters4dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramParameters4fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXRequestResidentProgramsNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs1dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs1fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs1svNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs2dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs2fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs2svNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs3dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs3fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs3svNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs4dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs4fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs4svNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXVertexAttribs4ubvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPointParameterivNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramNamedParameter4dvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDeleteFramebuffersEXTReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDeleteRenderbuffersEXTReqSize(const GLbyte *pc, Bool swap);
+
+#  undef HIDDEN
+#  undef PURE
+
+#endif /* !defined( _INDIRECT_REQSIZE_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixgrabs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixgrabs.h
@@ -0,0 +1,60 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef DIXGRABS_H
+#define DIXGRABS_H 1
+
+struct _GrabParameters;
+
+extern GrabPtr CreateGrab(
+	int /* client */,
+	DeviceIntPtr /* device */,
+	DeviceIntPtr /* modDevice */,
+	WindowPtr /* window */,
+        GrabType /* grabtype */,
+        GrabMask * /* mask */,
+        struct _GrabParameters * /* param */,
+	int /* type */,
+	KeyCode /* keybut */,
+        WindowPtr /* confineTo */,
+        CursorPtr /* cursor */);
+
+extern _X_EXPORT int DeletePassiveGrab(
+	pointer /* value */,
+	XID /* id */);
+
+extern _X_EXPORT Bool GrabMatchesSecond(
+	GrabPtr /* pFirstGrab */,
+	GrabPtr /* pSecondGrab */,
+	Bool /*ignoreDevice*/);
+
+extern _X_EXPORT int AddPassiveGrabToList(
+	ClientPtr /* client */,
+	GrabPtr /* pGrab */);
+
+extern _X_EXPORT Bool DeletePassiveGrabFromList(
+	GrabPtr /* pMinuendGrab */);
+
+#endif /* DIXGRABS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaawrap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaawrap.h
@@ -0,0 +1,79 @@
+
+#define XAA_SCREEN_PROLOGUE(pScreen, field)\
+  ((pScreen)->field = \
+   ((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->field)
+
+#define XAA_SCREEN_EPILOGUE(pScreen, field, wrapper)\
+    ((pScreen)->field = wrapper)
+
+
+#define XAA_GC_FUNC_PROLOGUE(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    (pGC)->funcs = pGCPriv->wrapFuncs;\
+    if(pGCPriv->flags)\
+	(pGC)->ops = pGCPriv->wrapOps
+
+#define XAA_GC_FUNC_EPILOGUE(pGC)\
+    pGCPriv->wrapFuncs = (pGC)->funcs;\
+    (pGC)->funcs = &XAAGCFuncs;\
+    if(pGCPriv->flags) {\
+	pGCPriv->wrapOps = (pGC)->ops;\
+	(pGC)->ops = (pGCPriv->flags & OPS_ARE_ACCEL) ? pGCPriv->XAAOps :\
+				&XAAPixmapOps;\
+    }
+
+
+#define XAA_GC_OP_PROLOGUE(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    GCFuncs *oldFuncs = pGC->funcs;\
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps
+
+#define XAA_GC_OP_PROLOGUE_WITH_RETURN(pGC)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    GCFuncs *oldFuncs = pGC->funcs;\
+    if(!RegionNumRects(pGC->pCompositeClip)) return; \
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps
+
+    
+#define XAA_GC_OP_EPILOGUE(pGC)\
+    pGCPriv->wrapOps = pGC->ops;\
+    pGC->funcs = oldFuncs;\
+    pGC->ops   = pGCPriv->XAAOps
+
+
+#define XAA_PIXMAP_OP_PROLOGUE(pGC, pDraw)\
+    XAAGCPtr pGCPriv = (XAAGCPtr)dixLookupPrivate(&(pGC)->devPrivates, XAAGetGCKey()); \
+    XAAPixmapPtr pixPriv = XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pDraw));\
+    GCFuncs *oldFuncs = pGC->funcs;\
+    pGC->funcs = pGCPriv->wrapFuncs;\
+    pGC->ops = pGCPriv->wrapOps; \
+    SYNC_CHECK(pGC)
+    
+#define XAA_PIXMAP_OP_EPILOGUE(pGC)\
+    pGCPriv->wrapOps = pGC->ops;\
+    pGC->funcs = oldFuncs;\
+    pGC->ops   = &XAAPixmapOps;\
+    pixPriv->flags |= DIRTY
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#define XAA_RENDER_PROLOGUE(pScreen,field)\
+    (GetPictureScreen(pScreen)->field = \
+     ((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->field)
+
+#define XAA_RENDER_EPILOGUE(pScreen, field, wrapper)\
+    (GetPictureScreen(pScreen)->field = wrapper)
+
+/* This also works fine for drawables */
+
+#define SYNC_CHECK(pGC) {\
+     XAAInfoRecPtr infoRec =\
+((XAAScreenPtr)dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec;	\
+    if(infoRec->NeedToSync) {\
+	(*infoRec->Sync)(infoRec->pScrn);\
+	infoRec->NeedToSync = FALSE;\
+    }}
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/BT.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/BT.h
@@ -0,0 +1,32 @@
+
+#include "xf86RamDac.h"
+
+extern _X_EXPORT RamDacHelperRecPtr BTramdacProbe(ScrnInfoPtr pScrn, RamDacSupportedInfoRecPtr ramdacs);
+extern _X_EXPORT void BTramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void BTramdacSetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr RamDacRegRec);
+
+#define ATT20C504_RAMDAC 	(VENDOR_BT << 16) | 0x00
+#define ATT20C505_RAMDAC 	(VENDOR_BT << 16) | 0x01
+#define BT485_RAMDAC		(VENDOR_BT << 16) | 0x02
+
+/*
+ * BT registers
+ */
+
+#define BT_WRITE_ADDR		0x00
+#define BT_RAMDAC_DATA		0x01	
+#define BT_PIXEL_MASK		0x02
+#define BT_READ_ADDR		0x03
+#define BT_CURS_WR_ADDR		0x04
+#define BT_CURS_DATA		0x05
+#define BT_COMMAND_REG_0	0x06
+#define BT_CURS_RD_ADDR		0x07
+#define BT_COMMAND_REG_1	0x08
+#define BT_COMMAND_REG_2	0x09
+#define BT_STATUS_REG		0x0A
+#define BT_CURS_RAM_DATA	0x0B
+#define BT_CURS_X_LOW		0x0C
+#define BT_CURS_X_HIGH		0x0D
+#define BT_CURS_Y_LOW		0x0E
+#define BT_CURS_Y_HIGH		0x0F
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setmmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setmmap.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETMMAP_H
+#define SETMMAP_H 1
+
+int SProcXSetDeviceModifierMapping(ClientPtr	/* client */
+    );
+
+int ProcXSetDeviceModifierMapping(ClientPtr	/* client */
+    );
+
+void SRepXSetDeviceModifierMapping(ClientPtr /* client */ ,
+				   int /* size */ ,
+				   xSetDeviceModifierMappingReply *	/* rep */
+    );
+
+#endif /* SETMMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xfixes.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xfixes.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright © 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XFIXES_H_
+#define _XFIXES_H_
+
+#include "resource.h"
+
+extern _X_EXPORT RESTYPE RegionResType;
+extern _X_EXPORT int XFixesErrorBase;
+
+#define VERIFY_REGION(pRegion, rid, client, mode)			\
+    do {								\
+	int err;							\
+	err = dixLookupResourceByType((pointer *) &pRegion, rid,	\
+				      RegionResType, client, mode);	\
+	if (err != Success) {						\
+	    client->errorValue = rid;					\
+	    return err;							\
+	}								\
+    } while (0)
+
+#define VERIFY_REGION_OR_NONE(pRegion, rid, client, mode) { \
+    pRegion = 0; \
+    if (rid) VERIFY_REGION(pRegion, rid, client, mode); \
+}
+
+extern _X_EXPORT RegionPtr
+XFixesRegionCopy (RegionPtr pRegion);
+
+
+#endif /* _XFIXES_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinput.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinput.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Kevin E. Martin <kem@redhat.com>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * This file provides access to:
+ * - global variables available to all hw/dmx routines, and
+ * - enumerations and typedefs needed by input routines in hw/dmx (and
+ *   hw/dmx/input).
+ *
+ * The goal is that no files in hw/dmx should include header files from
+ * hw/dmx/input -- the interface defined here should be the only
+ * interface exported to the hw/dmx layer.  \see input/dmxinputinit.c.
+ */
+ 
+#ifndef DMXINPUT_H
+#define DMXINPUT_H
+
+/** Maximum number of file descriptors for SIGIO handling */
+#define DMX_MAX_SIGIO_FDS 4
+
+struct _DMXInputInfo;
+
+/** Reason why window layout was updated. */
+typedef enum {
+    DMX_UPDATE_REALIZE,         /**< Window realized        */
+    DMX_UPDATE_UNREALIZE,       /**< Window unrealized      */
+    DMX_UPDATE_RESTACK,         /**< Stacking order changed */
+    DMX_UPDATE_COPY,            /**< Window copied          */
+    DMX_UPDATE_RESIZE,          /**< Window resized         */
+    DMX_UPDATE_REPARENT         /**< Window reparented      */
+} DMXUpdateType;
+
+typedef void (*ProcessInputEventsProc)(struct _DMXInputInfo *);
+typedef void (*UpdateWindowInfoProc)(struct _DMXInputInfo *,
+                                     DMXUpdateType, WindowPtr);
+
+/** An opaque structure that is only exposed in the dmx/input layer. */
+typedef struct _DMXLocalInputInfo *DMXLocalInputInfoPtr;
+
+/** State of the SIGIO engine */
+typedef enum {
+    DMX_NOSIGIO = 0,            /**< Device does not use SIGIO at all. */
+    DMX_USESIGIO,               /**< Device can use SIGIO, but is not
+                                 * (e.g., because the VT is switch
+                                 * away). */
+    DMX_ACTIVESIGIO             /**< Device is currently using SIGIO. */
+} dmxSigioState;
+
+/** DMXInputInfo is typedef'd in \a dmx.h so that all routines can have
+ * access to the global pointers.  However, the elements are only
+ * available to input-related routines. */
+struct _DMXInputInfo {
+    const char              *name; /**< Name of input display or device
+                                    * (from command line or config
+                                    * file)  */
+    Bool                    freename; /**< If true, free name on destroy */
+    Bool                    detached; /**< If true, input screen is detached */
+    int                     inputIdx; /**< Index into #dmxInputs global */
+    int                     scrnIdx;  /**< Index into #dmxScreens global */
+    Bool                    core;  /**< If True, initialize these
+                                    * devices as devices that send core
+                                    * events */
+    Bool                    console; /**< True if console and backend
+                                      * input share the same backend
+                                      * display  */
+
+    Bool                    windows; /**< True if window outlines are
+                                      * draw in console */
+
+    ProcessInputEventsProc  processInputEvents;
+    UpdateWindowInfoProc    updateWindowInfo;
+
+                                /* Local input information */
+    dmxSigioState           sigioState;    /**< Current stat */
+    int                     sigioFdCount;  /**< Number of fds in use */
+    int                     sigioFd[DMX_MAX_SIGIO_FDS];    /**< List of fds */
+    Bool                    sigioAdded[DMX_MAX_SIGIO_FDS]; /**< Active fds */
+
+    
+    /** True if a VT switch is pending, but has not yet happened. */
+    int                     vt_switch_pending;
+
+    /** True if a VT switch has happened. */
+    int                     vt_switched;
+
+    /** Number of devices handled in this _DMXInputInfo structure. */
+    int                     numDevs;
+
+    /** List of actual input devices.  Each _DMXInputInfo structure can
+     * refer to more than one device.  For example, the keyboard and the
+     * pointer of a backend display; or all of the XInput extension
+     * devices on a backend display. */
+    DMXLocalInputInfoPtr    *devs;
+
+    char                    *keycodes; /**< XKB keycodes from command line */
+    char                    *symbols;  /**< XKB symbols from command line */
+    char                    *geometry; /**< XKB geometry from command line */
+};
+
+extern int                  dmxNumInputs; /**< Number of #dmxInputs */
+extern DMXInputInfo         *dmxInputs;   /**< List of inputs */
+
+extern void dmxInputInit(DMXInputInfo *dmxInput);
+extern void dmxInputReInit(DMXInputInfo *dmxInput);
+extern void dmxInputLateReInit(DMXInputInfo *dmxInput);
+extern void dmxInputFree(DMXInputInfo *dmxInput);
+extern void dmxInputLogDevices(void);
+extern void dmxUpdateWindowInfo(DMXUpdateType type, WindowPtr pWindow);
+
+/* These functions are defined in input/dmxeq.c */
+extern void dmxeqSwitchScreen(DeviceIntPtr pDev, ScreenPtr pScreen, Bool fromDIX);
+
+/* This type is used in input/dmxevents.c.  Also, these functions are
+ * defined in input/dmxevents.c */
+typedef enum {
+    DMX_NO_BLOCK = 0,
+    DMX_BLOCK    = 1
+} DMXBlockType;
+
+extern void          dmxGetGlobalPosition(int *x, int *y);
+extern DMXScreenInfo *dmxFindFirstScreen(int x, int y);
+extern void          dmxCoreMotion(DevicePtr pDev, int x, int y, int delta,
+                                   DMXBlockType block);
+
+/* Support for dynamic addition of inputs.  This functions is defined in
+ * config/dmxconfig.c */
+extern DMXInputInfo *dmxConfigAddInput(const char *name, int core);
+#endif /* DMXINPUT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86x86emu.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86x86emu.h
@@ -0,0 +1,54 @@
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef XF86X86EMU_H_
+#define XF86X86EMU_H_
+#include <x86emu.h>
+
+#define M _X86EMU_env
+
+#define X86_EAX M.x86.R_EAX
+#define X86_EBX M.x86.R_EBX
+#define X86_ECX M.x86.R_ECX
+#define X86_EDX M.x86.R_EDX
+#define X86_ESI M.x86.R_ESI
+#define X86_EDI M.x86.R_EDI
+#define X86_EBP M.x86.R_EBP
+#define X86_EIP M.x86.R_EIP
+#define X86_ESP M.x86.R_ESP
+#define X86_EFLAGS M.x86.R_EFLG
+
+#define X86_FLAGS M.x86.R_FLG
+#define X86_AX M.x86.R_AX
+#define X86_BX M.x86.R_BX
+#define X86_CX M.x86.R_CX
+#define X86_DX M.x86.R_DX
+#define X86_SI M.x86.R_SI
+#define X86_DI M.x86.R_DI
+#define X86_BP M.x86.R_BP
+#define X86_IP M.x86.R_IP
+#define X86_SP M.x86.R_SP
+#define X86_CS M.x86.R_CS
+#define X86_DS M.x86.R_DS
+#define X86_ES M.x86.R_ES
+#define X86_SS M.x86.R_SS
+#define X86_FS M.x86.R_FS
+#define X86_GS M.x86.R_GS
+
+#define X86_AL M.x86.R_AL
+#define X86_BL M.x86.R_BL
+#define X86_CL M.x86.R_CL
+#define X86_DL M.x86.R_DL
+
+#define X86_AH M.x86.R_AH
+#define X86_BH M.x86.R_BH
+#define X86_CH M.x86.R_CH
+#define X86_DH M.x86.R_DH
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx_glxvisuals.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx_glxvisuals.h
@@ -0,0 +1,59 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLXVISUALS_H
+#define _GLXVISUALS_H
+
+#include <GL/glxint.h>
+
+/** GLX Visual private area. */
+typedef struct {
+    int x_visual_depth;
+    int x_visual_class;
+} dmxGlxVisualPrivate;
+
+__GLXvisualConfig *GetGLXVisualConfigs(Display *dpy,
+				       int screen,
+				       int *nconfigs);
+
+__GLXFBConfig *GetGLXFBConfigs(Display *dpy,
+			       int glxMajorOpcode,
+			       int *nconfigs);
+
+__GLXvisualConfig *GetGLXVisualConfigsFromFBConfigs(__GLXFBConfig *fbconfigs, 
+						    int nfbconfigs, 
+						    XVisualInfo *visuals,
+						    int nvisuals,
+						    __GLXvisualConfig
+						    *glxConfigs,
+						    int nGlxConfigs,
+						    int *nconfigs);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixfont.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixfont.h
@@ -0,0 +1,184 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXFONT_H
+#define DIXFONT_H 1
+
+#include "dix.h"
+#include <X11/fonts/font.h>
+#include "closure.h"
+#include <X11/fonts/fontstruct.h>
+
+#define NullDIXFontProp ((DIXFontPropPtr)0)
+
+typedef struct _DIXFontProp *DIXFontPropPtr;
+
+extern _X_EXPORT Bool SetDefaultFont(char * /*defaultfontname*/);
+
+extern _X_EXPORT void QueueFontWakeup(FontPathElementPtr /*fpe*/);
+
+extern _X_EXPORT void RemoveFontWakeup(FontPathElementPtr /*fpe*/);
+
+extern _X_EXPORT void FontWakeup(pointer /*data*/,
+		       int /*count*/,
+		       pointer /*LastSelectMask*/);
+
+extern _X_EXPORT int OpenFont(ClientPtr /*client*/,
+		    XID /*fid*/,
+		    Mask /*flags*/,
+		    unsigned /*lenfname*/,
+		    char * /*pfontname*/);
+
+extern _X_EXPORT int CloseFont(pointer /*pfont*/,
+		     XID /*fid*/);
+
+typedef struct _xQueryFontReply *xQueryFontReplyPtr;
+
+extern _X_EXPORT void QueryFont(FontPtr /*pFont*/,
+		      xQueryFontReplyPtr /*pReply*/,
+		      int /*nProtoCCIStructs*/);
+
+extern _X_EXPORT int ListFonts(ClientPtr /*client*/,
+		     unsigned char * /*pattern*/,
+		     unsigned int /*length*/,
+		     unsigned int /*max_names*/);
+
+extern _X_EXPORT int
+doListFontsWithInfo(ClientPtr /*client*/,
+		    LFWIclosurePtr /*c*/);
+
+extern _X_EXPORT int doPolyText(ClientPtr /*client*/,
+		      PTclosurePtr /*c*/
+);
+
+extern _X_EXPORT int PolyText(ClientPtr /*client*/,
+		    DrawablePtr /*pDraw*/,
+		    GCPtr /*pGC*/,
+		    unsigned char * /*pElt*/,
+		    unsigned char * /*endReq*/,
+		    int /*xorg*/,
+		    int /*yorg*/,
+		    int /*reqType*/,
+		    XID /*did*/);
+
+extern _X_EXPORT int doImageText(ClientPtr /*client*/,
+		       ITclosurePtr /*c*/);
+
+extern _X_EXPORT int ImageText(ClientPtr /*client*/,
+		     DrawablePtr /*pDraw*/,
+		     GCPtr /*pGC*/,
+		     int /*nChars*/,
+		     unsigned char * /*data*/,
+		     int /*xorg*/,
+		     int /*yorg*/,
+		     int /*reqType*/,
+		     XID /*did*/);
+
+extern _X_EXPORT int SetFontPath(ClientPtr /*client*/,
+		       int /*npaths*/,
+		       unsigned char * /*paths*/);
+
+extern _X_EXPORT int SetDefaultFontPath(char * /*path*/);
+
+extern _X_EXPORT int GetFontPath(ClientPtr client,
+		       int *count,
+		       int *length,
+		       unsigned char **result);
+
+extern _X_EXPORT void DeleteClientFontStuff(ClientPtr /*client*/);
+
+/* Quartz support on Mac OS X pulls in the QuickDraw
+   framework whose InitFonts function conflicts here. */
+#ifdef __APPLE__
+#define InitFonts Darwin_X_InitFonts
+#endif
+extern _X_EXPORT void InitFonts(void);
+
+extern _X_EXPORT void FreeFonts(void);
+
+extern _X_EXPORT FontPtr find_old_font(XID /*id*/);
+
+extern _X_EXPORT void GetGlyphs(FontPtr     /*font*/,
+		      unsigned long /*count*/,
+		      unsigned char * /*chars*/,
+		      FontEncoding /*fontEncoding*/,
+		      unsigned long * /*glyphcount*/,
+		      CharInfoPtr * /*glyphs*/);
+
+extern _X_EXPORT void QueryGlyphExtents(FontPtr     /*pFont*/,
+			      CharInfoPtr * /*charinfo*/,
+			      unsigned long /*count*/,
+			      ExtentInfoPtr /*info*/);
+
+extern _X_EXPORT Bool QueryTextExtents(FontPtr     /*pFont*/,
+			     unsigned long /*count*/,
+			     unsigned char * /*chars*/,
+			     ExtentInfoPtr /*info*/);
+
+extern _X_EXPORT Bool ParseGlyphCachingMode(char * /*str*/);
+
+extern _X_EXPORT void InitGlyphCaching(void);
+
+extern _X_EXPORT void SetGlyphCachingMode(int /*newmode*/);
+
+extern _X_EXPORT void register_fpe_functions(void);
+
+/*
+ * libXfont stubs.
+ */
+extern _X_EXPORT int client_auth_generation(ClientPtr client);
+
+extern _X_EXPORT void DeleteFontClientID(Font id);
+
+extern _X_EXPORT FontResolutionPtr GetClientResolutions(int *num);
+
+extern _X_EXPORT int GetDefaultPointSize(void);
+
+extern _X_EXPORT Font GetNewFontClientID(void);
+
+extern _X_EXPORT int init_fs_handlers(FontPathElementPtr fpe,
+				      BlockHandlerProcPtr block_handler);
+
+extern _X_EXPORT int RegisterFPEFunctions(NameCheckFunc name_func,
+					  InitFpeFunc init_func,
+					  FreeFpeFunc free_func,
+					  ResetFpeFunc reset_func,
+					  OpenFontFunc open_func,
+					  CloseFontFunc close_func,
+					  ListFontsFunc list_func,
+					  StartLfwiFunc start_lfwi_func,
+					  NextLfwiFunc next_lfwi_func,
+					  WakeupFpeFunc wakeup_func,
+					  ClientDiedFunc client_died,
+					  LoadGlyphsFunc load_glyphs,
+					  StartLaFunc start_list_alias_func,
+					  NextLaFunc next_list_alias_func,
+					  SetPathFunc set_path_func);
+
+extern _X_EXPORT void remove_fs_handlers(FontPathElementPtr fpe,
+					 BlockHandlerProcPtr blockHandler,
+					 Bool all);
+
+extern _X_EXPORT int StoreFontClientFont(FontPtr pfont, Font id);
+
+#endif				/* DIXFONT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiselectev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiselectev.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XISELECTEVENTS_H
+#define XISELECTEVENTS_H 1
+
+int SProcXISelectEvents(ClientPtr client);
+int ProcXISelectEvents(ClientPtr client);
+int SProcXIGetSelectedEvents(ClientPtr client);
+int ProcXIGetSelectedEvents(ClientPtr client);
+void SRepXIGetSelectedEvents(ClientPtr client,
+                             int len, xXIGetSelectedEventsReply *rep);
+
+#endif /* _XISELECTEVENTS_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/regionstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/regionstr.h
@@ -0,0 +1,370 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef REGIONSTRUCT_H
+#define REGIONSTRUCT_H
+
+typedef struct pixman_region16 RegionRec, *RegionPtr;
+
+#include "miscstruct.h"
+
+/* Return values from RectIn() */
+
+#define rgnOUT 0
+#define rgnIN  1
+#define rgnPART 2
+
+#define NullRegion ((RegionPtr)0)
+
+/*
+ *   clip region
+ */
+
+typedef struct pixman_region16_data RegDataRec, *RegDataPtr;
+
+extern _X_EXPORT BoxRec RegionEmptyBox;
+extern _X_EXPORT RegDataRec RegionEmptyData;
+extern _X_EXPORT RegDataRec RegionBrokenData;
+static inline Bool RegionNil(RegionPtr reg) {
+    return ((reg)->data && !(reg)->data->numRects);
+}
+
+/* not a region */
+
+static inline Bool RegionNar(RegionPtr reg) {
+    return ((reg)->data == &RegionBrokenData);
+}
+
+static inline int RegionNumRects(RegionPtr reg) {
+    return ((reg)->data ? (reg)->data->numRects : 1);
+}
+
+static inline int RegionSize(RegionPtr reg) {
+    return ((reg)->data ? (reg)->data->size : 0);
+}
+
+static inline BoxPtr RegionRects(RegionPtr reg) {
+    return ((reg)->data ? (BoxPtr)((reg)->data + 1) : &(reg)->extents);
+}
+
+static inline BoxPtr RegionBoxptr(RegionPtr reg) {
+    return ((BoxPtr)((reg)->data + 1));
+}
+
+static inline BoxPtr RegionBox(RegionPtr reg, int i) {
+    return (&RegionBoxptr(reg)[i]);
+}
+
+static inline BoxPtr RegionTop(RegionPtr reg) {
+    return RegionBox(reg, (reg)->data->numRects);
+}
+
+static inline BoxPtr RegionEnd(RegionPtr reg) {
+    return RegionBox(reg, (reg)->data->numRects - 1);
+}
+
+static inline size_t RegionSizeof(int n) {
+    return (sizeof(RegDataRec) + ((n) * sizeof(BoxRec)));
+}
+
+static inline void RegionInit(RegionPtr _pReg, BoxPtr _rect, int _size)
+{
+    if ((_rect) != NULL)
+    {
+        (_pReg)->extents = *(_rect);
+        (_pReg)->data = (RegDataPtr)NULL;
+    }
+    else
+    {
+        (_pReg)->extents = RegionEmptyBox;
+        if (((_size) > 1) && ((_pReg)->data =
+			      (RegDataPtr)malloc(RegionSizeof(_size))))
+        {
+            (_pReg)->data->size = (_size);
+            (_pReg)->data->numRects = 0;
+        }
+        else
+            (_pReg)->data = &RegionEmptyData;
+    }
+}
+
+static inline void RegionUninit(RegionPtr _pReg)
+{
+    if ((_pReg)->data && (_pReg)->data->size) {
+	free((_pReg)->data);
+	(_pReg)->data = NULL;
+    }
+}
+
+static inline void RegionReset(RegionPtr _pReg, BoxPtr _pBox)
+{
+    (_pReg)->extents = *(_pBox);
+    RegionUninit(_pReg);
+    (_pReg)->data = (RegDataPtr)NULL;
+}
+
+static inline Bool RegionNotEmpty(RegionPtr _pReg) {
+    return !RegionNil(_pReg);
+}
+
+static inline Bool RegionBroken(RegionPtr _pReg) {
+    return RegionNar(_pReg);
+}
+
+static inline void RegionEmpty(RegionPtr _pReg)
+{
+    RegionUninit(_pReg);
+    (_pReg)->extents.x2 = (_pReg)->extents.x1;
+    (_pReg)->extents.y2 = (_pReg)->extents.y1;
+    (_pReg)->data = &RegionEmptyData;
+}
+
+static inline BoxPtr RegionExtents(RegionPtr _pReg)
+{
+    return (&(_pReg)->extents);
+}
+
+static inline void RegionNull(RegionPtr _pReg)
+{
+    (_pReg)->extents = RegionEmptyBox;
+    (_pReg)->data = &RegionEmptyData;
+}
+
+extern _X_EXPORT void InitRegions(void);
+
+extern _X_EXPORT RegionPtr RegionCreate(
+    BoxPtr /*rect*/,
+    int /*size*/);
+
+extern _X_EXPORT void RegionDestroy(
+    RegionPtr /*pReg*/);
+
+static inline Bool
+RegionCopy(RegionPtr dst, RegionPtr src)
+{
+    return pixman_region_copy (dst, src);
+}
+
+static inline Bool
+RegionIntersect(
+    RegionPtr	newReg,     /* destination Region */
+    RegionPtr	reg1,
+    RegionPtr	reg2        /* source regions     */
+    )
+{
+    return pixman_region_intersect (newReg, reg1, reg2);
+}
+
+static inline Bool
+RegionUnion(
+    RegionPtr	newReg,          /* destination Region */
+    RegionPtr	reg1,
+    RegionPtr	reg2             /* source regions     */
+    )
+{
+    return pixman_region_union (newReg, reg1, reg2);
+}
+
+extern _X_EXPORT Bool RegionAppend(
+    RegionPtr /*dstrgn*/,
+    RegionPtr /*rgn*/);
+
+extern _X_EXPORT Bool RegionValidate(
+    RegionPtr /*badreg*/,
+    Bool * /*pOverlap*/);
+
+extern _X_EXPORT RegionPtr RegionFromRects(
+    int /*nrects*/,
+    xRectanglePtr /*prect*/,
+    int /*ctype*/);
+
+/*-
+ *-----------------------------------------------------------------------
+ * Subtract --
+ *	Subtract regS from regM and leave the result in regD.
+ *	S stands for subtrahend, M for minuend and D for difference.
+ *
+ * Results:
+ *	TRUE if successful.
+ *
+ * Side Effects:
+ *	regD is overwritten.
+ *
+ *-----------------------------------------------------------------------
+ */
+static inline Bool
+RegionSubtract(RegionPtr regD, RegionPtr regM, RegionPtr regS)
+{
+    return pixman_region_subtract (regD, regM, regS);
+}
+
+/*-
+ *-----------------------------------------------------------------------
+ * Inverse --
+ *	Take a region and a box and return a region that is everything
+ *	in the box but not in the region. The careful reader will note
+ *	that this is the same as subtracting the region from the box...
+ *
+ * Results:
+ *	TRUE.
+ *
+ * Side Effects:
+ *	newReg is overwritten.
+ *
+ *-----------------------------------------------------------------------
+ */
+
+static inline Bool
+RegionInverse(
+    RegionPtr	  newReg,       /* Destination region */
+    RegionPtr	  reg1,         /* Region to invert */
+    BoxPtr	  invRect	/* Bounding box for inversion */
+    )
+{
+    return pixman_region_inverse (newReg, reg1, invRect);
+}
+
+static inline int
+RegionContainsRect(RegionPtr region, BoxPtr prect)
+{
+    return pixman_region_contains_rectangle (region, prect);
+}
+
+/* TranslateRegion(pReg, x, y)
+   translates in place
+*/
+
+static inline void
+RegionTranslate(RegionPtr pReg, int x, int y)
+{
+    pixman_region_translate (pReg, x, y);
+}
+
+extern _X_EXPORT Bool RegionBreak(
+    RegionPtr /*pReg*/);
+
+static inline Bool
+RegionContainsPoint(
+    RegionPtr pReg,
+    int x,
+    int y,
+    BoxPtr box      /* "return" value */
+    )
+{
+    return pixman_region_contains_point (pReg, x, y, box);
+}
+
+static inline Bool
+RegionEqual(RegionPtr reg1, RegionPtr reg2)
+{
+    return pixman_region_equal (reg1, reg2);
+}
+
+extern _X_EXPORT Bool RegionRectAlloc(
+    RegionPtr /*pRgn*/,
+    int /*n*/
+);
+
+#ifdef DEBUG
+extern _X_EXPORT Bool RegionIsValid(
+    RegionPtr /*prgn*/
+);
+#endif
+
+extern _X_EXPORT void RegionPrint(
+    RegionPtr /*pReg*/);
+
+extern _X_EXPORT int RegionClipSpans(
+    RegionPtr /*prgnDst*/,
+    DDXPointPtr /*ppt*/,
+    int * /*pwidth*/,
+    int /*nspans*/,
+    DDXPointPtr /*pptNew*/,
+    int * /*pwidthNew*/,
+    int /*fSorted*/
+);
+
+#define INCLUDE_LEGACY_REGION_DEFINES
+#ifdef INCLUDE_LEGACY_REGION_DEFINES
+
+#define REGION_NIL				RegionNil
+#define REGION_NAR				RegionNar
+#define REGION_NUM_RECTS			RegionNumRects
+#define REGION_SIZE				RegionSize
+#define REGION_RECTS				RegionRects
+#define REGION_BOXPTR				RegionBoxptr
+#define REGION_BOX				RegionBox
+#define REGION_TOP				RegionTop
+#define REGION_END				RegionEnd
+#define REGION_SZOF				RegionSizeof
+#define BITMAP_TO_REGION			BitmapToRegion
+#define REGION_CREATE(pScreen, r, s)		RegionCreate(r,s)
+#define REGION_COPY(pScreen, d, r)		RegionCopy(d, r)
+#define REGION_DESTROY(pScreen, r)		RegionDestroy(r)
+#define REGION_INTERSECT(pScreen, res, r1, r2)	RegionIntersect(res, r1, r2)
+#define REGION_UNION(pScreen, res, r1, r2)	RegionUnion(res, r1, r2)
+#define REGION_SUBTRACT(pScreen, res, r1, r2)	RegionSubtract(res, r1, r2)
+#define REGION_INVERSE(pScreen, n, r, b)	RegionInverse(n, r, b)
+#define REGION_TRANSLATE(pScreen, r, x, y)	RegionTranslate(r, x, y)
+#define RECT_IN_REGION(pScreen, r, b) 		RegionContainsRect(r, b)
+#define POINT_IN_REGION(pScreen, r, x, y, b) 	RegionContainsPoint(r, x, y, b)
+#define REGION_EQUAL(pScreen, r1, r2)		RegionEqual(r1, r2)
+#define REGION_APPEND(pScreen, d, r)		RegionAppend(d, r)
+#define REGION_VALIDATE(pScreen, r, o)		RegionValidate(r, o)
+#define RECTS_TO_REGION(pScreen, n, r, c)	RegionFromRects(n, r, c)
+#define REGION_BREAK(pScreen, r)		RegionBreak(r)
+#define REGION_INIT(pScreen, r, b, s)		RegionInit(r, b, s)
+#define REGION_UNINIT(pScreen, r)		RegionUninit(r)
+#define REGION_RESET(pScreen, r, b)		RegionReset(r, b)
+#define REGION_NOTEMPTY(pScreen, r)		RegionNotEmpty(r)
+#define REGION_BROKEN(pScreen, r)		RegionBroken(r)
+#define REGION_EMPTY(pScreen, r)		RegionEmpty(r)
+#define REGION_EXTENTS(pScreen, r)		RegionExtents(r)
+#define REGION_NULL(pScreen, r)			RegionNull(r)
+
+#endif /* INCLUDE_LEGACY_REGION_DEFINES */
+#endif /* REGIONSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/TI.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/TI.h
@@ -0,0 +1,91 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT unsigned long TIramdacCalculateMNPForClock(unsigned long RefClock,
+    unsigned long ReqClock, char IsPixClock, unsigned long MinClock,
+    unsigned long MaxClock, unsigned long *rM, unsigned long *rN,
+    unsigned long *rP);
+extern _X_EXPORT RamDacHelperRecPtr TIramdacProbe(ScrnInfoPtr pScrn, RamDacSupportedInfoRecPtr ramdacs);
+extern _X_EXPORT void TIramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3026SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdac3030SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void TIramdacHWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void TIramdacLoadPalette( ScrnInfoPtr pScrn, int numColors, int *indices,
+    LOCO *colors, VisualPtr pVisual);
+
+typedef void TIramdacLoadPaletteProc(ScrnInfoPtr, int, int *, LOCO *,
+    VisualPtr);
+extern _X_EXPORT TIramdacLoadPaletteProc *TIramdacLoadPaletteWeak(void);
+
+#define TI3030_RAMDAC		(VENDOR_TI << 16) | 0x00
+#define TI3026_RAMDAC		(VENDOR_TI << 16) | 0x01
+
+/*
+ * TI Ramdac registers
+ */
+
+#define TIDAC_rev		0x01
+#define TIDAC_ind_curs_ctrl	0x06
+#define TIDAC_byte_router_ctrl	0x07
+#define TIDAC_latch_ctrl	0x0f
+#define TIDAC_true_color_ctrl	0x18
+#define TIDAC_multiplex_ctrl	0x19
+#define TIDAC_clock_select	0x1a
+#define TIDAC_palette_page	0x1c
+#define TIDAC_general_ctrl	0x1d
+#define TIDAC_misc_ctrl		0x1e
+#define TIDAC_pll_addr		0x2c
+#define TIDAC_pll_pixel_data	0x2d
+#define TIDAC_pll_memory_data	0x2e
+#define TIDAC_pll_loop_data	0x2f
+#define TIDAC_key_over_low	0x30
+#define TIDAC_key_over_high	0x31
+#define TIDAC_key_red_low	0x32
+#define TIDAC_key_red_high	0x33
+#define TIDAC_key_green_low	0x34
+#define TIDAC_key_green_high	0x35
+#define TIDAC_key_blue_low	0x36
+#define TIDAC_key_blue_high	0x37
+#define TIDAC_key_ctrl		0x38
+#define TIDAC_clock_ctrl	0x39
+#define TIDAC_sense_test	0x3a
+#define TIDAC_test_mode_data	0x3b
+#define TIDAC_crc_remain_lsb	0x3c
+#define TIDAC_crc_remain_msb	0x3d
+#define TIDAC_crc_bit_select	0x3e
+#define TIDAC_id		0x3f
+
+/* These are pll values that are accessed via TIDAC_pll_pixel_data */
+#define TIDAC_PIXEL_N		0x80
+#define TIDAC_PIXEL_M		0x81
+#define TIDAC_PIXEL_P		0x82
+#define TIDAC_PIXEL_VALID	0x83
+
+/* These are pll values that are accessed via TIDAC_pll_loop_data */
+#define TIDAC_LOOP_N		0x90
+#define TIDAC_LOOP_M		0x91
+#define TIDAC_LOOP_P		0x92
+#define TIDAC_LOOP_VALID	0x93
+
+/* Direct mapping addresses */
+#define TIDAC_INDEX		0xa0
+#define TIDAC_PALETTE_DATA	0xa1
+#define TIDAC_READ_MASK		0xa2
+#define TIDAC_READ_ADDR		0xa3
+#define TIDAC_CURS_WRITE_ADDR	0xa4
+#define TIDAC_CURS_COLOR	0xa5
+#define TIDAC_CURS_READ_ADDR	0xa7
+#define TIDAC_CURS_CTL		0xa9
+#define TIDAC_INDEXED_DATA	0xaa
+#define TIDAC_CURS_RAM_DATA	0xab
+#define TIDAC_CURS_XLOW		0xac
+#define TIDAC_CURS_XHIGH	0xad
+#define TIDAC_CURS_YLOW		0xae
+#define TIDAC_CURS_YHIGH	0xaf
+
+#define TIDAC_sw_reset		0xff
+
+/* Constants */  
+#define TIDAC_TVP_3026_ID       0x26
+#define TIDAC_TVP_3030_ID       0x30
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdevb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdevb.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEVB_H
+#define UNGRDEVB_H 1
+
+int SProcXUngrabDeviceButton(ClientPtr	/* client */
+    );
+
+int ProcXUngrabDeviceButton(ClientPtr	/* client */
+    );
+
+#endif /* UNGRDEVB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/TIPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/TIPriv.h
@@ -0,0 +1,29 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "TI.h"
+
+typedef struct {
+	char *DeviceName;
+} xf86TIramdacInfo;
+
+extern xf86TIramdacInfo TIramdacDeviceInfo[];
+
+#ifdef INIT_TI_RAMDAC_INFO
+xf86TIramdacInfo TIramdacDeviceInfo[] = {
+	{"TI TVP3030"},
+	{"TI TVP3026"}
+};
+#endif
+
+#define TISAVE(_reg) do { 						\
+    ramdacReg->DacRegs[_reg] = (*ramdacPtr->ReadDAC)(pScrn, _reg);	\
+} while (0)
+
+#define TIRESTORE(_reg) do { 						\
+    (*ramdacPtr->WriteDAC)(pScrn, _reg, 				\
+	(ramdacReg->DacRegs[_reg] & 0xFF00) >> 8, 			\
+	ramdacReg->DacRegs[_reg]);					\
+} while (0)
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxsigio.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxsigio.h
@@ -0,0 +1,45 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to SIGIO handling support.  \see dmxsigio.c */
+
+#ifndef _DMXSIGIO_H_
+#define _DMXSIGIO_H_
+extern void dmxSigioBlock(void);
+extern void dmxSigioUnblock(void);
+extern void dmxSigioEnableInput(void);
+extern void dmxSigioDisableInput(void);
+extern void dmxSigioRegister(DMXInputInfo *dmxInput, int fd);
+extern void dmxSigioUnregister(DMXInputInfo *dmxInput);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xsha1.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xsha1.h
@@ -0,0 +1,19 @@
+#ifndef XSHA1_H
+#define XSHA1_H
+
+/* Initialize SHA1 computation.  Returns NULL on error. */
+void *x_sha1_init(void);
+
+/*
+ * Add some data to be hashed.  ctx is the value returned by x_sha1_init()
+ * Returns 0 on error, 1 on success.
+ */
+int x_sha1_update(void *ctx, void *data, int size);
+
+/*
+ * Place the hash in result, and free ctx.
+ * Returns 0 on error, 1 on success. 
+ */
+int x_sha1_final(void *ctx, unsigned char result[20]);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/uda1380.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/uda1380.h
@@ -0,0 +1,74 @@
+/*************************************************************************************
+ * Copyright (C) 2005 Bogdan D. bogdand@users.sourceforge.net
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this 
+ * software and associated documentation files (the "Software"), to deal in the Software 
+ * without restriction, including without limitation the rights to use, copy, modify, 
+ * merge, publish, distribute, sublicense, and/or sell copies of the Software, 
+ * and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or 
+ * substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, 
+ * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE 
+ * AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, 
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the author shall not be used in advertising or 
+ * otherwise to promote the sale, use or other dealings in this Software without prior written 
+ * authorization from the author.
+ *
+ * Revision 1.3  2005/09/24 21:56:00  bogdand
+ * Changed the license to a X/MIT one
+ *
+ * Revision 1.2  2005/07/01 22:43:11  daniels
+ * Change all misc.h and os.h references to <X11/foo.h>.
+ *
+ *
+ ************************************************************************************/
+
+#ifndef __UDA1380_H__
+#define __UDA1380_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+	I2CDevRec d;
+	
+	CARD16 analog_mixer_settings;	/* register 0x03 */
+	
+	} UDA1380Rec, *UDA1380Ptr;
+
+#define UDA1380_ADDR_1   0x30
+#define UDA1380_ADDR_2   0x34
+
+#define xf86_Detect_uda1380		Detect_uda1380
+extern _X_EXPORT UDA1380Ptr Detect_uda1380(I2CBusPtr b, I2CSlaveAddr addr);
+#define xf86_uda1380_init		uda1380_init
+extern _X_EXPORT Bool uda1380_init(UDA1380Ptr t);
+#define xf86_uda1380_shutdown		uda1380_shutdown
+extern _X_EXPORT void uda1380_shutdown(UDA1380Ptr t);
+#define xf86_uda1380_setvolume		uda1380_setvolume
+extern _X_EXPORT void uda1380_setvolume(UDA1380Ptr t, INT32);
+#define xf86_uda1380_mute		uda1380_mute
+extern _X_EXPORT void uda1380_mute(UDA1380Ptr t, Bool);
+#define xf86_uda1380_setparameters	uda1380_setparameters
+extern _X_EXPORT void uda1380_setparameters(UDA1380Ptr t);
+#define xf86_uda1380_getstatus		uda1380_getstatus
+extern _X_EXPORT void uda1380_getstatus(UDA1380Ptr t);
+#define xf86_uda1380_dumpstatus		uda1380_dumpstatus
+extern _X_EXPORT void uda1380_dumpstatus(UDA1380Ptr t);
+
+#define UDA1380SymbolsList  \
+		"Detect_uda1380", \
+		"uda1380_init", \
+		"uda1380_shutdown", \
+		"uda1380_setvolume", \
+		"uda1380_mute", \
+		"uda1380_setparameters", \
+		"uda1380_getstatus", \
+		"uda1380_dumpstatus"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/CanvasP.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/CanvasP.h
@@ -0,0 +1,65 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+Copyright 2002 Red Hat Inc., Durham, North Carolina.
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ * This file was originally taken from xc/lib/Xaw/TemplateP.h
+ */
+
+#ifndef _CanvasP_h
+#define _CanvasP_h
+
+#include "Canvas.h"
+
+/* include superclass private header file */
+#include <X11/CoreP.h>
+
+typedef struct {
+    XtPointer extension;
+} CanvasClassPart;
+
+typedef struct _CanvasClassRec {
+    CoreClassPart	core_class;
+    CanvasClassPart	canvas_class;
+} CanvasClassRec;
+
+extern CanvasClassRec canvasClassRec;
+
+typedef struct {
+    XtCallbackList input_callback;
+    XtCallbackList expose_callback;
+    XtCallbackList resize_callback;
+} CanvasPart;
+
+typedef struct _CanvasRec {
+    CorePart	core;
+    CanvasPart	canvas;
+} CanvasRec;
+
+#endif /* _CanvasP_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx-config.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmx-config.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2005 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Provide configuration define's and undef's to build Xdmx in X.Org's
+ * modular source tree.
+ */
+
+#ifndef DMX_CONFIG_H
+#define DMX_CONFIG_H
+
+#include <dix-config.h>
+
+/*
+ * Note 1: This is a signed int that is printed as a decimal number.
+ *         Since we want to make it human-interpretable, the fields are
+ *         defined as:
+ *         2147483648
+ *         AAbbyymmdd
+ *         AA: major version 01-20
+ *         bb: minor version 00-99
+ *         yy: year          00-99 [See Note 2]
+ *         mm: month         01-12
+ *         dd: day           01-31
+ *
+ * Note 2: The default epoch for the year is 2000.
+ *         To change the default epoch, change the DMX_VENDOR_RELEASE
+ *         macro below, bumb the minor version number, and change
+ *         xdpyinfo to key off the major/minor version to determine the
+ *         new epoch.  Remember to do this on January 1, 2100 and every
+ *         100 years thereafter.
+ */
+#define DMX_VENDOR_RELEASE(major,minor,year,month,day) \
+    ((major)     * 100000000) + \
+    ((minor)     *   1000000) + \
+    ((year-2000) *     10000) + \
+    ((month)     *       100) + \
+    ((day)       *         1)
+#define VENDOR_RELEASE  DMX_VENDOR_RELEASE(1,2,2007,4,24)
+#define VENDOR_STRING   "DMX Project"
+
+/* Enable the DMX extension */
+#define DMXEXT
+
+#endif /* DMX_CONFIG_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/parser.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/parser.h
@@ -0,0 +1,114 @@
+
+/* A Bison parser, made by GNU Bison 2.4.1.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+   
+      Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+   
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+   
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+   
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/*
+ * Oracle GPL Disclaimer: For the avoidance of doubt, except that if any license choice
+ * other than GPL or LGPL is available it will apply instead, Oracle elects to use only
+ * the General Public License version 2 (GPLv2) at this time for any software where
+ * a choice of GPL license versions is made available with the language indicating
+ * that GPLv2 or any later version may be used, or where a choice of which version
+ * of the GPL is applied is otherwise unspecified.
+ */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+   
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_VIRTUAL = 258,
+     T_DISPLAY = 259,
+     T_WALL = 260,
+     T_OPTION = 261,
+     T_PARAM = 262,
+     T_STRING = 263,
+     T_DIMENSION = 264,
+     T_OFFSET = 265,
+     T_ORIGIN = 266,
+     T_COMMENT = 267,
+     T_LINE_COMMENT = 268
+   };
+#endif
+/* Tokens.  */
+#define T_VIRTUAL 258
+#define T_DISPLAY 259
+#define T_WALL 260
+#define T_OPTION 261
+#define T_PARAM 262
+#define T_STRING 263
+#define T_DIMENSION 264
+#define T_OFFSET 265
+#define T_ORIGIN 266
+#define T_COMMENT 267
+#define T_LINE_COMMENT 268
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+{
+
+/* Line 1676 of yacc.c  */
+#line 56 "parser.y"
+
+    DMXConfigTokenPtr      token;
+    DMXConfigStringPtr     string;
+    DMXConfigNumberPtr     number;
+    DMXConfigPairPtr       pair;
+    DMXConfigFullDimPtr    fdim;
+    DMXConfigPartDimPtr    pdim;
+    DMXConfigDisplayPtr    display;
+    DMXConfigWallPtr       wall;
+    DMXConfigOptionPtr     option;
+    DMXConfigParamPtr      param;
+    DMXConfigCommentPtr    comment;
+    DMXConfigSubPtr        subentry;
+    DMXConfigVirtualPtr    virtual;
+    DMXConfigEntryPtr      entry;
+
+
+
+/* Line 1676 of yacc.c  */
+#line 97 "parser.h"
+} YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+extern YYSTYPE yylval;
+
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvmcext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvmcext.h
@@ -0,0 +1,118 @@
+
+#ifndef _XVMC_H
+#define _XVMC_H
+#include <X11/extensions/Xv.h>
+#include "xvdix.h"
+
+typedef struct {
+  int num_xvimages;
+  int *xvimage_ids;
+} XvMCImageIDList;
+
+typedef struct {
+  int surface_type_id;
+  int chroma_format;
+  int color_description;
+  unsigned short max_width;
+  unsigned short max_height;
+  unsigned short subpicture_max_width;
+  unsigned short subpicture_max_height;
+  int mc_type;
+  int flags;
+  XvMCImageIDList *compatible_subpictures;
+} XvMCSurfaceInfoRec, *XvMCSurfaceInfoPtr;
+
+typedef struct {
+  XID context_id;
+  ScreenPtr pScreen;
+  int adapt_num;
+  int surface_type_id;
+  unsigned short width;
+  unsigned short height;
+  CARD32 flags;
+  int refcnt;
+  pointer port_priv;
+  pointer driver_priv;
+} XvMCContextRec, *XvMCContextPtr;
+
+typedef struct {
+  XID surface_id;
+  int surface_type_id;
+  XvMCContextPtr context;
+  pointer driver_priv;
+} XvMCSurfaceRec, *XvMCSurfacePtr;
+
+
+typedef struct {
+  XID subpicture_id;
+  int xvimage_id;
+  unsigned short width;
+  unsigned short height;
+  int num_palette_entries;
+  int entry_bytes;
+  char component_order[4];
+  XvMCContextPtr context;
+  pointer driver_priv;
+} XvMCSubpictureRec, *XvMCSubpicturePtr;
+
+typedef int (*XvMCCreateContextProcPtr) (
+  XvPortPtr port,
+  XvMCContextPtr context,
+  int *num_priv,
+  CARD32 **priv 
+);
+
+typedef void (*XvMCDestroyContextProcPtr) (
+  XvMCContextPtr context
+);
+
+typedef int (*XvMCCreateSurfaceProcPtr) (
+  XvMCSurfacePtr surface,
+  int *num_priv,
+  CARD32 **priv
+);
+
+typedef void (*XvMCDestroySurfaceProcPtr) (
+  XvMCSurfacePtr surface
+);
+
+typedef int (*XvMCCreateSubpictureProcPtr) (
+  XvMCSubpicturePtr subpicture,
+  int *num_priv,
+  CARD32 **priv
+);
+
+typedef void (*XvMCDestroySubpictureProcPtr) (
+  XvMCSubpicturePtr subpicture
+);
+
+
+typedef struct {
+  XvAdaptorPtr			    xv_adaptor;
+  int				    num_surfaces;
+  XvMCSurfaceInfoPtr		    *surfaces;
+  int				    num_subpictures;
+  XvImagePtr			    *subpictures;
+  XvMCCreateContextProcPtr          CreateContext; 
+  XvMCDestroyContextProcPtr         DestroyContext; 
+  XvMCCreateSurfaceProcPtr          CreateSurface;  
+  XvMCDestroySurfaceProcPtr         DestroySurface; 
+  XvMCCreateSubpictureProcPtr       CreateSubpicture; 
+  XvMCDestroySubpictureProcPtr      DestroySubpicture;
+} XvMCAdaptorRec, *XvMCAdaptorPtr;
+
+#ifndef XorgLoader
+extern _X_EXPORT void XvMCExtensionInit(void);
+
+extern _X_EXPORT int XvMCScreenInit(ScreenPtr pScreen,
+				    int num,
+				    XvMCAdaptorPtr adapt);
+
+extern _X_EXPORT XvImagePtr XvMCFindXvImage(XvPortPtr pPort, CARD32 id);
+
+extern _X_EXPORT int xf86XvMCRegisterDRInfo(ScreenPtr pScreen, char *name,
+			   char *busID, int major, int minor, 
+			   int patchLevel);
+#endif
+
+#endif /* _XVMC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86OSpriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86OSpriv.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 1999-2000 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86OSPRIV_H
+#define _XF86OSPRIV_H
+
+typedef pointer (*MapMemProcPtr)(int, unsigned long, unsigned long, int);
+typedef void (*UnmapMemProcPtr)(int, pointer, unsigned long);
+typedef pointer (*SetWCProcPtr)(int, unsigned long, unsigned long, Bool,
+				MessageType);
+typedef void (*ProtectMemProcPtr)(int, pointer, unsigned long, Bool); 
+typedef void (*UndoWCProcPtr)(int, pointer);
+typedef void (*ReadSideEffectsProcPtr)(int, pointer, unsigned long);
+
+typedef struct {
+	Bool			initialised;
+	MapMemProcPtr		mapMem;
+	UnmapMemProcPtr		unmapMem;
+	ProtectMemProcPtr	protectMem;
+	SetWCProcPtr		setWC;
+	UndoWCProcPtr		undoWC;
+	ReadSideEffectsProcPtr	readSideEffects;
+	Bool			linearSupported;
+} VidMemInfo, *VidMemInfoPtr;
+
+void xf86OSInitVidMem(VidMemInfoPtr);
+
+#endif /* _XF86OSPRIV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbrules.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbrules.h
@@ -0,0 +1,125 @@
+#ifndef _XKBRULES_H_
+#define	_XKBRULES_H_ 1
+
+/************************************************************
+ Copyright (c) 1996 by Silicon Graphics Computer Systems, Inc.
+
+ Permission to use, copy, modify, and distribute this
+ software and its documentation for any purpose and without
+ fee is hereby granted, provided that the above copyright
+ notice appear in all copies and that both that copyright
+ notice and this permission notice appear in supporting
+ documentation, and that the name of Silicon Graphics not be
+ used in advertising or publicity pertaining to distribution
+ of the software without specific prior written permission.
+ Silicon Graphics makes no representation about the suitability
+ of this software for any purpose. It is provided "as is"
+ without any express or implied warranty.
+
+ SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
+ SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+ GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL
+ DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
+ OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+ THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+ ********************************************************/
+
+/***====================================================================***/
+
+typedef struct _XkbRMLVOSet {
+        char *                  rules;
+        char *                  model;
+        char *                  layout;
+        char *                  variant;
+        char *                  options;
+} XkbRMLVOSet;
+
+typedef struct _XkbRF_VarDefs {
+	char *			model;
+	char *			layout;
+	char *			variant;
+	char *			options;
+} XkbRF_VarDefsRec,*XkbRF_VarDefsPtr;
+
+typedef struct _XkbRF_Rule {
+	int			number;
+        int			layout_num;
+        int			variant_num;
+	char *			model;
+	char *			layout;
+	char *			variant;
+	char *			option;
+	/* yields */
+	char *			keycodes;
+	char *			symbols;
+	char *			types;
+	char *			compat;
+	char *			geometry;
+	unsigned		flags;
+} XkbRF_RuleRec,*XkbRF_RulePtr;
+
+typedef struct _XkbRF_Group {
+	int			number;
+	char *			name;
+	char *			words;
+} XkbRF_GroupRec, *XkbRF_GroupPtr;
+
+#define	XkbRF_PendingMatch	(1L<<1)
+#define	XkbRF_Option		(1L<<2)
+#define	XkbRF_Append		(1L<<3)
+#define	XkbRF_Normal		(1L<<4)
+#define	XkbRF_Invalid		(1L<<5)
+
+typedef struct _XkbRF_Rules {
+	unsigned short		sz_rules;
+	unsigned short		num_rules;
+	XkbRF_RulePtr		rules;
+	unsigned short		sz_groups;
+	unsigned short		num_groups;
+        XkbRF_GroupPtr		groups;
+} XkbRF_RulesRec, *XkbRF_RulesPtr;
+
+/***====================================================================***/
+
+_XFUNCPROTOBEGIN
+
+/* Seems preferable to dragging xkbstr.h in. */
+struct _XkbComponentNames;
+
+extern _X_EXPORT Bool	XkbRF_GetComponents(
+    XkbRF_RulesPtr		/* rules */,
+    XkbRF_VarDefsPtr		/* var_defs */,
+    struct _XkbComponentNames *	/* names */
+);
+
+extern _X_EXPORT Bool	XkbRF_LoadRules(
+    FILE *		/* file */,
+    XkbRF_RulesPtr	/* rules */
+);
+
+extern _X_EXPORT Bool XkbRF_LoadRulesByName(
+    char *		/* base */,
+    char *		/* locale */,
+    XkbRF_RulesPtr	/* rules */
+);
+
+/***====================================================================***/
+
+extern _X_EXPORT XkbRF_RulesPtr XkbRF_Create(void);
+
+extern _X_EXPORT void XkbRF_Free(
+    XkbRF_RulesPtr	/* rules */,
+    Bool		/* freeRules */
+);
+
+/***====================================================================***/
+
+#define	_XKB_RF_NAMES_PROP_ATOM		"_XKB_RULES_NAMES"
+#define	_XKB_RF_NAMES_PROP_MAXLEN	1024
+
+_XFUNCPROTOEND
+
+#endif /* _XKBRULES_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mifillarc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mifillarc.h
@@ -0,0 +1,190 @@
+/************************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+********************************************************/
+
+
+#ifndef __MIFILLARC_H__
+#define __MIFILLARC_H__
+
+#define FULLCIRCLE (360 * 64)
+
+typedef struct _miFillArc {
+    int xorg, yorg;
+    int y;
+    int dx, dy;
+    int e;
+    int ym, yk, xm, xk;
+} miFillArcRec;
+
+/* could use 64-bit integers */
+typedef struct _miFillArcD {
+    int xorg, yorg;
+    int y;
+    int dx, dy;
+    double e;
+    double ym, yk, xm, xk;
+} miFillArcDRec;
+
+#define miFillArcEmpty(arc) (!(arc)->angle2 || \
+			     !(arc)->width || !(arc)->height || \
+			     (((arc)->width == 1) && ((arc)->height & 1)))
+
+#define miCanFillArc(arc) (((arc)->width == (arc)->height) || \
+			   (((arc)->width <= 800) && ((arc)->height <= 800)))
+
+#define MIFILLARCSETUP() \
+    x = 0; \
+    y = info.y; \
+    e = info.e; \
+    xk = info.xk; \
+    xm = info.xm; \
+    yk = info.yk; \
+    ym = info.ym; \
+    dx = info.dx; \
+    dy = info.dy; \
+    xorg = info.xorg; \
+    yorg = info.yorg
+
+#define MIFILLARCSTEP(slw) \
+    e += yk; \
+    while (e >= 0) \
+    { \
+	x++; \
+	xk -= xm; \
+	e += xk; \
+    } \
+    y--; \
+    yk -= ym; \
+    slw = (x << 1) + dx; \
+    if ((e == xk) && (slw > 1)) \
+	slw--
+
+#define MIFILLCIRCSTEP(slw) MIFILLARCSTEP(slw)
+#define MIFILLELLSTEP(slw) MIFILLARCSTEP(slw)
+
+#define miFillArcLower(slw) (((y + dy) != 0) && ((slw > 1) || (e != xk)))
+
+typedef struct _miSliceEdge {
+    int	    x;
+    int     stepx;
+    int	    deltax;
+    int	    e;
+    int	    dy;
+    int	    dx;
+} miSliceEdgeRec, *miSliceEdgePtr;
+
+typedef struct _miArcSlice {
+    miSliceEdgeRec edge1, edge2;
+    int min_top_y, max_top_y;
+    int min_bot_y, max_bot_y;
+    Bool edge1_top, edge2_top;
+    Bool flip_top, flip_bot;
+} miArcSliceRec;
+
+#define MIARCSLICESTEP(edge) \
+    edge.x -= edge.stepx; \
+    edge.e -= edge.dx; \
+    if (edge.e <= 0) \
+    { \
+	edge.x -= edge.deltax; \
+	edge.e += edge.dy; \
+    }
+
+#define miFillSliceUpper(slice) \
+		((y >= slice.min_top_y) && (y <= slice.max_top_y))
+
+#define miFillSliceLower(slice) \
+		((y >= slice.min_bot_y) && (y <= slice.max_bot_y))
+
+#define MIARCSLICEUPPER(xl,xr,slice,slw) \
+    xl = xorg - x; \
+    xr = xl + slw - 1; \
+    if (slice.edge1_top && (slice.edge1.x < xr)) \
+	xr = slice.edge1.x; \
+    if (slice.edge2_top && (slice.edge2.x > xl)) \
+	xl = slice.edge2.x;
+
+#define MIARCSLICELOWER(xl,xr,slice,slw) \
+    xl = xorg - x; \
+    xr = xl + slw - 1; \
+    if (!slice.edge1_top && (slice.edge1.x > xl)) \
+	xl = slice.edge1.x; \
+    if (!slice.edge2_top && (slice.edge2.x < xr)) \
+	xr = slice.edge2.x;
+
+#define MIWIDEARCSETUP(x,y,dy,slw,e,xk,xm,yk,ym) \
+    x = 0; \
+    y = slw >> 1; \
+    yk = y << 3; \
+    xm = 8; \
+    ym = 8; \
+    if (dy) \
+    { \
+	xk = 0; \
+	if (slw & 1) \
+	    e = -1; \
+	else \
+	    e = -(y << 2) - 2; \
+    } \
+    else \
+    { \
+	y++; \
+	yk += 4; \
+	xk = -4; \
+	if (slw & 1) \
+	    e = -(y << 2) - 3; \
+	else \
+	    e = - (y << 3); \
+    }
+
+#define MIFILLINARCSTEP(slw) \
+    ine += inyk; \
+    while (ine >= 0) \
+    { \
+	inx++; \
+	inxk -= inxm; \
+	ine += inxk; \
+    } \
+    iny--; \
+    inyk -= inym; \
+    slw = (inx << 1) + dx; \
+    if ((ine == inxk) && (slw > 1)) \
+	slw--
+
+#define miFillInArcLower(slw) (((iny + dy) != 0) && \
+			       ((slw > 1) || (ine != inxk)))
+
+extern _X_EXPORT void miFillArcSetup(
+    xArc * /*arc*/,
+    miFillArcRec * /*info*/
+);
+
+extern _X_EXPORT void miFillArcSliceSetup(
+    xArc * /*arc*/,
+    miArcSliceRec * /*slice*/,
+    GCPtr /*pGC*/
+);
+
+#endif /* __MIFILLARC_H__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessWindow.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessWindow.h
@@ -0,0 +1,60 @@
+/*
+ * Rootless window management
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESSWINDOW_H
+#define _ROOTLESSWINDOW_H
+
+#include "rootlessCommon.h"
+
+Bool RootlessCreateWindow(WindowPtr pWin);
+Bool RootlessDestroyWindow(WindowPtr pWin);
+
+void RootlessSetShape(WindowPtr pWin, int kind);
+
+Bool RootlessChangeWindowAttributes(WindowPtr pWin, unsigned long vmask);
+Bool RootlessPositionWindow(WindowPtr pWin, int x, int y);
+Bool RootlessRealizeWindow(WindowPtr pWin);
+Bool RootlessUnrealizeWindow(WindowPtr pWin);
+void RootlessRestackWindow(WindowPtr pWin, WindowPtr pOldNextSib);
+void RootlessCopyWindow(WindowPtr pWin,DDXPointRec ptOldOrg,RegionPtr prgnSrc);
+void RootlessMoveWindow(WindowPtr pWin,int x,int y,WindowPtr pSib,VTKind kind);
+void RootlessResizeWindow(WindowPtr pWin, int x, int y,
+			  unsigned int w, unsigned int h, WindowPtr pSib);
+void RootlessReparentWindow(WindowPtr pWin, WindowPtr pPriorParent);
+void RootlessChangeBorderWidth(WindowPtr pWin, unsigned int width);
+#ifdef __APPLE__
+void RootlessNativeWindowMoved (WindowPtr pWin);
+void RootlessNativeWindowStateChanged (WindowPtr pWin, unsigned int state); 
+#endif
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxerror.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxerror.h
@@ -0,0 +1,52 @@
+#ifndef _GLX_error_h_
+#define _GLX_error_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+/*
+** Error codes.  These have the extension error base added to them
+** when the extension initializes.
+*/
+extern int __glXerrorBase;
+extern int __glXBadContext;
+extern int __glXBadContextState;
+extern int __glXBadDrawable;
+extern int __glXBadPixmap;
+extern int __glXBadCurrentWindow;
+extern int __glXBadContextTag;
+extern int __glXBadRenderRequest;
+extern int __glXBadLargeRequest;
+extern int __glXUnsupportedPrivateRequest;
+extern int __glXBadFBConfig;
+extern int __glXBadPbuffer;
+
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiquerypointer.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiquerypointer.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef QUERYDP_H
+#define QUERYDP_H 1
+
+int SProcXIQueryPointer(ClientPtr /* client */);
+int ProcXIQueryPointer(ClientPtr /* client */);
+void SRepXIQueryPointer(ClientPtr /* client */ ,
+			int /* size */ ,
+			xXIQueryPointerReply *	/* rep */);
+
+#endif /* QUERYDP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Crtc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Crtc.h
@@ -0,0 +1,972 @@
+/*
+ * Copyright © 2006 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+#ifndef _XF86CRTC_H_
+#define _XF86CRTC_H_
+
+#include <edid.h>
+#include "randrstr.h"
+#if XF86_MODES_RENAME
+#include "xf86Rename.h"
+#endif
+#include "xf86Modes.h"
+#include "xf86Cursor.h"
+#include "xf86i2c.h"
+#include "damage.h"
+#include "picturestr.h"
+
+/* Compat definitions for older X Servers. */
+#ifndef M_T_PREFERRED
+#define M_T_PREFERRED	0x08
+#endif
+#ifndef M_T_DRIVER
+#define M_T_DRIVER	0x40
+#endif
+#ifndef M_T_USERPREF
+#define M_T_USERPREF	0x80
+#endif
+#ifndef HARDWARE_CURSOR_ARGB
+#define HARDWARE_CURSOR_ARGB				0x00004000
+#endif
+
+typedef struct _xf86Crtc xf86CrtcRec, *xf86CrtcPtr;
+typedef struct _xf86Output xf86OutputRec, *xf86OutputPtr;
+
+/* define a standard for connector types */
+typedef enum _xf86ConnectorType {
+   XF86ConnectorNone,
+   XF86ConnectorVGA,
+   XF86ConnectorDVI_I,
+   XF86ConnectorDVI_D,
+   XF86ConnectorDVI_A,
+   XF86ConnectorComposite,
+   XF86ConnectorSvideo,
+   XF86ConnectorComponent,
+   XF86ConnectorLFP,
+   XF86ConnectorProprietary,
+   XF86ConnectorHDMI,
+   XF86ConnectorDisplayPort,
+} xf86ConnectorType;
+
+typedef enum _xf86OutputStatus {
+   XF86OutputStatusConnected,
+   XF86OutputStatusDisconnected,
+   XF86OutputStatusUnknown
+} xf86OutputStatus;
+
+typedef struct _xf86CrtcFuncs {
+   /**
+    * Turns the crtc on/off, or sets intermediate power levels if available.
+    *
+    * Unsupported intermediate modes drop to the lower power setting.  If the
+    * mode is DPMSModeOff, the crtc must be disabled sufficiently for it to
+    * be safe to call mode_set.
+    */
+   void
+    (*dpms)(xf86CrtcPtr		crtc,
+	    int		    	mode);
+
+   /**
+    * Saves the crtc's state for restoration on VT switch.
+    */
+   void
+    (*save)(xf86CrtcPtr		crtc);
+
+   /**
+    * Restore's the crtc's state at VT switch.
+    */
+   void
+    (*restore)(xf86CrtcPtr	crtc);
+
+    /**
+     * Lock CRTC prior to mode setting, mostly for DRI.
+     * Returns whether unlock is needed
+     */
+    Bool
+    (*lock) (xf86CrtcPtr crtc);
+    
+    /**
+     * Unlock CRTC after mode setting, mostly for DRI
+     */
+    void
+    (*unlock) (xf86CrtcPtr crtc);
+    
+    /**
+     * Callback to adjust the mode to be set in the CRTC.
+     *
+     * This allows a CRTC to adjust the clock or even the entire set of
+     * timings, which is used for panels with fixed timings or for
+     * buses with clock limitations.
+     */
+    Bool
+    (*mode_fixup)(xf86CrtcPtr crtc,
+		  DisplayModePtr mode,
+		  DisplayModePtr adjusted_mode);
+
+    /**
+     * Prepare CRTC for an upcoming mode set.
+     */
+    void
+    (*prepare)(xf86CrtcPtr crtc);
+
+    /**
+     * Callback for setting up a video mode after fixups have been made.
+     */
+    void
+    (*mode_set)(xf86CrtcPtr crtc,
+		DisplayModePtr mode,
+		DisplayModePtr adjusted_mode,
+		int x, int y);
+
+    /**
+     * Commit mode changes to a CRTC
+     */
+    void
+    (*commit)(xf86CrtcPtr crtc);
+
+    /* Set the color ramps for the CRTC to the given values. */
+    void
+    (*gamma_set)(xf86CrtcPtr crtc, CARD16 *red, CARD16 *green, CARD16 *blue,
+		 int size);
+
+    /**
+     * Allocate the shadow area, delay the pixmap creation until needed
+     */
+    void *
+    (*shadow_allocate) (xf86CrtcPtr crtc, int width, int height);
+    
+    /**
+     * Create shadow pixmap for rotation support
+     */
+    PixmapPtr
+    (*shadow_create) (xf86CrtcPtr crtc, void *data, int width, int height);
+    
+    /**
+     * Destroy shadow pixmap
+     */
+    void
+    (*shadow_destroy) (xf86CrtcPtr crtc, PixmapPtr pPixmap, void *data);
+
+    /**
+     * Set cursor colors
+     */
+    void
+    (*set_cursor_colors) (xf86CrtcPtr crtc, int bg, int fg);
+
+    /**
+     * Set cursor position
+     */
+    void
+    (*set_cursor_position) (xf86CrtcPtr crtc, int x, int y);
+
+    /**
+     * Show cursor
+     */
+    void
+    (*show_cursor) (xf86CrtcPtr crtc);
+
+    /**
+     * Hide cursor
+     */
+    void
+    (*hide_cursor) (xf86CrtcPtr crtc);
+
+    /**
+     * Load monochrome image
+     */
+    void
+    (*load_cursor_image) (xf86CrtcPtr crtc, CARD8 *image);
+
+    /**
+     * Load ARGB image
+     */
+     void
+     (*load_cursor_argb) (xf86CrtcPtr crtc, CARD32 *image);
+     
+    /**
+     * Clean up driver-specific bits of the crtc
+     */
+    void
+    (*destroy) (xf86CrtcPtr	crtc);
+
+    /**
+     * Less fine-grained mode setting entry point for kernel modesetting
+     */
+    Bool
+    (*set_mode_major)(xf86CrtcPtr crtc, DisplayModePtr mode,
+		      Rotation rotation, int x, int y);
+
+    /**
+     * Callback for panning. Doesn't change the mode.
+     * Added in ABI version 2
+     */
+    void
+    (*set_origin)(xf86CrtcPtr crtc, int x, int y);
+
+} xf86CrtcFuncsRec, *xf86CrtcFuncsPtr;
+
+#define XF86_CRTC_VERSION 3
+
+struct _xf86Crtc {
+    /**
+     * ABI versioning
+     */
+    int version;
+
+    /**
+     * Associated ScrnInfo
+     */
+    ScrnInfoPtr	    scrn;
+    
+    /**
+     * Desired state of this CRTC
+     *
+     * Set when this CRTC should be driving one or more outputs 
+     */
+    Bool	    enabled;
+    
+    /**
+     * Active mode
+     *
+     * This reflects the mode as set in the CRTC currently
+     * It will be cleared when the VT is not active or
+     * during server startup
+     */
+    DisplayModeRec  mode;
+    Rotation	    rotation;
+    PixmapPtr	    rotatedPixmap;
+    void	    *rotatedData;
+    
+    /**
+     * Position on screen
+     *
+     * Locates this CRTC within the frame buffer
+     */
+    int		    x, y;
+    
+    /**
+     * Desired mode
+     *
+     * This is set to the requested mode, independent of
+     * whether the VT is active. In particular, it receives
+     * the startup configured mode and saves the active mode
+     * on VT switch.
+     */
+    DisplayModeRec  desiredMode;
+    Rotation	    desiredRotation;
+    int		    desiredX, desiredY;
+    
+    /** crtc-specific functions */
+    const xf86CrtcFuncsRec *funcs;
+
+    /**
+     * Driver private
+     *
+     * Holds driver-private information
+     */
+    void	    *driver_private;
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * RandR crtc
+     *
+     * When RandR 1.2 is available, this
+     * points at the associated crtc object
+     */
+    RRCrtcPtr	    randr_crtc;
+#else
+    void	    *randr_crtc;
+#endif
+
+    /**
+     * Current cursor is ARGB
+     */
+    Bool	    cursor_argb;
+    /**
+     * Track whether cursor is within CRTC range 
+     */
+    Bool	    cursor_in_range;
+    /**
+     * Track state of cursor associated with this CRTC
+     */
+    Bool	    cursor_shown;
+
+    /**
+     * Current transformation matrix
+     */
+    PictTransform   crtc_to_framebuffer;
+    /* framebuffer_to_crtc was removed in ABI 2 */
+    struct pict_f_transform f_crtc_to_framebuffer; /* ABI 2 */
+    struct pict_f_transform f_framebuffer_to_crtc; /* ABI 2 */
+    PictFilterPtr   filter; /* ABI 2 */
+    xFixed	    *params; /* ABI 2 */
+    int		    nparams; /* ABI 2 */
+    int		    filter_width; /* ABI 2 */
+    int		    filter_height; /* ABI 2 */
+    Bool	    transform_in_use;
+    RRTransformRec  transform; /* ABI 2 */
+    Bool	    transformPresent; /* ABI 2 */
+    RRTransformRec  desiredTransform; /* ABI 2 */
+    Bool	    desiredTransformPresent; /* ABI 2 */
+    /**
+     * Bounding box in screen space
+     */
+    BoxRec	    bounds;
+    /**
+     * Panning:
+     * TotalArea: total panning area, larger than CRTC's size
+     * TrackingArea: Area of the pointer for which the CRTC is panned
+     * border: Borders of the displayed CRTC area which induces panning if the pointer reaches them
+     * Added in ABI version 2
+     */
+    BoxRec          panningTotalArea;
+    BoxRec          panningTrackingArea;
+    INT16           panningBorder[4];
+
+    /**
+     * Current gamma, especially useful after initial config.
+     * Added in ABI version 3
+     */
+    CARD16 *gamma_red;
+    CARD16 *gamma_green;
+    CARD16 *gamma_blue;
+    int gamma_size;
+
+    /**
+     * Actual state of this CRTC
+     *
+     * Set to TRUE after modesetting, set to FALSE if no outputs are connected
+     * Added in ABI version 3
+     */
+    Bool	    active;
+    /**
+     * Clear the shadow
+     */
+    Bool	    shadowClear;
+};
+
+typedef struct _xf86OutputFuncs {
+    /**
+     * Called to allow the output a chance to create properties after the
+     * RandR objects have been created.
+     */
+    void
+    (*create_resources)(xf86OutputPtr output);
+
+    /**
+     * Turns the output on/off, or sets intermediate power levels if available.
+     *
+     * Unsupported intermediate modes drop to the lower power setting.  If the
+     * mode is DPMSModeOff, the output must be disabled, as the DPLL may be
+     * disabled afterwards.
+     */
+    void
+    (*dpms)(xf86OutputPtr	output,
+	    int			mode);
+
+    /**
+     * Saves the output's state for restoration on VT switch.
+     */
+    void
+    (*save)(xf86OutputPtr	output);
+
+    /**
+     * Restore's the output's state at VT switch.
+     */
+    void
+    (*restore)(xf86OutputPtr	output);
+
+    /**
+     * Callback for testing a video mode for a given output.
+     *
+     * This function should only check for cases where a mode can't be supported
+     * on the output specifically, and not represent generic CRTC limitations.
+     *
+     * \return MODE_OK if the mode is valid, or another MODE_* otherwise.
+     */
+    int
+    (*mode_valid)(xf86OutputPtr	    output,
+		  DisplayModePtr    pMode);
+
+    /**
+     * Callback to adjust the mode to be set in the CRTC.
+     *
+     * This allows an output to adjust the clock or even the entire set of
+     * timings, which is used for panels with fixed timings or for
+     * buses with clock limitations.
+     */
+    Bool
+    (*mode_fixup)(xf86OutputPtr output,
+		  DisplayModePtr mode,
+		  DisplayModePtr adjusted_mode);
+
+    /**
+     * Callback for preparing mode changes on an output
+     */
+    void
+    (*prepare)(xf86OutputPtr output);
+
+    /**
+     * Callback for committing mode changes on an output
+     */
+    void
+    (*commit)(xf86OutputPtr output);
+
+    /**
+     * Callback for setting up a video mode after fixups have been made.
+     *
+     * This is only called while the output is disabled.  The dpms callback
+     * must be all that's necessary for the output, to turn the output on
+     * after this function is called.
+     */
+    void
+    (*mode_set)(xf86OutputPtr  output,
+		DisplayModePtr mode,
+		DisplayModePtr adjusted_mode);
+
+    /**
+     * Probe for a connected output, and return detect_status.
+     */
+    xf86OutputStatus
+    (*detect)(xf86OutputPtr	    output);
+
+    /**
+     * Query the device for the modes it provides.
+     *
+     * This function may also update MonInfo, mm_width, and mm_height.
+     *
+     * \return singly-linked list of modes or NULL if no modes found.
+     */
+    DisplayModePtr
+    (*get_modes)(xf86OutputPtr	    output);
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * Callback when an output's property has changed.
+     */
+    Bool
+    (*set_property)(xf86OutputPtr output,
+		    Atom property,
+		    RRPropertyValuePtr value);
+#endif
+#ifdef RANDR_13_INTERFACE
+    /**
+     * Callback to get an updated property value
+     */
+    Bool
+    (*get_property)(xf86OutputPtr output,
+		    Atom property);
+#endif
+#ifdef RANDR_GET_CRTC_INTERFACE
+    /**
+     * Callback to get current CRTC for a given output
+     */
+    xf86CrtcPtr
+    (*get_crtc)(xf86OutputPtr output);
+#endif
+    /**
+     * Clean up driver-specific bits of the output
+     */
+    void
+    (*destroy) (xf86OutputPtr	    output);
+} xf86OutputFuncsRec, *xf86OutputFuncsPtr;
+
+
+#define XF86_OUTPUT_VERSION 2
+
+struct _xf86Output {
+    /**
+     * ABI versioning
+     */
+    int version;
+
+    /**
+     * Associated ScrnInfo
+     */
+    ScrnInfoPtr		scrn;
+
+    /**
+     * Currently connected crtc (if any)
+     *
+     * If this output is not in use, this field will be NULL.
+     */
+    xf86CrtcPtr		crtc;
+
+    /**
+     * Possible CRTCs for this output as a mask of crtc indices
+     */
+    CARD32		possible_crtcs;
+
+    /**
+     * Possible outputs to share the same CRTC as a mask of output indices
+     */
+    CARD32		possible_clones;
+    
+    /**
+     * Whether this output can support interlaced modes
+     */
+    Bool		interlaceAllowed;
+
+    /**
+     * Whether this output can support double scan modes
+     */
+    Bool		doubleScanAllowed;
+
+    /**
+     * List of available modes on this output.
+     *
+     * This should be the list from get_modes(), plus perhaps additional
+     * compatible modes added later.
+     */
+    DisplayModePtr	probed_modes;
+
+    /**
+     * Options parsed from the related monitor section
+     */
+    OptionInfoPtr	options;
+    
+    /**
+     * Configured monitor section
+     */
+    XF86ConfMonitorPtr  conf_monitor;
+    
+    /**
+     * Desired initial position
+     */
+    int			initial_x, initial_y;
+
+    /**
+     * Desired initial rotation
+     */
+    Rotation		initial_rotation;
+
+    /**
+     * Current connection status
+     *
+     * This indicates whether a monitor is known to be connected
+     * to this output or not, or whether there is no way to tell
+     */
+    xf86OutputStatus	status;
+
+    /** EDID monitor information */
+    xf86MonPtr		MonInfo;
+
+    /** subpixel order */
+    int			subpixel_order;
+
+    /** Physical size of the currently attached output device. */
+    int			mm_width, mm_height;
+
+    /** Output name */
+    char		*name;
+
+    /** output-specific functions */
+    const xf86OutputFuncsRec *funcs;
+
+    /** driver private information */
+    void		*driver_private;
+    
+    /** Whether to use the old per-screen Monitor config section */
+    Bool		use_screen_monitor;
+
+#ifdef RANDR_12_INTERFACE
+    /**
+     * RandR 1.2 output structure.
+     *
+     * When RandR 1.2 is available, this points at the associated
+     * RandR output structure and is created when this output is created
+     */
+    RROutputPtr		randr_output;
+#else
+    void		*randr_output;
+#endif
+    /** 
+     * Desired initial panning
+     * Added in ABI version 2
+     */
+    BoxRec          initialTotalArea;
+    BoxRec          initialTrackingArea;
+    INT16           initialBorder[4];
+};
+
+typedef struct _xf86CrtcConfigFuncs {
+    /**
+     * Requests that the driver resize the screen.
+     *
+     * The driver is responsible for updating scrn->virtualX and scrn->virtualY.
+     * If the requested size cannot be set, the driver should leave those values
+     * alone and return FALSE.
+     *
+     * A naive driver that cannot reallocate the screen may simply change
+     * virtual[XY].  A more advanced driver will want to also change the
+     * devPrivate.ptr and devKind of the screen pixmap, update any offscreen
+     * pixmaps it may have moved, and change pScrn->displayWidth.
+     */
+    Bool
+    (*resize)(ScrnInfoPtr	scrn,
+	      int		width,
+	      int		height);
+} xf86CrtcConfigFuncsRec, *xf86CrtcConfigFuncsPtr;
+
+typedef void (*xf86_crtc_notify_proc_ptr) (ScreenPtr pScreen);
+
+typedef struct _xf86CrtcConfig {
+    int			num_output;
+    xf86OutputPtr	*output;
+    /**
+     * compat_output is used whenever we deal
+     * with legacy code that only understands a single
+     * output. pScrn->modes will be loaded from this output,
+     * adjust frame will whack this output, etc.
+     */
+    int			compat_output;
+
+    int			num_crtc;
+    xf86CrtcPtr		*crtc;
+
+    int			minWidth, minHeight;
+    int			maxWidth, maxHeight;
+    
+    /* For crtc-based rotation */
+    DamagePtr		rotation_damage;
+    Bool		rotation_damage_registered;
+
+    /* DGA */
+    unsigned int	dga_flags;
+    unsigned long	dga_address;
+    DGAModePtr		dga_modes;
+    int			dga_nmode;
+    int			dga_width, dga_height, dga_stride;
+    DisplayModePtr	dga_save_mode;
+
+    const xf86CrtcConfigFuncsRec *funcs;
+
+    CreateScreenResourcesProcPtr    CreateScreenResources;
+
+    CloseScreenProcPtr		    CloseScreen;
+
+    /* Cursor information */
+    xf86CursorInfoPtr	cursor_info;
+    CursorPtr		cursor;
+    CARD8		*cursor_image;
+    Bool		cursor_on;
+    CARD32		cursor_fg, cursor_bg;
+
+    /**
+     * Options parsed from the related device section
+     */
+    OptionInfoPtr	options;
+
+    Bool		debug_modes;
+
+    /* wrap screen BlockHandler for rotation */
+    ScreenBlockHandlerProcPtr	BlockHandler;
+
+    /* callback when crtc configuration changes */
+    xf86_crtc_notify_proc_ptr  xf86_crtc_notify;
+
+} xf86CrtcConfigRec, *xf86CrtcConfigPtr;
+
+extern _X_EXPORT int xf86CrtcConfigPrivateIndex;
+
+#define XF86_CRTC_CONFIG_PTR(p)	((xf86CrtcConfigPtr) ((p)->privates[xf86CrtcConfigPrivateIndex].ptr))
+
+static _X_INLINE xf86OutputPtr
+xf86CompatOutput(ScrnInfoPtr pScrn)
+{
+    xf86CrtcConfigPtr config = XF86_CRTC_CONFIG_PTR(pScrn);
+    return config->output[config->compat_output];
+}
+
+static _X_INLINE xf86CrtcPtr
+xf86CompatCrtc(ScrnInfoPtr pScrn)
+{
+    xf86OutputPtr compat_output = xf86CompatOutput(pScrn);
+    if (!compat_output)
+	return NULL;
+    return compat_output->crtc;
+}
+
+static _X_INLINE RRCrtcPtr
+xf86CompatRRCrtc(ScrnInfoPtr pScrn)
+{
+    xf86CrtcPtr	compat_crtc = xf86CompatCrtc(pScrn);
+    if (!compat_crtc)
+	return NULL;
+    return compat_crtc->randr_crtc;
+}
+
+
+/*
+ * Initialize xf86CrtcConfig structure
+ */
+
+extern _X_EXPORT void
+xf86CrtcConfigInit (ScrnInfoPtr				scrn,
+		    const xf86CrtcConfigFuncsRec	*funcs);
+
+extern _X_EXPORT void
+xf86CrtcSetSizeRange (ScrnInfoPtr scrn,
+		      int minWidth, int minHeight,
+		      int maxWidth, int maxHeight);
+
+/*
+ * Crtc functions
+ */
+extern _X_EXPORT xf86CrtcPtr
+xf86CrtcCreate (ScrnInfoPtr		scrn,
+		const xf86CrtcFuncsRec	*funcs);
+
+extern _X_EXPORT void
+xf86CrtcDestroy (xf86CrtcPtr		crtc);
+
+
+/**
+ * Sets the given video mode on the given crtc
+ */
+
+extern _X_EXPORT Bool
+xf86CrtcSetModeTransform (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
+			  RRTransformPtr transform, int x, int y);
+
+extern _X_EXPORT Bool
+xf86CrtcSetMode (xf86CrtcPtr crtc, DisplayModePtr mode, Rotation rotation,
+		 int x, int y);
+
+extern _X_EXPORT void
+xf86CrtcSetOrigin (xf86CrtcPtr crtc, int x, int y);
+
+/*
+ * Assign crtc rotation during mode set
+ */
+extern _X_EXPORT Bool
+xf86CrtcRotate (xf86CrtcPtr crtc);
+
+/*
+ * Clean up any rotation data, used when a crtc is turned off
+ * as well as when rotation is disabled.
+ */
+extern _X_EXPORT void
+xf86RotateDestroy (xf86CrtcPtr crtc);
+
+/*
+ * free shadow memory allocated for all crtcs
+ */
+extern _X_EXPORT void
+xf86RotateFreeShadow(ScrnInfoPtr pScrn);
+
+/*
+ * Clean up rotation during CloseScreen
+ */
+extern _X_EXPORT void
+xf86RotateCloseScreen (ScreenPtr pScreen);
+
+/**
+ * Return whether any output is assigned to the crtc
+ */
+extern _X_EXPORT Bool
+xf86CrtcInUse (xf86CrtcPtr crtc);
+
+/*
+ * Output functions
+ */
+extern _X_EXPORT xf86OutputPtr
+xf86OutputCreate (ScrnInfoPtr		    scrn,
+		  const xf86OutputFuncsRec  *funcs,
+		  const char		    *name);
+
+extern _X_EXPORT void
+xf86OutputUseScreenMonitor (xf86OutputPtr output, Bool use_screen_monitor);
+
+extern _X_EXPORT Bool
+xf86OutputRename (xf86OutputPtr output, const char *name);
+
+extern _X_EXPORT void
+xf86OutputDestroy (xf86OutputPtr	output);
+
+extern _X_EXPORT void
+xf86ProbeOutputModes (ScrnInfoPtr pScrn, int maxX, int maxY);
+
+extern _X_EXPORT void
+xf86SetScrnInfoModes (ScrnInfoPtr pScrn);
+
+#ifdef RANDR_13_INTERFACE
+# define ScreenInitRetType	int
+#else
+# define ScreenInitRetType	Bool
+#endif
+
+extern _X_EXPORT ScreenInitRetType
+xf86CrtcScreenInit (ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+xf86InitialConfiguration (ScrnInfoPtr pScrn, Bool canGrow);
+
+extern _X_EXPORT void
+xf86DPMSSet(ScrnInfoPtr pScrn, int PowerManagementMode, int flags);
+    
+extern _X_EXPORT Bool
+xf86SaveScreen(ScreenPtr pScreen, int mode);
+
+extern _X_EXPORT void
+xf86DisableUnusedFunctions(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT DisplayModePtr
+xf86OutputFindClosestMode (xf86OutputPtr output, DisplayModePtr desired);
+    
+extern _X_EXPORT Bool
+xf86SetSingleMode (ScrnInfoPtr pScrn, DisplayModePtr desired, Rotation rotation);
+
+/**
+ * Set the EDID information for the specified output
+ */
+extern _X_EXPORT void
+xf86OutputSetEDID (xf86OutputPtr output, xf86MonPtr edid_mon);
+
+/**
+ * Return the list of modes supported by the EDID information
+ * stored in 'output'
+ */
+extern _X_EXPORT DisplayModePtr
+xf86OutputGetEDIDModes (xf86OutputPtr output);
+
+extern _X_EXPORT xf86MonPtr
+xf86OutputGetEDID (xf86OutputPtr output, I2CBusPtr pDDCBus);
+
+/**
+ * Initialize dga for this screen
+ */
+
+#ifdef XFreeXDGA
+extern _X_EXPORT Bool
+xf86DiDGAInit (ScreenPtr pScreen, unsigned long dga_address);
+
+/* this is the real function, used only internally */
+_X_INTERNAL Bool
+_xf86_di_dga_init_internal (ScreenPtr pScreen);
+
+/**
+ * Re-initialize dga for this screen (as when the set of modes changes)
+ */
+
+extern _X_EXPORT Bool
+xf86DiDGAReInit (ScreenPtr pScreen);
+#endif
+
+/* This is the real function, used only internally */
+_X_INTERNAL Bool
+_xf86_di_dga_reinit_internal (ScreenPtr pScreen);
+
+/*
+ * Set the subpixel order reported for the screen using
+ * the information from the outputs
+ */
+
+extern _X_EXPORT void
+xf86CrtcSetScreenSubpixelOrder (ScreenPtr pScreen);
+
+/*
+ * Get a standard string name for a connector type 
+ */
+extern _X_EXPORT char *
+xf86ConnectorGetName(xf86ConnectorType connector);
+
+/*
+ * Using the desired mode information in each crtc, set
+ * modes (used in EnterVT functions, or at server startup)
+ */
+
+extern _X_EXPORT Bool
+xf86SetDesiredModes (ScrnInfoPtr pScrn);
+
+/**
+ * Initialize the CRTC-based cursor code. CRTC function vectors must
+ * contain relevant cursor setting functions.
+ *
+ * Driver should call this from ScreenInit function
+ */
+extern _X_EXPORT Bool
+xf86_cursors_init (ScreenPtr screen, int max_width, int max_height, int flags);
+
+/**
+ * Called when anything on the screen is reconfigured.
+ *
+ * Reloads cursor images as needed, then adjusts cursor positions.
+ * 
+ * Driver should call this from crtc commit function.
+ */
+extern _X_EXPORT void
+xf86_reload_cursors (ScreenPtr screen);
+
+/**
+ * Called from EnterVT to turn the cursors back on
+ */
+extern _X_EXPORT void
+xf86_show_cursors (ScrnInfoPtr scrn);
+
+/**
+ * Called by the driver to turn cursors off
+ */
+extern _X_EXPORT void
+xf86_hide_cursors (ScrnInfoPtr scrn);
+
+/**
+ * Clean up CRTC-based cursor code. Driver must call this at CloseScreen time.
+ */
+extern _X_EXPORT void
+xf86_cursors_fini (ScreenPtr screen);
+
+/*
+ * For overlay video, compute the relevant CRTC and
+ * clip video to that.
+ * wraps xf86XVClipVideoHelper()
+ */
+
+extern _X_EXPORT Bool
+xf86_crtc_clip_video_helper(ScrnInfoPtr pScrn,
+			    xf86CrtcPtr *crtc_ret,
+			    xf86CrtcPtr desired_crtc,
+			    BoxPtr      dst,
+			    INT32	*xa,
+			    INT32	*xb,
+			    INT32	*ya,
+			    INT32	*yb,
+			    RegionPtr   reg,
+			    INT32	width,
+			    INT32	height);
+    
+extern _X_EXPORT xf86_crtc_notify_proc_ptr
+xf86_wrap_crtc_notify (ScreenPtr pScreen, xf86_crtc_notify_proc_ptr new);
+
+extern _X_EXPORT void
+xf86_unwrap_crtc_notify(ScreenPtr pScreen, xf86_crtc_notify_proc_ptr old);
+
+extern _X_EXPORT void
+xf86_crtc_notify(ScreenPtr pScreen);
+
+/**
+ * Gamma
+ */
+
+extern _X_EXPORT Bool
+xf86_crtc_supports_gamma(ScrnInfoPtr pScrn);
+
+#endif /* _XF86CRTC_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Optrec.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Optrec.h
@@ -0,0 +1,112 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/* 
+ * This file contains the Option Record that is passed between the Parser,
+ * and Module setup procs.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86Optrec_h_
+#define _xf86Optrec_h_
+#include <stdio.h>
+#include <string.h>
+
+#include <X11/Xfuncproto.h>
+
+/* 
+ * all records that need to be linked lists should contain a GenericList as
+ * their first field.
+ */
+typedef struct generic_list_rec
+{
+	void *next;
+}
+GenericListRec, *GenericListPtr, *glp;
+
+/*
+ * All options are stored using this data type.
+ */
+typedef struct
+{
+	GenericListRec list;
+	char *opt_name;
+	char *opt_val;
+	int opt_used;
+	char *opt_comment;
+}
+XF86OptionRec, *XF86OptionPtr;
+
+
+extern _X_EXPORT XF86OptionPtr xf86addNewOption(XF86OptionPtr head, char *name, char *val);
+extern _X_EXPORT XF86OptionPtr xf86optionListDup(XF86OptionPtr opt);
+extern _X_EXPORT void xf86optionListFree(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86optionName(XF86OptionPtr opt);
+extern _X_EXPORT char *xf86optionValue(XF86OptionPtr opt);
+extern _X_EXPORT XF86OptionPtr xf86newOption(char *name, char *value);
+extern _X_EXPORT XF86OptionPtr xf86nextOption(XF86OptionPtr list);
+extern _X_EXPORT XF86OptionPtr xf86findOption(XF86OptionPtr list, const char *name);
+extern _X_EXPORT char *xf86findOptionValue(XF86OptionPtr list, const char *name);
+extern _X_EXPORT XF86OptionPtr xf86optionListCreate(const char **options, int count, int used);
+extern _X_EXPORT XF86OptionPtr xf86optionListMerge(XF86OptionPtr head, XF86OptionPtr tail);
+extern _X_EXPORT int xf86nameCompare (const char *s1, const char *s2);
+extern _X_EXPORT char *xf86uLongToString(unsigned long i);
+extern _X_EXPORT XF86OptionPtr xf86parseOption(XF86OptionPtr head);
+extern _X_EXPORT void xf86printOptionList(FILE *fp, XF86OptionPtr list, int tabs);
+
+
+#endif /* _xf86Optrec_h_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbrop.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbrop.h
@@ -0,0 +1,136 @@
+/*
+ * Copyright © 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _FBROP_H_
+#define _FBROP_H_
+
+typedef struct _mergeRopBits {
+    FbBits   ca1, cx1, ca2, cx2;
+} FbMergeRopRec, *FbMergeRopPtr;
+
+extern _X_EXPORT const FbMergeRopRec	FbMergeRopBits[16];
+
+#define FbDeclareMergeRop() FbBits   _ca1, _cx1, _ca2, _cx2;
+#define FbDeclarePrebuiltMergeRop()	FbBits	_cca, _ccx;
+
+#define FbInitializeMergeRop(alu,pm) {\
+    const FbMergeRopRec  *_bits; \
+    _bits = &FbMergeRopBits[alu]; \
+    _ca1 = _bits->ca1 &  pm; \
+    _cx1 = _bits->cx1 | ~pm; \
+    _ca2 = _bits->ca2 &  pm; \
+    _cx2 = _bits->cx2 &  pm; \
+}
+
+#define FbDestInvarientRop(alu,pm)  ((pm) == FB_ALLONES && \
+				     (((alu) >> 1 & 5) == ((alu) & 5)))
+
+#define FbDestInvarientMergeRop()   (_ca1 == 0 && _cx1 == 0)
+
+/* AND has higher precedence than XOR */
+
+#define FbDoMergeRop(src, dst) \
+    (((dst) & (((src) & _ca1) ^ _cx1)) ^ (((src) & _ca2) ^ _cx2))
+
+#define FbDoDestInvarientMergeRop(src)	(((src) & _ca2) ^ _cx2)
+
+#define FbDoMaskMergeRop(src, dst, mask) \
+    (((dst) & ((((src) & _ca1) ^ _cx1) | ~(mask))) ^ ((((src) & _ca2) ^ _cx2) & (mask)))
+
+#define FbDoLeftMaskByteMergeRop(dst, src, lb, l) { \
+    FbBits  __xor = ((src) & _ca2) ^ _cx2; \
+    FbDoLeftMaskByteRRop(dst,lb,l,((src) & _ca1) ^ _cx1,__xor); \
+}
+
+#define FbDoRightMaskByteMergeRop(dst, src, rb, r) { \
+    FbBits  __xor = ((src) & _ca2) ^ _cx2; \
+    FbDoRightMaskByteRRop(dst,rb,r,((src) & _ca1) ^ _cx1,__xor); \
+}
+
+#define FbDoRRop(dst, and, xor)	(((dst) & (and)) ^ (xor))
+
+#define FbDoMaskRRop(dst, and, xor, mask) \
+    (((dst) & ((and) | ~(mask))) ^ (xor & mask))
+
+/*
+ * Take a single bit (0 or 1) and generate a full mask
+ */
+#define fbFillFromBit(b,t)	(~((t) ((b) & 1)-1))
+
+#define fbXorT(rop,fg,pm,t) ((((fg) & fbFillFromBit((rop) >> 1,t)) | \
+			      (~(fg) & fbFillFromBit((rop) >> 3,t))) & (pm))
+
+#define fbAndT(rop,fg,pm,t) ((((fg) & fbFillFromBit (rop ^ (rop>>1),t)) | \
+			      (~(fg) & fbFillFromBit((rop>>2) ^ (rop>>3),t))) | \
+			     ~(pm))
+
+#define fbXor(rop,fg,pm)	fbXorT(rop,fg,pm,FbBits)
+
+#define fbAnd(rop,fg,pm)	fbAndT(rop,fg,pm,FbBits)
+
+#define fbXorStip(rop,fg,pm)    fbXorT(rop,fg,pm,FbStip)
+
+#define fbAndStip(rop,fg,pm)	fbAndT(rop,fg,pm,FbStip)
+
+/*
+ * Stippling operations; 
+ */
+
+extern _X_EXPORT const FbBits	fbStipple16Bits[256];	/* half of table */
+#define FbStipple16Bits(b) \
+    (fbStipple16Bits[(b)&0xff] | fbStipple16Bits[(b) >> 8] << FB_HALFUNIT)
+extern _X_EXPORT const FbBits	fbStipple8Bits[256];
+extern _X_EXPORT const FbBits	fbStipple4Bits[16];
+extern _X_EXPORT const FbBits	fbStipple2Bits[4];
+extern _X_EXPORT const FbBits	fbStipple1Bits[2];
+extern _X_EXPORT const FbBits	*const fbStippleTable[];
+
+#define FbStippleRRop(dst, b, fa, fx, ba, bx) \
+    (FbDoRRop(dst, fa, fx) & b) | (FbDoRRop(dst, ba, bx) & ~b)
+
+#define FbStippleRRopMask(dst, b, fa, fx, ba, bx, m) \
+    (FbDoMaskRRop(dst, fa, fx, m) & (b)) | (FbDoMaskRRop(dst, ba, bx, m) & ~(b))
+						       
+#define FbDoLeftMaskByteStippleRRop(dst, b, fa, fx, ba, bx, lb, l) { \
+    FbBits  __xor = ((fx) & (b)) | ((bx) & ~(b)); \
+    FbDoLeftMaskByteRRop(dst, lb, l, ((fa) & (b)) | ((ba) & ~(b)), __xor); \
+}
+
+#define FbDoRightMaskByteStippleRRop(dst, b, fa, fx, ba, bx, rb, r) { \
+    FbBits  __xor = ((fx) & (b)) | ((bx) & ~(b)); \
+    FbDoRightMaskByteRRop(dst, rb, r, ((fa) & (b)) | ((ba) & ~(b)), __xor); \
+}
+
+#define FbOpaqueStipple(b, fg, bg) (((fg) & (b)) | ((bg) & ~(b)))
+    
+/*
+ * Compute rop for using tile code for 1-bit dest stipples; modifies
+ * existing rop to flip depending on pixel values
+ */
+#define FbStipple1RopPick(alu,b)    (((alu) >> (2 - (((b) & 1) << 1))) & 3)
+
+#define FbOpaqueStipple1Rop(alu,fg,bg)    (FbStipple1RopPick(alu,fg) | \
+					   (FbStipple1RopPick(alu,bg) << 2))
+
+#define FbStipple1Rop(alu,fg)	    (FbStipple1RopPick(alu,fg) | 4)
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bt829.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bt829.h
@@ -0,0 +1,99 @@
+#ifndef __BT829_H__
+#define __BT829_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+	int 		tunertype;	/* Must be set before init */
+        /* Private variables */
+	I2CDevRec d;
+
+    	CARD8		brightness;
+    	CARD8 		ccmode;
+        CARD8           code;
+    	CARD16		contrast;
+    	CARD8		format;
+	int		height;
+    	CARD8		hue;
+        CARD8           len;
+    	CARD8		mux;
+    	CARD8           out_en;
+        CARD8           p_io;
+    	CARD16		sat_u;
+    	CARD16		sat_v;
+        CARD8           vbien;
+        CARD8           vbifmt;
+	int 		width;
+
+    	CARD16		hdelay;
+        CARD16		hscale;
+    	CARD16		vactive;
+    	CARD16		vdelay;
+        CARD16		vscale;
+
+        CARD16          htotal;
+    	CARD8		id;
+    	CARD8		svideo_mux;
+} BT829Rec, *BT829Ptr;
+
+#define xf86_bt829_Detect	bt829_Detect
+extern _X_EXPORT BT829Ptr bt829_Detect(I2CBusPtr b, I2CSlaveAddr addr);
+
+/* ATI card specific initialization */
+#define BT829_ATI_ADDR_1	0x8A
+#define BT829_ATI_ADDR_2	0x88
+
+#define xf86_bt829_ATIInit	bt829_ATIInit
+extern _X_EXPORT int bt829_ATIInit(BT829Ptr bt);
+
+#define BT829_NTSC		1	/* NTSC-M */
+#define BT829_NTSC_JAPAN	2	/* NTSC-Japan */
+#define BT829_PAL		3	/* PAL-B,D,G,H,I */
+#define BT829_PAL_M		4	/* PAL-M */
+#define BT829_PAL_N		5	/* PAL-N */
+#define BT829_SECAM		6	/* SECAM */
+#define BT829_PAL_N_COMB	7	/* PAL-N combination */
+
+#define xf86_bt829_SetFormat	bt829_SetFormat
+extern _X_EXPORT int bt829_SetFormat(BT829Ptr bt, CARD8 format);
+
+#define BT829_MUX2	1	/* ATI -> composite video */
+#define BT829_MUX0	2	/* ATI -> tv tuner */
+#define BT829_MUX1	3	/* ATI -> s-video */
+
+#define xf86_bt829_SetMux	bt829_SetMux
+extern _X_EXPORT int bt829_SetMux(BT829Ptr bt, CARD8 mux);
+
+#define xf86_bt829_SetCaptSize		bt829_SetCaptSize
+extern _X_EXPORT int bt829_SetCaptSize(BT829Ptr bt, int width, int height);
+
+#define xf86_bt829_SetBrightness	bt829_SetBrightness
+extern _X_EXPORT void bt829_SetBrightness(BT829Ptr bt, int brightness);
+#define xf86_bt829_SetContrast		bt829_SetContrast
+extern _X_EXPORT void bt829_SetContrast(BT829Ptr bt, int contrast);
+#define xf86_bt829_SetSaturation	bt829_SetSaturation
+extern _X_EXPORT void bt829_SetSaturation(BT829Ptr bt, int saturation);
+#define xf86_bt829_SetTint		bt829_SetTint
+extern _X_EXPORT void bt829_SetTint(BT829Ptr bt, int hue);	 /* Hue */
+
+#define xf86_bt829_SetOUT_EN		bt829_SetOUT_EN
+extern _X_EXPORT void bt829_SetOUT_EN(BT829Ptr bt, BOOL out_en);/* VPOLE register */
+#define xf86_bt829_SetP_IO		bt829_SetP_IO
+extern _X_EXPORT void bt829_SetP_IO(BT829Ptr bt, CARD8 p_io);	 /* P_IO register */
+
+extern _X_EXPORT int bt829_SetCC(BT829Ptr bt);
+
+#define BT829SymbolsList   \
+		"bt829_Detect", \
+		"bt829_ATIInit", \
+		"bt829_SetFormat", \
+		"bt829_SetMux", \
+		"bt829_SetBrightness", \
+		"bt829_SetContrast", \
+		"bt829_SetSaturation", \
+		"bt829_SetTint", \
+		"bt829_SetCaptSize", \
+		"bt829_SetOUT_EN", \
+		"bt829_SetP_IO"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipointrst.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipointrst.h
@@ -0,0 +1,56 @@
+/*
+ * mipointrst.h
+ *
+ */
+
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef MIPOINTRST_H
+#define MIPOINTRST_H
+
+#include "mipointer.h"
+#include "scrnintstr.h"
+
+typedef struct {
+    ScreenPtr		    pScreen;    /* current screen */
+    ScreenPtr		    pSpriteScreen;/* screen containing current sprite */
+    CursorPtr		    pCursor;    /* current cursor */
+    CursorPtr		    pSpriteCursor;/* cursor on screen */
+    BoxRec		    limits;	/* current constraints */
+    Bool		    confined;	/* pointer can't change screens */
+    int			    x, y;	/* hot spot location */
+    int			    devx, devy;	/* sprite position */
+} miPointerRec, *miPointerPtr;
+
+typedef struct {
+    miPointerSpriteFuncPtr  spriteFuncs;	/* sprite-specific methods */
+    miPointerScreenFuncPtr  screenFuncs;	/* screen-specific methods */
+    CloseScreenProcPtr	    CloseScreen;
+    Bool		    waitForUpdate;	/* don't move cursor in SIGIO */
+    Bool		    showTransparent;	/* show empty cursors */
+} miPointerScreenRec, *miPointerScreenPtr;
+#endif /* MIPOINTRST_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/registry.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/registry.h
@@ -0,0 +1,64 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_REGISTRY_H
+#define DIX_REGISTRY_H
+
+/*
+ * Result returned from any unsuccessful lookup
+ */
+#define XREGISTRY_UNKNOWN "<unknown>"
+
+#ifdef XREGISTRY
+
+#include "resource.h"
+#include "extnsionst.h"
+
+/* Internal string registry - for auditing, debugging, security, etc. */
+
+/*
+ * Registration functions.  The name string is not copied, so it must
+ * not be a stack variable.
+ */
+extern _X_EXPORT void RegisterResourceName(RESTYPE type, char *name);
+extern _X_EXPORT void RegisterExtensionNames(ExtensionEntry *ext);
+
+/*
+ * Lookup functions.  The returned string must not be modified or freed.
+ */
+extern _X_EXPORT const char *LookupMajorName(int major);
+extern _X_EXPORT const char *LookupRequestName(int major, int minor);
+extern _X_EXPORT const char *LookupEventName(int event);
+extern _X_EXPORT const char *LookupErrorName(int error);
+extern _X_EXPORT const char *LookupResourceName(RESTYPE rtype);
+
+/*
+ * Setup and teardown
+ */
+extern _X_EXPORT void dixResetRegistry(void);
+
+#else /* XREGISTRY */
+
+/* Define calls away when the registry is not being built. */
+
+#define RegisterResourceName(a, b) { ; }
+#define RegisterExtensionNames(a) { ; }
+
+#define LookupMajorName(a) XREGISTRY_UNKNOWN
+#define LookupRequestName(a, b) XREGISTRY_UNKNOWN
+#define LookupEventName(a) XREGISTRY_UNKNOWN
+#define LookupErrorName(a) XREGISTRY_UNKNOWN
+#define LookupResourceName(a) XREGISTRY_UNKNOWN
+
+#define dixResetRegistry() { ; }
+
+#endif /* XREGISTRY */
+#endif /* DIX_REGISTRY_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Pci.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Pci.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright 1998 by Concurrent Computer Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Concurrent Computer
+ * Corporation not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Concurrent Computer Corporation makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Copyright 1998 by Metro Link Incorporated
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Metro Link
+ * Incorporated not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Metro Link Incorporated makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * This file is derived in part from the original xf86_PCI.h that included
+ * following copyright message:
+ *
+ * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holder(s)
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holder(s) make(s) no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/*
+ * This file has the private Pci definitions.  The public ones are imported
+ * from xf86Pci.h.  Drivers should not use this file.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _PCI_H
+#define _PCI_H 1
+
+#include "xf86Pci.h"
+#include "xf86PciInfo.h"
+
+/*
+ * Global Definitions
+ */
+#if (defined(__alpha__) || defined(__ia64__)) && defined (linux)
+#define PCI_DOM_MASK	0x01fful
+#else
+#define PCI_DOM_MASK 0x0ffu
+#endif
+
+#ifndef PCI_DOM_MASK
+# define PCI_DOM_MASK 0x0ffu
+#endif
+#define PCI_DOMBUS_MASK (((PCI_DOM_MASK) << 8) | 0x0ffu)
+
+/*
+ * "b" contains an optional domain number.
+ */
+#define PCI_MAKE_TAG(b,d,f)  ((((b) & (PCI_DOMBUS_MASK)) << 16) | \
+			      (((d) & 0x00001fu) << 11) | \
+			      (((f) & 0x000007u) << 8))
+
+#define PCI_MAKE_BUS(d,b)    ((((d) & (PCI_DOM_MASK)) << 8) | ((b) & 0xffu))
+
+#define PCI_DOM_FROM_TAG(tag)  (((tag) >> 24) & (PCI_DOM_MASK))
+#define PCI_BUS_FROM_TAG(tag)  (((tag) >> 16) & (PCI_DOMBUS_MASK))
+#define PCI_DEV_FROM_TAG(tag)  (((tag) & 0x0000f800u) >> 11)
+#define PCI_FUNC_FROM_TAG(tag) (((tag) & 0x00000700u) >> 8)
+
+#define PCI_DOM_FROM_BUS(bus)  (((bus) >> 8) & (PCI_DOM_MASK))
+#define PCI_BUS_NO_DOMAIN(bus) ((bus) & 0xffu)
+#define PCI_TAG_NO_DOMAIN(tag) ((tag) & 0x00ffff00u)
+
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
+	defined(__OpenBSD__) || defined(__NetBSD__) || \
+	defined(__DragonFly__) || defined(__sun) || defined(__GNU__)
+#define ARCH_PCI_INIT bsdPciInit
+#endif
+
+#if defined(linux)
+#define ARCH_PCI_INIT linuxPciInit
+#endif /* defined(linux) */
+
+#ifndef ARCH_PCI_INIT
+#error No PCI support available for this architecture/OS combination
+#endif
+
+extern void ARCH_PCI_INIT(void);
+
+#endif /* _PCI_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxdpms.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxdpms.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Author:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for DPMS extension support.  \see dmxdpms.c */
+
+#ifndef _DMXDPMS_H_
+#define _DMXDPMS_H_
+extern void dmxDPMSInit(DMXScreenInfo *dmxScreen);
+extern void dmxDPMSTerm(DMXScreenInfo *dmxScreen);
+extern void dmxDPMSWakeup(void); /* Call when input is processed */
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getselev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getselev.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETSELEV_H
+#define GETSELEV_H 1
+
+int SProcXGetSelectedExtensionEvents(ClientPtr	/* client */
+    );
+
+int ProcXGetSelectedExtensionEvents(ClientPtr	/* client */
+    );
+
+void SRepXGetSelectedExtensionEvents(ClientPtr /* client */ ,
+				     int /* size */ ,
+				     xGetSelectedExtensionEventsReply *	/* rep */
+    );
+
+#endif /* GETSELEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-ms.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-ms.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux MS mouse driver.  \see lnx-ms.c */
+
+#ifndef _LNX_MS_H_
+#define _LNX_MS_H_
+
+extern pointer msLinuxCreatePrivate(DeviceIntPtr pMouse);
+extern void    msLinuxDestroyPrivate(pointer priv);
+extern void    msLinuxRead(DevicePtr pDev,
+                           dmxMotionProcPtr motion,
+                           dmxEnqueueProcPtr enqueue,
+                           dmxCheckSpecialProcPtr checkspecial,
+                           DMXBlockType block);
+extern void    msLinuxInit(DevicePtr pDev);
+extern void    msLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     msLinuxOn(DevicePtr pDev);
+extern void    msLinuxOff(DevicePtr pDev);
+extern void    msLinuxCtrl(DevicePtr pDev, PtrCtrl *ctrl);
+extern void    msLinuxVTPreSwitch(pointer p);
+extern void    msLinuxVTPostSwitch(pointer p);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rrtransform.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rrtransform.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright © 2007 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _RRTRANSFORM_H_
+#define _RRTRANSFORM_H_
+
+#include <X11/extensions/randr.h>
+#include "picturestr.h"
+
+typedef struct _rrTransform	RRTransformRec, *RRTransformPtr;
+
+struct _rrTransform {
+    PictTransform   transform;
+    struct pict_f_transform f_transform;
+    struct pict_f_transform f_inverse;
+    PictFilterPtr   filter;
+    xFixed	    *params;
+    int		    nparams;
+    int		    width;
+    int		    height;
+};
+
+extern _X_EXPORT void
+RRTransformInit (RRTransformPtr transform);
+
+extern _X_EXPORT void
+RRTransformFini (RRTransformPtr transform);
+
+extern _X_EXPORT Bool
+RRTransformEqual (RRTransformPtr a, RRTransformPtr b);
+
+extern _X_EXPORT Bool
+RRTransformSetFilter (RRTransformPtr	dst,
+		      PictFilterPtr	filter,
+		      xFixed		*params,
+		      int		nparams,
+		      int		width,
+		      int		height);
+
+extern _X_EXPORT Bool
+RRTransformCopy (RRTransformPtr dst, RRTransformPtr src);
+
+extern _X_EXPORT Bool
+RRTransformCompute (int			    x,
+		    int			    y,
+		    int			    width,
+		    int			    height,
+		    Rotation		    rotation,
+		    RRTransformPtr	    rr_transform,
+
+		    PictTransformPtr	    transform,
+		    struct pict_f_transform *f_transform,
+		    struct pict_f_transform *f_inverse);
+
+
+#endif /* _RRTRANSFORM_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxwindow.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxwindow.h
@@ -0,0 +1,135 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for window support.  \see dmxwindow.c */
+
+#ifndef DMXWINDOW_H
+#define DMXWINDOW_H
+
+#include "windowstr.h"
+
+/** Window private area. */
+typedef struct _dmxWinPriv {
+    Window         window;
+    Bool           offscreen;
+    Bool           mapped;
+    Bool           restacked;
+    unsigned long  attribMask;
+    Colormap       cmap;
+    Visual        *visual;
+    Bool           isShaped;
+    Bool           hasPict;
+#ifdef GLXEXT
+    void          *swapGroup;
+    int            barrier;
+    void         (*windowDestroyed)(WindowPtr);
+    void         (*windowUnmapped)(WindowPtr);
+#endif
+} dmxWinPrivRec, *dmxWinPrivPtr;
+
+
+extern Bool dmxInitWindow(ScreenPtr pScreen);
+
+extern Window dmxCreateRootWindow(WindowPtr pWindow);
+
+extern void dmxGetDefaultWindowAttributes(WindowPtr pWindow,
+					  Colormap *cmap,
+					  Visual **visual);
+extern void dmxCreateAndRealizeWindow(WindowPtr pWindow, Bool doSync);
+
+extern Bool dmxCreateWindow(WindowPtr pWindow);
+extern Bool dmxDestroyWindow(WindowPtr pWindow);
+extern Bool dmxPositionWindow(WindowPtr pWindow, int x, int y);
+extern Bool dmxChangeWindowAttributes(WindowPtr pWindow, unsigned long mask);
+extern Bool dmxRealizeWindow(WindowPtr pWindow);
+extern Bool dmxUnrealizeWindow(WindowPtr pWindow);
+extern void dmxRestackWindow(WindowPtr pWindow, WindowPtr pOldNextSib);
+extern void dmxWindowExposures(WindowPtr pWindow, RegionPtr prgn,
+			       RegionPtr other_exposed);
+extern void dmxCopyWindow(WindowPtr pWindow, DDXPointRec ptOldOrg,
+			  RegionPtr prgnSrc);
+
+extern void dmxResizeWindow(WindowPtr pWindow, int x, int y,
+			    unsigned int w, unsigned int h, WindowPtr pSib);
+extern void dmxReparentWindow(WindowPtr pWindow, WindowPtr pPriorParent);
+
+extern void dmxChangeBorderWidth(WindowPtr pWindow, unsigned int width);
+
+extern void dmxResizeScreenWindow(ScreenPtr pScreen,
+				  int x, int y, int w, int h);
+extern void dmxResizeRootWindow(WindowPtr pRoot,
+				int x, int y, int w, int h);
+
+extern Bool dmxBEDestroyWindow(WindowPtr pWindow);
+
+/* Support for shape extension */
+extern void dmxSetShape(WindowPtr pWindow, int kind);
+
+/** Get window private pointer. */
+#define DMX_GET_WINDOW_PRIV(_pWin) ((dmxWinPrivPtr) \
+    dixLookupPrivate(&(_pWin)->devPrivates, dmxWinPrivateKey))
+
+/* All of these macros are only used in dmxwindow.c */
+#define DMX_WINDOW_FUNC_PROLOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_UNWRAP(funcs, pGCPriv, (_pGC));					\
+    if (pGCPriv->ops)							\
+	DMX_UNWRAP(ops, pGCPriv, (_pGC));				\
+} while (0)
+
+#define DMX_WINDOW_FUNC_EPILOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_WRAP(funcs, &dmxGCFuncs, pGCPriv, (_pGC));			\
+    if (pGCPriv->ops)							\
+	DMX_WRAP(ops, &dmxGCOps, pGCPriv, (_pGC));			\
+} while (0)
+
+#define DMX_WINDOW_X1(_pWin)						\
+    ((_pWin)->drawable.x - wBorderWidth(_pWin))
+#define DMX_WINDOW_Y1(_pWin)						\
+    ((_pWin)->drawable.y - wBorderWidth(_pWin))
+#define DMX_WINDOW_X2(_pWin)						\
+    ((_pWin)->drawable.x + wBorderWidth(_pWin) + (_pWin)->drawable.width) 
+#define DMX_WINDOW_Y2(_pWin)						\
+    ((_pWin)->drawable.y + wBorderWidth(_pWin) + (_pWin)->drawable.height) 
+
+#define DMX_WINDOW_OFFSCREEN(_pWin)					\
+    (DMX_WINDOW_X1(_pWin) >= (_pWin)->drawable.pScreen->width  ||	\
+     DMX_WINDOW_Y1(_pWin) >= (_pWin)->drawable.pScreen->height ||	\
+     DMX_WINDOW_X2(_pWin) <= 0                                 ||	\
+     DMX_WINDOW_Y2(_pWin) <= 0)
+
+#endif /* DMXWINDOW_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xichangecursor.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xichangecursor.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHDEVCUR_H
+#define CHDEVCUR_H 1
+
+int SProcXIChangeCursor(ClientPtr /* client */);
+int ProcXIChangeCursor(ClientPtr /* client */);
+
+#endif /* CHDEVCUR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/property.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/property.h
@@ -0,0 +1,91 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PROPERTY_H
+#define PROPERTY_H 
+
+#include "window.h"
+
+typedef struct _Property *PropertyPtr;
+
+extern _X_EXPORT int dixLookupProperty(
+    PropertyPtr * /*result*/,
+    WindowPtr /*pWin*/,
+    Atom /*proprty*/,
+    ClientPtr /*pClient*/,
+    Mask /*access_mode*/);
+
+extern _X_EXPORT int dixChangeWindowProperty(
+    ClientPtr /*pClient*/,
+    WindowPtr /*pWin*/,
+    Atom /*property*/,
+    Atom /*type*/,
+    int /*format*/,
+    int /*mode*/,
+    unsigned long /*len*/,
+    pointer /*value*/,
+    Bool /*sendevent*/);
+
+extern _X_EXPORT int ChangeWindowProperty(
+    WindowPtr /*pWin*/,
+    Atom /*property*/,
+    Atom /*type*/,
+    int /*format*/,
+    int /*mode*/,
+    unsigned long /*len*/,
+    pointer /*value*/,
+    Bool /*sendevent*/);
+
+extern _X_EXPORT int DeleteProperty(
+    ClientPtr /*client*/,
+    WindowPtr /*pWin*/,
+    Atom /*propName*/);
+
+extern _X_EXPORT void DeleteAllWindowProperties(
+    WindowPtr /*pWin*/);
+
+#endif  /* PROPERTY_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbdevhw.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbdevhw.h
@@ -0,0 +1,64 @@
+
+#ifndef _FBDEVHW_H_
+#define _FBDEVHW_H_
+
+#include "xf86str.h"
+#include "colormapst.h"
+
+#include <pciaccess.h>
+
+#define FBDEVHW_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FBDEVHW_PLANES			1	/* Non interleaved planes */
+#define FBDEVHW_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FBDEVHW_TEXT			3	/* Text/attributes	*/
+#define FBDEVHW_VGA_PLANES		4	/* EGA/VGA planes       */
+
+extern _X_EXPORT Bool  fbdevHWGetRec(ScrnInfoPtr pScrn);
+extern _X_EXPORT void  fbdevHWFreeRec(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT int   fbdevHWGetFD(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT Bool  fbdevHWProbe(struct pci_device * pPci, char *device, char **namep);
+extern _X_EXPORT Bool  fbdevHWInit(ScrnInfoPtr pScrn, struct pci_device * pPci, char *device);
+
+extern _X_EXPORT char* fbdevHWGetName(ScrnInfoPtr pScrn);
+extern _X_EXPORT int   fbdevHWGetDepth(ScrnInfoPtr pScrn, int *fbbpp);
+extern _X_EXPORT int   fbdevHWGetLineLength(ScrnInfoPtr pScrn);
+extern _X_EXPORT int   fbdevHWGetType(ScrnInfoPtr pScrn);
+extern _X_EXPORT int   fbdevHWGetVidmem(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void* fbdevHWMapVidmem(ScrnInfoPtr pScrn);
+extern _X_EXPORT int   fbdevHWLinearOffset(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool  fbdevHWUnmapVidmem(ScrnInfoPtr pScrn);
+extern _X_EXPORT void* fbdevHWMapMMIO(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool  fbdevHWUnmapMMIO(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void  fbdevHWSetVideoModes(ScrnInfoPtr pScrn);
+extern _X_EXPORT DisplayModePtr fbdevHWGetBuildinMode(ScrnInfoPtr pScrn);
+extern _X_EXPORT void  fbdevHWUseBuildinMode(ScrnInfoPtr pScrn);
+extern _X_EXPORT Bool  fbdevHWModeInit(ScrnInfoPtr pScrn, DisplayModePtr mode);
+extern _X_EXPORT void  fbdevHWSave(ScrnInfoPtr pScrn);
+extern _X_EXPORT void  fbdevHWRestore(ScrnInfoPtr pScrn);
+
+extern _X_EXPORT void  fbdevHWLoadPalette(ScrnInfoPtr pScrn, int numColors, int *indices,
+		 LOCO *colors, VisualPtr pVisual);
+
+extern _X_EXPORT ModeStatus fbdevHWValidMode(int scrnIndex, DisplayModePtr mode, Bool verbose, int flags);
+extern _X_EXPORT Bool  fbdevHWSwitchMode(int scrnIndex, DisplayModePtr mode, int flags);
+extern _X_EXPORT void  fbdevHWAdjustFrame(int scrnIndex, int x, int y, int flags);
+extern _X_EXPORT Bool  fbdevHWEnterVT(int scrnIndex, int flags);
+extern _X_EXPORT void  fbdevHWLeaveVT(int scrnIndex, int flags);
+extern _X_EXPORT void  fbdevHWDPMSSet(ScrnInfoPtr pScrn, int mode, int flags);
+
+extern _X_EXPORT Bool  fbdevHWSaveScreen(ScreenPtr pScreen, int mode);
+
+extern _X_EXPORT xf86SwitchModeProc	*fbdevHWSwitchModeWeak(void);
+extern _X_EXPORT xf86AdjustFrameProc	*fbdevHWAdjustFrameWeak(void);
+extern _X_EXPORT xf86EnterVTProc	*fbdevHWEnterVTWeak(void);
+extern _X_EXPORT xf86LeaveVTProc	*fbdevHWLeaveVTWeak(void);
+extern _X_EXPORT xf86ValidModeProc	*fbdevHWValidModeWeak(void);
+extern _X_EXPORT xf86DPMSSetProc	*fbdevHWDPMSSetWeak(void);
+extern _X_EXPORT xf86LoadPaletteProc	*fbdevHWLoadPaletteWeak(void);
+extern _X_EXPORT SaveScreenProcPtr	fbdevHWSaveScreenWeak(void);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dlloader.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dlloader.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright 1997 Metro Link, Inc.
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Metro Link, Inc. not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Metro Link, Inc. makes no
+ * representations about the suitability of this software for any purpose.
+ *  It is provided "as is" without express or implied warranty.
+ *
+ * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _DLLOADER_H
+#define _DLLOADER_H
+
+extern void *DLLoadModule(loaderPtr, int flags);
+extern void DLUnloadModule(void *);
+extern void *DLFindSymbol(const char *name);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Cursor.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Cursor.h
@@ -0,0 +1,51 @@
+
+#ifndef _XF86CURSOR_H
+#define _XF86CURSOR_H
+
+#include "xf86str.h"
+#include "mipointer.h"
+
+typedef struct _xf86CursorInfoRec {
+    ScrnInfoPtr pScrn;
+    int Flags;
+    int MaxWidth;
+    int MaxHeight;
+    void (*SetCursorColors)(ScrnInfoPtr pScrn, int bg, int fg);
+    void (*SetCursorPosition)(ScrnInfoPtr pScrn, int x, int y);
+    void (*LoadCursorImage)(ScrnInfoPtr pScrn, unsigned char *bits);
+    void (*HideCursor)(ScrnInfoPtr pScrn);
+    void (*ShowCursor)(ScrnInfoPtr pScrn);
+    unsigned char* (*RealizeCursor)(struct _xf86CursorInfoRec *, CursorPtr);
+    Bool (*UseHWCursor)(ScreenPtr, CursorPtr);
+
+#ifdef ARGB_CURSOR
+    Bool (*UseHWCursorARGB) (ScreenPtr, CursorPtr);
+    void (*LoadCursorARGB) (ScrnInfoPtr, CursorPtr);
+#endif
+
+} xf86CursorInfoRec, *xf86CursorInfoPtr;
+
+extern _X_EXPORT Bool xf86InitCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT xf86CursorInfoPtr xf86CreateCursorInfoRec(void);
+extern _X_EXPORT void xf86DestroyCursorInfoRec(xf86CursorInfoPtr);
+extern _X_EXPORT void xf86ForceHWCursor (ScreenPtr pScreen, Bool on);
+
+#define HARDWARE_CURSOR_INVERT_MASK 			0x00000001
+#define HARDWARE_CURSOR_AND_SOURCE_WITH_MASK		0x00000002
+#define HARDWARE_CURSOR_SWAP_SOURCE_AND_MASK		0x00000004
+#define HARDWARE_CURSOR_SOURCE_MASK_NOT_INTERLEAVED	0x00000008
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_1	0x00000010
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_8	0x00000020
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_16	0x00000040
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_32	0x00000080
+#define HARDWARE_CURSOR_SOURCE_MASK_INTERLEAVE_64	0x00000100
+#define HARDWARE_CURSOR_TRUECOLOR_AT_8BPP		0x00000200
+#define HARDWARE_CURSOR_BIT_ORDER_MSBFIRST		0x00000400
+#define HARDWARE_CURSOR_NIBBLE_SWAPPED			0x00000800
+#define HARDWARE_CURSOR_SHOW_TRANSPARENT		0x00001000
+#define HARDWARE_CURSOR_UPDATE_UNHIDDEN			0x00002000
+#ifdef ARGB_CURSOR
+#define HARDWARE_CURSOR_ARGB				0x00004000
+#endif
+
+#endif /* _XF86CURSOR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixstruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dixstruct.h
@@ -0,0 +1,190 @@
+/***********************************************************
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIXSTRUCT_H
+#define DIXSTRUCT_H
+
+#include "dix.h"
+#include "resource.h"
+#include "cursor.h"
+#include "gc.h"
+#include "pixmap.h"
+#include "privates.h"
+#include <X11/Xmd.h>
+
+/*
+ * 	direct-mapped hash table, used by resource manager to store
+ *      translation from client ids to server addresses.
+ */
+
+extern _X_EXPORT CallbackListPtr ClientStateCallback;
+
+typedef struct {
+    ClientPtr 		client;
+    xConnSetupPrefix 	*prefix; 
+    xConnSetup  	*setup;
+} NewClientInfoRec;
+
+typedef void (*ReplySwapPtr) (
+		ClientPtr	/* pClient */,
+		int		/* size */,
+		void *		/* pbuf */);
+
+extern _X_EXPORT void ReplyNotSwappd (
+		ClientPtr	/* pClient */,
+		int		/* size */,
+		void *		/* pbuf */) _X_NORETURN;
+
+typedef enum {ClientStateInitial,
+	      ClientStateAuthenticating,
+	      ClientStateRunning,
+	      ClientStateRetained,
+	      ClientStateGone,
+	      ClientStateCheckingSecurity,
+	      ClientStateCheckedSecurity} ClientState;
+
+#ifdef XFIXES
+typedef struct _saveSet {
+    struct _Window  *windowPtr;
+    Bool	    toRoot;
+    Bool	    map;
+} SaveSetElt;
+#define SaveSetWindow(ss)   ((ss).windowPtr)
+#define SaveSetToRoot(ss)   ((ss).toRoot)
+#define SaveSetShouldMap(ss)	    ((ss).map)
+#define SaveSetAssignWindow(ss,w)   ((ss).windowPtr = (w))
+#define SaveSetAssignToRoot(ss,tr)  ((ss).toRoot = (tr))
+#define SaveSetAssignMap(ss,m)      ((ss).map = (m))
+#else
+typedef struct _Window *SaveSetElt;
+#define SaveSetWindow(ss)   (ss)
+#define SaveSetToRoot(ss)   FALSE
+#define SaveSetShouldMap(ss)	    TRUE
+#define SaveSetAssignWindow(ss,w)   ((ss) = (w))
+#define SaveSetAssignToRoot(ss,tr)
+#define SaveSetAssignMap(ss,m)
+#endif
+
+typedef struct _Client {
+    int         index;
+    Mask        clientAsMask;
+    pointer     requestBuffer;
+    pointer     osPrivate;	/* for OS layer, including scheduler */
+    Bool        swapped;
+    ReplySwapPtr pSwapReplyFunc;
+    XID         errorValue;
+    int         sequence;
+    int         closeDownMode;
+    int         clientGone;
+    int         noClientException;	/* this client died or needs to be
+					 * killed */
+    int         ignoreCount;		/* count for Attend/IgnoreClient */
+    SaveSetElt	*saveSet;
+    int         numSaved;
+    int         (**requestVector) (
+		ClientPtr /* pClient */);
+    CARD32	req_len;		/* length of current request */
+    Bool	big_requests;		/* supports large requests */
+    int		priority;
+    ClientState clientState;
+    PrivateRec	*devPrivates;
+    unsigned short	xkbClientFlags;
+    unsigned short	mapNotifyMask;
+    unsigned short	newKeyboardNotifyMask;
+    unsigned short	vMajor,vMinor;
+    KeyCode		minKC,maxKC;
+
+    unsigned long replyBytesRemaining;
+    int	    smart_priority;
+    long    smart_start_tick;
+    long    smart_stop_tick;
+    long    smart_check_tick;
+    
+    DeviceIntPtr clientPtr;
+}           ClientRec;
+
+/*
+ * Scheduling interface
+ */
+extern _X_EXPORT long SmartScheduleTime;
+extern _X_EXPORT long SmartScheduleInterval;
+extern _X_EXPORT long SmartScheduleSlice;
+extern _X_EXPORT long SmartScheduleMaxSlice;
+extern _X_EXPORT Bool SmartScheduleDisable;
+extern _X_EXPORT void SmartScheduleStartTimer(void);
+extern _X_EXPORT void SmartScheduleStopTimer(void);
+#define SMART_MAX_PRIORITY  (20)
+#define SMART_MIN_PRIORITY  (-20)
+
+extern _X_EXPORT Bool SmartScheduleInit(void);
+
+
+/* This prototype is used pervasively in Xext, dix */
+#define DISPATCH_PROC(func) int func(ClientPtr /* client */)
+
+typedef struct _WorkQueue {
+    struct _WorkQueue *next;
+    Bool        (*function) (
+		ClientPtr	/* pClient */,
+		pointer		/* closure */
+);
+    ClientPtr   client;
+    pointer     closure;
+}           WorkQueueRec;
+
+extern _X_EXPORT TimeStamp currentTime;
+extern _X_EXPORT TimeStamp lastDeviceEventTime;
+
+extern _X_EXPORT int CompareTimeStamps(
+    TimeStamp /*a*/,
+    TimeStamp /*b*/);
+
+extern _X_EXPORT TimeStamp ClientTimeToServerTime(CARD32 /*c*/);
+
+typedef struct _CallbackRec {
+  CallbackProcPtr proc;
+  pointer data;
+  Bool deleted;
+  struct _CallbackRec *next;
+} CallbackRec, *CallbackPtr;
+
+typedef struct _CallbackList {
+  int inCallback;
+  Bool deleted;
+  int numDeleted;
+  CallbackPtr list;
+} CallbackListRec;
+
+/* proc vectors */
+
+extern _X_EXPORT int (* InitialVector[3]) (ClientPtr /*client*/);
+
+extern _X_EXPORT int (* ProcVector[256]) (ClientPtr /*client*/);
+
+extern _X_EXPORT int (* SwappedProcVector[256]) (ClientPtr /*client*/);
+
+extern _X_EXPORT ReplySwapPtr ReplySwapVector[256];
+
+extern _X_EXPORT int ProcBadRequest(ClientPtr /*client*/);
+
+#endif				/* DIXSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/screenint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/screenint.h
@@ -0,0 +1,69 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SCREENINT_H
+#define SCREENINT_H
+
+#include "misc.h"
+
+typedef struct _PixmapFormat *PixmapFormatPtr;
+typedef struct _Visual *VisualPtr;
+typedef struct _Depth  *DepthPtr;
+typedef struct _Screen *ScreenPtr;
+
+extern _X_EXPORT int AddScreen(
+    Bool (* /*pfnInit*/)(
+	int /*index*/,
+	ScreenPtr /*pScreen*/,
+	int /*argc*/,
+	char ** /*argv*/),
+    int /*argc*/,
+    char** /*argv*/);
+
+typedef struct _ColormapRec *ColormapPtr;
+
+#endif /* SCREENINT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bstore.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bstore.h
@@ -0,0 +1,22 @@
+/*
+ * Copyright (c) 1987 by the Regents of the University of California
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies.  The University of
+ * California makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ */
+
+/*
+ * Moved here from mi to allow wrapping of lower level backing store functions.
+ * -- 1997.10.27  Marc Aurele La France (tsi@xfree86.org)
+ */
+
+#ifndef _BSTORE_H_
+#define _BSTORE_H_
+
+#include "bstorestr.h"
+
+#endif /* _BSTORE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damageext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damageext.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright © 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGEEXT_H_
+#define _DAMAGEEXT_H_
+
+void
+DamageExtensionInit(void);
+
+#endif /* _DAMAGEEXT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/input.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/input.h
@@ -0,0 +1,563 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+#ifndef INPUT_H
+#define INPUT_H
+
+#include "misc.h"
+#include "screenint.h"
+#include <X11/Xmd.h>
+#include <X11/Xproto.h>
+#include <stdint.h>
+#include "window.h"     /* for WindowPtr */
+#include "xkbrules.h"
+#include "events.h"
+
+#define DEVICE_INIT	0
+#define DEVICE_ON	1
+#define DEVICE_OFF	2
+#define DEVICE_CLOSE	3
+
+#define POINTER_RELATIVE (1 << 1)
+#define POINTER_ABSOLUTE (1 << 2)
+#define POINTER_ACCELERATE (1 << 3)
+#define POINTER_SCREEN (1 << 4) /* Data in screen coordinates */
+
+/*int constants for pointer acceleration schemes*/
+#define PtrAccelNoOp            0
+#define PtrAccelPredictable     1
+#define PtrAccelLightweight     2
+#define PtrAccelDefault         PtrAccelPredictable
+
+#define MAX_VALUATORS 36
+/* Maximum number of valuators, divided by six, rounded up, to get number
+ * of events. */
+#define MAX_VALUATOR_EVENTS 6
+#define MAX_BUTTONS 256 /* completely arbitrarily chosen */
+
+#define NO_AXIS_LIMITS -1
+
+#define MAP_LENGTH	256
+#define DOWN_LENGTH	32	/* 256/8 => number of bytes to hold 256 bits */
+#define NullGrab ((GrabPtr)NULL)
+#define PointerRootWin ((WindowPtr)PointerRoot)
+#define NoneWin ((WindowPtr)None)
+#define NullDevice ((DevicePtr)NULL)
+
+#ifndef FollowKeyboard
+#define FollowKeyboard 		3
+#endif
+#ifndef FollowKeyboardWin
+#define FollowKeyboardWin  ((WindowPtr) FollowKeyboard)
+#endif
+#ifndef RevertToFollowKeyboard
+#define RevertToFollowKeyboard	3
+#endif
+
+typedef unsigned long Leds;
+typedef struct _OtherClients *OtherClientsPtr;
+typedef struct _InputClients *InputClientsPtr;
+typedef struct _DeviceIntRec *DeviceIntPtr;
+typedef struct _ClassesRec *ClassesPtr;
+typedef union _GrabMask GrabMask;
+
+typedef struct _EventList {
+    xEvent* event;
+    int evlen; /* length of allocated memory for event in bytes.  This is not
+                  the actual length of the event. The event's actual length is
+                  32 for standard events or 32 +
+                  ((xGenericEvent*)event)->length * 4 for GenericEvents.
+                  For events in the EQ, the length is
+                  ((InternalEvent*)event)->u.any.length */
+} EventList, *EventListPtr;
+
+/* The DIX stores incoming input events in this list */
+extern EventListPtr InputEventList;
+extern int InputEventListLen;
+
+typedef int (*DeviceProc)(
+    DeviceIntPtr /*device*/,
+    int /*what*/);
+
+typedef void (*ProcessInputProc)(
+    InternalEvent * /*event*/,
+    DeviceIntPtr /*device*/);
+
+typedef Bool (*DeviceHandleProc)(
+    DeviceIntPtr /*device*/,
+    void* /*data*/
+    );
+
+typedef void (*DeviceUnwrapProc)(
+    DeviceIntPtr /*device*/,
+    DeviceHandleProc /*proc*/,
+    void* /*data*/
+    );
+
+/* pointer acceleration handling */
+typedef void (*PointerAccelSchemeProc)(
+    DeviceIntPtr /*pDev*/,
+    int /*first_valuator*/,
+    int /*num_valuators*/,
+    int* /*valuators*/,
+    int /*evtime*/);
+
+typedef void (*DeviceCallbackProc)(
+              DeviceIntPtr /*pDev*/);
+
+typedef struct _DeviceRec {
+    pointer	devicePrivate;
+    ProcessInputProc processInputProc;	/* current */
+    ProcessInputProc realInputProc;	/* deliver */
+    ProcessInputProc enqueueInputProc;	/* enqueue */
+    Bool	on;			/* used by DDX to keep state */
+} DeviceRec, *DevicePtr;
+
+typedef struct {
+    int			click, bell, bell_pitch, bell_duration;
+    Bool		autoRepeat;
+    unsigned char	autoRepeats[32];
+    Leds		leds;
+    unsigned char	id;
+} KeybdCtrl;
+
+typedef struct {
+    KeySym  *map;
+    KeyCode minKeyCode,
+	    maxKeyCode;
+    int     mapWidth;
+} KeySymsRec, *KeySymsPtr;
+
+typedef struct {
+    int		num, den, threshold;
+    unsigned char id;
+} PtrCtrl;
+
+typedef struct {
+    int         resolution, min_value, max_value;
+    int         integer_displayed;
+    unsigned char id;
+} IntegerCtrl;
+
+typedef struct {
+    int         max_symbols, num_symbols_supported;
+    int         num_symbols_displayed;
+    KeySym      *symbols_supported;
+    KeySym      *symbols_displayed;
+    unsigned char id;
+} StringCtrl;
+
+typedef struct {
+    int         percent, pitch, duration;
+    unsigned char id;
+} BellCtrl;
+
+typedef struct {
+    Leds        led_values;
+    Mask        led_mask;
+    unsigned char id;
+} LedCtrl;
+
+extern _X_EXPORT KeybdCtrl	defaultKeyboardControl;
+extern _X_EXPORT PtrCtrl	defaultPointerControl;
+
+typedef struct _InputOption {
+    char                *key;
+    char                *value;
+    struct _InputOption *next;
+} InputOption;
+
+typedef struct _InputAttributes {
+    char                *product;
+    char                *vendor;
+    char                *device;
+    char                *pnp_id;
+    char                *usb_id;
+    char                **tags; /* null-terminated */
+    uint32_t            flags;
+} InputAttributes;
+
+#define ATTR_KEYBOARD (1<<0)
+#define ATTR_POINTER (1<<1)
+#define ATTR_JOYSTICK (1<<2)
+#define ATTR_TABLET (1<<3)
+#define ATTR_TOUCHPAD (1<<4)
+#define ATTR_TOUCHSCREEN (1<<5)
+
+/* Key/Button has been run through all input processing and events sent to clients. */
+#define KEY_PROCESSED 1
+#define BUTTON_PROCESSED 1
+/* Key/Button has not been fully processed, no events have been sent. */
+#define KEY_POSTED 2
+#define BUTTON_POSTED 2
+
+extern void set_key_down(DeviceIntPtr pDev, int key_code, int type);
+extern void set_key_up(DeviceIntPtr pDev, int key_code, int type);
+extern int key_is_down(DeviceIntPtr pDev, int key_code, int type);
+extern void set_button_down(DeviceIntPtr pDev, int button, int type);
+extern void set_button_up(DeviceIntPtr pDev, int button, int type);
+extern int button_is_down(DeviceIntPtr pDev, int button, int type);
+
+extern void InitCoreDevices(void);
+extern void InitXTestDevices(void);
+
+extern _X_EXPORT DeviceIntPtr AddInputDevice(
+    ClientPtr /*client*/,
+    DeviceProc /*deviceProc*/,
+    Bool /*autoStart*/);
+
+extern _X_EXPORT Bool EnableDevice(
+    DeviceIntPtr /*device*/,
+    BOOL /* sendevent */);
+
+extern _X_EXPORT Bool ActivateDevice(
+    DeviceIntPtr /*device*/,
+    BOOL /* sendevent */);
+
+extern _X_EXPORT Bool DisableDevice(
+    DeviceIntPtr /*device*/,
+    BOOL /* sendevent */);
+
+extern int InitAndStartDevices(void);
+
+extern void CloseDownDevices(void);
+
+extern void UndisplayDevices(void);
+
+extern _X_EXPORT int RemoveDevice(
+    DeviceIntPtr /*dev*/,
+    BOOL /* sendevent */);
+
+extern _X_EXPORT int NumMotionEvents(void);
+
+extern void RegisterPointerDevice(
+    DeviceIntPtr /*device*/);
+
+extern void RegisterKeyboardDevice(
+    DeviceIntPtr /*device*/);
+
+extern _X_EXPORT int dixLookupDevice(
+    DeviceIntPtr *         /* dev */,
+    int                    /* id */,
+    ClientPtr              /* client */,
+    Mask                   /* access_mode */);
+
+extern _X_EXPORT void QueryMinMaxKeyCodes(
+    KeyCode* /*minCode*/,
+    KeyCode* /*maxCode*/);
+
+extern _X_EXPORT Bool SetKeySymsMap(
+    KeySymsPtr /*dst*/,
+    KeySymsPtr /*src*/);
+
+extern _X_EXPORT Bool InitButtonClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    int /*numButtons*/,
+    Atom* /* labels */,
+    CARD8* /*map*/);
+
+extern _X_EXPORT Bool InitValuatorClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    int /*numAxes*/,
+    Atom* /* labels */,
+    int /*numMotionEvents*/,
+    int /*mode*/);
+
+extern _X_EXPORT Bool InitPointerAccelerationScheme(
+    DeviceIntPtr /*dev*/,
+    int /*scheme*/);
+
+extern _X_EXPORT Bool InitAbsoluteClassDeviceStruct(
+    DeviceIntPtr /*device*/);
+
+extern _X_EXPORT Bool InitFocusClassDeviceStruct(
+    DeviceIntPtr /*device*/);
+
+typedef void (*BellProcPtr)(
+    int /*percent*/,
+    DeviceIntPtr /*device*/,
+    pointer /*ctrl*/,
+    int);
+
+typedef void (*KbdCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    KeybdCtrl * /*ctrl*/);
+
+typedef void (*PtrCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    PtrCtrl * /*ctrl*/);
+
+extern _X_EXPORT Bool InitPtrFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    PtrCtrlProcPtr /*controlProc*/);
+
+typedef void (*StringCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    StringCtrl * /*ctrl*/);
+
+extern _X_EXPORT Bool InitStringFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    StringCtrlProcPtr /*controlProc*/,
+    int /*max_symbols*/,
+    int /*num_symbols_supported*/,
+    KeySym* /*symbols*/);
+
+typedef void (*BellCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    BellCtrl * /*ctrl*/);
+
+extern _X_EXPORT Bool InitBellFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    BellProcPtr /*bellProc*/,
+    BellCtrlProcPtr /*controlProc*/);
+
+typedef void (*LedCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    LedCtrl * /*ctrl*/);
+
+extern _X_EXPORT Bool InitLedFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    LedCtrlProcPtr /*controlProc*/);
+
+typedef void (*IntegerCtrlProcPtr)(
+    DeviceIntPtr /*device*/,
+    IntegerCtrl * /*ctrl*/);
+
+
+extern _X_EXPORT Bool InitIntegerFeedbackClassDeviceStruct(
+    DeviceIntPtr /*device*/,
+    IntegerCtrlProcPtr /*controlProc*/);
+
+extern _X_EXPORT Bool InitPointerDeviceStruct(
+    DevicePtr /*device*/,
+    CARD8* /*map*/,
+    int /*numButtons*/,
+    Atom* /* btn_labels */,
+    PtrCtrlProcPtr /*controlProc*/,
+    int /*numMotionEvents*/,
+    int /*numAxes*/,
+    Atom* /* axes_labels */);
+
+extern _X_EXPORT Bool InitKeyboardDeviceStruct(
+    DeviceIntPtr /*device*/,
+    XkbRMLVOSet * /*rmlvo*/,
+    BellProcPtr /*bellProc*/,
+    KbdCtrlProcPtr /*controlProc*/);
+
+extern int ApplyPointerMapping(
+    DeviceIntPtr /* pDev */,
+    CARD8 *      /* map */,
+    int          /* len */,
+    ClientPtr	/* client */);
+
+extern Bool BadDeviceMap(
+    BYTE* /*buff*/,
+    int /*length*/,
+    unsigned /*low*/,
+    unsigned /*high*/,
+    XID* /*errval*/);
+
+extern void NoteLedState(
+    DeviceIntPtr /*keybd*/,
+    int /*led*/,
+    Bool /*on*/);
+
+extern void MaybeStopHint(
+    DeviceIntPtr /*device*/,
+    ClientPtr /*client*/);
+
+extern void ProcessPointerEvent(
+    InternalEvent* /* ev */,
+    DeviceIntPtr /*mouse*/);
+
+extern void ProcessKeyboardEvent(
+    InternalEvent* /*ev*/,
+    DeviceIntPtr   /*keybd*/);
+
+extern Bool LegalModifier(
+    unsigned int /*key*/, 
+    DeviceIntPtr /*pDev*/);
+
+extern _X_EXPORT void ProcessInputEvents(void);
+
+extern _X_EXPORT void InitInput(
+    int  /*argc*/,
+    char ** /*argv*/);
+extern _X_EXPORT void CloseInput(void);
+
+extern _X_EXPORT int GetMaximumEventsNum(void);
+
+extern _X_EXPORT int GetEventList(EventListPtr* list);
+extern _X_EXPORT EventListPtr InitEventList(int num_events);
+extern _X_EXPORT void FreeEventList(EventListPtr list, int num_events);
+
+extern void CreateClassesChangedEvent(EventListPtr event,
+                                      DeviceIntPtr master,
+                                      DeviceIntPtr slave,
+                                      int type);
+extern EventListPtr UpdateFromMaster(
+    EventListPtr events,
+    DeviceIntPtr pDev,
+    int type,
+    int *num_events);
+
+extern _X_EXPORT int GetPointerEvents(
+    EventListPtr events,
+    DeviceIntPtr pDev,
+    int type,
+    int buttons,
+    int flags,
+    int first_valuator,
+    int num_valuators,
+    int *valuators);
+
+extern _X_EXPORT int GetKeyboardEvents(
+    EventListPtr events,
+    DeviceIntPtr pDev,
+    int type,
+    int key_code);
+
+extern int GetKeyboardValuatorEvents(
+    EventListPtr events,
+    DeviceIntPtr pDev,
+    int type,
+    int key_code,
+    int first_valuator,
+    int num_valuator,
+    int *valuators);
+
+extern int GetProximityEvents(
+    EventListPtr events,
+    DeviceIntPtr pDev,
+    int type,
+    int first_valuator,
+    int num_valuators,
+    int *valuators);
+
+extern void PostSyntheticMotion(
+    DeviceIntPtr pDev,
+    int x,
+    int y,
+    int screen,
+    unsigned long time);
+
+extern _X_EXPORT int GetMotionHistorySize(
+    void);
+
+extern _X_EXPORT void AllocateMotionHistory(
+    DeviceIntPtr pDev);
+
+extern _X_EXPORT int GetMotionHistory(
+    DeviceIntPtr pDev,
+    xTimecoord **buff,
+    unsigned long start,
+    unsigned long stop,
+    ScreenPtr pScreen,
+    BOOL core);
+
+extern int AttachDevice(ClientPtr client,
+                        DeviceIntPtr slave,
+                        DeviceIntPtr master);
+
+extern _X_EXPORT DeviceIntPtr GetPairedDevice(DeviceIntPtr kbd);
+extern DeviceIntPtr GetMaster(DeviceIntPtr dev, int type);
+
+extern _X_EXPORT int AllocDevicePair(ClientPtr client,
+                             char* name,
+                             DeviceIntPtr* ptr,
+                             DeviceIntPtr* keybd,
+                             DeviceProc ptr_proc,
+                             DeviceProc keybd_proc,
+                             Bool master);
+extern void DeepCopyDeviceClasses(DeviceIntPtr from,
+                                  DeviceIntPtr to,
+                                  DeviceChangedEvent *dce);
+
+/* Helper functions. */
+extern _X_EXPORT int generate_modkeymap(ClientPtr client, DeviceIntPtr dev,
+                              KeyCode **modkeymap, int *max_keys_per_mod);
+extern int change_modmap(ClientPtr client, DeviceIntPtr dev, KeyCode *map,
+                         int max_keys_per_mod);
+extern int AllocXTestDevice(ClientPtr client,
+                             char* name,
+                             DeviceIntPtr* ptr,
+                             DeviceIntPtr* keybd,
+                             DeviceIntPtr master_ptr,
+                             DeviceIntPtr master_keybd);
+extern BOOL IsXTestDevice(DeviceIntPtr dev, DeviceIntPtr master);
+extern DeviceIntPtr GetXTestDevice(DeviceIntPtr master);
+extern void SendDevicePresenceEvent(int deviceid, int type);
+extern _X_EXPORT InputAttributes *DuplicateInputAttributes(InputAttributes *attrs);
+extern _X_EXPORT void FreeInputAttributes(InputAttributes *attrs);
+
+/* misc event helpers */
+extern Mask GetEventFilter(DeviceIntPtr dev, xEvent *event);
+extern Mask GetWindowXI2Mask(DeviceIntPtr dev, WindowPtr win, xEvent* ev);
+void FixUpEventFromWindow(DeviceIntPtr pDev,
+                          xEvent *xE,
+                          WindowPtr pWin,
+                          Window child,
+                          Bool calcChild);
+
+/* Implemented by the DDX. */
+extern _X_EXPORT int NewInputDeviceRequest(
+    InputOption *options,
+    InputAttributes *attrs,
+    DeviceIntPtr *dev);
+extern  _X_EXPORT void DeleteInputDeviceRequest(
+    DeviceIntPtr dev);
+
+extern _X_EXPORT void DDXRingBell(
+    int volume,
+    int pitch,
+    int duration);
+
+/* Set to TRUE by default - os/utils.c sets it to FALSE on user request,
+   xfixes/cursor.c uses it to determine if the cursor is enabled */
+extern Bool EnableCursor;
+
+#endif /* INPUT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Module.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Module.h
@@ -0,0 +1,212 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains the parts of the loader interface that are visible
+ * to modules.  This is the only loader-related header that modules should
+ * include.
+ *
+ * It should include a bare minimum of other headers.
+ *
+ * Longer term, the module/loader code should probably live directly under
+ * Xserver/.
+ *
+ * XXX This file arguably belongs in xfree86/loader/.
+ */
+
+#ifndef _XF86MODULE_H
+#define _XF86MODULE_H
+
+#include "misc.h"
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+typedef enum {
+    LD_RESOLV_IFDONE		= 0,	/* only check if no more
+					   delays pending */
+    LD_RESOLV_NOW		= 1,	/* finish one delay step */
+    LD_RESOLV_FORCE		= 2	/* force checking... */
+} LoaderResolveOptions;
+
+#define DEFAULT_LIST ((char *)-1)
+
+/* This indicates a special module that doesn't have the usual entry point */
+#define EXTERN_MODULE ((pointer)-1)
+
+/* Built-in ABI classes.  These definitions must not be changed. */
+#define ABI_CLASS_NONE		NULL
+#define ABI_CLASS_ANSIC		"X.Org ANSI C Emulation"
+#define ABI_CLASS_VIDEODRV	"X.Org Video Driver"
+#define ABI_CLASS_XINPUT	"X.Org XInput driver"
+#define ABI_CLASS_EXTENSION	"X.Org Server Extension"
+#define ABI_CLASS_FONT		"X.Org Font Renderer"
+
+#define ABI_MINOR_MASK		0x0000FFFF
+#define ABI_MAJOR_MASK		0xFFFF0000
+#define GET_ABI_MINOR(v)	((v) & ABI_MINOR_MASK)
+#define GET_ABI_MAJOR(v)	(((v) & ABI_MAJOR_MASK) >> 16)
+#define SET_ABI_VERSION(maj, min) \
+		((((maj) << 16) & ABI_MAJOR_MASK) | ((min) & ABI_MINOR_MASK))
+
+/*
+ * ABI versions.  Each version has a major and minor revision.  Modules
+ * using lower minor revisions must work with servers of a higher minor
+ * revision.  There is no compatibility between different major revisions.
+ * Whenever the ABI_ANSIC_VERSION is changed, the others must also be
+ * changed.  The minor revision mask is 0x0000FFFF and the major revision
+ * mask is 0xFFFF0000.
+ */
+#define ABI_ANSIC_VERSION	SET_ABI_VERSION(0, 4)
+#define ABI_VIDEODRV_VERSION	SET_ABI_VERSION(8, 0)
+#define ABI_XINPUT_VERSION	SET_ABI_VERSION(11, 0)
+#define ABI_EXTENSION_VERSION	SET_ABI_VERSION(4, 0)
+#define ABI_FONT_VERSION	SET_ABI_VERSION(0, 6)
+
+#define MODINFOSTRING1	0xef23fdc5
+#define MODINFOSTRING2	0x10dc023a
+
+#ifndef MODULEVENDORSTRING
+#define MODULEVENDORSTRING	"X.Org Foundation"
+#endif
+
+/* Error return codes for errmaj.  New codes must only be added at the end. */
+typedef enum {
+    LDR_NOERROR = 0,
+    LDR_NOMEM,		/* memory allocation failed */
+    LDR_NOENT,		/* Module file does not exist */
+    LDR_NOSUBENT,	/* pre-requsite file to be sub-loaded does not exist */
+    LDR_NOSPACE,	/* internal module array full */
+    LDR_NOMODOPEN,	/* module file could not be opened (check errmin) */
+    LDR_UNKTYPE,	/* file is not a recognized module type */
+    LDR_NOLOAD,		/* type specific loader failed */
+    LDR_ONCEONLY,	/* Module should only be loaded once (not an error) */
+    LDR_NOPORTOPEN,	/* could not open port (check errmin) */
+    LDR_NOHARDWARE,	/* could not query/initialize the hardware device */
+    LDR_MISMATCH,	/* the module didn't match the spec'd requirments */
+    LDR_BADUSAGE,	/* LoadModule is called with bad arguments */
+    LDR_INVALID,	/* The module doesn't have a valid ModuleData object */
+    LDR_BADOS,		/* The module doesn't support the OS */
+    LDR_MODSPECIFIC	/* A module-specific error in the SetupProc */
+} LoaderErrorCode;
+
+/*
+ * Some common module classes.  The moduleclass can be used to identify
+ * that modules loaded are of the correct type.  This is a finer
+ * classification than the ABI classes even though the default set of
+ * classes have the same names.  For example, not all modules that require
+ * the video driver ABI are themselves video drivers.
+ */
+#define MOD_CLASS_NONE		NULL
+#define MOD_CLASS_VIDEODRV	"X.Org Video Driver"
+#define MOD_CLASS_XINPUT	"X.Org XInput Driver"
+#define MOD_CLASS_FONT		"X.Org Font Renderer"
+#define MOD_CLASS_EXTENSION	"X.Org Server Extension"
+
+/* This structure is expected to be returned by the initfunc */
+typedef struct {
+    const char * modname;	/* name of module, e.g. "foo" */
+    const char * vendor;	/* vendor specific string */
+    CARD32	 _modinfo1_;	/* constant MODINFOSTRING1/2 to find */
+    CARD32	 _modinfo2_;	/* infoarea with a binary editor or sign tool */
+    CARD32	 xf86version;	/* contains XF86_VERSION_CURRENT */
+    CARD8	 majorversion;	/* module-specific major version */
+    CARD8	 minorversion;	/* module-specific minor version */
+    CARD16	 patchlevel;	/* module-specific patch level */
+    const char * abiclass;	/* ABI class that the module uses */
+    CARD32	 abiversion;	/* ABI version */
+    const char * moduleclass;	/* module class description */
+    CARD32	 checksum[4];	/* contains a digital signature of the */
+				/* version info structure */
+} XF86ModuleVersionInfo;
+
+/*
+ * This structure can be used to callers of LoadModule and LoadSubModule to
+ * specify version and/or ABI requirements.
+ */
+typedef struct {
+    CARD8	 majorversion;	/* module-specific major version */
+    CARD8	 minorversion;	/* moudle-specific minor version */
+    CARD16	 patchlevel;	/* module-specific patch level */
+    const char * abiclass;	/* ABI class that the module uses */
+    CARD32	 abiversion;	/* ABI version */
+    const char * moduleclass;	/* module class */
+} XF86ModReqInfo;
+
+/* values to indicate unspecified fields in XF86ModReqInfo. */
+#define MAJOR_UNSPEC		0xFF
+#define MINOR_UNSPEC		0xFF
+#define PATCH_UNSPEC		0xFFFF
+#define ABI_VERS_UNSPEC		0xFFFFFFFF
+
+#define MODULE_VERSION_NUMERIC(maj, min, patch) \
+	((((maj) & 0xFF) << 24) | (((min) & 0xFF) << 16) | (patch & 0xFFFF))
+#define GET_MODULE_MAJOR_VERSION(vers)	(((vers) >> 24) & 0xFF)
+#define GET_MODULE_MINOR_VERSION(vers)	(((vers) >> 16) & 0xFF)
+#define GET_MODULE_PATCHLEVEL(vers)	((vers) & 0xFFFF)
+
+#define INITARGS void
+
+typedef void (*InitExtension)(INITARGS);
+
+typedef struct {
+    InitExtension	initFunc;
+    const char *	name;
+    Bool		*disablePtr;
+    InitExtension	setupFunc;	
+    const char **	initDependencies;
+} ExtensionModule;
+
+extern _X_EXPORT ExtensionModule *ExtensionModuleList;
+
+/* Prototypes for Loader functions that are exported to modules */
+extern _X_EXPORT pointer LoadSubModule(pointer, const char *, const char **,
+		      const char **, pointer, const XF86ModReqInfo *,
+		      int *, int *);
+extern _X_EXPORT void UnloadSubModule(pointer);
+extern _X_EXPORT void UnloadModule (pointer);
+extern _X_EXPORT pointer LoaderSymbol(const char *);
+extern _X_EXPORT char **LoaderListDirs(const char **, const char **);
+extern _X_EXPORT void LoaderFreeDirList(char **);
+extern _X_EXPORT void LoaderErrorMsg(const char *, const char *, int, int);
+extern _X_EXPORT void LoadExtension(ExtensionModule *, Bool);
+extern _X_EXPORT void LoaderGetOS(const char **name, int *major, int *minor, int *teeny);
+extern _X_EXPORT Bool LoaderShouldIgnoreABI(void);
+extern _X_EXPORT int LoaderGetABIVersion(const char *abiclass);
+
+typedef pointer (*ModuleSetupProc)(pointer, pointer, int *, int *);
+typedef void (*ModuleTearDownProc)(pointer);
+#define MODULESETUPPROTO(func) pointer func(pointer, pointer, int*, int*)
+#define MODULETEARDOWNPROTO(func) void func(pointer)
+
+typedef struct {
+    XF86ModuleVersionInfo *	vers;
+    ModuleSetupProc		setup;
+    ModuleTearDownProc		teardown;
+} XF86ModuleData;
+
+#endif /* _XF86STR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxgc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxgc.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for GC support.  \see dmxgc.c */
+
+#ifndef DMXGC_H
+#define DMXGC_H
+
+#include "gcstruct.h"
+
+/** GC private area. */
+typedef struct _dmxGCPriv {
+    GCOps   *ops;
+    GCFuncs *funcs;
+    XlibGC   gc;
+    Bool     msc;
+} dmxGCPrivRec, *dmxGCPrivPtr;
+
+
+extern Bool dmxInitGC(ScreenPtr pScreen);
+
+extern Bool dmxCreateGC(GCPtr pGC);
+extern void dmxValidateGC(GCPtr pGC, unsigned long changes,
+			  DrawablePtr pDrawable);
+extern void dmxChangeGC(GCPtr pGC, unsigned long mask);
+extern void dmxCopyGC(GCPtr pGCSrc, unsigned long changes, GCPtr pGCDst);
+extern void dmxDestroyGC(GCPtr pGC);
+extern void dmxChangeClip(GCPtr pGC, int type, pointer pvalue, int nrects);
+extern void dmxDestroyClip(GCPtr pGC);
+extern void dmxCopyClip(GCPtr pGCDst, GCPtr pGCSrc);
+
+extern void dmxBECreateGC(ScreenPtr pScreen, GCPtr pGC);
+extern Bool dmxBEFreeGC(GCPtr pGC);
+
+/** Get private. */
+#define DMX_GET_GC_PRIV(_pGC)						\
+    (dmxGCPrivPtr)dixLookupPrivate(&(_pGC)->devPrivates, dmxGCPrivateKey)
+
+#define DMX_GC_FUNC_PROLOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr _pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_UNWRAP(funcs, _pGCPriv, (_pGC));				\
+    if (_pGCPriv->ops)							\
+	DMX_UNWRAP(ops, _pGCPriv, (_pGC));				\
+} while (0)
+
+#define DMX_GC_FUNC_EPILOGUE(_pGC)					\
+do {									\
+    dmxGCPrivPtr _pGCPriv = DMX_GET_GC_PRIV(_pGC);			\
+    DMX_WRAP(funcs, &dmxGCFuncs, _pGCPriv, (_pGC));			\
+    if (_pGCPriv->ops)							\
+	DMX_WRAP(ops, &dmxGCOps, _pGCPriv, (_pGC));			\
+} while (0)
+
+#endif /* DMXGC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-ps2.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-ps2.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux PS/2 mouse driver.  \see lnx-ps2.c */
+
+#ifndef _LNX_PS2_H_
+#define _LNX_PS2_H_
+
+extern pointer ps2LinuxCreatePrivate(DeviceIntPtr pMouse);
+extern void    ps2LinuxDestroyPrivate(pointer priv);
+extern void    ps2LinuxRead(DevicePtr pDev,
+                            dmxMotionProcPtr motion,
+                            dmxEnqueueProcPtr enqueue,
+                            dmxCheckSpecialProcPtr checkspecial,
+                            DMXBlockType block);
+extern void    ps2LinuxInit(DevicePtr pDev);
+extern void    ps2LinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     ps2LinuxOn(DevicePtr pDev);
+extern void    ps2LinuxOff(DevicePtr pDev);
+extern void    ps2LinuxCtrl(DevicePtr pDev, PtrCtrl *ctrl);
+extern void    ps2LinuxVTPreSwitch(pointer p);
+extern void    ps2LinuxVTPostSwitch(pointer p);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closedev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closedev.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CLOSEDEV_H
+#define CLOSEDEV_H 1
+
+int SProcXCloseDevice(ClientPtr	/* client */
+    );
+
+int ProcXCloseDevice(ClientPtr	/* client */
+    );
+
+#endif /* CLOSEDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgdctl.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgdctl.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGDCTL_H
+#define CHGDCTL_H 1
+
+int SProcXChangeDeviceControl(ClientPtr	/* client */
+    );
+
+int ProcXChangeDeviceControl(ClientPtr	/* client */
+    );
+
+void SRepXChangeDeviceControl(ClientPtr /* client */ ,
+			      int /* size */ ,
+			      xChangeDeviceControlReply *	/* rep */
+    );
+
+#endif /* CHGDCTL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/midbestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/midbestr.h
@@ -0,0 +1,79 @@
+/******************************************************************************
+ * 
+ * Copyright (c) 1994, 1995  Hewlett-Packard Company
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Hewlett-Packard
+ * Company shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Hewlett-Packard Company.
+ * 
+ *     Header file for users of machine-independent DBE code
+ * 
+ *****************************************************************************/
+
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef MIDBE_STRUCT_H
+#define MIDBE_STRUCT_H
+
+
+/* DEFINES */
+
+#define MI_DBE_WINDOW_PRIV_PRIV(pDbeWindowPriv) \
+    (!(pDbeWindowPriv) ? NULL : (MiDbeWindowPrivPrivPtr) \
+     dixLookupPrivate(&(pDbeWindowPriv)->devPrivates, miDbeWindowPrivPrivKey))
+
+#define MI_DBE_WINDOW_PRIV_PRIV_FROM_WINDOW(pWin)\
+    MI_DBE_WINDOW_PRIV_PRIV(DBE_WINDOW_PRIV(pWin))
+
+/* TYPEDEFS */
+
+typedef struct _MiDbeWindowPrivPrivRec
+{
+    /* Place machine-specific fields in here.
+     * Since this is mi code, we do not really have machine-specific fields.
+     */
+
+    /* Pointer to a drawable that contains the contents of the back buffer.
+     */
+    PixmapPtr		pBackBuffer;
+
+    /* Pointer to a drawable that contains the contents of the front buffer.
+     * This pointer is only used for the XdbeUntouched swap action.  For that
+     * swap action, we need to copy the front buffer (window) contents into
+     * this drawable, copy the contents of current back buffer drawable (the
+     * back buffer) into the window, swap the front and back drawable pointers,
+     * and then swap the drawable/resource associations in the resource
+     * database.
+     */
+    PixmapPtr		pFrontBuffer;
+
+    /* Pointer back to our window private with which we are associated. */
+    DbeWindowPrivPtr	pDbeWindowPriv;
+
+} MiDbeWindowPrivPrivRec, *MiDbeWindowPrivPrivPtr;
+
+#endif /* MIDBE_STRUCT_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damageextint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damageextint.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright © 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGEEXTINT_H_
+#define _DAMAGEEXTINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/damageproto.h>
+#include "windowstr.h"
+#include "selection.h"
+#include "scrnintstr.h"
+#include "damageext.h"
+#include "damage.h" 
+#include "xfixes.h"
+
+typedef struct _DamageClient {
+    CARD32	major_version;
+    CARD32	minor_version;
+    int		critical;
+} DamageClientRec, *DamageClientPtr;
+
+#define GetDamageClient(pClient) ((DamageClientPtr)dixLookupPrivate(&(pClient)->devPrivates, DamageClientPrivateKey))
+
+typedef struct _DamageExt {
+    DamagePtr		pDamage;
+    DrawablePtr		pDrawable;
+    DamageReportLevel	level;
+    ClientPtr		pClient;
+    XID			id;
+    XID			drawable;
+} DamageExtRec, *DamageExtPtr;
+
+#define VERIFY_DAMAGEEXT(pDamageExt, rid, client, mode) { \
+    int rc = dixLookupResourceByType((pointer *)&(pDamageExt), rid, \
+                                     DamageExtType, client, mode); \
+    if (rc != Success) \
+        return rc; \
+}
+
+void
+DamageExtSetCritical (ClientPtr pClient, Bool critical);
+
+#endif /* _DAMAGEEXTINT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mispans.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mispans.h
@@ -0,0 +1,92 @@
+/***********************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISPANS_H
+#define MISPANS_H
+
+typedef struct {
+    int         count;		/* number of spans		    */
+    DDXPointPtr points;		/* pointer to list of start points  */
+    int         *widths;	/* pointer to list of widths	    */
+} Spans;
+
+typedef struct {
+    int		size;		/* Total number of *Spans allocated	*/
+    int		count;		/* Number of *Spans actually in group   */
+    Spans       *group;		/* List of Spans			*/
+    int		ymin, ymax;	/* Min, max y values encountered	*/
+} SpanGroup;
+
+/* Initialize SpanGroup.  MUST BE DONE before use. */
+extern _X_EXPORT void miInitSpanGroup(
+    SpanGroup * /*spanGroup*/
+);
+
+/* Add a Spans to a SpanGroup. The spans MUST BE in y-sorted order */
+extern _X_EXPORT void miAppendSpans(
+    SpanGroup * /*spanGroup*/,
+    SpanGroup * /*otherGroup*/,
+    Spans * /*spans*/
+);
+
+/* Paint a span group, insuring that each pixel is painted at most once */
+extern _X_EXPORT void miFillUniqueSpanGroup(
+    DrawablePtr /*pDraw*/,
+    GCPtr /*pGC*/,
+    SpanGroup * /*spanGroup*/
+);
+
+/* Free up data in a span group.  MUST BE DONE or you'll suffer memory leaks */
+extern _X_EXPORT void miFreeSpanGroup(
+    SpanGroup * /*spanGroup*/
+);
+
+/* Rops which must use span groups */
+#define miSpansCarefulRop(rop)	(((rop) & 0xc) == 0x8 || ((rop) & 0x3) == 0x2)
+#define miSpansEasyRop(rop)	(!miSpansCarefulRop(rop))
+
+#endif /* MISPANS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mistruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mistruct.h
@@ -0,0 +1,63 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISTRUCT_H
+#define MISTRUCT_H
+
+#include "mi.h"
+#include "regionstr.h"
+
+/* information about dashes */
+typedef struct _miDash {
+    DDXPointRec	pt;
+    int		e1, e2;	/* keep these, so we don't have to do it again */
+    int		e;	/* bresenham error term for this point on line */
+    int		which;
+    int		newLine;/* 0 if part of same original line as previous dash */
+    } miDashRec;
+
+#endif /* MISTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Canvas.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Canvas.h
@@ -0,0 +1,55 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+Copyright 2002 Red Hat Inc., Durham, North Carolina.
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ * This file was originally taken from xc/lib/Xaw/Template.h
+ */
+
+#ifndef _Canvas_h
+#define _Canvas_h
+
+#include <X11/Intrinsic.h>
+
+#define XtNcanvasExposeCallback "canvasExposeCallback"
+#define XtCcanvasExposeCallback "CanvasExposeCallback"
+#define XtNcanvasResizeCallback "canvasResizeCallback"
+#define XtCcanvasResizeCallback "CanvasResizeCallback"
+
+typedef struct _CanvasClassRec *CanvasWidgetClass;
+typedef struct _CanvasRec *CanvasWidget;
+extern WidgetClass canvasWidgetClass;
+
+typedef struct _CanvasExposeDataRec {
+    Widget       w;
+    XEvent       *event;
+    Region       region;
+} CanvasExposeDataRec, *CanvasExposeDataPtr;
+
+#endif /* _Canvas_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbstr.h
@@ -0,0 +1,633 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBSTR_H_
+#define	_XKBSTR_H_
+
+#include <X11/extensions/XKB.h>
+
+#define	XkbCharToInt(v) ((int) ((v) & 0x80 ? ((v) | (~0xff)) : ((v) & 0x7f)))
+#define	XkbIntTo2Chars(i, h, l) ((h) = (i >> 8) & 0xff, (l) = (i) & 0xff)
+
+#if defined(WORD64) && defined(UNSIGNEDBITFIELDS)
+#define	Xkb2CharsToInt(h, l) ((int) ((h) & 0x80 ? \
+                              (((h) << 8) | (l) | (~0xffff)) : \
+                              (((h) << 8) | (l) & 0x7fff))
+#else
+#define	Xkb2CharsToInt(h,l)	((short)(((h)<<8)|(l)))
+#endif
+
+	/*
+	 * Common data structures and access macros
+	 */
+
+typedef struct _XkbStateRec {
+	unsigned char   group; /* base + latched + locked */
+	/* FIXME: Why are base + latched short and not char?? */
+	unsigned short  base_group; /* physically ... down? */
+	unsigned short  latched_group;
+	unsigned char   locked_group;
+
+	unsigned char   mods; /* base + latched + locked */
+	unsigned char   base_mods; /* physically down */
+	unsigned char   latched_mods;
+	unsigned char   locked_mods;
+
+	unsigned char   compat_state; /* mods + group for core state */
+
+	/* grab mods = all depressed and latched mods, _not_ locked mods */
+	unsigned char   grab_mods; /* grab mods minus internal mods */
+	unsigned char   compat_grab_mods; /* grab mods + group for core state,
+	                                     but not locked groups if
+                                             IgnoreGroupLocks set */
+
+	/* effective mods = all mods (depressed, latched, locked) */
+	unsigned char   lookup_mods; /* effective mods minus internal mods */
+	unsigned char   compat_lookup_mods; /* effective mods + group */
+
+	unsigned short  ptr_buttons; /* core pointer buttons */
+} XkbStateRec,*XkbStatePtr;
+#define	XkbStateFieldFromRec(s)	XkbBuildCoreState((s)->lookup_mods,(s)->group)
+#define	XkbGrabStateFromRec(s)	XkbBuildCoreState((s)->grab_mods,(s)->group)
+
+typedef struct _XkbMods {
+	unsigned char	mask;	/* effective mods */
+	unsigned char	real_mods;
+	unsigned short	vmods;
+} XkbModsRec,*XkbModsPtr;
+
+typedef struct _XkbKTMapEntry {
+	Bool		active;
+	unsigned char	level;
+	XkbModsRec	mods;
+} XkbKTMapEntryRec,*XkbKTMapEntryPtr;
+
+typedef struct _XkbKeyType {
+	XkbModsRec		mods;
+	unsigned char	  	num_levels;
+	unsigned char	  	map_count;
+	XkbKTMapEntryPtr  	map;
+	XkbModsPtr  		preserve;
+	Atom		  	name;
+	Atom *			level_names;
+} XkbKeyTypeRec, *XkbKeyTypePtr;
+
+#define	XkbNumGroups(g)			((g)&0x0f)
+#define	XkbOutOfRangeGroupInfo(g)	((g)&0xf0)
+#define	XkbOutOfRangeGroupAction(g)	((g)&0xc0)
+#define	XkbOutOfRangeGroupNumber(g)	(((g)&0x30)>>4)
+#define	XkbSetGroupInfo(g, w, n) (((w) & 0xc0) | (((n) & 3) << 4) | \
+                                  ((g) & 0x0f))
+#define	XkbSetNumGroups(g,n)	(((g)&0xf0)|((n)&0x0f))
+
+	/*
+	 * Structures and access macros used primarily by the server
+	 */
+
+typedef struct _XkbBehavior {
+	unsigned char	type;
+	unsigned char	data;
+} XkbBehavior;
+
+#define	XkbAnyActionDataSize 7
+typedef	struct _XkbAnyAction {
+	unsigned char	type;
+	unsigned char	data[XkbAnyActionDataSize];
+} XkbAnyAction;
+
+typedef struct _XkbModAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	mask;
+	unsigned char	real_mods;
+        /* FIXME: Make this an int. */
+	unsigned char	vmods1;
+	unsigned char	vmods2;
+} XkbModAction;
+#define	XkbModActionVMods(a) ((short) (((a)->vmods1 << 8) | (a)->vmods2))
+#define	XkbSetModActionVMods(a,v) \
+	((a)->vmods1 = (((v) >> 8) & 0xff), \
+         (a)->vmods2 = (v) & 0xff)
+
+typedef struct _XkbGroupAction {
+	unsigned char	type;
+	unsigned char	flags;
+        /* FIXME: Make this an int. */
+	char		group_XXX;
+} XkbGroupAction;
+#define	XkbSAGroup(a)		(XkbCharToInt((a)->group_XXX))
+#define	XkbSASetGroup(a,g)	((a)->group_XXX=(g))
+
+typedef struct _XkbISOAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	mask;
+	unsigned char	real_mods;
+        /* FIXME: Make this an int. */
+	char		group_XXX;
+	unsigned char	affect;
+	unsigned char	vmods1;
+	unsigned char	vmods2;
+} XkbISOAction;
+
+typedef struct _XkbPtrAction {
+	unsigned char	type;
+	unsigned char	flags;
+        /* FIXME: Make this an int. */
+	unsigned char	high_XXX;
+	unsigned char	low_XXX;
+	unsigned char	high_YYY;
+	unsigned char	low_YYY;
+} XkbPtrAction;
+#define	XkbPtrActionX(a)      (Xkb2CharsToInt((a)->high_XXX,(a)->low_XXX))
+#define	XkbPtrActionY(a)      (Xkb2CharsToInt((a)->high_YYY,(a)->low_YYY))
+#define	XkbSetPtrActionX(a,x) (XkbIntTo2Chars(x,(a)->high_XXX,(a)->low_XXX))
+#define	XkbSetPtrActionY(a,y) (XkbIntTo2Chars(y,(a)->high_YYY,(a)->low_YYY))
+
+typedef struct _XkbPtrBtnAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	count;
+	unsigned char	button;
+} XkbPtrBtnAction;
+
+typedef struct _XkbPtrDfltAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	affect;
+	char		valueXXX;
+} XkbPtrDfltAction;
+#define	XkbSAPtrDfltValue(a)		(XkbCharToInt((a)->valueXXX))
+#define	XkbSASetPtrDfltValue(a, c) ((a)->valueXXX = (c) & 0xff)
+
+typedef struct _XkbSwitchScreenAction {
+	unsigned char	type;
+	unsigned char	flags;
+	char		screenXXX;
+} XkbSwitchScreenAction;
+#define	XkbSAScreen(a)			(XkbCharToInt((a)->screenXXX))
+#define	XkbSASetScreen(a, s) ((a)->screenXXX = (s) & 0xff)
+
+typedef struct _XkbCtrlsAction {
+	unsigned char	type;
+	unsigned char	flags;
+        /* FIXME: Make this an int. */
+	unsigned char	ctrls3;
+	unsigned char	ctrls2;
+	unsigned char	ctrls1;
+	unsigned char	ctrls0;
+} XkbCtrlsAction;
+#define	XkbActionSetCtrls(a, c) ((a)->ctrls3 = ((c) >> 24) & 0xff, \
+                                 (a)->ctrls2 = ((c) >> 16) & 0xff, \
+                                 (a)->ctrls1 = ((c) >> 8) & 0xff, \
+                                 (a)->ctrls0 = (c) & 0xff)
+#define	XkbActionCtrls(a) ((((unsigned int)(a)->ctrls3)<<24)|\
+			   (((unsigned int)(a)->ctrls2)<<16)|\
+			   (((unsigned int)(a)->ctrls1)<<8)|\
+                           ((unsigned int) (a)->ctrls0))
+
+typedef struct _XkbMessageAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	message[6];
+} XkbMessageAction;
+
+typedef struct	_XkbRedirectKeyAction {
+	unsigned char	type;
+	unsigned char	new_key;
+	unsigned char	mods_mask;
+	unsigned char	mods;
+        /* FIXME: Make this an int. */
+	unsigned char	vmods_mask0;
+	unsigned char	vmods_mask1;
+	unsigned char	vmods0;
+	unsigned char	vmods1;
+} XkbRedirectKeyAction;
+
+#define	XkbSARedirectVMods(a)		((((unsigned int)(a)->vmods1)<<8)|\
+					((unsigned int)(a)->vmods0))
+/* FIXME: This is blatantly not setting vmods.   Yeesh. */
+#define	XkbSARedirectSetVMods(a,m)	(((a)->vmods_mask1=(((m)>>8)&0xff)),\
+					 ((a)->vmods_mask0=((m)&0xff)))
+#define	XkbSARedirectVModsMask(a)	((((unsigned int)(a)->vmods_mask1)<<8)|\
+					((unsigned int)(a)->vmods_mask0))
+#define	XkbSARedirectSetVModsMask(a,m)	(((a)->vmods_mask1=(((m)>>8)&0xff)),\
+					 ((a)->vmods_mask0=((m)&0xff)))
+
+typedef struct _XkbDeviceBtnAction {
+	unsigned char	type;
+	unsigned char	flags;
+	unsigned char	count;
+	unsigned char	button;
+	unsigned char	device;
+} XkbDeviceBtnAction;
+
+typedef struct _XkbDeviceValuatorAction {
+	unsigned char	type;
+	unsigned char	device;
+	unsigned char	v1_what;
+	unsigned char	v1_ndx;
+	unsigned char	v1_value;
+	unsigned char	v2_what;
+	unsigned char	v2_ndx;
+	unsigned char	v2_value;
+} XkbDeviceValuatorAction;
+
+typedef	union _XkbAction {
+	XkbAnyAction		any;
+	XkbModAction		mods;
+	XkbGroupAction		group;
+	XkbISOAction		iso;
+	XkbPtrAction		ptr;
+	XkbPtrBtnAction		btn;
+	XkbPtrDfltAction	dflt;
+	XkbSwitchScreenAction	screen;
+	XkbCtrlsAction		ctrls;
+	XkbMessageAction	msg;
+	XkbRedirectKeyAction	redirect;
+	XkbDeviceBtnAction	devbtn;
+	XkbDeviceValuatorAction	devval;
+	unsigned char 		type;
+} XkbAction;
+
+typedef	struct _XkbControls {
+	unsigned char	mk_dflt_btn;
+	unsigned char	num_groups;
+	unsigned char	groups_wrap;
+	XkbModsRec	internal;
+	XkbModsRec	ignore_lock;
+	unsigned int	enabled_ctrls;
+	unsigned short	repeat_delay;
+	unsigned short	repeat_interval;
+	unsigned short	slow_keys_delay;
+	unsigned short	debounce_delay;
+	unsigned short	mk_delay;
+	unsigned short	mk_interval;
+	unsigned short	mk_time_to_max;
+	unsigned short	mk_max_speed;
+		 short	mk_curve;
+	unsigned short	ax_options;
+	unsigned short	ax_timeout;
+	unsigned short	axt_opts_mask;
+	unsigned short	axt_opts_values;
+	unsigned int	axt_ctrls_mask;
+	unsigned int	axt_ctrls_values;
+	unsigned char	per_key_repeat[XkbPerKeyBitArraySize];
+} XkbControlsRec, *XkbControlsPtr;
+
+#define	XkbAX_AnyFeedback(c)	((c)->enabled_ctrls&XkbAccessXFeedbackMask)
+#define	XkbAX_NeedOption(c,w)	((c)->ax_options&(w))
+#define	XkbAX_NeedFeedback(c, w) (XkbAX_AnyFeedback((c)) && \
+                                  XkbAX_NeedOption((c), (w)))
+
+typedef struct _XkbServerMapRec {
+	unsigned short		 num_acts;
+	unsigned short		 size_acts;
+	XkbAction		*acts;
+
+	XkbBehavior		*behaviors;
+	unsigned short		*key_acts;
+#if defined(__cplusplus) || defined(c_plusplus)
+	/* explicit is a C++ reserved word */
+	unsigned char		*c_explicit;
+#else
+	unsigned char		*explicit;
+#endif
+	unsigned char		 vmods[XkbNumVirtualMods];
+	unsigned short		*vmodmap;
+} XkbServerMapRec, *XkbServerMapPtr;
+
+#define	XkbSMKeyActionsPtr(m, k) (&(m)->acts[(m)->key_acts[(k)]])
+
+	/*
+	 * Structures and access macros used primarily by clients
+	 */
+
+typedef	struct _XkbSymMapRec {
+	unsigned char	 kt_index[XkbNumKbdGroups];
+	unsigned char	 group_info;
+	unsigned char	 width;
+	unsigned short	 offset;
+} XkbSymMapRec, *XkbSymMapPtr;
+
+typedef struct _XkbClientMapRec {
+	unsigned char		 size_types;
+	unsigned char		 num_types;
+	XkbKeyTypePtr		 types;
+
+	unsigned short		 size_syms;
+	unsigned short		 num_syms;
+	KeySym			*syms;
+	XkbSymMapPtr		 key_sym_map;
+
+	unsigned char		*modmap;
+} XkbClientMapRec, *XkbClientMapPtr;
+
+#define	XkbCMKeyGroupInfo(m, k) ((m)->key_sym_map[(k)].group_info)
+#define	XkbCMKeyNumGroups(m, k) (XkbNumGroups((m)->key_sym_map[(k)].group_info))
+#define	XkbCMKeyGroupWidth(m, k, g) (XkbCMKeyType((m), (k), (g))->num_levels)
+#define	XkbCMKeyGroupsWidth(m, k) ((m)->key_sym_map[(k)].width)
+#define	XkbCMKeyTypeIndex(m, k, g) ((m)->key_sym_map[(k)].kt_index[(g) & 0x3])
+#define	XkbCMKeyType(m, k, g) (&(m)->types[XkbCMKeyTypeIndex((m), (k), (g))])
+#define	XkbCMKeyNumSyms(m, k) (XkbCMKeyGroupsWidth((m), (k)) * \
+                               XkbCMKeyNumGroups((m), (k)))
+#define	XkbCMKeySymsOffset(m, k) ((m)->key_sym_map[(k)].offset)
+#define	XkbCMKeySymsPtr(m, k) (&(m)->syms[XkbCMKeySymsOffset((m), (k))])
+
+	/*
+	 * Compatibility structures and access macros
+	 */
+
+typedef struct _XkbSymInterpretRec {
+	KeySym		sym;
+	unsigned char	flags;
+	unsigned char	match;
+	unsigned char	mods;
+	unsigned char	virtual_mod;
+	XkbAnyAction	act;
+} XkbSymInterpretRec,*XkbSymInterpretPtr;
+
+typedef struct _XkbCompatMapRec {
+	XkbSymInterpretPtr	 sym_interpret;
+	XkbModsRec		 groups[XkbNumKbdGroups];
+	unsigned short		 num_si;
+	unsigned short		 size_si;
+} XkbCompatMapRec, *XkbCompatMapPtr;
+
+typedef struct _XkbIndicatorMapRec {
+	unsigned char	flags;
+        /* FIXME: For some reason, interepretation of groups is wildly
+         *        different between which being base/latched/locked. */
+	unsigned char	which_groups;
+	unsigned char	groups;
+	unsigned char	which_mods;
+	XkbModsRec	mods;
+	unsigned int	ctrls;
+} XkbIndicatorMapRec, *XkbIndicatorMapPtr;
+
+#define	XkbIM_IsAuto(i)	(!((i)->flags & XkbIM_NoAutomatic) && \
+			    (((i)->which_groups&&(i)->groups)||\
+			     ((i)->which_mods&&(i)->mods.mask)||\
+                          (i)->ctrls))
+#define	XkbIM_InUse(i)	((i)->flags || (i)->which_groups || (i)->which_mods || \
+                         (i)->ctrls)
+	
+
+typedef struct _XkbIndicatorRec {
+	unsigned long	  	phys_indicators;
+	XkbIndicatorMapRec	maps[XkbNumIndicators];
+} XkbIndicatorRec,*XkbIndicatorPtr;
+
+typedef	struct _XkbKeyNameRec {
+	char	name[XkbKeyNameLength];
+} XkbKeyNameRec,*XkbKeyNamePtr;
+
+typedef struct _XkbKeyAliasRec {
+	char	real[XkbKeyNameLength];
+	char	alias[XkbKeyNameLength];
+} XkbKeyAliasRec,*XkbKeyAliasPtr;
+
+	/*
+	 * Names for everything 
+	 */
+typedef struct _XkbNamesRec {
+	Atom		  keycodes;
+	Atom		  geometry;
+	Atom		  symbols;
+	Atom              types;
+	Atom		  compat;
+	Atom		  vmods[XkbNumVirtualMods];
+	Atom		  indicators[XkbNumIndicators];
+	Atom		  groups[XkbNumKbdGroups];
+	XkbKeyNamePtr	  keys;
+	XkbKeyAliasPtr	  key_aliases;
+	Atom		 *radio_groups;
+	Atom		  phys_symbols;
+
+	unsigned char	  num_keys;
+	unsigned char	  num_key_aliases;
+	unsigned short	  num_rg;
+} XkbNamesRec,*XkbNamesPtr;
+
+typedef	struct _XkbGeometry	*XkbGeometryPtr;
+	/*
+	 * Tie it all together into one big keyboard description
+	 */
+typedef	struct _XkbDesc {
+        unsigned int            defined;
+	unsigned short	 	flags;
+	unsigned short		device_spec;
+	KeyCode			min_key_code;
+	KeyCode			max_key_code;
+
+	XkbControlsPtr		ctrls;
+	XkbServerMapPtr		server;
+	XkbClientMapPtr		map;
+	XkbIndicatorPtr		indicators;
+	XkbNamesPtr		names;
+	XkbCompatMapPtr		compat;
+	XkbGeometryPtr		geom;
+} XkbDescRec, *XkbDescPtr;
+#define	XkbKeyKeyTypeIndex(d, k, g)	(XkbCMKeyTypeIndex((d)->map, (k), (g)))
+#define	XkbKeyKeyType(d, k, g)		(XkbCMKeyType((d)->map, (k), (g)))
+#define	XkbKeyGroupWidth(d, k, g)	(XkbCMKeyGroupWidth((d)->map, (k), (g)))
+#define	XkbKeyGroupsWidth(d, k)		(XkbCMKeyGroupsWidth((d)->map, (k)))
+#define	XkbKeyGroupInfo(d,k)		(XkbCMKeyGroupInfo((d)->map,(k)))
+#define	XkbKeyNumGroups(d,k)		(XkbCMKeyNumGroups((d)->map,(k)))
+#define	XkbKeyNumSyms(d,k)		(XkbCMKeyNumSyms((d)->map,(k)))
+#define	XkbKeySymsPtr(d,k)		(XkbCMKeySymsPtr((d)->map,(k)))
+#define	XkbKeySym(d, k, n)		(XkbKeySymsPtr((d), (k))[(n)])
+#define	XkbKeySymEntry(d,k,sl,g) \
+    (XkbKeySym((d), (k), (XkbKeyGroupsWidth((d), (k)) * (g)) + (sl)))
+#define	XkbKeyAction(d,k,n) \
+    (XkbKeyHasActions((d), (k)) ? & XkbKeyActionsPtr((d), (k))[(n)] : NULL)
+#define	XkbKeyActionEntry(d,k,sl,g) \
+    (XkbKeyHasActions((d), (k)) ? \
+     XkbKeyAction((d), (k), ((XkbKeyGroupsWidth((d), (k)) * (g)) + (sl))) : \
+     NULL)
+
+#define	XkbKeyHasActions(d, k) (!!(d)->server->key_acts[(k)])
+#define	XkbKeyNumActions(d, k) (XkbKeyHasActions((d), (k)) ? \
+                                XkbKeyNumSyms((d), (k)) : 1)
+#define	XkbKeyActionsPtr(d, k) (XkbSMKeyActionsPtr((d)->server, (k)))
+#define	XkbKeycodeInRange(d, k) ((k) >= (d)->min_key_code && \
+				 (k) <= (d)->max_key_code)
+#define	XkbNumKeys(d)		((d)->max_key_code-(d)->min_key_code+1)
+
+
+	/*
+	 * The following structures can be used to track changes
+	 * to a keyboard device
+	 */
+typedef struct _XkbMapChanges {
+	unsigned short		 changed;
+	KeyCode			 min_key_code;
+	KeyCode			 max_key_code;
+	unsigned char		 first_type;
+	unsigned char		 num_types;
+	KeyCode			 first_key_sym;
+	unsigned char		 num_key_syms;
+	KeyCode			 first_key_act;
+	unsigned char		 num_key_acts;
+	KeyCode			 first_key_behavior;
+	unsigned char		 num_key_behaviors;
+	KeyCode 		 first_key_explicit;
+	unsigned char		 num_key_explicit;
+	KeyCode			 first_modmap_key;
+	unsigned char		 num_modmap_keys;
+	KeyCode			 first_vmodmap_key;
+	unsigned char		 num_vmodmap_keys;
+	unsigned char		 pad;
+	unsigned short		 vmods;
+} XkbMapChangesRec,*XkbMapChangesPtr;
+
+typedef struct _XkbControlsChanges {
+	unsigned int 		 changed_ctrls;
+	unsigned int		 enabled_ctrls_changes;
+	Bool			 num_groups_changed;
+} XkbControlsChangesRec,*XkbControlsChangesPtr;
+
+typedef struct _XkbIndicatorChanges {
+	unsigned int		 state_changes;
+	unsigned int		 map_changes;
+} XkbIndicatorChangesRec,*XkbIndicatorChangesPtr;
+
+typedef struct _XkbNameChanges {
+	unsigned int 		changed;
+	unsigned char		first_type;
+	unsigned char		num_types;
+	unsigned char		first_lvl;
+	unsigned char		num_lvls;
+	unsigned char		num_aliases;
+	unsigned char		num_rg;
+	unsigned char		first_key;
+	unsigned char		num_keys;
+	unsigned short		changed_vmods;
+	unsigned long		changed_indicators;
+	unsigned char		changed_groups;
+} XkbNameChangesRec,*XkbNameChangesPtr;
+
+typedef struct _XkbCompatChanges {
+	unsigned char		changed_groups;
+	unsigned short		first_si;
+	unsigned short		num_si;
+} XkbCompatChangesRec,*XkbCompatChangesPtr;
+
+typedef struct _XkbChanges {
+	unsigned short		 device_spec;
+	unsigned short		 state_changes;
+	XkbMapChangesRec	 map;
+	XkbControlsChangesRec	 ctrls;
+	XkbIndicatorChangesRec	 indicators;
+	XkbNameChangesRec	 names;
+	XkbCompatChangesRec	 compat;
+} XkbChangesRec, *XkbChangesPtr;
+
+	/*
+	 * These data structures are used to construct a keymap from 
+	 * a set of components or to list components in the server
+	 * database.
+	 */
+typedef struct _XkbComponentNames {
+	char *			 keycodes;
+	char *			 types;
+	char *			 compat;
+	char *			 symbols;
+	char *			 geometry;
+} XkbComponentNamesRec, *XkbComponentNamesPtr;
+
+typedef struct _XkbComponentName {
+	unsigned short		flags;
+	char *			name;
+} XkbComponentNameRec,*XkbComponentNamePtr;
+
+typedef struct _XkbComponentList {
+	int			num_keymaps;
+	int			num_keycodes;
+	int			num_types;
+	int			num_compat;
+	int			num_symbols;
+	int			num_geometry;
+	XkbComponentNamePtr	keymaps;
+	XkbComponentNamePtr 	keycodes;
+	XkbComponentNamePtr	types;
+	XkbComponentNamePtr	compat;
+	XkbComponentNamePtr	symbols;
+	XkbComponentNamePtr	geometry;
+} XkbComponentListRec, *XkbComponentListPtr;
+
+	/*
+	 * The following data structures describe and track changes to a 
+	 * non-keyboard extension device 
+	 */
+typedef struct _XkbDeviceLedInfo {
+	unsigned short			led_class;
+	unsigned short			led_id;
+	unsigned int			phys_indicators;
+	unsigned int			maps_present;
+	unsigned int			names_present;
+	unsigned int			state;
+	Atom 				names[XkbNumIndicators];
+	XkbIndicatorMapRec		maps[XkbNumIndicators];
+} XkbDeviceLedInfoRec,*XkbDeviceLedInfoPtr;
+
+typedef struct _XkbDeviceInfo {
+	char *			name;
+	Atom			type;
+	unsigned short		device_spec;
+	Bool			has_own_state;
+	unsigned short		supported;
+	unsigned short		unsupported;
+
+	unsigned short		num_btns;
+	XkbAction *		btn_acts;
+
+	unsigned short		sz_leds;
+	unsigned short		num_leds;
+	unsigned short		dflt_kbd_fb;
+	unsigned short		dflt_led_fb;
+	XkbDeviceLedInfoPtr	leds;
+} XkbDeviceInfoRec,*XkbDeviceInfoPtr;
+
+#define	XkbXI_DevHasBtnActs(d)	((d)->num_btns > 0 && (d)->btn_acts)
+#define	XkbXI_LegalDevBtn(d,b)	(XkbXI_DevHasBtnActs(d) && (b) < (d)->num_btns)
+#define	XkbXI_DevHasLeds(d)	((d)->num_leds > 0 && (d)->leds)
+
+typedef struct _XkbDeviceLedChanges {
+	unsigned short		led_class;
+	unsigned short		led_id;
+	unsigned int		defined; /* names or maps changed */
+	struct _XkbDeviceLedChanges *next;
+} XkbDeviceLedChangesRec,*XkbDeviceLedChangesPtr;
+
+typedef struct _XkbDeviceChanges {
+	unsigned int		changed;
+	unsigned short		first_btn;
+	unsigned short		num_btns;
+	XkbDeviceLedChangesRec 	leds;
+} XkbDeviceChangesRec,*XkbDeviceChangesPtr;
+
+#endif /* _XKBSTR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxscreens.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxscreens.h
@@ -0,0 +1,57 @@
+#ifndef _GLX_screens_h_
+#define _GLX_screens_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#include "GL/internal/glcore.h"
+
+
+
+typedef struct {
+
+    __GLXvisualConfig *pGlxVisual;
+    GLint numVisuals;
+    GLint numGLXVisuals;
+    GLint *isGLXvis;
+
+    char *GLXvendor;
+    char *GLXversion;
+    char *GLXextensions;
+
+} __GLXscreenInfo;
+
+
+extern void __glXScreenInit(GLint);
+extern void __glXScreenReset(void);
+
+extern char *__glXGetServerString( unsigned int name );
+
+#endif /* !__GLX_screens_h__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-mouse.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-mouse.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB mouse driver.  \see usb-mouse.c \see usb-common.c */
+
+#ifndef _USB_MOU_H_
+#define _USB_MOU_H_
+extern void    mouUSBRead(DevicePtr pDev,
+                          dmxMotionProcPtr motion,
+                          dmxEnqueueProcPtr enqueue,
+                          dmxCheckSpecialProcPtr checkspecial,
+                          DMXBlockType block);
+extern void    mouUSBInit(DevicePtr pDev);
+extern void    mouUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     mouUSBOn(DevicePtr pDev);
+extern void    mouUSBCtrl(DevicePtr pDev, PtrCtrl *ctrl);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mifpoly.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mifpoly.h
@@ -0,0 +1,102 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef __MIFPOLY_H__
+#define __MIFPOLY_H__
+
+#include <X11/Xfuncproto.h>
+
+#define EPSILON	0.000001
+#define ISEQUAL(a,b) (Fabs((a) - (b)) <= EPSILON)
+#define UNEQUAL(a,b) (Fabs((a) - (b)) > EPSILON)
+#define WITHINHALF(a, b) (((a) - (b) > 0.0) ? (a) - (b) < 0.5 : \
+					     (b) - (a) <= 0.5)
+#define ROUNDTOINT(x)   ((int) (((x) > 0.0) ? ((x) + 0.5) : ((x) - 0.5)))
+#define ISZERO(x) 	(Fabs((x)) <= EPSILON)
+#define PTISEQUAL(a,b) (ISEQUAL(a.x,b.x) && ISEQUAL(a.y,b.y))
+#define PTUNEQUAL(a,b) (UNEQUAL(a.x,b.x) || UNEQUAL(a.y,b.y))
+#define PtEqual(a, b) (((a).x == (b).x) && ((a).y == (b).y))
+
+#define NotEnd		0
+#define FirstEnd	1
+#define SecondEnd	2
+
+#define SQSECANT 108.856472512142 /* 1/sin^2(11/2) - for 11o miter cutoff */
+#define D2SECANT 5.21671526231167 /* 1/2*sin(11/2) - max extension per width */
+
+static _X_INLINE int ICEIL(double x)
+{
+    int _cTmp = x;
+    return ((x == _cTmp) || (x < 0.0)) ? _cTmp : _cTmp+1;
+}
+
+/* Point with sub-pixel positioning.  In this case we use doubles, but
+ * see mifpolycon.c for other suggestions 
+ */
+typedef struct _SppPoint {
+	double	x, y;
+} SppPointRec, *SppPointPtr;
+
+typedef struct _SppArc {
+	double	x, y, width, height;
+	double	angle1, angle2;
+} SppArcRec, *SppArcPtr;
+
+/* mifpolycon.c */
+
+extern _X_EXPORT void miFillSppPoly(
+    DrawablePtr /*dst*/,
+    GCPtr /*pgc*/,
+    int /*count*/,
+    SppPointPtr /*ptsIn*/,
+    int /*xTrans*/,
+    int /*yTrans*/,
+    double /*xFtrans*/,
+    double /*yFtrans*/
+);
+
+#endif /* __MIFPOLY_H__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgkbd.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgkbd.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGKBD_H
+#define CHGKBD_H 1
+
+int SProcXChangeKeyboardDevice(ClientPtr	/* client */
+    );
+
+int ProcXChangeKeyboardDevice(ClientPtr	/* client */
+    );
+
+#endif /* CHGKBD_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/globals.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/globals.h
@@ -0,0 +1,125 @@
+
+#ifndef _XSERV_GLOBAL_H_
+#define _XSERV_GLOBAL_H_
+
+#include "window.h"	/* for WindowPtr */
+
+/* Global X server variables that are visible to mi, dix, os, and ddx */
+
+extern _X_EXPORT CARD32 defaultScreenSaverTime;
+extern _X_EXPORT CARD32 defaultScreenSaverInterval;
+extern _X_EXPORT CARD32 ScreenSaverTime;
+extern _X_EXPORT CARD32 ScreenSaverInterval;
+
+#ifdef SCREENSAVER
+extern _X_EXPORT Bool screenSaverSuspended;
+#endif
+
+extern _X_EXPORT char *defaultFontPath;
+extern _X_EXPORT int monitorResolution;
+extern _X_EXPORT int defaultColorVisualClass;
+
+extern _X_EXPORT int GrabInProgress;
+extern _X_EXPORT Bool noTestExtensions;
+
+extern _X_EXPORT char *ConnectionInfo;
+
+#ifdef DPMSExtension
+extern _X_EXPORT CARD32 DPMSStandbyTime;
+extern _X_EXPORT CARD32 DPMSSuspendTime;
+extern _X_EXPORT CARD32 DPMSOffTime;
+extern _X_EXPORT CARD16 DPMSPowerLevel;
+extern _X_EXPORT Bool DPMSEnabled;
+extern _X_EXPORT Bool DPMSDisabledSwitch;
+extern _X_EXPORT Bool DPMSCapableFlag;
+#endif
+
+#ifdef PANORAMIX
+extern _X_EXPORT Bool PanoramiXExtensionDisabledHack;
+#endif
+
+#ifdef COMPOSITE
+extern _X_EXPORT Bool noCompositeExtension;
+#endif
+
+#ifdef DAMAGE
+extern _X_EXPORT Bool noDamageExtension;
+#endif
+
+#ifdef DBE
+extern _X_EXPORT Bool noDbeExtension;
+#endif
+
+#ifdef DPMSExtension
+extern _X_EXPORT Bool noDPMSExtension;
+#endif
+
+#ifdef GLXEXT
+extern _X_EXPORT Bool noGlxExtension;
+#endif
+
+#ifdef SCREENSAVER
+extern _X_EXPORT Bool noScreenSaverExtension;
+#endif
+
+#ifdef MITSHM
+extern _X_EXPORT Bool noMITShmExtension;
+#endif
+
+#ifdef RANDR
+extern _X_EXPORT Bool noRRExtension;
+#endif
+
+extern _X_EXPORT Bool noRenderExtension;
+
+#ifdef XCSECURITY
+extern _X_EXPORT Bool noSecurityExtension;
+#endif
+
+#ifdef RES
+extern _X_EXPORT Bool noResExtension;
+#endif
+
+#ifdef XF86BIGFONT
+extern _X_EXPORT Bool noXFree86BigfontExtension;
+#endif
+
+#ifdef XFreeXDGA
+extern _X_EXPORT Bool noXFree86DGAExtension;
+#endif
+
+#ifdef XF86DRI
+extern _X_EXPORT Bool noXFree86DRIExtension;
+#endif
+
+#ifdef XF86VIDMODE
+extern _X_EXPORT Bool noXFree86VidModeExtension;
+#endif
+
+#ifdef XFIXES
+extern _X_EXPORT Bool noXFixesExtension;
+#endif
+
+#ifdef PANORAMIX
+extern _X_EXPORT Bool noPanoramiXExtension;
+#endif
+
+#ifdef XSELINUX
+extern _X_EXPORT Bool noSELinuxExtension;
+
+#define SELINUX_MODE_DEFAULT    0
+#define SELINUX_MODE_DISABLED   1
+#define SELINUX_MODE_PERMISSIVE 2
+#define SELINUX_MODE_ENFORCING  3
+extern _X_EXPORT int selinuxEnforcingState;
+#endif
+
+#ifdef XV
+extern _X_EXPORT Bool noXvExtension;
+#endif
+
+#ifdef DRI2
+extern _X_EXPORT Bool noDRI2Extension;
+#endif
+
+#endif /* !_XSERV_GLOBAL_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dix.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dix.h
@@ -0,0 +1,602 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef DIX_H
+#define DIX_H
+
+#include "callback.h"
+#include "gc.h"
+#include "window.h"
+#include "input.h"
+#include "cursor.h"
+#include "geext.h"
+#include "events.h"
+#include <X11/extensions/XI.h>
+
+#define EARLIER -1
+#define SAMETIME 0
+#define LATER 1
+
+#define NullClient ((ClientPtr) 0)
+#define REQUEST(type) \
+	type *stuff = (type *)client->requestBuffer
+
+
+#define REQUEST_SIZE_MATCH(req)\
+    if ((sizeof(req) >> 2) != client->req_len)\
+         return(BadLength)
+
+#define REQUEST_AT_LEAST_SIZE(req) \
+    if ((sizeof(req) >> 2) > client->req_len )\
+         return(BadLength)
+
+#define REQUEST_FIXED_SIZE(req, n)\
+    if (((sizeof(req) >> 2) > client->req_len) || \
+        (((sizeof(req) + (n) + 3) >> 2) != client->req_len)) \
+         return(BadLength)
+
+#define LEGAL_NEW_RESOURCE(id,client)\
+    if (!LegalNewID(id,client)) \
+    {\
+	client->errorValue = id;\
+        return BadIDChoice;\
+    }
+
+#define VALIDATE_DRAWABLE_AND_GC(drawID, pDraw, mode)\
+    {\
+	int rc = dixLookupDrawable(&(pDraw), drawID, client, M_ANY, mode);\
+	if (rc != Success)\
+	    return rc;\
+	rc = dixLookupGC(&(pGC), stuff->gc, client, DixUseAccess);\
+	if (rc != Success)\
+	    return rc;\
+	if ((pGC->depth != pDraw->depth) || (pGC->pScreen != pDraw->pScreen))\
+	    return BadMatch;\
+    }\
+    if (pGC->serialNumber != pDraw->serialNumber)\
+	ValidateGC(pDraw, pGC);
+
+
+#define WriteReplyToClient(pClient, size, pReply) { \
+   if ((pClient)->swapped) \
+      (*ReplySwapVector[((xReq *)(pClient)->requestBuffer)->reqType]) \
+           (pClient, (int)(size), pReply); \
+      else (void) WriteToClient(pClient, (int)(size), (char *)(pReply)); }
+
+#define WriteSwappedDataToClient(pClient, size, pbuf) \
+   if ((pClient)->swapped) \
+      (*(pClient)->pSwapReplyFunc)(pClient, (int)(size), pbuf); \
+   else (void) WriteToClient (pClient, (int)(size), (char *)(pbuf));
+
+typedef struct _TimeStamp *TimeStampPtr;
+
+#ifndef _XTYPEDEF_CLIENTPTR
+typedef struct _Client *ClientPtr; /* also in misc.h */
+#define _XTYPEDEF_CLIENTPTR
+#endif
+
+typedef struct _WorkQueue	*WorkQueuePtr;
+
+extern _X_EXPORT ClientPtr clients[MAXCLIENTS];
+extern _X_EXPORT ClientPtr serverClient;
+extern _X_EXPORT int currentMaxClients;
+extern _X_EXPORT char dispatchExceptionAtReset;
+
+typedef int HWEventQueueType;
+typedef HWEventQueueType* HWEventQueuePtr;
+
+extern _X_EXPORT HWEventQueuePtr checkForInput[2];
+
+typedef struct _TimeStamp {
+    CARD32 months;	/* really ~49.7 days */
+    CARD32 milliseconds;
+}           TimeStamp;
+
+/* dispatch.c */
+
+extern _X_EXPORT void SetInputCheck(
+    HWEventQueuePtr /*c0*/,
+    HWEventQueuePtr /*c1*/);
+
+extern _X_EXPORT void CloseDownClient(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT void UpdateCurrentTime(void);
+
+extern _X_EXPORT void UpdateCurrentTimeIf(void);
+
+extern _X_EXPORT int dixDestroyPixmap(
+    pointer /*value*/,
+    XID /*pid*/);
+
+extern _X_EXPORT void InitClient(
+    ClientPtr /*client*/,
+    int /*i*/,
+    pointer /*ospriv*/);
+
+extern _X_EXPORT ClientPtr NextAvailableClient(
+    pointer /*ospriv*/);
+
+extern _X_EXPORT void SendErrorToClient(
+    ClientPtr /*client*/,
+    unsigned int /*majorCode*/,
+    unsigned int /*minorCode*/,
+    XID /*resId*/,
+    int /*errorCode*/);
+
+extern _X_EXPORT void MarkClientException(
+    ClientPtr /*client*/);
+
+extern _X_HIDDEN Bool CreateConnectionBlock(void);
+/* dixutils.c */
+
+extern _X_EXPORT int CompareISOLatin1Lowered(
+    unsigned char * /*a*/,
+    int alen,
+    unsigned char * /*b*/,
+    int blen);
+
+extern _X_EXPORT int dixLookupWindow(
+    WindowPtr *result,
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT int dixLookupDrawable(
+    DrawablePtr *result,
+    XID id,
+    ClientPtr client,
+    Mask type_mask,
+    Mask access_mode);
+
+extern _X_EXPORT int dixLookupGC(
+    GCPtr *result,
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT int dixLookupFontable(
+    FontPtr *result,
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT int dixLookupClient(
+    ClientPtr *result,
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT void NoopDDA(void);
+
+extern _X_EXPORT int AlterSaveSetForClient(
+    ClientPtr /*client*/,
+    WindowPtr /*pWin*/,
+    unsigned /*mode*/,
+    Bool /*toRoot*/,
+    Bool /*map*/);
+  
+extern _X_EXPORT void DeleteWindowFromAnySaveSet(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void BlockHandler(
+    pointer /*pTimeout*/,
+    pointer /*pReadmask*/);
+
+extern _X_EXPORT void WakeupHandler(
+    int /*result*/,
+    pointer /*pReadmask*/);
+
+void
+EnableLimitedSchedulingLatency(void);
+
+void
+DisableLimitedSchedulingLatency(void);
+
+typedef void (* WakeupHandlerProcPtr)(
+    pointer /* blockData */,
+    int /* result */,
+    pointer /* pReadmask */);
+
+extern _X_EXPORT Bool RegisterBlockAndWakeupHandlers(
+    BlockHandlerProcPtr /*blockHandler*/,
+    WakeupHandlerProcPtr /*wakeupHandler*/,
+    pointer /*blockData*/);
+
+extern _X_EXPORT void RemoveBlockAndWakeupHandlers(
+    BlockHandlerProcPtr /*blockHandler*/,
+    WakeupHandlerProcPtr /*wakeupHandler*/,
+    pointer /*blockData*/);
+
+extern _X_EXPORT void InitBlockAndWakeupHandlers(void);
+
+extern _X_EXPORT void ProcessWorkQueue(void);
+
+extern _X_EXPORT void ProcessWorkQueueZombies(void);
+
+extern _X_EXPORT Bool QueueWorkProc(
+    Bool (* /*function*/)(
+        ClientPtr /*clientUnused*/,
+        pointer /*closure*/),
+    ClientPtr /*client*/,
+    pointer /*closure*/
+);
+
+typedef Bool (* ClientSleepProcPtr)(
+    ClientPtr /*client*/,
+    pointer /*closure*/);
+
+extern _X_EXPORT Bool ClientSleep(
+    ClientPtr /*client*/,
+    ClientSleepProcPtr /* function */,
+    pointer /*closure*/);
+
+#ifndef ___CLIENTSIGNAL_DEFINED___
+#define ___CLIENTSIGNAL_DEFINED___
+extern _X_EXPORT Bool ClientSignal(
+    ClientPtr /*client*/);
+#endif /* ___CLIENTSIGNAL_DEFINED___ */
+
+extern _X_EXPORT void ClientWakeup(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT Bool ClientIsAsleep(
+    ClientPtr /*client*/);
+
+/* atom.c */
+
+extern _X_EXPORT Atom MakeAtom(
+    const char * /*string*/,
+    unsigned /*len*/,
+    Bool /*makeit*/);
+
+extern _X_EXPORT Bool ValidAtom(
+    Atom /*atom*/);
+
+extern _X_EXPORT const char *NameForAtom(
+    Atom /*atom*/);
+
+extern _X_EXPORT void AtomError(void) _X_NORETURN;
+
+extern _X_EXPORT void FreeAllAtoms(void);
+
+extern _X_EXPORT void InitAtoms(void);
+
+/* main.c */
+
+extern _X_EXPORT void SetVendorRelease(int release);
+
+extern _X_EXPORT void SetVendorString(char *string);
+
+/* events.c */
+
+extern void SetMaskForEvent(
+    int /* deviceid */,
+    Mask /* mask */,
+    int /* event */);
+
+extern _X_EXPORT void ConfineToShape(
+    DeviceIntPtr /* pDev */, 
+    RegionPtr /* shape */, 
+    int*      /* px */,
+    int*      /* py */);
+
+extern _X_EXPORT Bool IsParent(
+    WindowPtr /* maybeparent */,
+    WindowPtr /* child */);
+
+extern _X_EXPORT WindowPtr GetCurrentRootWindow(DeviceIntPtr pDev);
+
+extern _X_EXPORT WindowPtr GetSpriteWindow(DeviceIntPtr pDev);
+
+
+extern _X_EXPORT void NoticeEventTime(InternalEvent *ev);
+
+extern void EnqueueEvent(
+    InternalEvent * /* ev */,
+    DeviceIntPtr  /* device */);
+
+extern void ActivatePointerGrab(
+    DeviceIntPtr /* mouse */,
+    GrabPtr /* grab */,
+    TimeStamp /* time */,
+    Bool /* autoGrab */);
+
+extern void DeactivatePointerGrab(
+    DeviceIntPtr /* mouse */);
+
+extern void ActivateKeyboardGrab(
+    DeviceIntPtr /* keybd */,
+    GrabPtr /* grab */,
+    TimeStamp /* time */,
+    Bool /* passive */);
+
+extern void DeactivateKeyboardGrab(
+    DeviceIntPtr /* keybd */);
+
+extern BOOL ActivateFocusInGrab(
+    DeviceIntPtr /* dev */,
+    WindowPtr /* old */,
+    WindowPtr /* win */);
+
+extern void AllowSome(
+    ClientPtr	/* client */,
+    TimeStamp /* time */,
+    DeviceIntPtr /* thisDev */,
+    int /* newState */);
+
+extern void ReleaseActiveGrabs(
+    ClientPtr client);
+
+extern _X_EXPORT int DeliverEventsToWindow(
+    DeviceIntPtr /* pWin */,
+    WindowPtr /* pWin */,
+    xEventPtr /* pEvents */,
+    int /* count */,
+    Mask /* filter */,
+    GrabPtr /* grab */);
+
+extern int DeliverDeviceEvents(
+    WindowPtr /* pWin */,
+    InternalEvent* /* event */,
+    GrabPtr /* grab */,
+    WindowPtr /* stopAt */,
+    DeviceIntPtr /* dev */);
+
+extern void InitializeSprite(
+    DeviceIntPtr /* pDev */,
+    WindowPtr    /* pWin */);
+
+extern void UpdateSpriteForScreen(
+    DeviceIntPtr /* pDev */,
+    ScreenPtr /* pScreen */);
+
+extern _X_EXPORT void WindowHasNewCursor(
+    WindowPtr /* pWin */);
+
+extern Bool CheckDeviceGrabs(
+    DeviceIntPtr /* device */,
+    DeviceEvent* /* event */,
+    int /* checkFirst */);
+
+extern void DeliverFocusedEvent(
+    DeviceIntPtr /* keybd */,
+    InternalEvent* /* event */,
+    WindowPtr /* window */);
+
+extern void DeliverGrabbedEvent(
+    InternalEvent* /* event */,
+    DeviceIntPtr /* thisDev */,
+    Bool /* deactivateGrab */);
+
+extern void FixKeyState(
+    DeviceEvent* /* event */,
+    DeviceIntPtr /* keybd */);
+
+extern void RecalculateDeliverableEvents(
+    WindowPtr /* pWin */);
+
+extern _X_EXPORT int OtherClientGone(
+    pointer /* value */,
+    XID /* id */);
+
+extern void DoFocusEvents(
+    DeviceIntPtr /* dev */,
+    WindowPtr /* fromWin */,
+    WindowPtr /* toWin */,
+    int /* mode */);
+
+extern int SetInputFocus(
+    ClientPtr /* client */,
+    DeviceIntPtr /* dev */,
+    Window /* focusID */,
+    CARD8 /* revertTo */,
+    Time /* ctime */,
+    Bool /* followOK */);
+
+extern int GrabDevice(
+    ClientPtr /* client */,
+    DeviceIntPtr /* dev */,
+    unsigned /* this_mode */,
+    unsigned /* other_mode */,
+    Window /* grabWindow */,
+    unsigned /* ownerEvents */,
+    Time /* ctime */,
+    GrabMask* /* mask */,
+    int /* grabtype */,
+    Cursor /* curs */,
+    Window /* confineToWin */,
+    CARD8 * /* status */);
+
+extern void InitEvents(void);
+
+extern void CloseDownEvents(void);
+
+extern void DeleteWindowFromAnyEvents(
+    WindowPtr	/* pWin */,
+    Bool /* freeResources */);
+
+
+extern Mask EventMaskForClient(
+    WindowPtr /* pWin */,
+    ClientPtr /* client */);
+
+
+
+extern _X_EXPORT int DeliverEvents(
+    WindowPtr /*pWin*/,
+    xEventPtr /*xE*/,
+    int /*count*/,
+    WindowPtr /*otherParent*/);
+
+extern Bool CheckMotion(
+    DeviceEvent* /* ev */,
+    DeviceIntPtr /* pDev */);
+
+extern _X_EXPORT void WriteEventsToClient(
+    ClientPtr /*pClient*/,
+    int	     /*count*/,
+    xEventPtr /*events*/);
+
+extern _X_EXPORT int TryClientEvents(
+    ClientPtr /*client*/,
+    DeviceIntPtr /* device */,
+    xEventPtr /*pEvents*/,
+    int /*count*/,
+    Mask /*mask*/,
+    Mask /*filter*/,
+    GrabPtr /*grab*/);
+
+extern _X_EXPORT void WindowsRestructured(void);
+
+extern int SetClientPointer(
+        ClientPtr /* client */,
+        DeviceIntPtr /* device */);
+
+extern _X_EXPORT DeviceIntPtr PickPointer(
+    ClientPtr /* client */);
+
+extern _X_EXPORT DeviceIntPtr PickKeyboard(
+    ClientPtr /* client */);
+
+extern Bool IsInterferingGrab(
+        ClientPtr /* client */,
+        DeviceIntPtr /* dev */,
+        xEvent* /* events */);
+
+#ifdef PANORAMIX
+extern _X_EXPORT void ReinitializeRootWindow(WindowPtr win, int xoff, int yoff);
+#endif
+
+#ifdef RANDR
+extern _X_EXPORT void
+ScreenRestructured (ScreenPtr pScreen);
+#endif
+
+extern _X_EXPORT int ffs(int i);
+
+
+/*
+ *  ServerGrabCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr ServerGrabCallback;
+
+typedef enum {SERVER_GRABBED, SERVER_UNGRABBED,
+	      CLIENT_PERVIOUS, CLIENT_IMPERVIOUS } ServerGrabState;
+
+typedef struct {
+    ClientPtr client;
+    ServerGrabState grabstate;
+} ServerGrabInfoRec;
+
+/*
+ *  EventCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr EventCallback;
+
+typedef struct {
+    ClientPtr client;
+    xEventPtr events;
+    int count;
+} EventInfoRec;
+
+/*
+ *  DeviceEventCallback stuff
+ */
+
+extern _X_EXPORT CallbackListPtr DeviceEventCallback;
+
+typedef struct {
+    InternalEvent *event;
+    DeviceIntPtr device;
+} DeviceEventInfoRec;
+
+extern int XItoCoreType(int xi_type);
+extern Bool DevHasCursor(DeviceIntPtr pDev);
+extern Bool _X_EXPORT IsPointerDevice( DeviceIntPtr dev);
+extern Bool _X_EXPORT IsKeyboardDevice(DeviceIntPtr dev);
+extern Bool IsPointerEvent(InternalEvent *event);
+extern _X_EXPORT Bool IsMaster(DeviceIntPtr dev);
+
+extern _X_HIDDEN void CopyKeyClass(DeviceIntPtr device, DeviceIntPtr master);
+extern _X_HIDDEN int CorePointerProc(DeviceIntPtr dev, int what);
+extern _X_HIDDEN int CoreKeyboardProc(DeviceIntPtr dev, int what);
+
+
+/*
+ * These are deprecated compatibility functions and will be removed soon!
+ * Please use the noted replacements instead.
+ */
+/* replaced by dixLookupWindow */
+extern _X_EXPORT WindowPtr SecurityLookupWindow(
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+/* replaced by dixLookupWindow */
+extern _X_EXPORT WindowPtr LookupWindow(
+    XID id,
+    ClientPtr client);
+
+/* replaced by dixLookupDrawable */
+extern _X_EXPORT pointer SecurityLookupDrawable(
+    XID id,
+    ClientPtr client,
+    Mask access_mode);
+
+/* replaced by dixLookupDrawable */
+extern _X_EXPORT pointer LookupDrawable(
+    XID id,
+    ClientPtr client);
+
+/* replaced by dixLookupClient */
+extern _X_EXPORT ClientPtr LookupClient(
+    XID id,
+    ClientPtr client);
+
+#endif /* DIX_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xichangehierarchy.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xichangehierarchy.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+/***********************************************************************
+ *
+ * Request change in the device hierarchy.
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHDEVHIER_H
+#define CHDEVHIER_H 1
+
+int SProcXIChangeHierarchy(ClientPtr /* client */);
+int ProcXIChangeHierarchy(ClientPtr /* client */);
+
+void XISendDeviceHierarchyEvent(int flags[]);
+
+#endif /* CHDEVHIER_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdevk.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ungrdevk.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef UNGRDEVK_H
+#define UNGRDEVK_H 1
+
+int SProcXUngrabDeviceKey(ClientPtr	/* client */
+    );
+
+int ProcXUngrabDeviceKey(ClientPtr	/* client */
+    );
+
+#endif /* UNGRDEVK_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_ops.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_ops.h
@@ -0,0 +1,142 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for primitive operation functions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_PRIM_OPS_H
+#define __X86EMU_PRIM_OPS_H
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+u16     aaa_word (u16 d);
+u16     aas_word (u16 d);
+u16     aad_word (u16 d);
+u16     aam_word (u8 d);
+u8      adc_byte (u8 d, u8 s);
+u16     adc_word (u16 d, u16 s);
+u32     adc_long (u32 d, u32 s);
+u8      add_byte (u8 d, u8 s);
+u16     add_word (u16 d, u16 s);
+u32     add_long (u32 d, u32 s);
+u8      and_byte (u8 d, u8 s);
+u16     and_word (u16 d, u16 s);
+u32     and_long (u32 d, u32 s);
+u8      cmp_byte (u8 d, u8 s);
+u16     cmp_word (u16 d, u16 s);
+u32     cmp_long (u32 d, u32 s);
+u8      daa_byte (u8 d);
+u8      das_byte (u8 d);
+u8      dec_byte (u8 d);
+u16     dec_word (u16 d);
+u32     dec_long (u32 d);
+u8      inc_byte (u8 d);
+u16     inc_word (u16 d);
+u32     inc_long (u32 d);
+u8      or_byte (u8 d, u8 s);
+u16     or_word (u16 d, u16 s);
+u32     or_long (u32 d, u32 s);
+u8      neg_byte (u8 s);
+u16     neg_word (u16 s);
+u32     neg_long (u32 s);
+u8      not_byte (u8 s);
+u16     not_word (u16 s);
+u32     not_long (u32 s);
+u8      rcl_byte (u8 d, u8 s);
+u16     rcl_word (u16 d, u8 s);
+u32     rcl_long (u32 d, u8 s);
+u8      rcr_byte (u8 d, u8 s);
+u16     rcr_word (u16 d, u8 s);
+u32     rcr_long (u32 d, u8 s);
+u8      rol_byte (u8 d, u8 s);
+u16     rol_word (u16 d, u8 s);
+u32     rol_long (u32 d, u8 s);
+u8      ror_byte (u8 d, u8 s);
+u16     ror_word (u16 d, u8 s);
+u32     ror_long (u32 d, u8 s);
+u8      shl_byte (u8 d, u8 s);
+u16     shl_word (u16 d, u8 s);
+u32     shl_long (u32 d, u8 s);
+u8      shr_byte (u8 d, u8 s);
+u16     shr_word (u16 d, u8 s);
+u32     shr_long (u32 d, u8 s);
+u8      sar_byte (u8 d, u8 s);
+u16     sar_word (u16 d, u8 s);
+u32     sar_long (u32 d, u8 s);
+u16     shld_word (u16 d, u16 fill, u8 s);
+u32     shld_long (u32 d, u32 fill, u8 s);
+u16     shrd_word (u16 d, u16 fill, u8 s);
+u32     shrd_long (u32 d, u32 fill, u8 s);
+u8      sbb_byte (u8 d, u8 s);
+u16     sbb_word (u16 d, u16 s);
+u32     sbb_long (u32 d, u32 s);
+u8      sub_byte (u8 d, u8 s);
+u16     sub_word (u16 d, u16 s);
+u32     sub_long (u32 d, u32 s);
+void    test_byte (u8 d, u8 s);
+void    test_word (u16 d, u16 s);
+void    test_long (u32 d, u32 s);
+u8      xor_byte (u8 d, u8 s);
+u16     xor_word (u16 d, u16 s);
+u32     xor_long (u32 d, u32 s);
+void    imul_byte (u8 s);
+void    imul_word (u16 s);
+void    imul_long (u32 s);
+void 	imul_long_direct(u32 *res_lo, u32* res_hi,u32 d, u32 s);
+void    mul_byte (u8 s);
+void    mul_word (u16 s);
+void    mul_long (u32 s);
+void    idiv_byte (u8 s);
+void    idiv_word (u16 s);
+void    idiv_long (u32 s);
+void    div_byte (u8 s);
+void    div_word (u16 s);
+void    div_long (u32 s);
+void    ins (int size);
+void    outs (int size);
+u16     mem_access_word (int addr);
+void    push_word (u16 w);
+void    push_long (u32 w);
+u16     pop_word (void);
+u32		pop_long (void);
+void    cpuid (void);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_PRIM_OPS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiXsrv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/panoramiXsrv.h
@@ -0,0 +1,53 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _PANORAMIXSRV_H_
+#define _PANORAMIXSRV_H_
+
+#include "panoramiX.h"
+
+extern _X_EXPORT int PanoramiXNumScreens;
+extern _X_EXPORT int PanoramiXPixWidth;
+extern _X_EXPORT int PanoramiXPixHeight;
+
+extern _X_EXPORT VisualID PanoramiXTranslateVisualID(int screen, VisualID orig);
+extern _X_EXPORT void PanoramiXConsolidate(void);
+extern _X_EXPORT Bool PanoramiXCreateConnectionBlock(void);
+extern _X_EXPORT PanoramiXRes * PanoramiXFindIDByScrnum(RESTYPE, XID, int);
+extern _X_EXPORT Bool XineramaRegisterConnectionBlockCallback(void (*func)(void));
+extern _X_EXPORT int XineramaDeleteResource(pointer, XID);
+
+extern _X_EXPORT void XineramaReinitData(ScreenPtr);
+
+extern _X_EXPORT unsigned long XRC_DRAWABLE;
+extern _X_EXPORT unsigned long XRT_WINDOW;
+extern _X_EXPORT unsigned long XRT_PIXMAP;
+extern _X_EXPORT unsigned long XRT_GC;
+extern _X_EXPORT unsigned long XRT_COLORMAP;
+
+/*
+ * Drivers are allowed to wrap this function.  Each wrapper can decide that the
+ * two visuals are unequal, but if they are deemed equal, the wrapper must call
+ * down and return FALSE if the wrapped function does.  This ensures that all
+ * layers agree that the visuals are equal.  The first visual is always from
+ * screen 0.
+ */
+typedef Bool (*XineramaVisualsEqualProcPtr)(VisualPtr, ScreenPtr, VisualPtr);
+extern _X_EXPORT XineramaVisualsEqualProcPtr XineramaVisualsEqualPtr;
+
+extern _X_EXPORT void XineramaGetImageData(
+    DrawablePtr *pDrawables,
+    int left,
+    int top,
+    int width, 
+    int height,
+    unsigned int format,
+    unsigned long planemask,
+    char *data,
+    int pitch,
+    Bool isRoot
+);
+
+#endif /* _PANORAMIXSRV_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/callback.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/callback.h
@@ -0,0 +1,87 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef CALLBACK_H
+#define CALLBACK_H
+
+#include <X11/X.h>	/* for GContext, Mask */
+#include <X11/Xdefs.h>	/* for Bool */
+#include <X11/Xproto.h>
+#include <X11/Xfuncproto.h>
+
+/*
+ *  callback manager stuff
+ */
+
+#ifndef _XTYPEDEF_CALLBACKLISTPTR
+typedef struct _CallbackList *CallbackListPtr; /* also in misc.h */
+#define _XTYPEDEF_CALLBACKLISTPTR
+#endif
+
+typedef void (*CallbackProcPtr) (
+    CallbackListPtr *, pointer, pointer);
+
+extern _X_EXPORT Bool AddCallback(
+    CallbackListPtr * /*pcbl*/,
+    CallbackProcPtr /*callback*/,
+    pointer /*data*/);
+
+extern _X_EXPORT Bool DeleteCallback(
+    CallbackListPtr * /*pcbl*/,
+    CallbackProcPtr /*callback*/,
+    pointer /*data*/);
+
+extern _X_EXPORT void CallCallbacks(
+    CallbackListPtr * /*pcbl*/,
+    pointer /*call_data*/);
+
+extern _X_EXPORT void DeleteCallbackList(
+    CallbackListPtr * /*pcbl*/);
+
+extern _X_EXPORT void InitCallbackManager(void);
+
+#endif /* CALLBACK_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/micoord.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/micoord.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2000 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from the
+ * XFree86 Project.
+ *
+ */
+
+#ifndef _MICOORD_H_
+#define _MICOORD_H_ 1
+
+#include "servermd.h"
+
+/* Macros which handle a coordinate in a single register */
+
+/*
+ * Most compilers will convert divisions by 65536 into shifts, if signed
+ * shifts exist.  If your machine does arithmetic shifts and your compiler
+ * can't get it right, add to this line.
+ */
+
+/*
+ * mips compiler - what a joke - it CSEs the 65536 constant into a reg
+ * forcing as to use div instead of shift.  Let's be explicit.
+ */
+
+#if defined(mips) || \
+    defined(sparc) || defined(__sparc64__) || \
+    defined(__alpha) || defined(__alpha__) || \
+    defined(__i386__) || defined(__i386) || defined(__ia64__) || \
+    defined(__s390x__) || defined(__s390__) || \
+    defined(__amd64__) || defined(amd64) || defined(__amd64)
+#define GetHighWord(x) (((int) (x)) >> 16)
+#else
+#define GetHighWord(x) (((int) (x)) / 65536)
+#endif
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define intToCoord(i,x,y)   (((x) = GetHighWord(i)), ((y) = (int) ((short) (i))))
+#define coordToInt(x,y)	(((x) << 16) | ((y) & 0xffff))
+#define intToX(i)	(GetHighWord(i))
+#define intToY(i)	((int) ((short) i))
+#else
+#define intToCoord(i,x,y)   (((x) = (int) ((short) (i))), ((y) = GetHighWord(i)))
+#define coordToInt(x,y)	(((y) << 16) | ((x) & 0xffff))
+#define intToX(i)	((int) ((short) (i)))
+#define intToY(i)	(GetHighWord(i))
+#endif
+
+#endif /* _MICOORD_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/randrstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/randrstr.h
@@ -0,0 +1,989 @@
+/*
+ * Copyright © 2000 Compaq Computer Corporation
+ * Copyright © 2002 Hewlett-Packard Company
+ * Copyright © 2006 Intel Corporation
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that copyright
+ * notice and this permission notice appear in supporting documentation, and
+ * that the name of the copyright holders not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no representations
+ * about the suitability of this software for any purpose.  It is provided "as
+ * is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ *
+ * Author:  Jim Gettys, Hewlett-Packard Company, Inc.
+ *	    Keith Packard, Intel Corporation
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _RANDRSTR_H_
+#define _RANDRSTR_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "resource.h"
+#include "scrnintstr.h"
+#include "windowstr.h"
+#include "pixmapstr.h"
+#include "extnsionst.h"
+#include "servermd.h"
+#include "rrtransform.h"
+#include <X11/extensions/randr.h>
+#include <X11/extensions/randrproto.h>
+#include <X11/extensions/render.h> 	/* we share subpixel order information */
+#include "picturestr.h"
+#include <X11/Xfuncproto.h>
+
+/* required for ABI compatibility for now */
+#define RANDR_10_INTERFACE 1
+#define RANDR_12_INTERFACE 1
+#define RANDR_13_INTERFACE 1 /* requires RANDR_12_INTERFACE */
+#define RANDR_GET_CRTC_INTERFACE 1
+
+#define RANDR_INTERFACE_VERSION 0x0103
+
+typedef XID	RRMode;
+typedef XID	RROutput;
+typedef XID	RRCrtc;
+
+extern _X_EXPORT int	RREventBase, RRErrorBase;
+
+extern _X_EXPORT int (*ProcRandrVector[RRNumberRequests])(ClientPtr);
+extern _X_EXPORT int (*SProcRandrVector[RRNumberRequests])(ClientPtr);
+    
+/*
+ * Modeline for a monitor. Name follows directly after this struct
+ */
+
+#define RRModeName(pMode) ((char *) (pMode + 1))
+typedef struct _rrMode		RRModeRec, *RRModePtr;
+typedef struct _rrPropertyValue	RRPropertyValueRec, *RRPropertyValuePtr;
+typedef struct _rrProperty	RRPropertyRec, *RRPropertyPtr;
+typedef struct _rrCrtc		RRCrtcRec, *RRCrtcPtr;
+typedef struct _rrOutput	RROutputRec, *RROutputPtr;
+
+struct _rrMode {
+    int		    refcnt;
+    xRRModeInfo	    mode;
+    char	    *name;
+    ScreenPtr	    userScreen;
+};
+
+struct _rrPropertyValue {
+    Atom	    type;       /* ignored by server */
+    short	    format;     /* format of data for swapping - 8,16,32 */
+    long	    size;	/* size of data in (format/8) bytes */
+    pointer         data;	/* private to client */
+};
+
+struct _rrProperty {
+    RRPropertyPtr   next;
+    ATOM 	    propertyName;
+    Bool	    is_pending;
+    Bool	    range;
+    Bool	    immutable;
+    int		    num_valid;
+    INT32	    *valid_values;
+    RRPropertyValueRec	current, pending;
+};
+
+struct _rrCrtc {
+    RRCrtc	    id;
+    ScreenPtr	    pScreen;
+    RRModePtr	    mode;
+    int		    x, y;
+    Rotation	    rotation;
+    Rotation	    rotations;
+    Bool	    changed;
+    int		    numOutputs;
+    RROutputPtr	    *outputs;
+    int		    gammaSize;
+    CARD16	    *gammaRed;
+    CARD16	    *gammaBlue;
+    CARD16	    *gammaGreen;
+    void	    *devPrivate;
+    Bool	    transforms;
+    RRTransformRec  client_pending_transform;
+    RRTransformRec  client_current_transform;
+    PictTransform   transform;
+    struct pict_f_transform f_transform;
+    struct pict_f_transform f_inverse;
+};
+
+struct _rrOutput {
+    RROutput	    id;
+    ScreenPtr	    pScreen;
+    char	    *name;
+    int		    nameLength;
+    CARD8	    connection;
+    CARD8	    subpixelOrder;
+    int		    mmWidth;
+    int		    mmHeight;
+    RRCrtcPtr	    crtc;
+    int		    numCrtcs;
+    RRCrtcPtr	    *crtcs;
+    int		    numClones;
+    RROutputPtr	    *clones;
+    int		    numModes;
+    int		    numPreferred;
+    RRModePtr	    *modes;
+    int		    numUserModes;
+    RRModePtr	    *userModes;
+    Bool	    changed;
+    RRPropertyPtr   properties;
+    Bool	    pendingProperties;
+    void	    *devPrivate;
+};
+
+#if RANDR_12_INTERFACE
+typedef Bool (*RRScreenSetSizeProcPtr) (ScreenPtr	pScreen,
+					CARD16		width,
+					CARD16		height,
+					CARD32		mmWidth,
+					CARD32		mmHeight);
+					
+typedef Bool (*RRCrtcSetProcPtr) (ScreenPtr		pScreen,
+				  RRCrtcPtr		crtc,
+				  RRModePtr		mode,
+				  int			x,
+				  int			y,
+				  Rotation		rotation,
+				  int			numOutputs,
+				  RROutputPtr		*outputs);
+
+typedef Bool (*RRCrtcSetGammaProcPtr) (ScreenPtr	pScreen,
+				       RRCrtcPtr	crtc);
+
+typedef Bool (*RRCrtcGetGammaProcPtr) (ScreenPtr	pScreen,
+				       RRCrtcPtr	crtc);
+
+typedef Bool (*RROutputSetPropertyProcPtr) (ScreenPtr		pScreen,
+					    RROutputPtr		output,
+					    Atom		property,
+					    RRPropertyValuePtr	value);
+
+typedef Bool (*RROutputValidateModeProcPtr) (ScreenPtr		pScreen,
+					     RROutputPtr	output,
+					     RRModePtr		mode);
+
+typedef void (*RRModeDestroyProcPtr) (ScreenPtr	    pScreen,
+				      RRModePtr	    mode);
+
+#endif
+
+#if RANDR_13_INTERFACE
+typedef Bool (*RROutputGetPropertyProcPtr) (ScreenPtr		pScreen,
+					    RROutputPtr		output,
+					    Atom		property);
+typedef Bool (*RRGetPanningProcPtr)    (ScreenPtr		pScrn,
+					RRCrtcPtr		crtc,
+					BoxPtr		totalArea,
+					BoxPtr		trackingArea,
+					INT16		*border);
+typedef Bool (*RRSetPanningProcPtr)    (ScreenPtr		pScrn,
+					RRCrtcPtr		crtc,
+					BoxPtr		totalArea,
+					BoxPtr		trackingArea,
+					INT16		*border);
+
+#endif /* RANDR_13_INTERFACE */
+
+typedef Bool (*RRGetInfoProcPtr) (ScreenPtr pScreen, Rotation *rotations);
+typedef Bool (*RRCloseScreenProcPtr) ( int i, ScreenPtr pscreen);
+
+/* These are for 1.0 compatibility */
+ 
+typedef struct _rrRefresh {
+    CARD16	    rate;
+    RRModePtr	    mode;
+} RRScreenRate, *RRScreenRatePtr;
+
+typedef struct _rrScreenSize {
+    int		    id;
+    short	    width, height;
+    short	    mmWidth, mmHeight;
+    int		    nRates;
+    RRScreenRatePtr pRates;
+} RRScreenSize, *RRScreenSizePtr;
+
+#ifdef RANDR_10_INTERFACE
+
+typedef Bool (*RRSetConfigProcPtr) (ScreenPtr		pScreen,
+				    Rotation		rotation,
+				    int			rate,
+				    RRScreenSizePtr	pSize);
+
+#endif
+	
+
+typedef struct _rrScrPriv {
+    /*
+     * 'public' part of the structure; DDXen fill this in
+     * as they initialize
+     */
+#if RANDR_10_INTERFACE
+    RRSetConfigProcPtr	    rrSetConfig;
+#endif
+    RRGetInfoProcPtr	    rrGetInfo;
+#if RANDR_12_INTERFACE
+    RRScreenSetSizeProcPtr  rrScreenSetSize;
+    RRCrtcSetProcPtr	    rrCrtcSet;
+    RRCrtcSetGammaProcPtr   rrCrtcSetGamma;
+    RRCrtcGetGammaProcPtr   rrCrtcGetGamma;
+    RROutputSetPropertyProcPtr	rrOutputSetProperty;
+    RROutputValidateModeProcPtr	rrOutputValidateMode;
+    RRModeDestroyProcPtr	rrModeDestroy;
+#endif
+#if RANDR_13_INTERFACE
+    RROutputGetPropertyProcPtr	rrOutputGetProperty;
+    RRGetPanningProcPtr	rrGetPanning;
+    RRSetPanningProcPtr	rrSetPanning;
+#endif
+    
+    /*
+     * Private part of the structure; not considered part of the ABI
+     */
+    TimeStamp		    lastSetTime;	/* last changed by client */
+    TimeStamp		    lastConfigTime;	/* possible configs changed */
+    RRCloseScreenProcPtr    CloseScreen;
+
+    Bool		    changed;		/* some config changed */
+    Bool		    configChanged;	/* configuration changed */
+    Bool		    layoutChanged;	/* screen layout changed */
+
+    CARD16		    minWidth, minHeight;
+    CARD16		    maxWidth, maxHeight;
+    CARD16		    width, height;	/* last known screen size */
+    CARD16		    mmWidth, mmHeight;	/* last known screen size */
+
+    int			    numOutputs;
+    RROutputPtr		    *outputs;
+    RROutputPtr		    primaryOutput;
+
+    int			    numCrtcs;
+    RRCrtcPtr		    *crtcs;
+
+    /* Last known pointer position */
+    RRCrtcPtr		    pointerCrtc;
+
+#ifdef RANDR_10_INTERFACE
+    /*
+     * Configuration information
+     */
+    Rotation		    rotations;
+    CARD16		    reqWidth, reqHeight;
+    
+    int			    nSizes;
+    RRScreenSizePtr	    pSizes;
+    
+    Rotation		    rotation;
+    int			    rate;
+    int			    size;
+#endif
+} rrScrPrivRec, *rrScrPrivPtr;
+
+extern _X_EXPORT DevPrivateKeyRec rrPrivKeyRec;
+#define rrPrivKey (&rrPrivKeyRec)
+
+#define rrGetScrPriv(pScr)  ((rrScrPrivPtr)dixLookupPrivate(&(pScr)->devPrivates, rrPrivKey))
+#define rrScrPriv(pScr)	rrScrPrivPtr    pScrPriv = rrGetScrPriv(pScr)
+#define SetRRScreen(s,p) dixSetPrivate(&(s)->devPrivates, rrPrivKey, p)
+
+/*
+ * each window has a list of clients requesting
+ * RRNotify events.  Each client has a resource
+ * for each window it selects RRNotify input for,
+ * this resource is used to delete the RRNotifyRec
+ * entry from the per-window queue.
+ */
+
+typedef struct _RREvent *RREventPtr;
+
+typedef struct _RREvent {
+    RREventPtr  next;
+    ClientPtr	client;
+    WindowPtr	window;
+    XID		clientResource;
+    int		mask;
+} RREventRec;
+
+typedef struct _RRTimes {
+    TimeStamp	setTime;
+    TimeStamp	configTime;
+} RRTimesRec, *RRTimesPtr;
+
+typedef struct _RRClient {
+    int		major_version;
+    int		minor_version;
+/*  RRTimesRec	times[0]; */
+} RRClientRec, *RRClientPtr;
+
+extern _X_EXPORT RESTYPE RRClientType, RREventType; /* resource types for event masks */
+extern _X_EXPORT DevPrivateKeyRec RRClientPrivateKeyRec;
+#define RRClientPrivateKey (&RRClientPrivateKeyRec)
+extern _X_EXPORT RESTYPE RRCrtcType, RRModeType, RROutputType;
+
+#define VERIFY_RR_OUTPUT(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
+	                                 RROutputType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define VERIFY_RR_CRTC(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
+	                                 RRCrtcType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define VERIFY_RR_MODE(id, ptr, a)\
+    {\
+	int rc = dixLookupResourceByType((pointer *)&(ptr), id,\
+	                                 RRModeType, client, a);\
+	if (rc != Success) {\
+	    client->errorValue = id;\
+	    return rc;\
+	}\
+    }
+
+#define GetRRClient(pClient)    ((RRClientPtr)dixLookupPrivate(&(pClient)->devPrivates, RRClientPrivateKey))
+#define rrClientPriv(pClient)	RRClientPtr pRRClient = GetRRClient(pClient)
+
+/* Initialize the extension */
+extern _X_EXPORT void
+RRExtensionInit (void);
+
+#ifdef RANDR_12_INTERFACE
+/*
+ * Set the range of sizes for the screen
+ */
+extern _X_EXPORT void
+RRScreenSetSizeRange (ScreenPtr	pScreen,
+		      CARD16	minWidth,
+		      CARD16	minHeight,
+		      CARD16	maxWidth,
+		      CARD16	maxHeight);
+#endif
+
+/* rrscreen.c */
+/*
+ * Notify the extension that the screen size has been changed.
+ * The driver is responsible for calling this whenever it has changed
+ * the size of the screen
+ */
+extern _X_EXPORT void
+RRScreenSizeNotify (ScreenPtr	pScreen);
+
+/*
+ * Request that the screen be resized
+ */
+extern _X_EXPORT Bool
+RRScreenSizeSet (ScreenPtr  pScreen,
+		 CARD16	    width,
+		 CARD16	    height,
+		 CARD32	    mmWidth,
+		 CARD32	    mmHeight);
+
+/*
+ * Send ConfigureNotify event to root window when 'something' happens
+ */
+extern _X_EXPORT void
+RRSendConfigNotify (ScreenPtr pScreen);
+    
+/*
+ * screen dispatch
+ */
+extern _X_EXPORT int
+ProcRRGetScreenSizeRange (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetScreenSize (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetScreenResources (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetScreenResourcesCurrent (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetScreenConfig (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetScreenInfo (ClientPtr client);
+
+/*
+ * Deliver a ScreenNotify event
+ */
+extern _X_EXPORT void
+RRDeliverScreenEvent (ClientPtr client, WindowPtr pWin, ScreenPtr pScreen);
+    
+/* mirandr.c */
+extern _X_EXPORT Bool
+miRandRInit (ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+miRRGetInfo (ScreenPtr pScreen, Rotation *rotations);
+
+extern _X_EXPORT Bool
+miRRCrtcSet (ScreenPtr	pScreen,
+	     RRCrtcPtr	crtc,
+	     RRModePtr	mode,
+	     int	x,
+	     int	y,
+	     Rotation	rotation,
+	     int	numOutput,
+	     RROutputPtr *outputs);
+
+extern _X_EXPORT Bool
+miRROutputSetProperty (ScreenPtr	    pScreen,
+		       RROutputPtr	    output,
+		       Atom		    property,
+		       RRPropertyValuePtr   value);
+
+extern _X_EXPORT Bool
+miRROutputGetProperty (ScreenPtr	    pScreen,
+		       RROutputPtr	    output,
+		       Atom		    property);
+
+extern _X_EXPORT Bool
+miRROutputValidateMode (ScreenPtr	    pScreen,
+			RROutputPtr	    output,
+			RRModePtr	    mode);
+
+extern _X_EXPORT void
+miRRModeDestroy (ScreenPtr  pScreen,
+		 RRModePtr  mode);
+
+/* randr.c */
+/*
+ * Send all pending events
+ */
+extern _X_EXPORT void
+RRTellChanged (ScreenPtr pScreen);
+
+/*
+ * Poll the driver for changed information
+ */
+extern _X_EXPORT Bool
+RRGetInfo (ScreenPtr pScreen, Bool force_query);
+
+extern _X_EXPORT Bool RRInit (void);
+
+extern _X_EXPORT Bool RRScreenInit(ScreenPtr pScreen);
+
+extern _X_EXPORT RROutputPtr
+RRFirstOutput (ScreenPtr pScreen);
+
+extern _X_EXPORT Rotation
+RRGetRotation (ScreenPtr pScreen);
+
+extern _X_EXPORT CARD16
+RRVerticalRefresh (xRRModeInfo *mode);
+
+#ifdef RANDR_10_INTERFACE					
+/*
+ * This is the old interface, deprecated but left
+ * around for compatibility
+ */
+
+/*
+ * Then, register the specific size with the screen
+ */
+
+extern _X_EXPORT RRScreenSizePtr
+RRRegisterSize (ScreenPtr		pScreen,
+		short			width, 
+		short			height,
+		short			mmWidth,
+		short			mmHeight);
+
+extern _X_EXPORT Bool
+RRRegisterRate (ScreenPtr		pScreen,
+		     RRScreenSizePtr	pSize,
+		     int		rate);
+
+/*
+ * Finally, set the current configuration of the screen
+ */
+
+extern _X_EXPORT void
+RRSetCurrentConfig (ScreenPtr		pScreen,
+		    Rotation		rotation,
+		    int			rate,
+		    RRScreenSizePtr	pSize);
+
+extern _X_EXPORT Bool RRScreenInit (ScreenPtr pScreen);
+
+extern _X_EXPORT Rotation
+RRGetRotation (ScreenPtr pScreen);
+
+#endif					
+
+/* rrcrtc.c */
+
+/*
+ * Notify the CRTC of some change; layoutChanged indicates that
+ * some position or size element changed
+ */
+extern _X_EXPORT void
+RRCrtcChanged (RRCrtcPtr crtc, Bool layoutChanged);
+
+/*
+ * Create a CRTC
+ */
+extern _X_EXPORT RRCrtcPtr
+RRCrtcCreate (ScreenPtr pScreen, void	*devPrivate);
+
+/*
+ * Set the allowed rotations on a CRTC
+ */
+extern _X_EXPORT void
+RRCrtcSetRotations (RRCrtcPtr crtc, Rotation rotations);
+
+/*
+ * Set whether transforms are allowed on a CRTC
+ */
+extern _X_EXPORT void
+RRCrtcSetTransformSupport (RRCrtcPtr crtc, Bool transforms);
+
+/*
+ * Notify the extension that the Crtc has been reconfigured,
+ * the driver calls this whenever it has updated the mode
+ */
+extern _X_EXPORT Bool
+RRCrtcNotify (RRCrtcPtr	    crtc,
+	      RRModePtr	    mode,
+	      int	    x,
+	      int	    y,
+	      Rotation	    rotation,
+	      RRTransformPtr transform,
+	      int	    numOutputs,
+	      RROutputPtr   *outputs);
+
+extern _X_EXPORT void
+RRDeliverCrtcEvent (ClientPtr client, WindowPtr pWin, RRCrtcPtr crtc);
+    
+/*
+ * Request that the Crtc be reconfigured
+ */
+extern _X_EXPORT Bool
+RRCrtcSet (RRCrtcPtr    crtc,
+	   RRModePtr	mode,
+	   int		x,
+	   int		y,
+	   Rotation	rotation,
+	   int		numOutput,
+	   RROutputPtr  *outputs);
+
+/*
+ * Request that the Crtc gamma be changed
+ */
+
+extern _X_EXPORT Bool
+RRCrtcGammaSet (RRCrtcPtr   crtc,
+		CARD16	    *red,
+		CARD16	    *green,
+		CARD16	    *blue);
+
+/*
+ * Request current gamma back from the DDX (if possible).
+ * This includes gamma size.
+ */
+ 
+extern _X_EXPORT Bool
+RRCrtcGammaGet(RRCrtcPtr crtc);
+
+/*
+ * Notify the extension that the Crtc gamma has been changed
+ * The driver calls this whenever it has changed the gamma values
+ * in the RRCrtcRec
+ */
+
+extern _X_EXPORT Bool
+RRCrtcGammaNotify (RRCrtcPtr	crtc);
+
+/*
+ * Set the size of the gamma table at server startup time
+ */
+
+extern _X_EXPORT Bool
+RRCrtcGammaSetSize (RRCrtcPtr	crtc,
+		    int		size);
+
+/*
+ * Return the area of the frame buffer scanned out by the crtc,
+ * taking into account the current mode and rotation
+ */
+
+extern _X_EXPORT void
+RRCrtcGetScanoutSize(RRCrtcPtr crtc, int *width, int *height);
+
+/*
+ * Compute the complete transformation matrix including
+ * client-specified transform, rotation/reflection values and the crtc 
+ * offset.
+ *
+ * Return TRUE if the resulting transform is not a simple translation.
+ */
+extern _X_EXPORT Bool
+RRTransformCompute (int			    x,
+		    int			    y,
+		    int			    width,
+		    int			    height,
+		    Rotation		    rotation,
+		    RRTransformPtr	    rr_transform,
+
+		    PictTransformPtr	    transform,
+		    struct pict_f_transform *f_transform,
+		    struct pict_f_transform *f_inverse);
+
+/*
+ * Return crtc transform
+ */
+extern _X_EXPORT RRTransformPtr
+RRCrtcGetTransform (RRCrtcPtr crtc);
+
+/*
+ * Check whether the pending and current transforms are the same
+ */
+extern _X_EXPORT Bool
+RRCrtcPendingTransform (RRCrtcPtr crtc);
+
+/*
+ * Destroy a Crtc at shutdown
+ */
+extern _X_EXPORT void
+RRCrtcDestroy (RRCrtcPtr crtc);
+
+
+/*
+ * Set the pending CRTC transformation
+ */
+
+extern _X_EXPORT int
+RRCrtcTransformSet (RRCrtcPtr		crtc,
+		    PictTransformPtr	transform,
+		    struct pict_f_transform *f_transform,
+		    struct pict_f_transform *f_inverse,
+		    char		*filter,
+		    int			filter_len,
+		    xFixed		*params,
+		    int			nparams);
+
+/*
+ * Initialize crtc type
+ */
+extern _X_EXPORT Bool
+RRCrtcInit (void);
+
+/*
+ * Crtc dispatch
+ */
+
+extern _X_EXPORT int
+ProcRRGetCrtcInfo (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetCrtcConfig (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetCrtcGammaSize (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetCrtcGamma (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetCrtcGamma (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetCrtcTransform (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetCrtcTransform (ClientPtr client);
+
+int
+ProcRRGetPanning (ClientPtr client);
+
+int
+ProcRRSetPanning (ClientPtr client);
+
+/* rrdispatch.c */
+extern _X_EXPORT Bool
+RRClientKnowsRates (ClientPtr	pClient);
+
+/* rrmode.c */
+/*
+ * Find, and if necessary, create a mode
+ */
+
+extern _X_EXPORT RRModePtr
+RRModeGet (xRRModeInfo	*modeInfo,
+	   const char	*name);
+
+/*
+ * Destroy a mode.
+ */
+
+extern _X_EXPORT void
+RRModeDestroy (RRModePtr mode);
+
+/*
+ * Return a list of modes that are valid for some output in pScreen
+ */
+extern _X_EXPORT RRModePtr *
+RRModesForScreen (ScreenPtr pScreen, int *num_ret);
+    
+/*
+ * Initialize mode type
+ */
+extern _X_EXPORT Bool
+RRModeInit (void);
+    
+extern _X_EXPORT int
+ProcRRCreateMode (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRDestroyMode (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRAddOutputMode (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRDeleteOutputMode (ClientPtr client);
+
+/* rroutput.c */
+
+/*
+ * Notify the output of some change. configChanged indicates whether
+ * any external configuration (mode list, clones, connected status)
+ * has changed, or whether the change was strictly internal
+ * (which crtc is in use)
+ */
+extern _X_EXPORT void
+RROutputChanged (RROutputPtr output, Bool configChanged);
+
+/*
+ * Create an output
+ */
+
+extern _X_EXPORT RROutputPtr
+RROutputCreate (ScreenPtr   pScreen,
+		const char  *name,
+		int	    nameLength,
+		void	    *devPrivate);
+
+/*
+ * Notify extension that output parameters have been changed
+ */
+extern _X_EXPORT Bool
+RROutputSetClones (RROutputPtr  output,
+		   RROutputPtr  *clones,
+		   int		numClones);
+
+extern _X_EXPORT Bool
+RROutputSetModes (RROutputPtr	output,
+		  RRModePtr	*modes,
+		  int		numModes,
+		  int		numPreferred);
+
+extern _X_EXPORT int
+RROutputAddUserMode (RROutputPtr    output,
+		     RRModePtr	    mode);
+
+extern _X_EXPORT int
+RROutputDeleteUserMode (RROutputPtr output,
+			RRModePtr   mode);
+
+extern _X_EXPORT Bool
+RROutputSetCrtcs (RROutputPtr	output,
+		  RRCrtcPtr	*crtcs,
+		  int		numCrtcs);
+
+extern _X_EXPORT Bool
+RROutputSetConnection (RROutputPtr  output,
+		       CARD8	    connection);
+
+extern _X_EXPORT Bool
+RROutputSetSubpixelOrder (RROutputPtr output,
+			  int	      subpixelOrder);
+
+extern _X_EXPORT Bool
+RROutputSetPhysicalSize (RROutputPtr	output,
+			 int		mmWidth,
+			 int		mmHeight);
+
+extern _X_EXPORT void
+RRDeliverOutputEvent(ClientPtr client, WindowPtr pWin, RROutputPtr output);
+
+extern _X_EXPORT void
+RROutputDestroy (RROutputPtr	output);
+
+extern _X_EXPORT int
+ProcRRGetOutputInfo (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRSetOutputPrimary (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetOutputPrimary (ClientPtr client);
+
+/*
+ * Initialize output type
+ */
+extern _X_EXPORT Bool
+RROutputInit (void);
+    
+/* rrpointer.c */
+extern _X_EXPORT void
+RRPointerMoved (ScreenPtr pScreen, int x, int y);
+
+extern _X_EXPORT void
+RRPointerScreenConfigured (ScreenPtr pScreen);
+
+/* rrproperty.c */
+
+extern _X_EXPORT void
+RRDeleteAllOutputProperties (RROutputPtr output);
+
+extern _X_EXPORT RRPropertyValuePtr
+RRGetOutputProperty (RROutputPtr output, Atom property, Bool pending);
+
+extern _X_EXPORT RRPropertyPtr
+RRQueryOutputProperty (RROutputPtr output, Atom property);
+		       
+extern _X_EXPORT void
+RRDeleteOutputProperty (RROutputPtr output, Atom property);
+
+extern _X_EXPORT Bool
+RRPostPendingProperties (RROutputPtr output);
+    
+extern _X_EXPORT int
+RRChangeOutputProperty (RROutputPtr output, Atom property, Atom type,
+			int format, int mode, unsigned long len,
+			pointer value, Bool sendevent, Bool pending);
+
+extern _X_EXPORT int
+RRConfigureOutputProperty (RROutputPtr output, Atom property,
+			   Bool pending, Bool range, Bool immutable,
+			   int num_values, INT32 *values);
+extern _X_EXPORT int
+ProcRRChangeOutputProperty (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRGetOutputProperty (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRListOutputProperties (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRQueryOutputProperty (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRConfigureOutputProperty (ClientPtr client);
+
+extern _X_EXPORT int
+ProcRRDeleteOutputProperty (ClientPtr client);
+
+/* rrxinerama.c */
+#ifdef XINERAMA
+extern _X_EXPORT void
+RRXineramaExtensionInit(void);
+#endif
+
+#endif /* _RANDRSTR_H_ */
+
+/*
+ 
+randr extension implementation structure
+
+Query state:
+    ProcRRGetScreenInfo/ProcRRGetScreenResources
+	RRGetInfo
+ 
+	    • Request configuration from driver, either 1.0 or 1.2 style
+	    • These functions only record state changes, all
+	      other actions are pended until RRTellChanged is called
+ 
+	    ->rrGetInfo
+	    1.0:
+		RRRegisterSize
+		RRRegisterRate
+		RRSetCurrentConfig
+	    1.2:
+		RRScreenSetSizeRange
+		RROutputSetCrtcs
+		RRModeGet
+		RROutputSetModes
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROutputSetClones
+		RRCrtcNotify
+ 
+	• Must delay scanning configuration until after ->rrGetInfo returns
+	  because some drivers will call SetCurrentConfig in the middle
+	  of the ->rrGetInfo operation.
+ 
+	1.0:
+
+	    • Scan old configuration, mirror to new structures
+ 
+	    RRScanOldConfig
+		RRCrtcCreate
+		RROutputCreate
+		RROutputSetCrtcs
+		RROutputSetConnection
+		RROutputSetSubpixelOrder
+		RROldModeAdd	• This adds modes one-at-a-time
+		    RRModeGet
+		RRCrtcNotify
+ 
+	• send events, reset pointer if necessary
+ 
+	RRTellChanged
+	    WalkTree (sending events)
+ 
+	    • when layout has changed:
+		RRPointerScreenConfigured
+		RRSendConfigNotify
+ 
+Asynchronous state setting (1.2 only)
+    When setting state asynchronously, the driver invokes the
+    ->rrGetInfo function and then calls RRTellChanged to flush
+    the changes to the clients and reset pointer if necessary
+
+Set state
+
+    ProcRRSetScreenConfig
+	RRCrtcSet
+	    1.2:
+		->rrCrtcSet
+		    RRCrtcNotify
+	    1.0:
+		->rrSetConfig
+		RRCrtcNotify
+	    RRTellChanged
+ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86pciBus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86pciBus.h
@@ -0,0 +1,42 @@
+
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_PCI_BUS_H
+#define _XF86_PCI_BUS_H
+
+void xf86PciProbe(void);
+Bool xf86PciAddMatchingDev(DriverPtr drvp);
+Bool xf86PciProbeDev(DriverPtr drvp);
+void xf86PciIsolateDevice(char *argument);
+int xf86PciMatchDriver(char* matches[], int nmatches);
+
+#endif /* _XF86_PCI_BUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-private.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-private.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Private header file for USB support.  This file provides
+ * Linux-specific include files and the definition of the private
+ * structure.  \see usb-common.c \see usb-keyboard.c \see usb-mouse.c
+ * \see usb-other.c */
+
+#ifndef _USB_PRIVATE_H_
+#define _USB_PRIVATE_H_
+
+#include "dmxinputinit.h"
+#include "inputstr.h"
+#include <X11/Xos.h>
+#include <errno.h>
+#include <linux/input.h>
+#include "usb-common.h"
+
+                                /*  Support for force feedback was
+                                 *  introduced in Linxu 2.4.10 */
+#ifndef EV_MSC
+#define EV_MSC      0x04
+#endif
+#ifndef EV_FF
+#define EV_FF       0x15
+#endif
+#ifndef LED_SLEEP
+#define LED_SLEEP   0x05
+#endif
+#ifndef LED_SUSPEND
+#define LED_SUSPEND 0x06
+#endif
+#ifndef LED_MUTE
+#define LED_MUTE    0x07
+#endif
+#ifndef LED_MISC
+#define LED_MISC    0x08
+#endif
+#ifndef BTN_DEAD
+#define BTN_DEAD    0x12f
+#endif
+#ifndef BTN_THUMBL
+#define BTN_THUMBL  0x13d
+#endif
+#ifndef BTN_THUMBR
+#define BTN_THUMBR  0x13e
+#endif
+#ifndef MSC_SERIAL
+#define MSC_SERIAL  0x00
+#endif
+#ifndef MSC_MAX
+#define MSC_MAX     0x07
+#endif
+
+                                /* Support for older kernels. */
+#ifndef ABS_WHEEL
+#define ABS_WHEEL   0x08
+#endif
+#ifndef ABS_GAS
+#define ABS_GAS     0x09
+#endif
+#ifndef ABS_BRAKE
+#define ABS_BRAKE   0x0a
+#endif
+
+#define NUM_STATE_ENTRIES (256/32)
+
+/* Private area for USB devices. */
+typedef struct _myPrivate {
+    DeviceIntPtr   pDevice;                 /**< Device (mouse or other) */
+    int            fd;                      /**< File descriptor */
+    unsigned char  mask[EV_MAX/8 + 1];      /**< Mask */
+    int            numRel, numAbs, numLeds; /**< Counts */
+    int            relmap[DMX_MAX_AXES];    /**< Relative axis map */
+    int            absmap[DMX_MAX_AXES];    /**< Absolute axis map */
+
+    CARD32         kbdState[NUM_STATE_ENTRIES]; /**< Keyboard state */
+    DeviceIntPtr   pKeyboard;                   /** Keyboard device */
+
+    int            pitch;       /**< Bell pitch  */
+    unsigned long  duration;    /**< Bell duration */
+
+    /* FIXME: dmxInput is never initialized */
+    DMXInputInfo   *dmxInput;   /**< For pretty-printing */
+} myPrivate;
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Xinput.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Xinput.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright 1995-1999 by Frederic Lepied, France. <Lepied@XFree86.org>
+ *                                                                            
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is  hereby granted without fee, provided that
+ * the  above copyright   notice appear  in   all  copies and  that both  that
+ * copyright  notice   and   this  permission   notice  appear  in  supporting
+ * documentation, and that   the  name of  Frederic   Lepied not  be  used  in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific,  written      prior  permission.     Frederic  Lepied   makes  no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.                   
+ *                                                                            
+ * FREDERIC  LEPIED DISCLAIMS ALL   WARRANTIES WITH REGARD  TO  THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED   WARRANTIES OF MERCHANTABILITY  AND   FITNESS, IN NO
+ * EVENT  SHALL FREDERIC  LEPIED BE   LIABLE   FOR ANY  SPECIAL, INDIRECT   OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA  OR PROFITS, WHETHER  IN  AN ACTION OF  CONTRACT,  NEGLIGENCE OR OTHER
+ * TORTIOUS  ACTION, ARISING    OUT OF OR   IN  CONNECTION  WITH THE USE    OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * Copyright (c) 2000-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+#ifndef _xf86Xinput_h
+#define _xf86Xinput_h
+
+#include "xf86str.h"
+#include "inputstr.h"
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XIproto.h>
+#include "XIstubs.h"
+
+/* Input device flags */
+#define XI86_OPEN_ON_INIT       0x01 /* open the device at startup time */
+#define XI86_CONFIGURED         0x02 /* the device has been configured */
+#define XI86_ALWAYS_CORE	0x04 /* device always controls the pointer */
+/* the device sends Xinput and core pointer events */
+#define XI86_SEND_CORE_EVENTS	XI86_ALWAYS_CORE
+/* if the device is the core pointer or is sending core events, and
+ * SEND_DRAG_EVENTS is false, and a buttons is done, then no motion events
+ * (mouse drag action) are sent. This is mainly to allow a touch screen to be
+ * used with netscape and other browsers which do strange things if the mouse
+ * moves between button down and button up. With a touch screen, this motion
+ * is common due to the user's finger moving slightly.
+ */
+#define XI86_SEND_DRAG_EVENTS	0x08
+#define XI86_CORE_POINTER	0x10 /* device is the core pointer */
+#define XI86_CORE_KEYBOARD	0x20 /* device is the core keyboard */
+#define XI86_POINTER_CAPABLE	0x40 /* capable of being a core pointer */
+#define XI86_KEYBOARD_CAPABLE	0x80 /* capable of being a core keyboard */
+
+#define XI_PRIVATE(dev) \
+	(((LocalDevicePtr)((dev)->public.devicePrivate))->private)
+
+/* Valuator verification macro */
+#define XI_VERIFY_VALUATORS(num_valuators)					\
+	if (num_valuators > MAX_VALUATORS) {					\
+		xf86Msg(X_ERROR, "%s: num_valuator %d is greater than"		\
+			" MAX_VALUATORS\n", __FUNCTION__, num_valuators);	\
+		return;								\
+	}
+
+/* Stupid API backwards-compatibility. */
+#define TS_Raw 60
+#define TS_Scaled 61
+
+/* This holds the input driver entry and module information. */
+typedef struct _InputDriverRec {
+    int			    driverVersion;
+    char *		    driverName;
+    void		    (*Identify)(int flags);
+    struct _LocalDeviceRec *(*PreInit)(struct _InputDriverRec *drv,
+				       IDevPtr dev, int flags);
+    void		    (*UnInit)(struct _InputDriverRec *drv,
+				      struct _LocalDeviceRec *pInfo,
+				      int flags);
+    pointer		    module;
+    int			    refCount;
+} InputDriverRec, *InputDriverPtr;
+
+/* This is to input devices what the ScrnInfoRec is to screens. */
+
+typedef struct _LocalDeviceRec {
+    struct _LocalDeviceRec *next;
+    char *		    name;
+    int			    flags;
+
+    Bool		    (*device_control)(DeviceIntPtr device, int what);
+    void		    (*read_input)(struct _LocalDeviceRec *local);
+    int			    (*control_proc)(struct _LocalDeviceRec *local,
+					   xDeviceCtl *control);
+    void		    (*close_proc)(struct _LocalDeviceRec *local);
+    int			    (*switch_mode)(ClientPtr client, DeviceIntPtr dev,
+					  int mode);
+    Bool		    (*conversion_proc)(struct _LocalDeviceRec *local,
+					      int first, int num, int v0,
+					      int v1, int v2, int v3, int v4,
+					      int v5, int *x, int *y);
+    Bool		    (*reverse_conversion_proc)(
+					struct _LocalDeviceRec *local,
+					int x, int y, int *valuators);
+    int                     (*set_device_valuators)
+				(struct _LocalDeviceRec *local,
+				 int *valuators, int first_valuator,
+				 int num_valuators);
+
+    int			    fd;
+    Atom		    atom;
+    DeviceIntPtr	    dev;
+    pointer		    private;
+    int			    private_flags;
+    unsigned int	    first;
+    unsigned int	    last;
+    int			    old_x;
+    int			    old_y;
+    char *		    type_name;
+    IntegerFeedbackPtr	    always_core_feedback;
+    IDevPtr		    conf_idev;
+    InputDriverPtr	    drv;
+    pointer		    module;
+    pointer		    options;
+    unsigned int            history_size;
+    InputAttributes         *attrs;
+} LocalDeviceRec, *LocalDevicePtr, InputInfoRec, *InputInfoPtr;
+
+typedef struct _DeviceAssocRec 
+{
+    char *		    config_section_name;
+    LocalDevicePtr	    (*device_allocate)(void);
+} DeviceAssocRec, *DeviceAssocPtr;
+
+/* xf86Globals.c */
+extern _X_EXPORT InputInfoPtr xf86InputDevs;
+
+/* xf86Xinput.c */
+extern _X_EXPORT void xf86PostMotionEvent(DeviceIntPtr device, int is_absolute,
+			 int first_valuator, int num_valuators, ...);
+extern _X_EXPORT void xf86PostMotionEventP(DeviceIntPtr device, int is_absolute,
+			 int first_valuator, int num_valuators, int *valuators);
+extern _X_EXPORT void xf86PostProximityEvent(DeviceIntPtr device, int is_in,
+			    int first_valuator, int num_valuators, ...);
+extern _X_EXPORT void xf86PostProximityEventP(DeviceIntPtr device, int is_in, int first_valuator,
+			     int num_valuators, int *valuators);
+extern _X_EXPORT void xf86PostButtonEvent(DeviceIntPtr device, int is_absolute, int button,
+		    	 int is_down, int first_valuator, int num_valuators,
+			 ...);
+extern _X_EXPORT void xf86PostButtonEventP(DeviceIntPtr device, int is_absolute, int button,
+			  int is_down, int first_valuator, int num_valuators,
+			  int *valuators);
+extern _X_EXPORT void xf86PostKeyEvent(DeviceIntPtr device, unsigned int key_code, int is_down,
+		      int is_absolute, int first_valuator, int num_valuators,
+		      ...);
+extern _X_EXPORT void xf86PostKeyEventP(DeviceIntPtr device, unsigned int key_code, int is_down,
+		       int is_absolute, int first_valuator, int num_valuators,
+		       int *valuators);
+extern _X_EXPORT void xf86PostKeyboardEvent(DeviceIntPtr device, unsigned int key_code,
+                           int is_down);
+extern _X_EXPORT int xf86ActivateDevice(LocalDevicePtr local);
+extern _X_EXPORT LocalDevicePtr xf86FirstLocalDevice(void);
+extern _X_EXPORT int xf86ScaleAxis(int Cx, int Sxhigh, int Sxlow, int Rxhigh, int Rxlow);
+extern _X_EXPORT void xf86XInputSetScreen(LocalDevicePtr local, int screen_number, int x, int y);
+extern _X_EXPORT void xf86ProcessCommonOptions(InputInfoPtr pInfo, pointer options);
+extern _X_EXPORT void xf86InitValuatorAxisStruct(DeviceIntPtr dev, int axnum, Atom label, int minval,
+				int maxval, int resolution, int min_res,
+				int max_res);
+extern _X_EXPORT void xf86InitValuatorDefaults(DeviceIntPtr dev, int axnum);
+extern _X_EXPORT void xf86AddEnabledDevice(InputInfoPtr pInfo);
+extern _X_EXPORT void xf86RemoveEnabledDevice(InputInfoPtr pInfo);
+extern _X_EXPORT void xf86DisableDevice(DeviceIntPtr dev, Bool panic);
+extern _X_EXPORT void xf86EnableDevice(DeviceIntPtr dev);
+/* not exported */
+int xf86NewInputDevice(IDevPtr idev, DeviceIntPtr *pdev, BOOL is_auto);
+
+/* xf86Helper.c */
+extern _X_EXPORT void xf86AddInputDriver(InputDriverPtr driver, pointer module, int flags);
+extern _X_EXPORT void xf86DeleteInputDriver(int drvIndex);
+extern _X_EXPORT InputInfoPtr xf86AllocateInput(InputDriverPtr drv, int flags);
+extern _X_EXPORT InputDriverPtr xf86LookupInputDriver(const char *name);
+extern _X_EXPORT InputInfoPtr xf86LookupInput(const char *name);
+extern _X_EXPORT void xf86DeleteInput(InputInfoPtr pInp, int flags);
+extern _X_EXPORT void xf86MotionHistoryAllocate(LocalDevicePtr local);
+
+/* xf86Option.c */
+extern _X_EXPORT void xf86CollectInputOptions(InputInfoPtr pInfo, const char **defaultOpts,
+			     pointer extraOpts);
+
+
+/* Legacy hatred */
+#define SendCoreEvents 59
+#define DontSendCoreEvents 60
+
+#endif /* _xf86Xinput_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RamDac.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86RamDac.h
@@ -0,0 +1,121 @@
+
+#ifndef _XF86RAMDAC_H
+#define _XF86RAMDAC_H 1
+
+#include "colormapst.h"
+#include "xf86Cursor.h"
+
+/* Define unique vendor codes for RAMDAC's */
+#define VENDOR_IBM	0x0000
+#define VENDOR_BT	0x0001
+#define VENDOR_TI	0x0002
+
+typedef struct _RamDacRegRec {
+/* This is probably the nastiest assumption, we allocate 1024 slots for
+ * ramdac registers, should be enough. I've checked IBM and TVP series 
+ * and they seem o.k 
+ * Then we allocate 768 entries for the DAC too. IBM640 needs 1024 -FIXME
+ */
+    unsigned short DacRegs[0x400];	/* register set */
+    unsigned char DAC[0x300];		/* colour map */
+    Bool Overlay;
+} RamDacRegRec, *RamDacRegRecPtr;
+
+typedef struct _RamDacHWRegRec {
+    RamDacRegRec	SavedReg;
+    RamDacRegRec	ModeReg;
+} RamDacHWRec, *RamDacHWRecPtr;
+
+typedef struct _RamDacRec {
+    CARD32 RamDacType;
+
+    void (*LoadPalette)(
+	ScrnInfoPtr pScrn, 
+	int numColors, 
+	int *indices, 
+	LOCO *colors,
+	VisualPtr pVisual
+    );
+
+    unsigned char (*ReadDAC)(
+	ScrnInfoPtr pScrn,
+	CARD32
+    );
+
+    void (*WriteDAC)(
+	ScrnInfoPtr pScrn,
+	CARD32,
+	unsigned char,
+	unsigned char
+    );
+
+    void (*WriteAddress)(
+	ScrnInfoPtr pScrn,
+	CARD32
+    );
+
+    void (*WriteData)(
+	ScrnInfoPtr pScrn,
+	unsigned char
+    );
+
+    void (*ReadAddress)(
+	ScrnInfoPtr pScrn,
+	CARD32
+    );
+
+    unsigned char (*ReadData)(
+	ScrnInfoPtr pScrn
+    );
+} RamDacRec, *RamDacRecPtr;
+
+typedef struct _RamDacHelperRec {
+    CARD32 RamDacType;
+
+    void (*Restore)(
+	ScrnInfoPtr pScrn,
+	RamDacRecPtr ramdacPtr,
+	RamDacRegRecPtr ramdacReg
+    );
+
+    void (*Save)(
+	ScrnInfoPtr pScrn,
+	RamDacRecPtr ramdacPtr,
+	RamDacRegRecPtr ramdacReg
+    );
+
+    void (*SetBpp)(
+	ScrnInfoPtr pScrn,
+	RamDacRegRecPtr ramdacReg
+    );
+
+    void (*HWCursorInit)(
+	xf86CursorInfoPtr infoPtr
+    );
+} RamDacHelperRec, *RamDacHelperRecPtr;
+
+#define RAMDACHWPTR(p) ((RamDacHWRecPtr)((p)->privates[RamDacGetHWIndex()].ptr))
+
+typedef struct _RamdacScreenRec {
+    RamDacRecPtr	RamDacRec;
+} RamDacScreenRec, *RamDacScreenRecPtr;
+#define RAMDACSCRPTR(p) ((RamDacScreenRecPtr)((p)->privates[RamDacGetScreenIndex()].ptr))->RamDacRec
+
+extern _X_EXPORT int RamDacHWPrivateIndex;
+extern _X_EXPORT int RamDacScreenPrivateIndex;
+
+typedef struct {
+    int		token;
+} RamDacSupportedInfoRec, *RamDacSupportedInfoRecPtr;
+
+extern _X_EXPORT RamDacRecPtr RamDacCreateInfoRec(void);
+extern _X_EXPORT RamDacHelperRecPtr RamDacHelperCreateInfoRec(void);
+extern _X_EXPORT void RamDacDestroyInfoRec(RamDacRecPtr RamDacRec);
+extern _X_EXPORT void RamDacHelperDestroyInfoRec(RamDacHelperRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacInit(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec);
+extern _X_EXPORT Bool RamDacHandleColormaps(ScreenPtr pScreen, int maxColors, int sigRGBbits,
+			   unsigned int flags);
+extern _X_EXPORT void RamDacFreeRec(ScrnInfoPtr pScrn);
+extern _X_EXPORT int  RamDacGetHWIndex(void);
+
+#endif /* _XF86RAMDAC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-other.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-other.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB generic driver.  \see usb-other.c \see usb-common.c */
+
+#ifndef _USB_OTHER_H_
+#define _USB_OTHER_H_
+extern void    othUSBRead(DevicePtr pDev,
+                          dmxMotionProcPtr motion,
+                          dmxEnqueueProcPtr enqueue,
+                          dmxCheckSpecialProcPtr checkspecial,
+                          DMXBlockType block);
+extern void    othUSBInit(DevicePtr pDev);
+extern void    othUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     othUSBOn(DevicePtr pDev);
+extern void    othUSBCtrl(DevicePtr pDev, PtrCtrl *ctrl);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xacestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xacestr.h
@@ -0,0 +1,147 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XACESTR_H
+#define _XACESTR_H
+
+#include "dix.h"
+#include "resource.h"
+#include "extnsionst.h"
+#include "window.h"
+#include "input.h"
+#include "property.h"
+#include "selection.h"
+#include "xace.h"
+
+/* XACE_CORE_DISPATCH */
+typedef struct {
+    ClientPtr client;
+    int status;
+} XaceCoreDispatchRec;
+
+/* XACE_RESOURCE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    XID id;
+    RESTYPE rtype;
+    pointer res;
+    RESTYPE ptype;
+    pointer parent;
+    Mask access_mode;
+    int status;
+} XaceResourceAccessRec;
+
+/* XACE_DEVICE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    DeviceIntPtr dev;
+    Mask access_mode;
+    int status;
+} XaceDeviceAccessRec;
+
+/* XACE_PROPERTY_ACCESS */
+typedef struct {
+    ClientPtr client;
+    WindowPtr pWin;
+    PropertyPtr *ppProp;
+    Mask access_mode;
+    int status;
+} XacePropertyAccessRec;
+
+/* XACE_SEND_ACCESS */
+typedef struct {
+    ClientPtr client;
+    DeviceIntPtr dev;
+    WindowPtr pWin;
+    xEventPtr events;
+    int count;
+    int status;
+} XaceSendAccessRec;
+
+/* XACE_RECEIVE_ACCESS */
+typedef struct {
+    ClientPtr client;
+    WindowPtr pWin;
+    xEventPtr events;
+    int count;
+    int status;
+} XaceReceiveAccessRec;
+
+/* XACE_CLIENT_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ClientPtr target;
+    Mask access_mode;
+    int status;
+} XaceClientAccessRec;
+
+/* XACE_EXT_DISPATCH */
+/* XACE_EXT_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ExtensionEntry *ext;
+    Mask access_mode;
+    int status;
+} XaceExtAccessRec;
+
+/* XACE_SERVER_ACCESS */
+typedef struct {
+    ClientPtr client;
+    Mask access_mode;
+    int status;
+} XaceServerAccessRec;
+
+/* XACE_SELECTION_ACCESS */
+typedef struct {
+    ClientPtr client;
+    Selection **ppSel;
+    Mask access_mode;
+    int status;
+} XaceSelectionAccessRec;
+
+/* XACE_SCREEN_ACCESS */
+/* XACE_SCREENSAVER_ACCESS */
+typedef struct {
+    ClientPtr client;
+    ScreenPtr screen;
+    Mask access_mode;
+    int status;
+} XaceScreenAccessRec;
+
+/* XACE_AUTH_AVAIL */
+typedef struct {
+    ClientPtr client;
+    XID authId;
+} XaceAuthAvailRec;
+
+/* XACE_KEY_AVAIL */
+typedef struct {
+    xEventPtr event;
+    DeviceIntPtr keybd;
+    int count;
+} XaceKeyAvailRec;
+
+/* XACE_AUDIT_BEGIN */
+/* XACE_AUDIT_END */
+typedef struct {
+    ClientPtr client;
+    int requestResult;
+} XaceAuditRec;
+
+#endif /* _XACESTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/msp3430.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/msp3430.h
@@ -0,0 +1,113 @@
+#ifndef __MSP3430_H__
+#define __MSP3430_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+        I2CDevRec d;
+	
+	int standard;
+	int connector;
+	int mode;
+
+        CARD8 hardware_version, major_revision, product_code, rom_version;
+#ifdef MSP_DEBUG
+	CARD8 registers_present[256];
+#endif
+
+	CARD16 chip_id;
+	CARD8  chip_family;
+	Bool  recheck;		/*reinitialization needed after channel change */
+	CARD8 c_format;		/*current state of audio format */
+	CARD16 c_standard;	/*current state of standard register */
+	CARD8	c_source;	/*current state of source register */
+	CARD8	c_matrix;	/*current state of matrix register */
+	CARD8	c_fmmatrix;	/*current state of fmmatrix register */
+	int		c_mode;	/* current state of mode for autoswitchimg */
+	CARD8	volume;
+	} MSP3430Rec, * MSP3430Ptr;
+
+
+#define MSP3430_ADDR_1      0x80
+#define MSP3430_ADDR_2		0x84
+#define MSP3430_ADDR_3		0x88
+
+#define MSP3430_PAL		1
+#define MSP3430_NTSC		2
+#define MSP3430_PAL_DK1         (0x100 | MSP3430_PAL)
+#define MSP3430_SECAM           3
+
+#define MSP3430_CONNECTOR_1     1   /* tuner on AIW cards */
+#define MSP3430_CONNECTOR_2     2   /* SVideo on AIW cards */
+#define MSP3430_CONNECTOR_3     3   /* composite on AIW cards */
+
+#define MSP3430_ADDR(a)         ((a)->d.SlaveAddr)
+
+#define MSP3430_FAST_MUTE	0xFF
+/* a handy volume transform function, -1000..1000 -> 0x01..0x7F */
+#define MSP3430_VOLUME(value) (0x01+(0x7F-0x01)*log(value+1001)/log(2001))
+
+/*----------------------------------------------------------*/
+
+/* MSP chip families */
+#define MSPFAMILY_UNKNOWN	0	
+#define MSPFAMILY_34x0D		1
+#define MSPFAMILY_34x5D		2
+#define MSPFAMILY_34x0G		3
+#define MSPFAMILY_34x5G		4
+
+/* values for MSP standard */
+#define MSPSTANDARD_UNKNOWN	0x00
+#define MSPSTANDARD_AUTO	0x01
+#define MSPSTANDARD_FM_M	0x02
+#define MSPSTANDARD_FM_BG	0x03
+#define MSPSTANDARD_FM_DK1	0x04
+#define MSPSTANDARD_FM_DK2	0x04
+#define MSPSTANDARD_NICAM_BG	0x08
+#define MSPSTANDARD_NICAM_L	0x09
+#define MSPSTANDARD_NICAM_I	0x0A
+#define MSPSTANDARD_NICAM_DK	0x0B
+
+/* values for MSP format */
+#define MSPFORMAT_UNKNOWN	0x00
+#define MSPFORMAT_FM		0x10
+#define MSPFORMAT_1xFM		0x00|MSPFORMAT_FM
+#define MSPFORMAT_2xFM		0x01|MSPFORMAT_FM
+#define MSPFORMAT_NICAM		0x20
+#define MSPFORMAT_NICAM_FM	0x00|MSPFORMAT_NICAM
+#define MSPFORMAT_NICAM_AM	0x01|MSPFORMAT_NICAM
+#define MSPFORMAT_SCART		0x30
+
+/* values for MSP mode */
+#define MSPMODE_UNKNOWN		0
+/* automatic modes */
+#define MSPMODE_STEREO_AB	1
+#define MSPMODE_STEREO_A	2
+#define MSPMODE_STEREO_B	3
+/* forced modes */
+#define MSPMODE_MONO		4
+#define MSPMODE_STEREO		5
+#define MSPMODE_AB			6
+#define MSPMODE_A			7
+#define MSPMODE_B			8
+/*----------------------------------------------------------*/
+
+#define xf86_InitMSP3430	InitMSP3430
+extern _X_EXPORT void InitMSP3430(MSP3430Ptr m);
+#define xf86_DetectMSP3430	DetectMSP3430
+extern _X_EXPORT MSP3430Ptr DetectMSP3430(I2CBusPtr b, I2CSlaveAddr addr);
+#define xf86_ResetMSP3430	ResetMSP3430
+extern _X_EXPORT void ResetMSP3430(MSP3430Ptr m);
+#define xf86_MSP3430SetVolume	MSP3430SetVolume
+extern _X_EXPORT void MSP3430SetVolume (MSP3430Ptr m, CARD8 value);
+#define xf86_MSP3430SetSAP	MSP3430SetSAP
+extern _X_EXPORT void MSP3430SetSAP (MSP3430Ptr m, int mode);
+
+#define MSP3430SymbolsList \
+		"InitMSP3430", \
+		"DetectMSP3430", \
+		"ResetMSP3430", \
+		"MSP3430SetVolume", \
+		"MSP3430SetSAP"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiallowev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiallowev.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIALLOWEV_H
+#define XIALLOWEV_H 1
+
+int ProcXIAllowEvents(ClientPtr client);
+int SProcXIAllowEvents(ClientPtr client);
+
+#endif /* XIALLOWEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootless.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootless.h
@@ -0,0 +1,450 @@
+/*
+ * External interface to generic rootless mode
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ * Copyright (c) 2002-2003 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _ROOTLESS_H
+#define _ROOTLESS_H
+
+#include "rootlessConfig.h"
+#include "mi.h"
+#include "gcstruct.h"
+
+/*
+   Each top-level rootless window has a one-to-one correspondence to a physical
+   on-screen window. The physical window is refered to as a "frame".
+ */
+
+typedef void * RootlessFrameID;
+
+/*
+ * RootlessWindowRec
+ *  This structure stores the per-frame data used by the rootless code.
+ *  Each top-level X window has one RootlessWindowRec associated with it.
+ */
+typedef struct _RootlessWindowRec {
+    // Position and size includes the window border
+    // Position is in per-screen coordinates
+    int x, y;
+    unsigned int width, height;
+    unsigned int borderWidth;
+    int level;
+
+    RootlessFrameID wid;	// implementation specific frame id
+    WindowPtr win;		// underlying X window
+
+    // Valid only when drawing (ie. is_drawing is set)
+    char *pixelData;
+    int bytesPerRow;
+
+    PixmapPtr pixmap;
+
+#ifdef ROOTLESS_TRACK_DAMAGE
+    RegionRec damage;
+#endif
+
+    unsigned int is_drawing :1;	// Currently drawing?
+    unsigned int is_reorder_pending :1;
+    unsigned int is_offscreen :1;
+    unsigned int is_obscured :1;
+} RootlessWindowRec, *RootlessWindowPtr;
+
+
+/* Offset for screen-local to global coordinate transforms */
+#ifdef ROOTLESS_GLOBAL_COORDS
+extern int rootlessGlobalOffsetX;
+extern int rootlessGlobalOffsetY;
+#endif
+
+/* The minimum number of bytes or pixels for which to use the
+   implementation's accelerated functions. */
+extern unsigned int rootless_CopyBytes_threshold;
+extern unsigned int rootless_FillBytes_threshold;
+extern unsigned int rootless_CompositePixels_threshold;
+extern unsigned int rootless_CopyWindow_threshold;
+
+/* Operations used by CompositePixels */
+enum rl_composite_op_enum {
+    RL_COMPOSITE_SRC = 0,
+    RL_COMPOSITE_OVER,
+};
+
+/* Data formats for depth field and composite functions */
+enum rl_depth_enum {
+    RL_DEPTH_NIL = 0,			/* null source when compositing */
+    RL_DEPTH_ARGB8888,
+    RL_DEPTH_RGB555,
+    RL_DEPTH_A8,			/* for masks when compositing */
+    RL_DEPTH_INDEX8,
+};
+
+/* Macro to form the composite function for CompositePixels */
+#define RL_COMPOSITE_FUNCTION(op, src_depth, mask_depth, dest_depth) \
+    (((op) << 24) | ((src_depth) << 16) \
+     | ((mask_depth) << 8) | ((dest_depth) << 0))
+
+/* Gravity for window contents during resizing */
+enum rl_gravity_enum {
+    RL_GRAVITY_NONE             = 0,	/* no gravity, fill everything */
+    RL_GRAVITY_NORTH_WEST       = 1,	/* anchor to top-left corner */
+    RL_GRAVITY_NORTH_EAST       = 2,	/* anchor to top-right corner */
+    RL_GRAVITY_SOUTH_EAST       = 3,	/* anchor to bottom-right corner */
+    RL_GRAVITY_SOUTH_WEST       = 4,	/* anchor to bottom-left corner */
+};
+
+
+/*------------------------------------------
+   Rootless Implementation Functions
+  ------------------------------------------*/
+
+/*
+ * Create a new frame.
+ *  The frame is created unmapped.
+ *
+ *  pFrame      RootlessWindowPtr for this frame should be completely
+ *              initialized before calling except for pFrame->wid, which
+ *              is set by this function.
+ *  pScreen     Screen on which to place the new frame
+ *  newX, newY  Position of the frame. These will be identical to pFrame-x,
+ *              pFrame->y unless ROOTLESS_GLOBAL_COORDS is set.
+ *  pNewShape   Shape for the frame (in frame-local coordinates). NULL for
+ *              unshaped frames.
+ */
+typedef Bool (*RootlessCreateFrameProc)
+    (RootlessWindowPtr pFrame, ScreenPtr pScreen, int newX, int newY,
+     RegionPtr pNewShape);
+
+/*
+ * Destroy a frame.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ */
+typedef void (*RootlessDestroyFrameProc)
+    (RootlessFrameID wid);
+
+/*
+ * Move a frame on screen.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ *  pScreen     Screen to move the new frame to
+ *  newX, newY  New position of the frame
+ */
+typedef void (*RootlessMoveFrameProc) 
+    (RootlessFrameID wid, ScreenPtr pScreen, int newX, int newY);
+
+/*
+ * Resize and move a frame.
+ *  Drawing is stopped and all updates are flushed before this is called.
+ *
+ *  wid         Frame id
+ *  pScreen     Screen to move the new frame to
+ *  newX, newY  New position of the frame
+ *  newW, newH  New size of the frame
+ *  gravity     Gravity for window contents (rl_gravity_enum). This is always
+ *              RL_GRAVITY_NONE unless ROOTLESS_RESIZE_GRAVITY is set.
+ */
+typedef void (*RootlessResizeFrameProc)
+    (RootlessFrameID wid, ScreenPtr pScreen,
+     int newX, int newY, unsigned int newW, unsigned int newH,
+     unsigned int gravity);
+
+/*
+ * Change frame ordering (AKA stacking, layering).
+ *  Drawing is stopped before this is called. Unmapped frames are mapped by
+ *  setting their ordering.
+ *
+ *  wid         Frame id
+ *  nextWid     Frame id of frame that is now above this one or NULL if this
+ *              frame is at the top.
+ */
+typedef void (*RootlessRestackFrameProc)
+    (RootlessFrameID wid, RootlessFrameID nextWid);
+
+/*
+ * Change frame's shape.
+ *  Drawing is stopped before this is called.
+ *
+ *  wid         Frame id
+ *  pNewShape   New shape for the frame (in frame-local coordinates)
+ *              or NULL if now unshaped.
+ */
+typedef void (*RootlessReshapeFrameProc)
+    (RootlessFrameID wid, RegionPtr pNewShape);
+
+/*
+ * Unmap a frame.
+ *
+ *  wid         Frame id
+ */
+typedef void (*RootlessUnmapFrameProc)
+    (RootlessFrameID wid);
+
+/*
+ * Start drawing to a frame.
+ *  Prepare a frame for direct access to its backing buffer.
+ *
+ *  wid         Frame id
+ *  pixelData   Address of the backing buffer (returned)
+ *  bytesPerRow Width in bytes of the backing buffer (returned)
+ */
+typedef void (*RootlessStartDrawingProc)
+    (RootlessFrameID wid, char **pixelData, int *bytesPerRow);
+
+/*
+ * Stop drawing to a frame.
+ *  No drawing to the frame's backing buffer will occur until drawing
+ *  is started again.
+ *
+ *  wid         Frame id
+ *  flush       Flush drawing updates for this frame to the screen. This
+ *              will always be FALSE if ROOTLESS_TRACK_DAMAGE is set.
+ */
+typedef void (*RootlessStopDrawingProc)
+    (RootlessFrameID wid, Bool flush);
+
+/*
+ * Flush drawing updates to the screen.
+ *  Drawing is stopped before this is called.
+ *
+ *  wid         Frame id
+ *  pDamage     Region containing all the changed pixels in frame-lcoal
+ *              coordinates. This is clipped to the window's clip. This
+ *              will be NULL if ROOTLESS_TRACK_DAMAGE is not set.
+ */
+typedef void (*RootlessUpdateRegionProc)
+    (RootlessFrameID wid, RegionPtr pDamage);
+
+/*
+ * Mark damaged rectangles as requiring redisplay to screen.
+ *  This will only be called if ROOTLESS_TRACK_DAMAGE is not set.
+ *
+ *  wid         Frame id
+ *  nrects      Number of damaged rectangles
+ *  rects       Array of damaged rectangles in frame-local coordinates
+ *  shift_x,    Vector to shift rectangles by
+ *   shift_y
+ */
+typedef void (*RootlessDamageRectsProc)
+    (RootlessFrameID wid, int nrects, const BoxRec *rects,
+     int shift_x, int shift_y);
+
+/*
+ * Switch the window associated with a frame. (Optional)
+ *  When a framed window is reparented, the frame is resized and set to
+ *  use the new top-level parent. If defined this function will be called
+ *  afterwards for implementation specific bookkeeping.
+ *
+ *  pFrame      Frame whose window has switched
+ *  oldWin      Previous window wrapped by this frame
+ */
+typedef void (*RootlessSwitchWindowProc)
+    (RootlessWindowPtr pFrame, WindowPtr oldWin);
+
+/*
+ * Check if window should be reordered. (Optional)
+ *  The underlying window system may animate windows being ordered in.
+ *  We want them to be mapped but remain ordered out until the animation
+ *  completes. If defined this function will be called to check if a
+ *  framed window should be reordered now. If this function returns
+ *  FALSE, the window will still be mapped from the X11 perspective, but
+ *  the RestackFrame function will not be called for its frame.
+ *
+ *  pFrame      Frame to reorder
+ */
+typedef Bool (*RootlessDoReorderWindowProc)
+    (RootlessWindowPtr pFrame);
+
+/*
+ * Copy bytes. (Optional)
+ *  Source and destinate may overlap and the right thing should happen.
+ *
+ *  width       Bytes to copy per row
+ *  height      Number of rows
+ *  src         Source data
+ *  srcRowBytes Width of source in bytes
+ *  dst         Destination data
+ *  dstRowBytes Width of destination in bytes
+ */
+typedef void (*RootlessCopyBytesProc)
+    (unsigned int width, unsigned int height,
+     const void *src, unsigned int srcRowBytes,
+     void *dst, unsigned int dstRowBytes);
+
+/*
+ * Fill memory with 32-bit pattern. (Optional)
+ *
+ *  width       Bytes to fill per row
+ *  height      Number of rows
+ *  value       32-bit pattern to fill with
+ *  dst         Destination data
+ *  dstRowBytes Width of destination in bytes
+ */
+typedef void (*RootlessFillBytesProc)
+    (unsigned int width, unsigned int height, unsigned int value,
+     void *dst, unsigned int dstRowBytes);
+
+/*
+ * Composite pixels from source and mask to destination. (Optional)
+ *
+ *  width, height   Size of area to composite to in pizels
+ *  function        Composite function built with RL_COMPOSITE_FUNCTION
+ *  src             Source data
+ *  srcRowBytes     Width of source in bytes (Passing NULL means source
+ *                  is a single pixel.
+ *  mask            Mask data
+ *  maskRowBytes    Width of mask in bytes
+ *  dst             Destination data
+ *  dstRowBytes     Width of destination in bytes
+ *
+ *  For src and dst, the first element of the array is the color data. If
+ *  the second element is non-null it implies there is alpha data (which
+ *  may be meshed or planar). Data without alpha is assumed to be opaque.
+ *
+ *  An X11 error code is returned.
+ */
+typedef int (*RootlessCompositePixelsProc)
+    (unsigned int width, unsigned int height, unsigned int function,
+     void *src[2], unsigned int srcRowBytes[2],
+     void *mask, unsigned int maskRowBytes,
+     void *dst[2], unsigned int dstRowBytes[2]);
+
+/*
+ * Copy area in frame to another part of frame. (Optional)
+ *
+ *  wid         Frame id
+ *  dstNrects   Number of rectangles to copy
+ *  dstRects    Array of rectangles to copy
+ *  dx, dy      Number of pixels away to copy area
+ */
+typedef void (*RootlessCopyWindowProc)
+    (RootlessFrameID wid, int dstNrects, const BoxRec *dstRects,
+     int dx, int dy);
+
+
+typedef void (*RootlessHideWindowProc)
+     (RootlessFrameID wid);
+
+typedef void (*RootlessUpdateColormapProc)
+     (RootlessFrameID wid, ScreenPtr pScreen);
+
+/*
+ * Rootless implementation function list
+ */
+typedef struct _RootlessFrameProcs {
+    RootlessCreateFrameProc CreateFrame;
+    RootlessDestroyFrameProc DestroyFrame;
+
+    RootlessMoveFrameProc MoveFrame;
+    RootlessResizeFrameProc ResizeFrame;
+    RootlessRestackFrameProc RestackFrame;
+    RootlessReshapeFrameProc ReshapeFrame;
+    RootlessUnmapFrameProc UnmapFrame;
+
+    RootlessStartDrawingProc StartDrawing;
+    RootlessStopDrawingProc StopDrawing;
+    RootlessUpdateRegionProc UpdateRegion;
+#ifndef ROOTLESS_TRACK_DAMAGE
+    RootlessDamageRectsProc DamageRects;
+#endif
+
+    /* Optional frame functions */
+    RootlessSwitchWindowProc SwitchWindow;
+    RootlessDoReorderWindowProc DoReorderWindow;
+    RootlessHideWindowProc HideWindow;
+    RootlessUpdateColormapProc UpdateColormap;
+
+    /* Optional acceleration functions */
+    RootlessCopyBytesProc CopyBytes;
+    RootlessFillBytesProc FillBytes;
+    RootlessCompositePixelsProc CompositePixels;
+    RootlessCopyWindowProc CopyWindow;
+} RootlessFrameProcsRec, *RootlessFrameProcsPtr;
+
+
+/*
+ * Initialize rootless mode on the given screen.
+ */
+Bool RootlessInit(ScreenPtr pScreen, RootlessFrameProcsPtr procs);
+
+/*
+ * Initialize acceleration for rootless mode on a given screen.
+ *  Note: RootlessAccelInit() must be called before DamageSetup()
+ *  and RootlessInit() must be called afterwards.
+ */
+Bool RootlessAccelInit(ScreenPtr pScreen);
+
+/*
+ * Return the frame ID for the physical window displaying the given window. 
+ *
+ *  create      If true and the window has no frame, attempt to create one
+ */
+RootlessFrameID RootlessFrameForWindow(WindowPtr pWin, Bool create);
+
+/*
+ * Return the top-level parent of a window.
+ *  The root is the top-level parent of itself, even though the root is
+ *  not otherwise considered to be a top-level window.
+ */
+WindowPtr TopLevelParent(WindowPtr pWindow);
+
+/*
+ * Prepare a window for direct access to its backing buffer.
+ */
+void RootlessStartDrawing(WindowPtr pWindow);
+
+/*
+ * Finish drawing to a window's backing buffer.
+ *
+ *  flush       If true and ROOTLESS_TRACK_DAMAGE is set, damaged areas
+ *              are flushed to the screen.
+ */
+void RootlessStopDrawing(WindowPtr pWindow, Bool flush);
+
+/*
+ * Alocate a new screen pixmap.
+ *  miCreateScreenResources does not do this properly with a null
+ *  framebuffer pointer.
+ */
+void RootlessUpdateScreenPixmap(ScreenPtr pScreen);
+
+/*
+ * Reposition all windows on a screen to their correct positions.
+ */
+void RootlessRepositionWindows(ScreenPtr pScreen);
+
+/*
+ * Bring all windows to the front of the native stack
+ */
+void RootlessOrderAllWindows (Bool include_unhitable);
+#endif /* _ROOTLESS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxconsole.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxconsole.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for console device support.  \see dmxconsole.c \see dmxcommon.c */
+
+#ifndef _DMXCONSOLE_H_
+#define _DMXCONSOLE_H_
+
+extern pointer dmxConsoleCreatePrivate(DeviceIntPtr pDevice);
+extern void    dmxConsoleDestroyPrivate(pointer private);
+extern void    dmxConsoleInit(DevicePtr pDev);
+extern void    dmxConsoleReInit(DevicePtr pDev);
+extern void    dmxConsoleMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void    dmxConsoleKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void    dmxConsoleCollectEvents(DevicePtr pDev,
+                                       dmxMotionProcPtr motion,
+                                       dmxEnqueueProcPtr enqueue,
+                                       dmxCheckSpecialProcPtr checkspecial,
+                                       DMXBlockType block);
+extern int     dmxConsoleFunctions(pointer private, DMXFunctionType function);
+extern void    dmxConsoleUpdatePosition(pointer private, int x, int y);
+extern void    dmxConsoleKbdSetCtrl(pointer private, KeybdCtrl *ctrl);
+extern void    dmxConsoleCapture(DMXInputInfo *dmxInput);
+extern void    dmxConsoleUncapture(DMXInputInfo *dmxInput);
+extern void    dmxConsoleUpdateInfo(pointer private,
+                                    DMXUpdateType, WindowPtr pWindow);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mizerarc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mizerarc.h
@@ -0,0 +1,126 @@
+/************************************************************
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+********************************************************/
+
+
+typedef struct {
+    int x;
+    int y;
+    int mask;
+} miZeroArcPtRec;
+
+typedef struct {
+    int x, y, k1, k3, a, b, d, dx, dy;
+    int alpha, beta;
+    int xorg, yorg;
+    int xorgo, yorgo;
+    int w, h;
+    int initialMask;
+    miZeroArcPtRec start, altstart, end, altend;
+    int firstx, firsty;
+    int startAngle, endAngle;
+} miZeroArcRec;
+
+#define miCanZeroArc(arc) (((arc)->width == (arc)->height) || \
+			   (((arc)->width <= 800) && ((arc)->height <= 800)))
+
+#define MIARCSETUP() \
+    x = info.x; \
+    y = info.y; \
+    k1 = info.k1; \
+    k3 = info.k3; \
+    a = info.a; \
+    b = info.b; \
+    d = info.d; \
+    dx = info.dx; \
+    dy = info.dy
+
+#define MIARCOCTANTSHIFT(clause) \
+    if (a < 0) \
+    { \
+	if (y == info.h) \
+	{ \
+	    d = -1; \
+	    a = b = k1 = 0; \
+	} \
+	else \
+	{ \
+	    dx = (k1 << 1) - k3; \
+	    k1 = dx - k1; \
+	    k3 = -k3; \
+	    b = b + a - (k1 >> 1); \
+	    d = b + ((-a) >> 1) - d + (k3 >> 3); \
+	    if (dx < 0) \
+		a = -((-dx) >> 1) - a; \
+	    else \
+		a = (dx >> 1) - a; \
+	    dx = 0; \
+	    dy = 1; \
+	    clause \
+	} \
+    }
+
+#define MIARCSTEP(move1,move2) \
+    b -= k1; \
+    if (d < 0) \
+    { \
+	x += dx; \
+	y += dy; \
+	a += k1; \
+	d += b; \
+	move1 \
+    } \
+    else \
+    { \
+	x++; \
+	y++; \
+	a += k3; \
+	d -= a; \
+	move2 \
+    }
+
+#define MIARCCIRCLESTEP(clause) \
+    b -= k1; \
+    x++; \
+    if (d < 0) \
+    { \
+	a += k1; \
+	d += b; \
+    } \
+    else \
+    { \
+	y++; \
+	a += k3; \
+	d -= a; \
+	clause \
+    }
+
+/* mizerarc.c */
+
+extern _X_EXPORT Bool miZeroArcSetup(
+    xArc * /*arc*/,
+    miZeroArcRec * /*info*/,
+    Bool /*ok360*/
+);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxevents.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxevents.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to event processing functions.  \see dmxevents.h */
+
+#ifndef _DMXEVENTS_H_
+#define _DMXEVENTS_H_
+
+extern void dmxMotion(DevicePtr pDev, int *v, int firstAxis, int axesCount,
+                      DMXMotionType type, DMXBlockType block);
+extern void dmxEnqueue(DevicePtr pDev, int type, int detail, KeySym keySym,
+                       XEvent *e, DMXBlockType block);
+extern int  dmxCheckSpecialKeys(DevicePtr pDev, KeySym keySym);
+extern void dmxInvalidateGlobalPosition(void);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86_OSproc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86_OSproc.h
@@ -0,0 +1,220 @@
+/*
+ * Copyright 1990, 1991 by Thomas Roell, Dinkelscherben, Germany
+ * Copyright 1992 by David Dawes <dawes@XFree86.org>
+ * Copyright 1992 by Jim Tsillas <jtsilla@damon.ccs.northeastern.edu>
+ * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
+ * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
+ * Copyright 1992 by Orest Zborowski <obz@eskimo.com>
+ * Copyright 1993 by Vrije Universiteit, The Netherlands
+ * Copyright 1993 by David Wexelblat <dwex@XFree86.org>
+ * Copyright 1994, 1996 by Holger Veit <Holger.Veit@gmd.de>
+ * Copyright 1994-2003 by The XFree86 Project, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holders 
+ * not be used in advertising or publicity pertaining to distribution of 
+ * the software without specific, written prior permission.  The above listed
+ * copyright holders make no representations about the suitability of this 
+ * software for any purpose.  It is provided "as is" without express or 
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD 
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDERS BE 
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING 
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * The ARM32 code here carries the following copyright:
+ *
+ * Copyright 1997
+ * Digital Equipment Corporation. All rights reserved.
+ * This software is furnished under license and may be used and copied only in 
+ * accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * this software in source and/or binary form. No title or ownership is
+ * transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and retain
+ *    this copyright notice and list of conditions as they appear in the
+ *    source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of Digital 
+ *    Equipment Corporation. Neither the "Digital Equipment Corporation"
+ *    name nor any trademark or logo of Digital Equipment Corporation may be
+ *    used to endorse or promote products derived from this software without
+ *    the prior written permission of Digital Equipment Corporation.
+ *
+ * 3) This software is provided "AS-IS" and any express or implied warranties,
+ *    including but not limited to, any implied warranties of merchantability,
+ *    fitness for a particular purpose, or non-infringement are disclaimed.
+ *    In no event shall DIGITAL be liable for any damages whatsoever, and in
+ *    particular, DIGITAL shall not be liable for special, indirect,
+ *    consequential, or incidental damages or damages for lost profits, loss
+ *    of revenue or loss of use, whether such damages arise in contract, 
+ *    negligence, tort, under statute, in equity, at law or otherwise, even
+ *    if advised of the possibility of such damage. 
+ *
+ */
+
+
+#ifndef _XF86_OSPROC_H
+#define _XF86_OSPROC_H
+
+/*
+ * The actual prototypes have been pulled into this seperate file so
+ * that they can can be used without pulling in all of the OS specific
+ * stuff like sys/stat.h, etc. This casues problem for loadable modules.
+ */ 
+
+/*
+ * Flags for xf86MapVidMem().  Multiple flags can be or'd together.  The
+ * flags may be used as hints.  For example it would be permissible to
+ * enable write combining for memory marked only for framebuffer use.
+ */
+
+#define VIDMEM_FRAMEBUFFER	0x01	/* memory for framebuffer use */
+#define VIDMEM_MMIO		0x02	/* memory for I/O use */
+#define VIDMEM_MMIO_32BIT	0x04	/* memory accesses >= 32bit */
+#define VIDMEM_READSIDEEFFECT	0x08	/* reads can have side-effects */
+#define VIDMEM_SPARSE		0x10	/* sparse mapping required
+					 * assumed when VIDMEM_MMIO is
+					 * set. May be used with
+					 * VIDMEM_FRAMEBUFFER) */
+#define VIDMEM_READONLY		0x20	/* read-only mapping
+					 * used when reading BIOS images
+					 * through xf86MapVidMem() */
+
+/*
+ * OS-independent modem state flags for xf86SetSerialModemState() and
+ * xf86GetSerialModemState().
+ */
+#define XF86_M_LE		0x001	/* line enable */
+#define XF86_M_DTR		0x002	/* data terminal ready */
+#define XF86_M_RTS		0x004	/* request to send */
+#define XF86_M_ST		0x008	/* secondary transmit */
+#define XF86_M_SR		0x010	/* secondary receive */
+#define XF86_M_CTS		0x020	/* clear to send */
+#define XF86_M_CAR		0x040	/* carrier detect */
+#define XF86_M_RNG		0x080	/* ring */
+#define XF86_M_DSR		0x100	/* data set ready */
+
+#ifndef NO_OSLIB_PROTOTYPES
+/*
+ * This is to prevent re-entrancy to FatalError() when aborting.
+ * Anything that can be called as a result of AbortDDX() should use this
+ * instead of FatalError().
+ */
+
+#define xf86FatalError(a, b) \
+	if (dispatchException & DE_TERMINATE) { \
+		ErrorF(a, b); \
+		ErrorF("\n"); \
+		return; \
+	} else FatalError(a, b)
+
+/***************************************************************************/
+/* Prototypes                                                              */
+/***************************************************************************/
+
+#include <X11/Xfuncproto.h>
+#include "opaque.h"
+
+_XFUNCPROTOBEGIN
+
+/* public functions */
+extern _X_EXPORT Bool xf86LinearVidMem(void);
+extern _X_EXPORT Bool xf86CheckMTRR(int);
+extern _X_EXPORT pointer xf86MapVidMem(int, int, unsigned long, unsigned long);
+extern _X_EXPORT void xf86UnMapVidMem(int, pointer, unsigned long);
+extern _X_EXPORT void xf86MapReadSideEffects(int, int, pointer, unsigned long);
+extern _X_EXPORT int xf86ReadBIOS(unsigned long, unsigned long, unsigned char *, int);
+extern _X_EXPORT Bool xf86EnableIO(void);
+extern _X_EXPORT void xf86DisableIO(void);
+#ifdef __NetBSD__
+extern _X_EXPORT void xf86SetTVOut(int);
+extern _X_EXPORT void xf86SetRGBOut(void);
+#endif
+extern _X_EXPORT void xf86OSRingBell(int, int, int);
+extern _X_EXPORT void xf86SetReallySlowBcopy(void);
+extern _X_EXPORT void xf86SlowBcopy(unsigned char *, unsigned char *, int);
+extern _X_EXPORT int xf86OpenSerial(pointer options);
+extern _X_EXPORT int xf86SetSerial(int fd, pointer options);
+extern _X_EXPORT int xf86SetSerialSpeed(int fd, int speed);
+extern _X_EXPORT int xf86ReadSerial(int fd, void *buf, int count);
+extern _X_EXPORT int xf86WriteSerial(int fd, const void *buf, int count);
+extern _X_EXPORT int xf86CloseSerial(int fd);
+extern _X_EXPORT int xf86FlushInput(int fd);
+extern _X_EXPORT int xf86WaitForInput(int fd, int timeout);
+extern _X_EXPORT int xf86SerialSendBreak(int fd, int duration);
+extern _X_EXPORT int xf86SetSerialModemState(int fd, int state);
+extern _X_EXPORT int xf86GetSerialModemState(int fd);
+extern _X_EXPORT int xf86SerialModemSetBits(int fd, int bits);
+extern _X_EXPORT int xf86SerialModemClearBits(int fd, int bits);
+extern _X_EXPORT int xf86LoadKernelModule(const char *pathname);
+
+/* AGP GART interface */
+
+typedef struct _AgpInfo {
+	CARD32		bridgeId;
+	CARD32		agpMode;
+	unsigned long	base;
+	unsigned long	size;
+	unsigned long	totalPages;
+	unsigned long	systemPages;
+	unsigned long	usedPages;
+} AgpInfo, *AgpInfoPtr;
+
+extern _X_EXPORT Bool xf86AgpGARTSupported(void);
+extern _X_EXPORT AgpInfoPtr xf86GetAGPInfo(int screenNum);
+extern _X_EXPORT Bool xf86AcquireGART(int screenNum);
+extern _X_EXPORT Bool xf86ReleaseGART(int screenNum);
+extern _X_EXPORT int xf86AllocateGARTMemory(int screenNum, unsigned long size, int type,
+				  unsigned long *physical);
+extern _X_EXPORT Bool xf86DeallocateGARTMemory(int screenNum, int key);
+extern _X_EXPORT Bool xf86BindGARTMemory(int screenNum, int key, unsigned long offset);
+extern _X_EXPORT Bool xf86UnbindGARTMemory(int screenNum, int key);
+extern _X_EXPORT Bool xf86EnableAGP(int screenNum, CARD32 mode);
+extern _X_EXPORT Bool xf86GARTCloseScreen(int screenNum);
+
+/* These routines are in shared/sigio.c and are not loaded as part of the
+   module.  These routines are small, and the code if very POSIX-signal (or
+   OS-signal) specific, so it seemed better to provide more complex
+   wrappers than to wrap each individual function called. */
+extern _X_EXPORT int xf86InstallSIGIOHandler(int fd, void (*f)(int, void *), void *);
+extern _X_EXPORT int xf86RemoveSIGIOHandler(int fd);
+extern _X_EXPORT int xf86BlockSIGIO (void);
+extern _X_EXPORT void xf86UnblockSIGIO (int);
+extern _X_EXPORT void xf86AssertBlockedSIGIO (char *);
+extern _X_EXPORT Bool xf86SIGIOSupported (void);
+
+#ifdef XF86_OS_PRIVS
+typedef void (*PMClose)(void);
+extern _X_EXPORT void xf86OpenConsole(void);
+extern _X_EXPORT void xf86CloseConsole(void);
+extern _X_HIDDEN Bool xf86VTActivate(int vtno);
+extern _X_EXPORT Bool xf86VTSwitchPending(void);
+extern _X_EXPORT Bool xf86VTSwitchAway(void);
+extern _X_EXPORT Bool xf86VTSwitchTo(void);
+extern _X_EXPORT void xf86VTRequest(int sig);
+extern _X_EXPORT int xf86ProcessArgument(int, char **, int);
+extern _X_EXPORT void xf86UseMsg(void);
+extern _X_EXPORT PMClose xf86OSPMOpen(void);
+
+extern _X_EXPORT void xf86MakeNewMapping(int, int, unsigned long, unsigned long, pointer);
+extern _X_EXPORT void xf86InitVidMem(void);
+
+#endif /* XF86_OS_PRIVS */
+
+
+_XFUNCPROTOEND
+#endif /* NO_OSLIB_PROTOTYPES */
+
+#endif /* _XF86_OSPROC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exglobals.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exglobals.h
@@ -0,0 +1,84 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/*****************************************************************
+ *
+ * Globals referenced elsewhere in the server.
+ *
+ */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+#include "privates.h"
+
+#ifndef EXGLOBALS_H
+#define EXGLOBALS_H 1
+
+extern int IReqCode;
+extern int IEventBase;
+extern int BadDevice;
+extern int BadMode;
+extern int DeviceBusy;
+extern int BadClass;
+
+/* Note: only the ones needed in files other than extinit.c are declared */
+extern const Mask DevicePointerMotionMask;
+extern const Mask DevicePointerMotionHintMask;
+extern const Mask DeviceFocusChangeMask;
+extern const Mask DeviceStateNotifyMask;
+extern const Mask DeviceMappingNotifyMask;
+extern const Mask DeviceOwnerGrabButtonMask;
+extern const Mask DeviceButtonGrabMask;
+extern const Mask DeviceButtonMotionMask;
+extern const Mask DevicePresenceNotifyMask;
+extern const Mask DevicePropertyNotifyMask;
+extern const Mask XIAllMasks;
+
+extern Mask PropagateMask[];
+
+extern int DeviceValuator;
+extern int DeviceKeyPress;
+extern int DeviceKeyRelease;
+extern int DeviceButtonPress;
+extern int DeviceButtonRelease;
+extern int DeviceMotionNotify;
+extern int DeviceFocusIn;
+extern int DeviceFocusOut;
+extern int ProximityIn;
+extern int ProximityOut;
+extern int DeviceStateNotify;
+extern int DeviceKeyStateNotify;
+extern int DeviceButtonStateNotify;
+extern int DeviceMappingNotify;
+extern int ChangeDeviceNotify;
+extern int DevicePresenceNotify;
+extern int DevicePropertyNotify;
+
+extern int RT_INPUTCLIENT;
+
+extern DevPrivateKeyRec XIClientPrivateKeyRec;
+#define XIClientPrivateKey (&XIClientPrivateKeyRec)
+
+#endif /* EXGLOBALS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miscanfill.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miscanfill.h
@@ -0,0 +1,147 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SCANFILLINCLUDED
+#define SCANFILLINCLUDED
+/*
+ *     scanfill.h
+ *
+ *     Written by Brian Kelleher; Jan 1985
+ *
+ *     This file contains a few macros to help track
+ *     the edge of a filled object.  The object is assumed
+ *     to be filled in scanline order, and thus the
+ *     algorithm used is an extension of Bresenham's line
+ *     drawing algorithm which assumes that y is always the
+ *     major axis.
+ *     Since these pieces of code are the same for any filled shape,
+ *     it is more convenient to gather the library in one
+ *     place, but since these pieces of code are also in
+ *     the inner loops of output primitives, procedure call
+ *     overhead is out of the question.
+ *     See the author for a derivation if needed.
+ */
+
+
+/*
+ *  In scan converting polygons, we want to choose those pixels
+ *  which are inside the polygon.  Thus, we add .5 to the starting
+ *  x coordinate for both left and right edges.  Now we choose the
+ *  first pixel which is inside the pgon for the left edge and the
+ *  first pixel which is outside the pgon for the right edge.
+ *  Draw the left pixel, but not the right.
+ *
+ *  How to add .5 to the starting x coordinate:
+ *      If the edge is moving to the right, then subtract dy from the
+ *  error term from the general form of the algorithm.
+ *      If the edge is moving to the left, then add dy to the error term.
+ *
+ *  The reason for the difference between edges moving to the left
+ *  and edges moving to the right is simple:  If an edge is moving
+ *  to the right, then we want the algorithm to flip immediately.
+ *  If it is moving to the left, then we don't want it to flip until
+ *  we traverse an entire pixel.
+ */
+#define BRESINITPGON(dy, x1, x2, xStart, d, m, m1, incr1, incr2) { \
+    int dx;      /* local storage */ \
+\
+    /* \
+     *  if the edge is horizontal, then it is ignored \
+     *  and assumed not to be processed.  Otherwise, do this stuff. \
+     */ \
+    if ((dy) != 0) { \
+        xStart = (x1); \
+        dx = (x2) - xStart; \
+        if (dx < 0) { \
+            m = dx / (dy); \
+            m1 = m - 1; \
+            incr1 = -2 * dx + 2 * (dy) * m1; \
+            incr2 = -2 * dx + 2 * (dy) * m; \
+            d = 2 * m * (dy) - 2 * dx - 2 * (dy); \
+        } else { \
+            m = dx / (dy); \
+            m1 = m + 1; \
+            incr1 = 2 * dx - 2 * (dy) * m1; \
+            incr2 = 2 * dx - 2 * (dy) * m; \
+            d = -2 * m * (dy) + 2 * dx; \
+        } \
+    } \
+}
+
+#define BRESINCRPGON(d, minval, m, m1, incr1, incr2) { \
+    if (m1 > 0) { \
+        if (d > 0) { \
+            minval += m1; \
+            d += incr1; \
+        } \
+        else { \
+            minval += m; \
+            d += incr2; \
+        } \
+    } else {\
+        if (d >= 0) { \
+            minval += m1; \
+            d += incr1; \
+        } \
+        else { \
+            minval += m; \
+            d += incr2; \
+        } \
+    } \
+}
+
+
+/*
+ *     This structure contains all of the information needed
+ *     to run the bresenham algorithm.
+ *     The variables may be hardcoded into the declarations
+ *     instead of using this structure to make use of
+ *     register declarations.
+ */
+typedef struct {
+    int minor;         /* minor axis        */
+    int d;           /* decision variable */
+    int m, m1;       /* slope and slope+1 */
+    int incr1, incr2; /* error increments */
+} BRESINFO;
+
+
+#define BRESINITPGONSTRUCT(dmaj, min1, min2, bres) \
+	BRESINITPGON(dmaj, min1, min2, bres.minor, bres.d, \
+                     bres.m, bres.m1, bres.incr1, bres.incr2)
+
+#define BRESINCRPGONSTRUCT(bres) \
+        BRESINCRPGON(bres.d, bres.minor, bres.m, bres.m1, bres.incr1, bres.incr2)
+
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/hotplug.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/hotplug.h
@@ -0,0 +1,32 @@
+/*
+ * Copyright © 2006-2007 Daniel Stone
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Daniel Stone <daniel@fooishbar.org>
+ */
+
+#ifndef HOTPLUG_H
+#define HOTPLUG_H
+
+extern _X_EXPORT void config_init(void);
+extern _X_EXPORT void config_fini(void);
+
+#endif /* HOTPLUG_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compositeext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compositeext.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright © 2009 NVIDIA Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _COMPOSITEEXT_H_
+#define _COMPOSITEEXT_H_
+
+#include "misc.h"
+#include "scrnintstr.h"
+
+extern _X_EXPORT Bool CompositeRegisterAlternateVisuals(ScreenPtr pScreen,
+                                                        VisualID *vids,
+                                                        int nVisuals);
+
+#endif /* _COMPOSITEEXT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxsync.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxsync.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for sync support.  \see dmxsync.c */
+
+#ifndef _DMXSYNC_H_
+#define _DMXSYNC_H_
+
+extern void dmxSyncActivate(const char *interval);
+extern void dmxSyncInit(void);
+extern void dmxSync(DMXScreenInfo *dmxScreen, Bool now);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcursor.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcursor.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   David H. Dawes <dawes@xfree86.org>
+ *   Kevin E. Martin <kem@redhat.com>
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for cursor support.  \see dmxcursor.c. */
+
+#ifndef DMXCURSOR_H
+#define DMXCURSOR_H
+
+#include "mipointer.h"
+
+/** Cursor private area. */
+typedef struct _dmxCursorPriv {
+    Cursor  cursor;
+} dmxCursorPrivRec, *dmxCursorPrivPtr;
+
+/** Cursor functions for mi layer. \see dmxcursor.c \see dmxscrinit.c */
+extern miPointerScreenFuncRec dmxPointerCursorFuncs;
+/** Sprite functions for mi layer. \see dmxcursor.c \see dmxscrinit.c */
+extern miPointerSpriteFuncRec dmxPointerSpriteFuncs;
+
+extern void dmxReInitOrigins(void);
+extern void dmxInitOrigins(void);
+extern void dmxInitOverlap(void);
+extern void dmxCursorNoMulti(void);
+extern void dmxMoveCursor(DeviceIntPtr pDev, ScreenPtr pScreen, int x, int y);
+extern void dmxCheckCursor(void);
+extern int  dmxOnScreen(int x, int y, DMXScreenInfo *dmxScreen);
+extern void dmxHideCursor(DMXScreenInfo *dmxScreen);
+
+extern void dmxBECreateCursor(ScreenPtr pScreen, CursorPtr pCursor);
+extern Bool dmxBEFreeCursor(ScreenPtr pScreen, CursorPtr pCursor);
+
+#define DMX_GET_CURSOR_PRIV(_pCursor, _pScreen) ((dmxCursorPrivPtr) \
+    dixLookupPrivate(&(_pCursor)->devPrivates, CursorScreenKey(_pScreen)))
+
+#define DMX_SET_CURSOR_PRIV(_pCursor, _pScreen, v) \
+    dixSetPrivate(&(_pCursor)->devPrivates, CursorScreenKey(_pScreen), v)
+
+#endif /* DMXCURSOR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/debug.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/debug.h
@@ -0,0 +1,210 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for debug definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_DEBUG_H
+#define __X86EMU_DEBUG_H
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+/* checks to be enabled for "runtime" */
+
+#define CHECK_IP_FETCH_F                0x1
+#define CHECK_SP_ACCESS_F               0x2
+#define CHECK_MEM_ACCESS_F              0x4 /*using regular linear pointer */
+#define CHECK_DATA_ACCESS_F             0x8 /*using segment:offset*/
+
+#ifdef DEBUG
+# define CHECK_IP_FETCH()              	(M.x86.check & CHECK_IP_FETCH_F)
+# define CHECK_SP_ACCESS()             	(M.x86.check & CHECK_SP_ACCESS_F)
+# define CHECK_MEM_ACCESS()            	(M.x86.check & CHECK_MEM_ACCESS_F)
+# define CHECK_DATA_ACCESS()           	(M.x86.check & CHECK_DATA_ACCESS_F)
+#else
+# define CHECK_IP_FETCH()
+# define CHECK_SP_ACCESS()
+# define CHECK_MEM_ACCESS()
+# define CHECK_DATA_ACCESS()
+#endif
+
+#ifdef DEBUG
+# define DEBUG_INSTRUMENT()    	(M.x86.debug & DEBUG_INSTRUMENT_F)
+# define DEBUG_DECODE()        	(M.x86.debug & DEBUG_DECODE_F)
+# define DEBUG_TRACE()         	(M.x86.debug & DEBUG_TRACE_F)
+# define DEBUG_STEP()          	(M.x86.debug & DEBUG_STEP_F)
+# define DEBUG_DISASSEMBLE()   	(M.x86.debug & DEBUG_DISASSEMBLE_F)
+# define DEBUG_BREAK()         	(M.x86.debug & DEBUG_BREAK_F)
+# define DEBUG_SVC()           	(M.x86.debug & DEBUG_SVC_F)
+# define DEBUG_SAVE_IP_CS()     (M.x86.debug & DEBUG_SAVE_IP_CS_F)
+
+# define DEBUG_FS()            	(M.x86.debug & DEBUG_FS_F)
+# define DEBUG_PROC()          	(M.x86.debug & DEBUG_PROC_F)
+# define DEBUG_SYSINT()        	(M.x86.debug & DEBUG_SYSINT_F)
+# define DEBUG_TRACECALL()     	(M.x86.debug & DEBUG_TRACECALL_F)
+# define DEBUG_TRACECALLREGS() 	(M.x86.debug & DEBUG_TRACECALL_REGS_F)
+# define DEBUG_SYS()           	(M.x86.debug & DEBUG_SYS_F)
+# define DEBUG_MEM_TRACE()     	(M.x86.debug & DEBUG_MEM_TRACE_F)
+# define DEBUG_IO_TRACE()      	(M.x86.debug & DEBUG_IO_TRACE_F)
+# define DEBUG_DECODE_NOPRINT() (M.x86.debug & DEBUG_DECODE_NOPRINT_F)
+#else
+# define DEBUG_INSTRUMENT()    	0
+# define DEBUG_DECODE()        	0
+# define DEBUG_TRACE()         	0
+# define DEBUG_STEP()          	0
+# define DEBUG_DISASSEMBLE()   	0
+# define DEBUG_BREAK()         	0
+# define DEBUG_SVC()           	0
+# define DEBUG_SAVE_IP_CS()     0
+# define DEBUG_FS()            	0
+# define DEBUG_PROC()          	0
+# define DEBUG_SYSINT()        	0
+# define DEBUG_TRACECALL()     	0
+# define DEBUG_TRACECALLREGS() 	0
+# define DEBUG_SYS()           	0
+# define DEBUG_MEM_TRACE()     	0
+# define DEBUG_IO_TRACE()      	0
+# define DEBUG_DECODE_NOPRINT() 0
+#endif
+
+#ifdef DEBUG
+
+# define DECODE_PRINTF(x)     	if (DEBUG_DECODE()) \
+									x86emu_decode_printf(x)
+# define DECODE_PRINTF2(x,y)  	if (DEBUG_DECODE()) \
+									x86emu_decode_printf2(x,y)
+
+/*
+ * The following allow us to look at the bytes of an instruction.  The
+ * first INCR_INSTRN_LEN, is called everytime bytes are consumed in
+ * the decoding process.  The SAVE_IP_CS is called initially when the
+ * major opcode of the instruction is accessed.
+ */
+#define INC_DECODED_INST_LEN(x)                    	\
+	if (DEBUG_DECODE())  	                       	\
+		x86emu_inc_decoded_inst_len(x)
+
+#define SAVE_IP_CS(x,y)                               			\
+	if (DEBUG_DECODE() | DEBUG_TRACECALL() | DEBUG_BREAK() \
+              | DEBUG_IO_TRACE() | DEBUG_SAVE_IP_CS()) { \
+		M.x86.saved_cs = x;                          			\
+		M.x86.saved_ip = y;                          			\
+	}
+#else
+# define INC_DECODED_INST_LEN(x)
+# define DECODE_PRINTF(x)
+# define DECODE_PRINTF2(x,y)
+# define SAVE_IP_CS(x,y)
+#endif
+
+#ifdef DEBUG
+#define TRACE_REGS()                                   		\
+	if (DEBUG_DISASSEMBLE()) {                         		\
+		x86emu_just_disassemble();                        	\
+		goto EndOfTheInstructionProcedure;             		\
+	}                                                   	\
+	if (DEBUG_TRACE() || DEBUG_DECODE()) X86EMU_trace_regs()
+#else
+# define TRACE_REGS()
+#endif
+
+#ifdef DEBUG
+# define SINGLE_STEP()		if (DEBUG_STEP()) x86emu_single_step()
+#else
+# define SINGLE_STEP()
+#endif
+
+#define TRACE_AND_STEP()	\
+	TRACE_REGS();			\
+	SINGLE_STEP()
+
+#ifdef DEBUG
+# define START_OF_INSTR()
+# define END_OF_INSTR()		EndOfTheInstructionProcedure: x86emu_end_instr();
+# define END_OF_INSTR_NO_TRACE()	x86emu_end_instr();
+#else
+# define START_OF_INSTR()
+# define END_OF_INSTR()
+# define END_OF_INSTR_NO_TRACE()
+#endif
+
+#ifdef DEBUG
+# define  CALL_TRACE(u,v,w,x,s)                                 \
+	if (DEBUG_TRACECALLREGS())									\
+		x86emu_dump_regs();                                     \
+	if (DEBUG_TRACECALL())                                     	\
+		printk("%04x:%04x: CALL %s%04x:%04x\n", u , v, s, w, x);
+# define RETURN_TRACE(n,u,v)                                    \
+	if (DEBUG_TRACECALLREGS())									\
+		x86emu_dump_regs();                                     \
+	if (DEBUG_TRACECALL())                                     	\
+		printk("%04x:%04x: %s\n",u,v,n);
+#else
+# define CALL_TRACE(u,v,w,x,s)
+# define RETURN_TRACE(n,u,v)
+#endif
+
+#ifdef DEBUG
+#define	DB(x)	x
+#else
+#define	DB(x)
+#endif
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+extern void x86emu_inc_decoded_inst_len (int x);
+extern void x86emu_decode_printf (char *x);
+extern void x86emu_decode_printf2 (char *x, int y);
+extern void x86emu_just_disassemble (void);
+extern void x86emu_single_step (void);
+extern void x86emu_end_instr (void);
+extern void x86emu_dump_regs (void);
+extern void x86emu_dump_xregs (void);
+extern void x86emu_print_int_vect (u16 iv);
+extern void x86emu_instrument_instruction (void);
+extern void x86emu_check_ip_access (void);
+extern void x86emu_check_sp_access (void);
+extern void x86emu_check_mem_access (u32 p);
+extern void x86emu_check_data_access (uint s, uint o);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_DEBUG_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Pci.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Pci.h
@@ -0,0 +1,262 @@
+/*
+ * Copyright 1998 by Concurrent Computer Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Concurrent Computer
+ * Corporation not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Concurrent Computer Corporation makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * CONCURRENT COMPUTER CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL CONCURRENT COMPUTER CORPORATION BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * Copyright 1998 by Metro Link Incorporated
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without fee,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of Metro Link
+ * Incorporated not be used in advertising or publicity pertaining to
+ * distribution of the software without specific, written prior
+ * permission.  Metro Link Incorporated makes no representations
+ * about the suitability of this software for any purpose.  It is
+ * provided "as is" without express or implied warranty.
+ *
+ * METRO LINK INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL METRO LINK INCORPORATED BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ *
+ * This file is derived in part from the original xf86_PCI.h that included
+ * following copyright message:
+ *
+ * Copyright 1995 by Robin Cutshaw <robin@XFree86.Org>
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holder(s)
+ * not be used in advertising or publicity pertaining to distribution of
+ * the software without specific, written prior permission.  The above listed
+ * copyright holder(s) make(s) no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without express or
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM(S) ALL WARRANTIES WITH REGARD
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1999-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/*
+ * This file contains just the public interface to the PCI code.
+ * Drivers should use this file rather than Pci.h.
+ */
+
+#ifndef _XF86PCI_H
+#define _XF86PCI_H 1
+#include <X11/Xarch.h>
+#include <X11/Xfuncproto.h>
+#include "misc.h"
+#include <pciaccess.h>
+
+/*
+ * PCI cfg space definitions (e.g. stuff right out of the PCI spec)
+ */
+
+/* Device identification register */
+#define PCI_ID_REG			0x00
+
+/* Command and status register */
+#define PCI_CMD_STAT_REG		0x04
+#define PCI_CMD_BASE_REG		0x10
+#define PCI_CMD_BIOS_REG		0x30
+#define PCI_CMD_MASK			0xffff
+#define PCI_CMD_IO_ENABLE		0x01
+#define PCI_CMD_MEM_ENABLE		0x02
+#define PCI_CMD_MASTER_ENABLE		0x04
+#define PCI_CMD_SPECIAL_ENABLE		0x08
+#define PCI_CMD_INVALIDATE_ENABLE	0x10
+#define PCI_CMD_PALETTE_ENABLE		0x20
+#define PCI_CMD_PARITY_ENABLE		0x40
+#define PCI_CMD_STEPPING_ENABLE		0x80
+#define PCI_CMD_SERR_ENABLE		0x100
+#define PCI_CMD_BACKTOBACK_ENABLE	0x200
+#define PCI_CMD_BIOS_ENABLE		0x01
+
+/* base class */
+#define PCI_CLASS_REG		0x08
+#define PCI_CLASS_MASK		0xff000000
+#define PCI_CLASS_SHIFT		24
+#define PCI_CLASS_EXTRACT(x)	\
+	(((x) & PCI_CLASS_MASK) >> PCI_CLASS_SHIFT)
+
+/* base class values */
+#define PCI_CLASS_PREHISTORIC		0x00
+#define PCI_CLASS_MASS_STORAGE		0x01
+#define PCI_CLASS_NETWORK		0x02
+#define PCI_CLASS_DISPLAY		0x03
+#define PCI_CLASS_MULTIMEDIA		0x04
+#define PCI_CLASS_MEMORY		0x05
+#define PCI_CLASS_BRIDGE		0x06
+#define PCI_CLASS_COMMUNICATIONS	0x07
+#define PCI_CLASS_SYSPERIPH		0x08
+#define PCI_CLASS_INPUT			0x09
+#define PCI_CLASS_DOCKING		0x0a
+#define PCI_CLASS_PROCESSOR		0x0b
+#define PCI_CLASS_SERIALBUS		0x0c
+#define PCI_CLASS_WIRELESS		0x0d
+#define PCI_CLASS_I2O			0x0e
+#define PCI_CLASS_SATELLITE		0x0f
+#define PCI_CLASS_CRYPT			0x10
+#define PCI_CLASS_DATA_ACQUISTION	0x11
+#define PCI_CLASS_UNDEFINED		0xff
+
+/* sub class */
+#define PCI_SUBCLASS_MASK	0x00ff0000
+#define PCI_SUBCLASS_SHIFT	16
+#define PCI_SUBCLASS_EXTRACT(x)	\
+	(((x) & PCI_SUBCLASS_MASK) >> PCI_SUBCLASS_SHIFT)
+
+/* Sub class values */
+/* 0x00 prehistoric subclasses */
+#define PCI_SUBCLASS_PREHISTORIC_MISC	0x00
+#define PCI_SUBCLASS_PREHISTORIC_VGA	0x01
+
+/* 0x03 display subclasses */
+#define PCI_SUBCLASS_DISPLAY_VGA	0x00
+#define PCI_SUBCLASS_DISPLAY_XGA	0x01
+#define PCI_SUBCLASS_DISPLAY_MISC	0x80
+
+/* 0x04 multimedia subclasses */
+#define PCI_SUBCLASS_MULTIMEDIA_VIDEO	0x00
+#define PCI_SUBCLASS_MULTIMEDIA_AUDIO	0x01
+#define PCI_SUBCLASS_MULTIMEDIA_MISC	0x80
+
+/* 0x06 bridge subclasses */
+#define PCI_SUBCLASS_BRIDGE_HOST	0x00
+#define PCI_SUBCLASS_BRIDGE_ISA		0x01
+#define PCI_SUBCLASS_BRIDGE_EISA	0x02
+#define PCI_SUBCLASS_BRIDGE_MC		0x03
+#define PCI_SUBCLASS_BRIDGE_PCI		0x04
+#define PCI_SUBCLASS_BRIDGE_PCMCIA	0x05
+#define PCI_SUBCLASS_BRIDGE_NUBUS	0x06
+#define PCI_SUBCLASS_BRIDGE_CARDBUS	0x07
+#define PCI_SUBCLASS_BRIDGE_RACEWAY	0x08
+#define PCI_SUBCLASS_BRIDGE_MISC	0x80
+#define PCI_IF_BRIDGE_PCI_SUBTRACTIVE	0x01
+
+/* 0x0b processor subclasses */
+#define PCI_SUBCLASS_PROCESSOR_386	0x00
+#define PCI_SUBCLASS_PROCESSOR_486	0x01
+#define PCI_SUBCLASS_PROCESSOR_PENTIUM	0x02
+#define PCI_SUBCLASS_PROCESSOR_ALPHA	0x10
+#define PCI_SUBCLASS_PROCESSOR_POWERPC	0x20
+#define PCI_SUBCLASS_PROCESSOR_MIPS	0x30
+#define PCI_SUBCLASS_PROCESSOR_COPROC	0x40
+
+/* PCI-PCI bridge mapping registers */
+#define PCI_PCI_BRIDGE_BUS_REG		0x18
+#define PCI_SUBORDINATE_BUS_MASK	0x00ff0000
+#define PCI_SECONDARY_BUS_MASK		0x0000ff00
+#define PCI_PRIMARY_BUS_MASK		0x000000ff
+
+#define PCI_PCI_BRIDGE_IO_REG		0x1c
+#define PCI_PCI_BRIDGE_MEM_REG		0x20
+#define PCI_PCI_BRIDGE_PMEM_REG		0x24
+
+#define PCI_PCI_BRIDGE_CONTROL_REG	0x3E
+#define PCI_PCI_BRIDGE_PARITY_EN	0x01
+#define PCI_PCI_BRIDGE_SERR_EN		0x02
+#define PCI_PCI_BRIDGE_ISA_EN		0x04
+#define PCI_PCI_BRIDGE_VGA_EN		0x08
+#define PCI_PCI_BRIDGE_MASTER_ABORT_EN	0x20
+#define PCI_PCI_BRIDGE_SECONDARY_RESET	0x40
+#define PCI_PCI_BRIDGE_FAST_B2B_EN	0x80
+
+/* Subsystem identification register */
+#define PCI_SUBSYSTEM_ID_REG		0x2c
+
+/* User defined cfg space regs */
+#define PCI_REG_USERCONFIG		0x40
+#define PCI_OPTION_REG			0x40
+
+/*
+ * Typedefs, etc...
+ */
+
+/* Primitive Types */
+typedef unsigned long ADDRESS;		/* Memory/PCI address */
+typedef unsigned long IOADDRESS;	/* Must be large enough for a pointer */
+typedef unsigned long PCITAG;
+
+typedef enum {
+    PCI_MEM,
+    PCI_MEM_SIZE,
+    PCI_MEM_SPARSE_BASE,
+    PCI_MEM_SPARSE_MASK,
+    PCI_IO,
+    PCI_IO_SIZE,
+    PCI_IO_SPARSE_BASE,
+    PCI_IO_SPARSE_MASK
+} PciAddrType;
+
+
+/* Public PCI access functions */
+extern _X_EXPORT PCITAG pciTag(int busnum, int devnum, int funcnum);
+extern _X_EXPORT Bool xf86scanpci(void);
+
+/* Domain access functions.  Some of these probably shouldn't be public */
+extern _X_EXPORT pointer xf86MapDomainMemory(int ScreenNum, int Flags, struct pci_device *dev,
+    ADDRESS Base, unsigned long Size);
+extern _X_EXPORT IOADDRESS xf86MapLegacyIO(struct pci_device *dev);
+
+#endif /* _XF86PCI_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-keyboard.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-keyboard.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to USB keyboard driver. \see usb-keyboard.c \see usb-common.c */
+
+#ifndef _USB_KEYBOARD_H_
+#define _USB_KEYBOARD_H_
+extern void    kbdUSBInit(DevicePtr pDev);
+extern void    kbdUSBGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     kbdUSBOn(DevicePtr pDev);
+extern void    kbdUSBRead(DevicePtr pDev,
+                          dmxMotionProcPtr motion,
+                          dmxEnqueueProcPtr enqueue,
+                          dmxCheckSpecialProcPtr checkspecial,
+                          DMXBlockType block);
+extern void    kbdUSBCtrl(DevicePtr pDev, KeybdCtrl *ctrl);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/propertyst.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/propertyst.h
@@ -0,0 +1,68 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PROPERTYSTRUCT_H
+#define PROPERTYSTRUCT_H 
+#include "misc.h"
+#include "property.h"
+#include "privates.h"
+/* 
+ *   PROPERTY -- property element
+ */
+
+typedef struct _Property {
+        struct _Property       *next;
+	ATOM 		propertyName;
+	ATOM		type;       /* ignored by server */
+	short		format;     /* format of data for swapping - 8,16,32 */
+	long		size;       /* size of data in (format/8) bytes */
+	pointer         data;       /* private to client */
+	PrivateRec	*devPrivates;
+} PropertyRec;
+
+#endif /* PROPERTYSTRUCT_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcompat.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcompat.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to VDL compatibility support.  \see dmxcompat.c
+ *
+ * This file is not used by the DMX server.
+ */
+
+#ifndef _DMXCOMPAT_H_
+#define _DMXCOMPAT_H_
+
+extern DMXConfigEntryPtr dmxVDLRead(const char *filename);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcb.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Header file for connection block functions.  \see dmxcb.c.
+ */
+
+#ifndef _DMXCB_H_
+#define _DMXCB_H_
+/** The cursor position, in global coordinates. */
+extern int  dmxGlobalWidth, dmxGlobalHeight;
+
+/** #dmxComputeWidthHeight can either recompute the global bounding box
+ * or not. */
+typedef enum {
+    DMX_RECOMPUTE_BOUNDING_BOX,
+    DMX_NO_RECOMPUTE_BOUNDING_BOX
+} DMXRecomputeFlag;
+
+extern void dmxSetWidthHeight(int width, int height);
+extern void dmxComputeWidthHeight(DMXRecomputeFlag flag);
+extern void dmxConnectionBlockCallback(void);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/closestr.h
@@ -0,0 +1,151 @@
+/*
+
+Copyright 1991, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+
+#ifndef CLOSESTR_H
+#define CLOSESTR_H
+
+#include <X11/Xproto.h>
+#include "closure.h"
+#include "dix.h"
+#include "misc.h"
+#include "gcstruct.h"
+
+/* closure structures */
+
+/* OpenFont */
+
+typedef struct _OFclosure {
+    ClientPtr   client;
+    short       current_fpe;
+    short       num_fpes;
+    FontPathElementPtr *fpe_list;
+    Mask        flags;
+
+/* XXX -- get these from request buffer instead? */
+    char       *origFontName;
+    int		origFontNameLen;
+    XID         fontid;
+    char       *fontname;
+    int         fnamelen;
+    FontPtr	non_cachable_font;
+}           OFclosureRec;
+
+/* ListFontsWithInfo */
+
+#define XLFDMAXFONTNAMELEN	256
+typedef struct _LFWIstate {
+    char	pattern[XLFDMAXFONTNAMELEN];
+    int		patlen;
+    int		current_fpe;
+    int		max_names;
+    Bool	list_started;
+    pointer	private;
+} LFWIstateRec, *LFWIstatePtr;
+
+typedef struct _LFWIclosure {
+    ClientPtr		client;
+    int			num_fpes;
+    FontPathElementPtr	*fpe_list;
+    xListFontsWithInfoReply *reply;
+    int			length;
+    LFWIstateRec	current;
+    LFWIstateRec	saved;
+    int			savedNumFonts;
+    Bool		haveSaved;
+    char		*savedName;
+} LFWIclosureRec;
+
+/* ListFonts */
+
+typedef struct _LFclosure {
+    ClientPtr   client;
+    int         num_fpes;
+    FontPathElementPtr *fpe_list;
+    FontNamesPtr names;
+    LFWIstateRec current;
+    LFWIstateRec saved;
+    Bool        haveSaved;
+    char	*savedName;
+    int		savedNameLen;
+}	LFclosureRec;
+
+/* PolyText */
+
+typedef
+    int			(* PolyTextPtr)(
+			DrawablePtr /* pDraw */,
+			GCPtr /* pGC */,
+			int /* x */,
+			int /* y */,
+			int /* count */,
+			void * /* chars or shorts */
+			);
+
+typedef struct _PTclosure {
+    ClientPtr		client;
+    DrawablePtr		pDraw;
+    GC			*pGC;
+    unsigned char	*pElt;
+    unsigned char	*endReq;
+    unsigned char	*data;
+    int			xorg;
+    int			yorg;
+    CARD8		reqType;
+    PolyTextPtr		polyText;
+    int			itemSize;
+    XID			did;
+    int			err;
+} PTclosureRec;
+
+/* ImageText */
+
+typedef
+    void		(* ImageTextPtr)(
+			DrawablePtr /* pDraw */,
+			GCPtr /* pGC */,
+			int /* x */,
+			int /* y */,
+			int /* count */,
+			void * /* chars or shorts */
+			);
+
+typedef struct _ITclosure {
+    ClientPtr		client;
+    DrawablePtr		pDraw;
+    GC			*pGC;
+    BYTE		nChars;
+    unsigned char	*data;
+    int			xorg;
+    int			yorg;
+    CARD8		reqType;
+    ImageTextPtr	imageText;
+    int			itemSize;
+    XID			did;
+} ITclosureRec;
+#endif				/* CLOSESTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86bigfontsrv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86bigfontsrv.h
@@ -0,0 +1,34 @@
+/*
+ * Copyright © 2010 Yaakov Selkowitz
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XF86BIGFONTSRV_H_
+#define _XF86BIGFONTSRV_H_
+
+#include <X11/fonts/font.h>
+
+extern void XFree86BigfontExtensionInit(void);
+extern void XF86BigfontFreeFontShm(FontPtr);
+extern void XF86BigfontCleanup(void);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dri2.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dri2.h
@@ -0,0 +1,287 @@
+/*
+ * Copyright © 2007 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Kristian Høgsberg (krh@redhat.com)
+ */
+
+#ifndef _DRI2_H_
+#define _DRI2_H_
+
+#include <X11/extensions/dri2tokens.h>
+
+/* Version 2 structure (with format at the end) */
+typedef struct {
+    unsigned int attachment;
+    unsigned int name;
+    unsigned int pitch;
+    unsigned int cpp;
+    unsigned int flags;
+    unsigned int format;
+    void *driverPrivate;
+} DRI2BufferRec, *DRI2BufferPtr;
+
+extern CARD8 dri2_major; /* version of DRI2 supported by DDX */
+extern CARD8 dri2_minor;
+
+typedef DRI2BufferRec DRI2Buffer2Rec, *DRI2Buffer2Ptr;
+typedef void (*DRI2SwapEventPtr)(ClientPtr client, void *data, int type,
+				 CARD64 ust, CARD64 msc, CARD64 sbc);
+
+
+typedef DRI2BufferPtr	(*DRI2CreateBuffersProcPtr)(DrawablePtr pDraw,
+						    unsigned int *attachments,
+						    int count);
+typedef void		(*DRI2DestroyBuffersProcPtr)(DrawablePtr pDraw,
+						     DRI2BufferPtr buffers,
+						     int count);
+typedef void		(*DRI2CopyRegionProcPtr)(DrawablePtr pDraw,
+						 RegionPtr pRegion,
+						 DRI2BufferPtr pDestBuffer,
+						 DRI2BufferPtr pSrcBuffer);
+typedef void		(*DRI2WaitProcPtr)(WindowPtr pWin,
+					   unsigned int sequence);
+typedef int		(*DRI2AuthMagicProcPtr)(int fd, uint32_t magic);
+
+/**
+ * Schedule a buffer swap
+ *
+ * This callback is used to support glXSwapBuffers and the OML_sync_control
+ * extension (see it for a description of the params).
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the server may block the client at the next
+ * GLX request using DRI2WaitSwap. When the event arrives, drivers should call
+ * \c DRI2SwapComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * The DDX is responsible for doing a flip, exchange, or blit of the swap
+ * when the corresponding event arrives.  The \c DRI2CanFlip and
+ * \c DRI2CanExchange functions can be used as helpers for this purpose.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param pDestBuffer current front buffer
+ * \param pSrcBuffer current back buffer
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ * \param func function to call when the swap completes
+ * \param data data for the callback \p func.
+ */
+typedef int		(*DRI2ScheduleSwapProcPtr)(ClientPtr client,
+						   DrawablePtr pDraw,
+						   DRI2BufferPtr pDestBuffer,
+						   DRI2BufferPtr pSrcBuffer,
+						   CARD64 *target_msc,
+						   CARD64 divisor,
+						   CARD64 remainder,
+						   DRI2SwapEventPtr func,
+						   void *data);
+typedef DRI2BufferPtr	(*DRI2CreateBufferProcPtr)(DrawablePtr pDraw,
+						   unsigned int attachment,
+						   unsigned int format);
+typedef void		(*DRI2DestroyBufferProcPtr)(DrawablePtr pDraw,
+						    DRI2BufferPtr buffer);
+/**
+ * Get current media stamp counter values
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.
+ *
+ * Drivers should return the current frame counter and the timestamp from
+ * when the returned frame count was last incremented.
+ *
+ * The count should correspond to the screen where the drawable is currently
+ * visible.  If the drawable isn't visible (e.g. redirected), the server
+ * should return BadDrawable to the client, pending GLX spec updates to
+ * define this behavior.
+ *
+ * \param pDraw drawable whose count we want
+ * \param ust timestamp from when the count was last incremented.
+ * \param mst current frame count
+ */
+typedef int		(*DRI2GetMSCProcPtr)(DrawablePtr pDraw, CARD64 *ust,
+					     CARD64 *msc);
+/**
+ * Schedule a frame count related wait
+ *
+ * This callback is used to support the SGI_video_sync and OML_sync_control
+ * extensions.  See those specifications for details on how to handle
+ * the divisor and remainder parameters.
+ *
+ * Drivers should queue an event for the frame count that satisfies the
+ * parameters passed in.  If the event is in the future (i.e. the conditions
+ * aren't currently satisfied), the driver should block the client using
+ * \c DRI2BlockClient.  When the event arrives, drivers should call
+ * \c DRI2WaitMSCComplete, which will handle waking the client and returning
+ * the appropriate data.
+ *
+ * \param client client pointer (used for block/unblock)
+ * \param pDraw drawable whose count we want
+ * \param target_msc frame count to wait for
+ * \param divisor divisor for condition equation
+ * \param remainder remainder for division equation
+ */
+typedef int		(*DRI2ScheduleWaitMSCProcPtr)(ClientPtr client,
+						      DrawablePtr pDraw,
+						      CARD64 target_msc,
+						      CARD64 divisor,
+						      CARD64 remainder);
+
+typedef void		(*DRI2InvalidateProcPtr)(DrawablePtr pDraw,
+						 void *data);
+
+/**
+ * Version of the DRI2InfoRec structure defined in this header
+ */
+#define DRI2INFOREC_VERSION 5
+
+typedef struct {
+    unsigned int version;	/**< Version of this struct */
+    int fd;
+    const char *driverName;
+    const char *deviceName;
+
+    DRI2CreateBufferProcPtr	CreateBuffer;
+    DRI2DestroyBufferProcPtr	DestroyBuffer;
+    DRI2CopyRegionProcPtr	CopyRegion;
+    DRI2WaitProcPtr		Wait;
+
+    /* added in version 4 */
+
+    DRI2ScheduleSwapProcPtr	ScheduleSwap;
+    DRI2GetMSCProcPtr		GetMSC;
+    DRI2ScheduleWaitMSCProcPtr	ScheduleWaitMSC;
+
+    /* number of drivers in the driverNames array */
+    unsigned int numDrivers;
+    /* array of driver names, indexed by DRI2Driver* driver types */
+    /* a name of NULL means that driver is not supported */
+    const char * const *driverNames;
+
+    /* added in version 5 */
+
+    DRI2AuthMagicProcPtr	AuthMagic;
+}  DRI2InfoRec, *DRI2InfoPtr;
+
+extern _X_EXPORT int DRI2EventBase;
+
+extern _X_EXPORT Bool DRI2ScreenInit(ScreenPtr	pScreen,
+		    DRI2InfoPtr info);
+
+extern _X_EXPORT void DRI2CloseScreen(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRI2HasSwapControl(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool DRI2Connect(ScreenPtr pScreen,
+		 unsigned int driverType,
+		 int *fd,
+		 const char **driverName,
+		 const char **deviceName);
+
+extern _X_EXPORT Bool DRI2Authenticate(ScreenPtr pScreen, uint32_t magic);
+
+extern _X_EXPORT int DRI2CreateDrawable(ClientPtr client,
+					DrawablePtr pDraw,
+					XID id,
+					DRI2InvalidateProcPtr invalidate,
+					void *priv);
+
+extern _X_EXPORT void DRI2DestroyDrawable(DrawablePtr pDraw);
+
+extern _X_EXPORT DRI2BufferPtr *DRI2GetBuffers(DrawablePtr pDraw,
+			     int *width,
+			     int *height,
+			     unsigned int *attachments,
+			     int count,
+			     int *out_count);
+
+extern _X_EXPORT int DRI2CopyRegion(DrawablePtr pDraw,
+		   RegionPtr pRegion,
+		   unsigned int dest,
+		   unsigned int src);
+
+/**
+ * Determine the major and minor version of the DRI2 extension.
+ *
+ * Provides a mechanism to other modules (e.g., 2D drivers) to determine the
+ * version of the DRI2 extension.  While it is possible to peek directly at
+ * the \c XF86ModuleData from a layered module, such a module will fail to
+ * load (due to an unresolved symbol) if the DRI2 extension is not loaded.
+ *
+ * \param major  Location to store the major verion of the DRI2 extension
+ * \param minor  Location to store the minor verion of the DRI2 extension
+ *
+ * \note
+ * This interface was added some time after the initial release of the DRI2
+ * module.  Layered modules that wish to use this interface must first test
+ * its existance by calling \c xf86LoaderCheckSymbol.
+ */
+extern _X_EXPORT void DRI2Version(int *major, int *minor);
+
+extern _X_EXPORT DRI2BufferPtr *DRI2GetBuffersWithFormat(DrawablePtr pDraw,
+	int *width, int *height, unsigned int *attachments, int count,
+	int *out_count);
+
+extern _X_EXPORT void DRI2SwapInterval(DrawablePtr pDrawable, int interval);
+extern _X_EXPORT int DRI2SwapBuffers(ClientPtr client, DrawablePtr pDrawable,
+				     CARD64 target_msc, CARD64 divisor,
+				     CARD64 remainder, CARD64 *swap_target,
+				     DRI2SwapEventPtr func, void *data);
+extern _X_EXPORT Bool DRI2WaitSwap(ClientPtr client, DrawablePtr pDrawable);
+
+extern _X_EXPORT int DRI2GetMSC(DrawablePtr pDrawable, CARD64 *ust,
+				CARD64 *msc, CARD64 *sbc);
+extern _X_EXPORT int DRI2WaitMSC(ClientPtr client, DrawablePtr pDrawable,
+				 CARD64 target_msc, CARD64 divisor,
+				 CARD64 remainder);
+extern _X_EXPORT int ProcDRI2WaitMSCReply(ClientPtr client, CARD64 ust,
+					  CARD64 msc, CARD64 sbc);
+extern _X_EXPORT int DRI2WaitSBC(ClientPtr client, DrawablePtr pDraw,
+				 CARD64 target_sbc);
+extern _X_EXPORT Bool DRI2ThrottleClient(ClientPtr client, DrawablePtr pDraw);
+
+extern _X_EXPORT Bool DRI2CanFlip(DrawablePtr pDraw);
+
+extern _X_EXPORT Bool DRI2CanExchange(DrawablePtr pDraw);
+
+/* Note: use *only* for MSC related waits */
+extern _X_EXPORT void DRI2BlockClient(ClientPtr client, DrawablePtr pDraw);
+
+extern _X_EXPORT void DRI2SwapComplete(ClientPtr client, DrawablePtr pDraw,
+				       int frame, unsigned int tv_sec,
+				       unsigned int tv_usec, int type,
+				       DRI2SwapEventPtr swap_complete,
+				       void *swap_data);
+extern _X_EXPORT void DRI2WaitMSCComplete(ClientPtr client, DrawablePtr pDraw,
+					  int frame, unsigned int tv_sec,
+					  unsigned int tv_usec);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/regs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/regs.h
@@ -0,0 +1,337 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for x86 register definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_REGS_H
+#define __X86EMU_REGS_H
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#ifdef PACK
+# pragma PACK
+#endif
+
+/*
+ * General EAX, EBX, ECX, EDX type registers.  Note that for
+ * portability, and speed, the issue of byte swapping is not addressed
+ * in the registers.  All registers are stored in the default format
+ * available on the host machine.  The only critical issue is that the
+ * registers should line up EXACTLY in the same manner as they do in
+ * the 386.  That is:
+ *
+ * EAX & 0xff  === AL
+ * EAX & 0xffff == AX
+ *
+ * etc.  The result is that alot of the calculations can then be
+ * done using the native instruction set fully.
+ */
+
+#ifdef	__BIG_ENDIAN__
+
+typedef struct {
+    u32 e_reg;
+	} I32_reg_t;
+
+typedef struct {
+	u16 filler0, x_reg;
+	} I16_reg_t;
+
+typedef struct {
+	u8 filler0, filler1, h_reg, l_reg;
+	} I8_reg_t;
+
+#else /* !__BIG_ENDIAN__ */
+
+typedef struct {
+    u32 e_reg;
+	} I32_reg_t;
+
+typedef struct {
+	u16 x_reg;
+	} I16_reg_t;
+
+typedef struct {
+	u8 l_reg, h_reg;
+	} I8_reg_t;
+
+#endif /* BIG_ENDIAN */
+
+typedef union {
+	I32_reg_t   I32_reg;
+	I16_reg_t   I16_reg;
+	I8_reg_t    I8_reg;
+	} i386_general_register;
+
+struct i386_general_regs {
+	i386_general_register A, B, C, D;
+	};
+
+typedef struct i386_general_regs Gen_reg_t;
+
+struct i386_special_regs {
+	i386_general_register SP, BP, SI, DI, IP;
+	u32 FLAGS;
+	};
+
+/*  
+ * Segment registers here represent the 16 bit quantities
+ * CS, DS, ES, SS.
+ */
+
+struct i386_segment_regs {
+    u16 CS, DS, SS, ES, FS, GS;
+	};
+
+/* 8 bit registers */
+#define R_AH  gen.A.I8_reg.h_reg
+#define R_AL  gen.A.I8_reg.l_reg
+#define R_BH  gen.B.I8_reg.h_reg
+#define R_BL  gen.B.I8_reg.l_reg
+#define R_CH  gen.C.I8_reg.h_reg
+#define R_CL  gen.C.I8_reg.l_reg
+#define R_DH  gen.D.I8_reg.h_reg
+#define R_DL  gen.D.I8_reg.l_reg
+
+/* 16 bit registers */
+#define R_AX  gen.A.I16_reg.x_reg
+#define R_BX  gen.B.I16_reg.x_reg
+#define R_CX  gen.C.I16_reg.x_reg
+#define R_DX  gen.D.I16_reg.x_reg
+
+/* 32 bit extended registers */
+#define R_EAX  gen.A.I32_reg.e_reg
+#define R_EBX  gen.B.I32_reg.e_reg
+#define R_ECX  gen.C.I32_reg.e_reg
+#define R_EDX  gen.D.I32_reg.e_reg
+
+/* special registers */
+#define R_SP  spc.SP.I16_reg.x_reg
+#define R_BP  spc.BP.I16_reg.x_reg
+#define R_SI  spc.SI.I16_reg.x_reg
+#define R_DI  spc.DI.I16_reg.x_reg
+#define R_IP  spc.IP.I16_reg.x_reg
+#define R_FLG spc.FLAGS
+
+/* special registers */
+#define R_SP  spc.SP.I16_reg.x_reg
+#define R_BP  spc.BP.I16_reg.x_reg
+#define R_SI  spc.SI.I16_reg.x_reg
+#define R_DI  spc.DI.I16_reg.x_reg
+#define R_IP  spc.IP.I16_reg.x_reg
+#define R_FLG spc.FLAGS
+
+/* special registers */
+#define R_ESP  spc.SP.I32_reg.e_reg
+#define R_EBP  spc.BP.I32_reg.e_reg
+#define R_ESI  spc.SI.I32_reg.e_reg
+#define R_EDI  spc.DI.I32_reg.e_reg
+#define R_EIP  spc.IP.I32_reg.e_reg
+#define R_EFLG spc.FLAGS
+
+/* segment registers */
+#define R_CS  seg.CS
+#define R_DS  seg.DS
+#define R_SS  seg.SS
+#define R_ES  seg.ES
+#define R_FS  seg.FS
+#define R_GS  seg.GS
+
+/* flag conditions   */
+#define FB_CF 0x0001            /* CARRY flag  */
+#define FB_PF 0x0004            /* PARITY flag */
+#define FB_AF 0x0010            /* AUX  flag   */
+#define FB_ZF 0x0040            /* ZERO flag   */
+#define FB_SF 0x0080            /* SIGN flag   */
+#define FB_TF 0x0100            /* TRAP flag   */
+#define FB_IF 0x0200            /* INTERRUPT ENABLE flag */
+#define FB_DF 0x0400            /* DIR flag    */
+#define FB_OF 0x0800            /* OVERFLOW flag */
+
+/* 80286 and above always have bit#1 set */
+#define F_ALWAYS_ON  (0x0002)   /* flag bits always on */
+
+/*
+ * Define a mask for only those flag bits we will ever pass back 
+ * (via PUSHF) 
+ */
+#define F_MSK (FB_CF|FB_PF|FB_AF|FB_ZF|FB_SF|FB_TF|FB_IF|FB_DF|FB_OF)
+
+/* following bits masked in to a 16bit quantity */
+
+#define F_CF 0x0001             /* CARRY flag  */
+#define F_PF 0x0004             /* PARITY flag */
+#define F_AF 0x0010             /* AUX  flag   */
+#define F_ZF 0x0040             /* ZERO flag   */
+#define F_SF 0x0080             /* SIGN flag   */
+#define F_TF 0x0100             /* TRAP flag   */
+#define F_IF 0x0200             /* INTERRUPT ENABLE flag */
+#define F_DF 0x0400             /* DIR flag    */
+#define F_OF 0x0800             /* OVERFLOW flag */
+
+#define TOGGLE_FLAG(flag)     	(M.x86.R_FLG ^= (flag))
+#define SET_FLAG(flag)        	(M.x86.R_FLG |= (flag))
+#define CLEAR_FLAG(flag)      	(M.x86.R_FLG &= ~(flag))
+#define ACCESS_FLAG(flag)     	(M.x86.R_FLG & (flag))
+#define CLEARALL_FLAG(m)    	(M.x86.R_FLG = 0)
+
+#define CONDITIONAL_SET_FLAG(COND,FLAG) \
+  if (COND) SET_FLAG(FLAG); else CLEAR_FLAG(FLAG)
+
+#define F_PF_CALC 0x010000      /* PARITY flag has been calced    */
+#define F_ZF_CALC 0x020000      /* ZERO flag has been calced      */
+#define F_SF_CALC 0x040000      /* SIGN flag has been calced      */
+
+#define F_ALL_CALC      0xff0000        /* All have been calced   */
+
+/*
+ * Emulator machine state.
+ * Segment usage control.
+ */
+#define SYSMODE_SEG_DS_SS       0x00000001
+#define SYSMODE_SEGOVR_CS       0x00000002
+#define SYSMODE_SEGOVR_DS       0x00000004
+#define SYSMODE_SEGOVR_ES       0x00000008
+#define SYSMODE_SEGOVR_FS       0x00000010
+#define SYSMODE_SEGOVR_GS       0x00000020
+#define SYSMODE_SEGOVR_SS       0x00000040
+#define SYSMODE_PREFIX_REPE     0x00000080
+#define SYSMODE_PREFIX_REPNE    0x00000100
+#define SYSMODE_PREFIX_DATA     0x00000200
+#define SYSMODE_PREFIX_ADDR     0x00000400
+#define SYSMODE_INTR_PENDING    0x10000000
+#define SYSMODE_EXTRN_INTR      0x20000000
+#define SYSMODE_HALTED          0x40000000
+
+#define SYSMODE_SEGMASK (SYSMODE_SEG_DS_SS      | \
+						 SYSMODE_SEGOVR_CS      | \
+						 SYSMODE_SEGOVR_DS      | \
+						 SYSMODE_SEGOVR_ES      | \
+						 SYSMODE_SEGOVR_FS      | \
+						 SYSMODE_SEGOVR_GS      | \
+						 SYSMODE_SEGOVR_SS)
+#define SYSMODE_CLRMASK (SYSMODE_SEG_DS_SS      | \
+						 SYSMODE_SEGOVR_CS      | \
+						 SYSMODE_SEGOVR_DS      | \
+						 SYSMODE_SEGOVR_ES      | \
+						 SYSMODE_SEGOVR_FS      | \
+						 SYSMODE_SEGOVR_GS      | \
+						 SYSMODE_SEGOVR_SS      | \
+						 SYSMODE_PREFIX_DATA    | \
+						 SYSMODE_PREFIX_ADDR)
+
+#define  INTR_SYNCH           0x1
+#define  INTR_ASYNCH          0x2
+#define  INTR_HALTED          0x4
+
+typedef struct {
+    struct i386_general_regs    gen;
+    struct i386_special_regs    spc;
+    struct i386_segment_regs    seg;
+    /*
+     * MODE contains information on:
+     *  REPE prefix             2 bits  repe,repne
+     *  SEGMENT overrides       5 bits  normal,DS,SS,CS,ES
+     *  Delayed flag set        3 bits  (zero, signed, parity)
+     *  reserved                6 bits
+     *  interrupt #             8 bits  instruction raised interrupt
+     *  BIOS video segregs      4 bits  
+     *  Interrupt Pending       1 bits  
+     *  Extern interrupt        1 bits
+     *  Halted                  1 bits
+     */
+    u32                         mode;
+    volatile int                intr;   /* mask of pending interrupts */
+	int                         debug;
+#ifdef DEBUG
+	int                         check;
+    u16                         saved_ip;
+    u16                         saved_cs;
+    int                         enc_pos;
+    int                         enc_str_pos;
+    char                        decode_buf[32]; /* encoded byte stream  */
+    char                        decoded_buf[256]; /* disassembled strings */
+#endif
+    u8                          intno;
+    u8                          __pad[3];
+	} X86EMU_regs;
+
+/****************************************************************************
+REMARKS:
+Structure maintaining the emulator machine state.
+
+MEMBERS:
+mem_base		- Base real mode memory for the emulator
+mem_size		- Size of the real mode memory block for the emulator
+private			- private data pointer
+x86			- X86 registers
+****************************************************************************/
+typedef struct {
+	unsigned long	mem_base;
+	unsigned long	mem_size;
+	void*        	private;
+	X86EMU_regs		x86;
+	} X86EMU_sysEnv;
+
+#ifdef END_PACK
+# pragma END_PACK
+#endif
+
+/*----------------------------- Global Variables --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+/* Global emulator machine state.
+ *
+ * We keep it global to avoid pointer dereferences in the code for speed.
+ */
+
+extern    X86EMU_sysEnv	_X86EMU_env;
+#define   M             _X86EMU_env
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+/* Function to log information at runtime */
+
+void	printk(const char *fmt, ...);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_REGS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fb24_32.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fb24_32.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _FB24_32_H_
+#define _FB24_32_H_
+
+Bool
+fb24_32FinishScreenInit(ScreenPtr    pScreen,
+			pointer      pbits,
+			int          xsize,
+			int          ysize,
+			int          dpix,
+			int          dpiy,
+			int          width,
+			int          bpp);
+
+Bool
+fb24_32ScreenInit(ScreenPtr  pScreen,
+		  pointer    pbits,
+		  int        xsize,
+		  int        ysize,
+		  int        dpix,
+		  int        dpiy,
+		  int        width,
+		  int        bpp);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgprop.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgprop.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGPROP_H
+#define CHGPROP_H 1
+
+int SProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
+    );
+
+int ProcXChangeDeviceDontPropagateList(ClientPtr	/* client */
+    );
+
+#endif /* CHGPROP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/site.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/site.h
@@ -0,0 +1,130 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+#ifndef SITE_H
+#define SITE_H
+/*
+ * The vendor string identifies the vendor responsible for the
+ * server executable.
+ */
+#ifndef VENDOR_STRING
+#define VENDOR_STRING "The X.Org Foundation"
+#endif
+
+/*
+ * The vendor release number identifies, for the purpose of submitting
+ * traceable bug reports, the release number of software produced
+ * by the vendor.
+ */
+#ifndef VENDOR_RELEASE
+#define VENDOR_RELEASE	6600
+#endif
+
+/*
+ * The following constants are provided solely as a last line of defense.  The
+ * normal build ALWAYS overrides them using a special rule given in
+ * server/dix/Imakefile.  If you want to change either of these constants, 
+ * you should set the DefaultFontPath or DefaultRGBDatabase configuration 
+ * parameters.
+ * DO NOT CHANGE THESE VALUES OR THE DIX IMAKEFILE!
+ */
+#ifndef COMPILEDDEFAULTFONTPATH
+#define COMPILEDDEFAULTFONTPATH	"/usr/share/fonts/X11/misc/"
+#endif
+
+/*
+ * The following constants contain default values for all of the variables 
+ * that can be initialized on the server command line or in the environment.
+ */
+#define COMPILEDDEFAULTFONT	"fixed"
+#define COMPILEDCURSORFONT	"cursor"
+#ifndef COMPILEDDISPLAYCLASS
+#define COMPILEDDISPLAYCLASS	"MIT-unspecified"
+#endif
+#define DEFAULT_TIMEOUT		60	/* seconds */
+#define DEFAULT_KEYBOARD_CLICK 	0
+#define DEFAULT_BELL		50
+#define DEFAULT_BELL_PITCH	400
+#define DEFAULT_BELL_DURATION	100
+#define DEFAULT_AUTOREPEAT	TRUE
+#define DEFAULT_AUTOREPEATS	{\
+        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\
+        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
+
+#define DEFAULT_LEDS		0x0        /* all off */
+#define DEFAULT_LEDS_MASK	0xffffffff /* 32 */
+#define DEFAULT_INT_RESOLUTION		1000
+#define DEFAULT_INT_MIN_VALUE		0
+#define DEFAULT_INT_MAX_VALUE		100
+#define DEFAULT_INT_DISPLAYED		0
+
+#define DEFAULT_PTR_NUMERATOR	2
+#define DEFAULT_PTR_DENOMINATOR	1
+#define DEFAULT_PTR_THRESHOLD	4
+
+#define DEFAULT_SCREEN_SAVER_TIME (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_INTERVAL (10 * (60 * 1000))
+#define DEFAULT_SCREEN_SAVER_BLANKING PreferBlanking
+#define DEFAULT_SCREEN_SAVER_EXPOSURES AllowExposures
+#ifndef NOLOGOHACK
+#define DEFAULT_LOGO_SCREEN_SAVER 1
+#endif
+#ifndef DEFAULT_ACCESS_CONTROL
+#define DEFAULT_ACCESS_CONTROL TRUE
+#endif
+
+/* Default logging parameters. */
+#ifndef DEFAULT_LOG_VERBOSITY
+#define DEFAULT_LOG_VERBOSITY		0
+#endif
+#ifndef DEFAULT_LOG_FILE_VERBOSITY
+#define DEFAULT_LOG_FILE_VERBOSITY	3
+#endif
+
+#endif /* SITE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisb.h
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 1997  Metro Link Incorporated
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ *
+ */
+
+#ifndef	_xisb_H_
+#define _xisb_H_
+
+#include <unistd.h>
+
+/******************************************************************************
+ *		Definitions
+ *									structs, typedefs, #defines, enums
+ *****************************************************************************/
+
+typedef struct _XISBuffer
+{
+	int fd;
+	int trace;
+	int block_duration;
+	ssize_t current;	/* bytes read */
+	ssize_t end;
+	ssize_t buffer_size;
+	unsigned char *buf;
+} XISBuffer;
+
+/******************************************************************************
+ *		Declarations
+ *								variables:	use xisb_LOC in front
+ *											of globals.
+ *											put locals in the .c file.
+ *****************************************************************************/
+extern _X_EXPORT XISBuffer * XisbNew (int fd, ssize_t size);
+extern _X_EXPORT void XisbFree (XISBuffer *b);
+extern _X_EXPORT int XisbRead (XISBuffer *b);
+extern _X_EXPORT ssize_t XisbWrite (XISBuffer *b, unsigned char *msg, ssize_t len);
+extern _X_EXPORT void XisbTrace (XISBuffer *b, int trace);
+extern _X_EXPORT void XisbBlockDuration (XISBuffer *b, int block_duration);
+
+/*
+ *	DO NOT PUT ANYTHING AFTER THIS ENDIF
+ */
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/BTPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/BTPriv.h
@@ -0,0 +1,20 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "BT.h"
+
+typedef struct {
+	char *DeviceName;
+} xf86BTramdacInfo;
+
+extern xf86BTramdacInfo BTramdacDeviceInfo[];
+
+#ifdef INIT_BT_RAMDAC_INFO
+xf86BTramdacInfo BTramdacDeviceInfo[] = {
+	{"AT&T 20C504"},
+	{"AT&T 20C505"},
+	{"BT485/484"}
+};
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xipassivegrab.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xipassivegrab.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIPASSIVEGRAB_H
+#define XIPASSIVEGRAB_H 1
+
+int SProcXIPassiveUngrabDevice(ClientPtr client);
+int ProcXIPassiveUngrabDevice(ClientPtr client);
+void SRepXIPassiveGrabDevice(ClientPtr client, int size, xXIPassiveGrabDeviceReply * rep);
+int ProcXIPassiveGrabDevice(ClientPtr client);
+int SProcXIPassiveGrabDevice(ClientPtr client);
+
+#endif /* XIPASSIVEGRAB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86int10.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86int10.h
@@ -0,0 +1,185 @@
+
+/*
+ *                   XFree86 int10 module
+ *   execute BIOS int 10h calls in x86 real mode environment
+ *                 Copyright 1999 Egbert Eich
+ */
+
+#ifndef _XF86INT10_H
+#define _XF86INT10_H
+
+#include <X11/Xmd.h>
+#include <X11/Xdefs.h>
+#include "xf86Pci.h"
+
+#define SEG_ADDR(x) (((x) >> 4) & 0x00F000)
+#define SEG_OFF(x) ((x) & 0x0FFFF)
+
+#define SET_BIOS_SCRATCH     0x1
+#define RESTORE_BIOS_SCRATCH 0x2
+
+/* int10 info structure */
+typedef struct {
+    int entityIndex;
+    int scrnIndex;
+    pointer cpuRegs;
+    CARD16  BIOSseg;
+    CARD16  inb40time;
+    char * BIOSScratch;
+    int Flags;
+    pointer private;
+    struct _int10Mem* mem;
+    int num;
+    int ax;
+    int bx;
+    int cx;
+    int dx;
+    int si;
+    int di;
+    int es;
+    int bp;
+    int flags;
+    int stackseg;
+    struct pci_device *dev;
+    IOADDRESS ioBase;
+} xf86Int10InfoRec, *xf86Int10InfoPtr;
+
+typedef struct _int10Mem {
+    CARD8(*rb)(xf86Int10InfoPtr, int);
+    CARD16(*rw)(xf86Int10InfoPtr, int);
+    CARD32(*rl)(xf86Int10InfoPtr, int);
+    void(*wb)(xf86Int10InfoPtr, int, CARD8);
+    void(*ww)(xf86Int10InfoPtr, int, CARD16);
+    void(*wl)(xf86Int10InfoPtr, int, CARD32);
+} int10MemRec, *int10MemPtr;
+
+typedef struct {
+    CARD8 save_msr;
+    CARD8 save_pos102;
+    CARD8 save_vse;
+    CARD8 save_46e8;
+} legacyVGARec, *legacyVGAPtr;
+    
+/* OS dependent functions */
+extern _X_EXPORT xf86Int10InfoPtr xf86InitInt10(int entityIndex);
+extern _X_EXPORT xf86Int10InfoPtr xf86ExtendedInitInt10(int entityIndex,
+							int Flags);
+extern _X_EXPORT void xf86FreeInt10(xf86Int10InfoPtr pInt);
+extern _X_EXPORT void *xf86Int10AllocPages(xf86Int10InfoPtr pInt, int num,
+					   int *off);
+extern _X_EXPORT void xf86Int10FreePages(xf86Int10InfoPtr pInt, void *pbase,
+					 int num);
+extern _X_EXPORT pointer xf86int10Addr(xf86Int10InfoPtr pInt, CARD32 addr);
+
+/* x86 executor related functions */
+extern _X_EXPORT void xf86ExecX86int10(xf86Int10InfoPtr pInt);
+
+#ifdef _INT10_PRIVATE
+
+#define I_S_DEFAULT_INT_VECT 0xFF065
+#define SYS_SIZE 0x100000
+#define SYS_BIOS 0xF0000
+#if 1
+#define BIOS_SIZE 0x10000
+#else /* a bug in DGUX requires this - let's try it */
+#define BIOS_SIZE (0x10000 - 1)
+#endif
+#define LOW_PAGE_SIZE 0x600
+#define V_RAM 0xA0000
+#define VRAM_SIZE 0x20000
+#define V_BIOS_SIZE 0x10000
+#define V_BIOS 0xC0000
+#define BIOS_SCRATCH_OFF 0x449
+#define BIOS_SCRATCH_END 0x466
+#define BIOS_SCRATCH_LEN (BIOS_SCRATCH_END - BIOS_SCRATCH_OFF + 1)
+#define HIGH_MEM V_BIOS
+#define HIGH_MEM_SIZE (SYS_BIOS - HIGH_MEM)
+#define SEG_ADR(type, seg, reg)  type((seg << 4) + (X86_##reg))
+#define SEG_EADR(type, seg, reg) type((seg << 4) + (X86_E##reg))
+
+#define X86_TF_MASK		0x00000100
+#define X86_IF_MASK		0x00000200
+#define X86_IOPL_MASK		0x00003000
+#define X86_NT_MASK		0x00004000
+#define X86_VM_MASK		0x00020000
+#define X86_AC_MASK		0x00040000
+#define X86_VIF_MASK		0x00080000	/* virtual interrupt flag */
+#define X86_VIP_MASK		0x00100000	/* virtual interrupt pending */
+#define X86_ID_MASK		0x00200000
+
+#define MEM_RB(name, addr)      (*name->mem->rb)(name, addr)
+#define MEM_RW(name, addr)      (*name->mem->rw)(name, addr)
+#define MEM_RL(name, addr)      (*name->mem->rl)(name, addr)
+#define MEM_WB(name, addr, val) (*name->mem->wb)(name, addr, val)
+#define MEM_WW(name, addr, val) (*name->mem->ww)(name, addr, val)
+#define MEM_WL(name, addr, val) (*name->mem->wl)(name, addr, val)
+
+/* OS dependent functions */
+extern _X_EXPORT Bool MapCurrentInt10(xf86Int10InfoPtr pInt);
+/* x86 executor related functions */
+extern _X_EXPORT Bool xf86Int10ExecSetup(xf86Int10InfoPtr pInt);
+
+/* int.c */
+extern _X_EXPORT xf86Int10InfoPtr Int10Current;
+int int_handler(xf86Int10InfoPtr pInt);
+
+/* helper_exec.c */
+int setup_int(xf86Int10InfoPtr pInt);
+void finish_int(xf86Int10InfoPtr, int sig);
+CARD32 getIntVect(xf86Int10InfoPtr pInt, int num);
+void pushw(xf86Int10InfoPtr pInt, CARD16 val);
+int run_bios_int(int num, xf86Int10InfoPtr pInt);
+void dump_code(xf86Int10InfoPtr pInt);
+void dump_registers(xf86Int10InfoPtr pInt);
+void stack_trace(xf86Int10InfoPtr pInt);
+CARD8 bios_checksum(const CARD8 *start, int size);
+void LockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);
+void UnlockLegacyVGA(xf86Int10InfoPtr pInt, legacyVGAPtr vga);
+#if defined (_PC)
+extern _X_EXPORT void xf86Int10SaveRestoreBIOSVars(xf86Int10InfoPtr pInt, Bool save);
+#endif
+int port_rep_inb(xf86Int10InfoPtr pInt,
+		 CARD16 port, CARD32 base, int d_f, CARD32 count);
+int port_rep_inw(xf86Int10InfoPtr pInt,
+		 CARD16 port, CARD32 base, int d_f, CARD32 count);
+int port_rep_inl(xf86Int10InfoPtr pInt,
+		 CARD16 port, CARD32 base, int d_f, CARD32 count);
+int port_rep_outb(xf86Int10InfoPtr pInt,
+		  CARD16 port, CARD32 base, int d_f, CARD32 count);
+int port_rep_outw(xf86Int10InfoPtr pInt,
+		  CARD16 port, CARD32 base, int d_f, CARD32 count);
+int port_rep_outl(xf86Int10InfoPtr pInt,
+		  CARD16 port, CARD32 base, int d_f, CARD32 count);
+
+CARD8 x_inb(CARD16 port);
+CARD16 x_inw(CARD16 port);
+void x_outb(CARD16 port, CARD8 val);
+void x_outw(CARD16 port, CARD16 val);
+CARD32 x_inl(CARD16 port);
+void x_outl(CARD16 port, CARD32 val);
+
+CARD8 Mem_rb(CARD32 addr);
+CARD16 Mem_rw(CARD32 addr);
+CARD32 Mem_rl(CARD32 addr);
+void Mem_wb(CARD32 addr, CARD8 val);
+void Mem_ww(CARD32 addr, CARD16 val);
+void Mem_wl(CARD32 addr, CARD32 val);
+
+/* helper_mem.c */
+void setup_int_vect(xf86Int10InfoPtr pInt);
+int setup_system_bios(void *base_addr);
+void reset_int_vect(xf86Int10InfoPtr pInt);
+void set_return_trap(xf86Int10InfoPtr pInt);
+extern _X_EXPORT void * xf86HandleInt10Options(ScrnInfoPtr pScrn, int entityIndex);
+Bool int10skip(const void* options);
+Bool int10_check_bios(int scrnIndex, int codeSeg,
+    const unsigned char* vbiosMem);
+Bool initPrimary(const void* options);
+extern _X_EXPORT BusType xf86int10GetBiosLocationType(const xf86Int10InfoPtr pInt);
+extern _X_EXPORT Bool xf86int10GetBiosSegment(xf86Int10InfoPtr pInt, void *base);
+#ifdef DEBUG
+void dprint(unsigned long start, unsigned long size);
+#endif
+
+#endif /* _INT10_PRIVATE */
+#endif /* _XF86INT10_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/IBMPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/IBMPriv.h
@@ -0,0 +1,27 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "IBM.h"
+
+typedef struct {
+	char *DeviceName;
+} xf86IBMramdacInfo;
+
+extern xf86IBMramdacInfo IBMramdacDeviceInfo[];
+
+#ifdef INIT_IBM_RAMDAC_INFO
+xf86IBMramdacInfo IBMramdacDeviceInfo[] = {
+	{"IBM 524"},
+	{"IBM 524A"},
+	{"IBM 525"},
+	{"IBM 526"},
+	{"IBM 526DB(DoubleBuffer)"},
+	{"IBM 528"},
+	{"IBM 528A"},
+	{"IBM 624"},
+	{"IBM 624DB(DoubleBuffer)"},
+	{"IBM 640"}
+};
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/scrnintstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/scrnintstr.h
@@ -0,0 +1,629 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef SCREENINTSTRUCT_H
+#define SCREENINTSTRUCT_H
+
+#include "screenint.h"
+#include "regionstr.h"
+#include "bstore.h"
+#include "colormap.h"
+#include "cursor.h"
+#include "validate.h"
+#include <X11/Xproto.h>
+#include "dix.h"
+#include "privates.h"
+
+typedef struct _PixmapFormat {
+    unsigned char	depth;
+    unsigned char	bitsPerPixel;
+    unsigned char	scanlinePad;
+    } PixmapFormatRec;
+    
+typedef struct _Visual {
+    VisualID		vid;
+    short		class;
+    short		bitsPerRGBValue;
+    short		ColormapEntries;
+    short		nplanes;/* = log2 (ColormapEntries). This does not
+				 * imply that the screen has this many planes.
+				 * it may have more or fewer */
+    unsigned long	redMask, greenMask, blueMask;
+    int			offsetRed, offsetGreen, offsetBlue;
+  } VisualRec;
+
+typedef struct _Depth {
+    unsigned char	depth;
+    short		numVids;
+    VisualID		*vids;    /* block of visual ids for this depth */
+  } DepthRec;
+
+typedef struct _ScreenSaverStuff {
+    WindowPtr pWindow;
+    XID       wid;
+    char      blanked;
+    Bool      (*ExternalScreenSaver)(
+	ScreenPtr	/*pScreen*/,
+	int		/*xstate*/,
+	Bool		/*force*/);
+} ScreenSaverStuffRec;
+
+
+/*
+ *  There is a typedef for each screen function pointer so that code that
+ *  needs to declare a screen function pointer (e.g. in a screen private
+ *  or as a local variable) can easily do so and retain full type checking.
+ */
+
+typedef    Bool (* CloseScreenProcPtr)(
+	int /*index*/,
+	ScreenPtr /*pScreen*/);
+
+typedef    void (* QueryBestSizeProcPtr)(
+	int /*class*/,
+	unsigned short * /*pwidth*/,
+	unsigned short * /*pheight*/,
+	ScreenPtr /*pScreen*/);
+
+typedef    Bool (* SaveScreenProcPtr)(
+	 ScreenPtr /*pScreen*/,
+	 int /*on*/);
+
+typedef    void (* GetImageProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*sx*/,
+	int /*sy*/,
+	int /*w*/,
+	int /*h*/,
+	unsigned int /*format*/,
+	unsigned long /*planeMask*/,
+	char * /*pdstLine*/);
+
+typedef    void (* GetSpansProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*wMax*/,
+	DDXPointPtr /*ppt*/,
+	int* /*pwidth*/,
+	int /*nspans*/,
+	char * /*pdstStart*/);
+
+typedef    void (* SourceValidateProcPtr)(
+	DrawablePtr /*pDrawable*/,
+	int /*x*/,
+	int /*y*/,
+	int /*width*/,
+	int /*height*/);
+
+typedef    Bool (* CreateWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* DestroyWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* PositionWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/);
+
+typedef    Bool (* ChangeWindowAttributesProcPtr)(
+	WindowPtr /*pWindow*/,
+	unsigned long /*mask*/);
+
+typedef    Bool (* RealizeWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    Bool (* UnrealizeWindowProcPtr)(
+	WindowPtr /*pWindow*/);
+
+typedef    void (* RestackWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	WindowPtr /*pOldNextSib*/);
+
+typedef    int  (* ValidateTreeProcPtr)(
+	WindowPtr /*pParent*/,
+	WindowPtr /*pChild*/,
+	VTKind /*kind*/);
+
+typedef    void (* PostValidateTreeProcPtr)(
+	WindowPtr /*pParent*/,
+	WindowPtr /*pChild*/,
+	VTKind /*kind*/);
+
+typedef    void (* WindowExposuresProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgn*/,
+	RegionPtr /*other_exposed*/);
+
+typedef    void (* CopyWindowProcPtr)(
+	WindowPtr /*pWindow*/,
+	DDXPointRec /*ptOldOrg*/,
+	RegionPtr /*prgnSrc*/);
+
+typedef    void (* ClearToBackgroundProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/,
+	int /*w*/,
+	int /*h*/,
+	Bool /*generateExposures*/);
+
+typedef    void (* ClipNotifyProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*dx*/,
+	int /*dy*/);
+
+/* pixmap will exist only for the duration of the current rendering operation */
+#define CREATE_PIXMAP_USAGE_SCRATCH                     1
+/* pixmap will be the backing pixmap for a redirected window */
+#define CREATE_PIXMAP_USAGE_BACKING_PIXMAP              2
+/* pixmap will contain a glyph */
+#define CREATE_PIXMAP_USAGE_GLYPH_PICTURE               3
+
+typedef    PixmapPtr (* CreatePixmapProcPtr)(
+	ScreenPtr /*pScreen*/,
+	int /*width*/,
+	int /*height*/,
+	int /*depth*/,
+	unsigned /*usage_hint*/);
+
+typedef    Bool (* DestroyPixmapProcPtr)(
+	PixmapPtr /*pPixmap*/);
+
+typedef    void (* SaveDoomedAreasProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgnSave*/,
+	int /*xorg*/,
+	int /*yorg*/);
+
+typedef    RegionPtr (* RestoreAreasProcPtr)(
+	WindowPtr /*pWindow*/,
+	RegionPtr /*prgnRestore*/);
+
+typedef    void (* ExposeCopyProcPtr)(
+	WindowPtr /*pSrc*/,
+	DrawablePtr /*pDst*/,
+	GCPtr /*pGC*/,
+	RegionPtr /*prgnExposed*/,
+	int /*srcx*/,
+	int /*srcy*/,
+	int /*dstx*/,
+	int /*dsty*/,
+	unsigned long /*plane*/);
+
+typedef    RegionPtr (* TranslateBackingStoreProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*windx*/,
+	int /*windy*/,
+	RegionPtr /*oldClip*/,
+	int /*oldx*/,
+	int /*oldy*/);
+
+typedef    RegionPtr (* ClearBackingStoreProcPtr)(
+	WindowPtr /*pWindow*/,
+	int /*x*/,
+	int /*y*/,
+	int /*w*/,
+	int /*h*/,
+	Bool /*generateExposures*/);
+
+typedef    void (* DrawGuaranteeProcPtr)(
+	WindowPtr /*pWindow*/,
+	GCPtr /*pGC*/,
+	int /*guarantee*/);
+    
+typedef    Bool (* RealizeFontProcPtr)(
+	ScreenPtr /*pScreen*/,
+	FontPtr /*pFont*/);
+
+typedef    Bool (* UnrealizeFontProcPtr)(
+	ScreenPtr /*pScreen*/,
+	FontPtr /*pFont*/);
+
+typedef    void (* ConstrainCursorProcPtr)(
+        DeviceIntPtr /*pDev*/,
+	ScreenPtr /*pScreen*/,
+	BoxPtr /*pBox*/);
+
+typedef    void (* CursorLimitsProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/,
+	BoxPtr /*pHotBox*/,
+	BoxPtr /*pTopLeftBox*/);
+
+typedef    Bool (* DisplayCursorProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    Bool (* RealizeCursorProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    Bool (* UnrealizeCursorProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/);
+
+typedef    void (* RecolorCursorProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	CursorPtr /*pCursor*/,
+	Bool /*displayed*/);
+
+typedef    Bool (* SetCursorPositionProcPtr)(
+        DeviceIntPtr /* pDev */,
+	ScreenPtr /*pScreen*/,
+	int /*x*/,
+	int /*y*/,
+	Bool /*generateEvent*/);
+
+typedef    Bool (* CreateGCProcPtr)(
+	GCPtr /*pGC*/);
+
+typedef    Bool (* CreateColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* DestroyColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* InstallColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    void (* UninstallColormapProcPtr)(
+	ColormapPtr /*pColormap*/);
+
+typedef    int (* ListInstalledColormapsProcPtr) (
+	ScreenPtr /*pScreen*/,
+	XID* /*pmaps */);
+
+typedef    void (* StoreColorsProcPtr)(
+	ColormapPtr /*pColormap*/,
+	int /*ndef*/,
+	xColorItem * /*pdef*/);
+
+typedef    void (* ResolveColorProcPtr)(
+	unsigned short* /*pred*/,
+	unsigned short* /*pgreen*/,
+	unsigned short* /*pblue*/,
+	VisualPtr /*pVisual*/);
+
+typedef    RegionPtr (* BitmapToRegionProcPtr)(
+	PixmapPtr /*pPix*/);
+
+typedef    void (* SendGraphicsExposeProcPtr)(
+	ClientPtr /*client*/,
+	RegionPtr /*pRgn*/,
+	XID /*drawable*/,
+	int /*major*/,
+	int /*minor*/);
+
+typedef    void (* ScreenBlockHandlerProcPtr)(
+	int /*screenNum*/,
+	pointer /*blockData*/,
+	pointer /*pTimeout*/,
+	pointer /*pReadmask*/);
+
+typedef    void (* ScreenWakeupHandlerProcPtr)(
+	 int /*screenNum*/,
+	 pointer /*wakeupData*/,
+	 unsigned long /*result*/,
+	 pointer /*pReadMask*/);
+
+typedef    Bool (* CreateScreenResourcesProcPtr)(
+	ScreenPtr /*pScreen*/);
+
+typedef    Bool (* ModifyPixmapHeaderProcPtr)(
+	PixmapPtr /*pPixmap*/,
+	int /*width*/,
+	int /*height*/,
+	int /*depth*/,
+	int /*bitsPerPixel*/,
+	int /*devKind*/,
+	pointer /*pPixData*/);
+
+typedef    PixmapPtr (* GetWindowPixmapProcPtr)(
+	WindowPtr /*pWin*/);
+
+typedef    void (* SetWindowPixmapProcPtr)(
+	WindowPtr /*pWin*/,
+	PixmapPtr /*pPix*/);
+
+typedef    PixmapPtr (* GetScreenPixmapProcPtr)(
+	ScreenPtr /*pScreen*/);
+
+typedef    void (* SetScreenPixmapProcPtr)(
+	PixmapPtr /*pPix*/);
+
+typedef    void (* MarkWindowProcPtr)(
+	WindowPtr /*pWin*/);
+
+typedef    Bool (* MarkOverlappedWindowsProcPtr)(
+	WindowPtr /*parent*/,
+	WindowPtr /*firstChild*/,
+	WindowPtr * /*pLayerWin*/);
+
+typedef    Bool (* ChangeSaveUnderProcPtr)(
+	WindowPtr /*pLayerWin*/,
+	WindowPtr /*firstChild*/);
+
+typedef    void (* PostChangeSaveUnderProcPtr)(
+	WindowPtr /*pLayerWin*/,
+	WindowPtr /*firstChild*/);
+
+typedef    int (* ConfigNotifyProcPtr)(
+	WindowPtr /*pWin*/,
+	int /*x*/,
+	int /*y*/,
+	int /*w*/,
+	int /*h*/,
+	int /*bw*/,
+	WindowPtr /*pSib*/);
+
+typedef    void (* MoveWindowProcPtr)(
+	WindowPtr /*pWin*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pSib*/,
+	VTKind /*kind*/);
+
+typedef    void (* ResizeWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/, 
+    unsigned int /*w*/,
+    unsigned int /*h*/,
+    WindowPtr /*pSib*/
+);
+
+typedef    WindowPtr (* GetLayerWindowProcPtr)(
+    WindowPtr /*pWin*/
+);
+
+typedef    void (* HandleExposuresProcPtr)(
+    WindowPtr /*pWin*/);
+
+typedef    void (* ReparentWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pPriorParent*/);
+
+typedef    void (* SetShapeProcPtr)(
+        WindowPtr /*pWin*/,
+        int /* kind */);
+
+typedef    void (* ChangeBorderWidthProcPtr)(
+	WindowPtr /*pWin*/,
+	unsigned int /*width*/);
+
+typedef    void (* MarkUnrealizedWindowProcPtr)(
+	WindowPtr /*pChild*/,
+	WindowPtr /*pWin*/,
+	Bool /*fromConfigure*/);
+
+typedef    Bool (* DeviceCursorInitializeProcPtr)(
+        DeviceIntPtr /* pDev */,
+        ScreenPtr    /* pScreen */);
+
+typedef    void (* DeviceCursorCleanupProcPtr)(
+        DeviceIntPtr /* pDev */,
+        ScreenPtr    /* pScreen */);
+
+typedef struct _Screen {
+    int			myNum;	/* index of this instance in Screens[] */
+    ATOM		id;
+    short		x, y, width, height;
+    short		mmWidth, mmHeight;
+    short		numDepths;
+    unsigned char      	rootDepth;
+    DepthPtr       	allowedDepths;
+    unsigned long      	rootVisual;
+    unsigned long	defColormap;
+    short		minInstalledCmaps, maxInstalledCmaps;
+    char                backingStoreSupport, saveUnderSupport;
+    unsigned long	whitePixel, blackPixel;
+    GCPtr		GCperDepth[MAXFORMATS+1];
+			/* next field is a stipple to use as default in
+			   a GC.  we don't build default tiles of all depths
+			   because they are likely to be of a color
+			   different from the default fg pixel, so
+			   we don't win anything by building
+			   a standard one.
+			*/
+    PixmapPtr		PixmapPerDepth[1];
+    pointer		devPrivate;
+    short       	numVisuals;
+    VisualPtr		visuals;
+    WindowPtr		root;
+    ScreenSaverStuffRec screensaver;
+
+    /* Random screen procedures */
+
+    CloseScreenProcPtr		CloseScreen;
+    QueryBestSizeProcPtr	QueryBestSize;
+    SaveScreenProcPtr		SaveScreen;
+    GetImageProcPtr		GetImage;
+    GetSpansProcPtr		GetSpans;
+    SourceValidateProcPtr	SourceValidate;
+
+    /* Window Procedures */
+
+    CreateWindowProcPtr		CreateWindow;
+    DestroyWindowProcPtr	DestroyWindow;
+    PositionWindowProcPtr	PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    RealizeWindowProcPtr	RealizeWindow;
+    UnrealizeWindowProcPtr	UnrealizeWindow;
+    ValidateTreeProcPtr		ValidateTree;
+    PostValidateTreeProcPtr	PostValidateTree;
+    WindowExposuresProcPtr	WindowExposures;
+    CopyWindowProcPtr		CopyWindow;
+    ClearToBackgroundProcPtr	ClearToBackground;
+    ClipNotifyProcPtr		ClipNotify;
+    RestackWindowProcPtr	RestackWindow;
+
+    /* Pixmap procedures */
+
+    CreatePixmapProcPtr		CreatePixmap;
+    DestroyPixmapProcPtr	DestroyPixmap;
+
+    /* Backing store procedures */
+
+    SaveDoomedAreasProcPtr	SaveDoomedAreas;
+    RestoreAreasProcPtr		RestoreAreas;
+    ExposeCopyProcPtr		ExposeCopy;
+    TranslateBackingStoreProcPtr TranslateBackingStore;
+    ClearBackingStoreProcPtr	ClearBackingStore;
+    DrawGuaranteeProcPtr	DrawGuarantee;
+    /*
+     * A read/write copy of the lower level backing store vector is needed now
+     * that the functions can be wrapped.
+     */
+    BSFuncRec			BackingStoreFuncs;
+    
+    /* Font procedures */
+
+    RealizeFontProcPtr		RealizeFont;
+    UnrealizeFontProcPtr	UnrealizeFont;
+
+    /* Cursor Procedures */
+
+    ConstrainCursorProcPtr	ConstrainCursor;
+    CursorLimitsProcPtr		CursorLimits;
+    DisplayCursorProcPtr	DisplayCursor;
+    RealizeCursorProcPtr	RealizeCursor;
+    UnrealizeCursorProcPtr	UnrealizeCursor;
+    RecolorCursorProcPtr	RecolorCursor;
+    SetCursorPositionProcPtr	SetCursorPosition;
+
+    /* GC procedures */
+
+    CreateGCProcPtr		CreateGC;
+
+    /* Colormap procedures */
+
+    CreateColormapProcPtr	CreateColormap;
+    DestroyColormapProcPtr	DestroyColormap;
+    InstallColormapProcPtr	InstallColormap;
+    UninstallColormapProcPtr	UninstallColormap;
+    ListInstalledColormapsProcPtr ListInstalledColormaps;
+    StoreColorsProcPtr		StoreColors;
+    ResolveColorProcPtr		ResolveColor;
+
+    /* Region procedures */
+
+    BitmapToRegionProcPtr	BitmapToRegion;
+    SendGraphicsExposeProcPtr	SendGraphicsExpose;
+
+    /* os layer procedures */
+
+    ScreenBlockHandlerProcPtr	BlockHandler;
+    ScreenWakeupHandlerProcPtr	WakeupHandler;
+
+    pointer blockData;
+    pointer wakeupData;
+
+    /* anybody can get a piece of this array */
+    PrivateRec	*devPrivates;
+
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    ModifyPixmapHeaderProcPtr	ModifyPixmapHeader;
+
+    GetWindowPixmapProcPtr	GetWindowPixmap;
+    SetWindowPixmapProcPtr	SetWindowPixmap;
+    GetScreenPixmapProcPtr	GetScreenPixmap;
+    SetScreenPixmapProcPtr	SetScreenPixmap;
+
+    PixmapPtr pScratchPixmap;		/* scratch pixmap "pool" */
+
+    unsigned int		totalPixmapSize;
+
+    MarkWindowProcPtr		MarkWindow;
+    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
+    ChangeSaveUnderProcPtr	ChangeSaveUnder;
+    PostChangeSaveUnderProcPtr	PostChangeSaveUnder;
+    ConfigNotifyProcPtr		ConfigNotify;
+    MoveWindowProcPtr		MoveWindow;
+    ResizeWindowProcPtr		ResizeWindow;
+    GetLayerWindowProcPtr	GetLayerWindow;
+    HandleExposuresProcPtr	HandleExposures;
+    ReparentWindowProcPtr	ReparentWindow;
+
+    SetShapeProcPtr		SetShape;
+
+    ChangeBorderWidthProcPtr	ChangeBorderWidth;
+    MarkUnrealizedWindowProcPtr	MarkUnrealizedWindow;
+
+    /* Device cursor procedures */
+    DeviceCursorInitializeProcPtr DeviceCursorInitialize;
+    DeviceCursorCleanupProcPtr    DeviceCursorCleanup;
+} ScreenRec;
+
+static inline RegionPtr BitmapToRegion(ScreenPtr _pScreen, PixmapPtr pPix) {
+    return (*(_pScreen)->BitmapToRegion)(pPix); /* no mi version?! */
+}
+
+typedef struct _ScreenInfo {
+    int		imageByteOrder;
+    int		bitmapScanlineUnit;
+    int		bitmapScanlinePad;
+    int		bitmapBitOrder;
+    int		numPixmapFormats;
+    PixmapFormatRec
+		formats[MAXFORMATS];
+    int		numScreens;
+    ScreenPtr	screens[MAXSCREENS];
+} ScreenInfo;
+
+extern _X_EXPORT ScreenInfo screenInfo;
+
+extern _X_EXPORT void InitOutput(
+    ScreenInfo 	* /*pScreenInfo*/,
+    int     	/*argc*/,
+    char    	** /*argv*/);
+
+#endif /* SCREENINTSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xvpriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xvpriv.h
@@ -0,0 +1,88 @@
+
+/*
+ * Copyright (c) 2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XVPRIV_H_
+#define _XF86XVPRIV_H_
+
+#include "xf86xv.h"
+#include "privates.h"
+
+/*** These are DDX layer privates ***/
+
+extern _X_EXPORT DevPrivateKey XF86XvScreenKey;
+
+typedef struct {
+   DestroyWindowProcPtr		DestroyWindow;
+   ClipNotifyProcPtr		ClipNotify;
+   WindowExposuresProcPtr	WindowExposures;
+   void                         (*AdjustFrame)(int, int, int, int);
+   Bool                         (*EnterVT)(int, int);
+   void                         (*LeaveVT)(int, int);
+   GCPtr			videoGC;
+} XF86XVScreenRec, *XF86XVScreenPtr;
+
+typedef struct {
+  int flags;  
+  PutVideoFuncPtr PutVideo;
+  PutStillFuncPtr PutStill;
+  GetVideoFuncPtr GetVideo;
+  GetStillFuncPtr GetStill;
+  StopVideoFuncPtr StopVideo;
+  SetPortAttributeFuncPtr SetPortAttribute;
+  GetPortAttributeFuncPtr GetPortAttribute;
+  QueryBestSizeFuncPtr QueryBestSize;
+  PutImageFuncPtr PutImage;
+  ReputImageFuncPtr ReputImage;
+  QueryImageAttributesFuncPtr QueryImageAttributes;
+  ClipNotifyFuncPtr ClipNotify;
+} XvAdaptorRecPrivate, *XvAdaptorRecPrivatePtr;
+
+typedef struct {
+   ScrnInfoPtr pScrn;
+   DrawablePtr pDraw;
+   unsigned char type;
+   unsigned int subWindowMode;
+   DDXPointRec clipOrg;
+   RegionPtr clientClip;
+   RegionPtr pCompositeClip;
+   Bool FreeCompositeClip;
+   XvAdaptorRecPrivatePtr AdaptorRec;
+   XvStatus isOn;
+   Bool moved;
+   int vid_x, vid_y, vid_w, vid_h;
+   int drw_x, drw_y, drw_w, drw_h;
+   DevUnion DevPriv;
+} XvPortRecPrivate, *XvPortRecPrivatePtr;
+
+typedef struct _XF86XVWindowRec{
+   XvPortRecPrivatePtr PortRec;
+   struct _XF86XVWindowRec *next;
+   GCPtr pGC;
+} XF86XVWindowRec, *XF86XVWindowPtr;
+
+#endif  /* _XF86XVPRIV_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fpu_regs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fpu_regs.h
@@ -0,0 +1,119 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for FPU register definitions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_FPU_REGS_H
+#define __X86EMU_FPU_REGS_H
+
+#ifdef X86_FPU_SUPPORT
+
+#ifdef PACK
+# pragma PACK
+#endif
+
+/* Basic 8087 register can hold any of the following values: */
+
+union x86_fpu_reg_u {
+    s8                  tenbytes[10];
+    double              dval;
+    float               fval;
+    s16                 sval;
+    s32                 lval;
+	};
+
+struct x86_fpu_reg {
+	union x86_fpu_reg_u reg;
+	char                tag;
+	};
+
+/*
+ * Since we are not going to worry about the problems of aliasing
+ * registers, every time a register is modified, its result type is
+ * set in the tag fields for that register.  If some operation
+ * attempts to access the type in a way inconsistent with its current
+ * storage format, then we flag the operation.  If common, we'll
+ * attempt the conversion.
+ */
+
+#define  X86_FPU_VALID          0x80
+#define  X86_FPU_REGTYP(r)      ((r) & 0x7F)
+
+#define  X86_FPU_WORD           0x0
+#define  X86_FPU_SHORT          0x1
+#define  X86_FPU_LONG           0x2
+#define  X86_FPU_FLOAT          0x3
+#define  X86_FPU_DOUBLE         0x4
+#define  X86_FPU_LDBL           0x5
+#define  X86_FPU_BSD            0x6
+
+#define  X86_FPU_STKTOP  0
+
+struct x86_fpu_registers {
+    struct x86_fpu_reg  x86_fpu_stack[8];
+    int                 x86_fpu_flags;
+    int                 x86_fpu_config;         /* rounding modes, etc. */
+    short               x86_fpu_tos, x86_fpu_bos;
+	};
+
+#ifdef END_PACK
+# pragma END_PACK
+#endif
+
+/*
+ * There are two versions of the following macro.
+ *
+ * One version is for opcode D9, for which there are more than 32
+ * instructions encoded in the second byte of the opcode.
+ *
+ * The other version, deals with all the other 7 i87 opcodes, for
+ * which there are only 32 strings needed to describe the
+ * instructions.
+ */
+
+#endif /* X86_FPU_SUPPORT */
+
+#ifdef DEBUG
+# define DECODE_PRINTINSTR32(t,mod,rh,rl)     	\
+	DECODE_PRINTF(t[(mod<<3)+(rh)]);
+# define DECODE_PRINTINSTR256(t,mod,rh,rl)    	\
+	DECODE_PRINTF(t[(mod<<6)+(rh<<3)+(rl)]);
+#else
+# define DECODE_PRINTINSTR32(t,mod,rh,rl)
+# define DECODE_PRINTINSTR256(t,mod,rh,rl)
+#endif
+
+#endif /* __X86EMU_FPU_REGS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiqueryversion.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiqueryversion.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright © 2009 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <X11/extensions/XI2proto.h>
+
+#ifndef QUERYVERSION_H
+#define QUERYVERSION_H 1
+
+int SProcXIQueryVersion(ClientPtr client);
+int ProcXIQueryVersion(ClientPtr client);
+void SRepXIQueryVersion(ClientPtr client, int size, xXIQueryVersionReply* rep);
+
+#endif /* QUERYVERSION_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbsrv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xkbsrv.h
@@ -0,0 +1,986 @@
+/************************************************************
+Copyright (c) 1993 by Silicon Graphics Computer Systems, Inc.
+
+Permission to use, copy, modify, and distribute this
+software and its documentation for any purpose and without
+fee is hereby granted, provided that the above copyright
+notice appear in all copies and that both that copyright
+notice and this permission notice appear in supporting
+documentation, and that the name of Silicon Graphics not be 
+used in advertising or publicity pertaining to distribution 
+of the software without specific prior written permission.
+Silicon Graphics makes no representation about the suitability 
+of this software for any purpose. It is provided "as is"
+without any express or implied warranty.
+
+SILICON GRAPHICS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS 
+SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL SILICON
+GRAPHICS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
+DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, 
+DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE 
+OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION  WITH
+THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef _XKBSRV_H_
+#define	_XKBSRV_H_
+
+#define XkbAllocClientMap		SrvXkbAllocClientMap
+#define XkbAllocServerMap		SrvXkbAllocServerMap
+#define XkbChangeTypesOfKey		SrvXkbChangeTypesOfKey
+#define XkbCopyKeyTypes			SrvXkbCopyKeyTypes
+#define XkbFreeClientMap		SrvXkbFreeClientMap
+#define XkbFreeServerMap		SrvXkbFreeServerMap
+#define	XkbKeyTypesForCoreSymbols	SrvXkbKeyTypesForCoreSymbols
+#define	XkbApplyCompatMapToKey		SrvXkbApplyCompatMapToKey
+#define XkbResizeKeyActions		SrvXkbResizeKeyActions
+#define XkbResizeKeySyms		SrvXkbResizeKeySyms
+#define XkbResizeKeyType		SrvXkbResizeKeyType
+#define XkbAllocCompatMap		SrvXkbAllocCompatMap
+#define XkbAllocControls		SrvXkbAllocControls
+#define XkbAllocIndicatorMaps		SrvXkbAllocIndicatorMaps
+#define XkbAllocKeyboard		SrvXkbAllocKeyboard
+#define XkbAllocNames			SrvXkbAllocNames
+#define XkbFreeCompatMap		SrvXkbFreeCompatMap
+#define XkbFreeKeyboard			SrvXkbFreeKeyboard
+#define XkbFreeNames			SrvXkbFreeNames
+#define XkbLatchModifiers		SrvXkbLatchModifiers
+#define XkbLatchGroup			SrvXkbLatchGroup
+#define XkbVirtualModsToReal		SrvXkbVirtualModsToReal
+#define	XkbChangeKeycodeRange		SrvXkbChangeKeycodeRange
+#define	XkbApplyVirtualModChanges	SrvXkbApplyVirtualModChanges
+
+#include <X11/extensions/XKBproto.h>
+#include "xkbstr.h"
+#include "xkbrules.h"
+#include "inputstr.h"
+#include "events.h"
+
+typedef struct _XkbInterest {
+	DeviceIntPtr		dev;
+	ClientPtr		client;
+	XID			resource;
+	struct _XkbInterest *	next;
+	CARD16			extDevNotifyMask;
+	CARD16			stateNotifyMask;
+	CARD16			namesNotifyMask;
+	CARD32 			ctrlsNotifyMask;
+	CARD8			compatNotifyMask;
+	BOOL			bellNotifyMask;
+	BOOL			actionMessageMask;
+	CARD16			accessXNotifyMask;
+	CARD32			iStateNotifyMask;
+	CARD32			iMapNotifyMask;
+	CARD16			altSymsNotifyMask;
+	CARD32			autoCtrls;
+	CARD32			autoCtrlValues;
+} XkbInterestRec,*XkbInterestPtr;
+
+typedef struct _XkbRadioGroup {
+	CARD8		flags;
+	CARD8		nMembers;
+	CARD8		dfltDown;
+	CARD8		currentDown;
+	CARD8		members[XkbRGMaxMembers];
+} XkbRadioGroupRec, *XkbRadioGroupPtr;
+
+typedef struct	_XkbEventCause {
+	CARD8		kc;
+	CARD8		event;
+	CARD8		mjr;
+	CARD8		mnr;
+	ClientPtr	client;
+} XkbEventCauseRec,*XkbEventCausePtr;
+#define	XkbSetCauseKey(c,k,e)	{ (c)->kc= (k),(c)->event= (e),\
+				  (c)->mjr= (c)->mnr= 0; \
+				  (c)->client= NULL; }
+#define	XkbSetCauseReq(c,j,n,cl) { (c)->kc= (c)->event= 0,\
+				  (c)->mjr= (j),(c)->mnr= (n);\
+				  (c)->client= (cl); }
+#define	XkbSetCauseCoreReq(c,e,cl) XkbSetCauseReq(c,e,0,cl)
+#define	XkbSetCauseXkbReq(c,e,cl)  XkbSetCauseReq(c,XkbReqCode,e,cl)
+#define	XkbSetCauseUnknown(c)	   XkbSetCauseKey(c,0,0)
+
+#define	_OFF_TIMER		0
+#define	_KRG_WARN_TIMER		1
+#define	_KRG_TIMER		2
+#define	_SK_TIMEOUT_TIMER	3
+#define	_ALL_TIMEOUT_TIMER	4
+
+#define	_BEEP_NONE		0
+#define	_BEEP_FEATURE_ON	1
+#define	_BEEP_FEATURE_OFF	2
+#define	_BEEP_FEATURE_CHANGE	3
+#define	_BEEP_SLOW_WARN		4
+#define	_BEEP_SLOW_PRESS	5
+#define	_BEEP_SLOW_ACCEPT	6
+#define	_BEEP_SLOW_REJECT	7
+#define	_BEEP_SLOW_RELEASE	8
+#define	_BEEP_STICKY_LATCH	9
+#define	_BEEP_STICKY_LOCK	10
+#define	_BEEP_STICKY_UNLOCK	11
+#define	_BEEP_LED_ON		12
+#define	_BEEP_LED_OFF		13
+#define	_BEEP_LED_CHANGE	14
+#define	_BEEP_BOUNCE_REJECT	15
+
+typedef struct _XkbFilter {
+	CARD16			  keycode;
+	CARD8			  what;
+	CARD8			  active;
+	CARD8			  filterOthers;
+	CARD32			  priv;
+	XkbAction		  upAction;
+	int			(*filter)(
+					struct _XkbSrvInfo* 	/* xkbi */,
+					struct _XkbFilter *	/* filter */,
+					unsigned		/* keycode */,
+					XkbAction *		/* action */
+				  );
+	struct _XkbFilter	 *next;
+} XkbFilterRec,*XkbFilterPtr;
+
+typedef struct _XkbSrvInfo {
+	XkbStateRec	 prev_state;
+	XkbStateRec	 state;
+	XkbDescPtr	 desc;
+
+	DeviceIntPtr	 device;
+	KbdCtrlProcPtr	 kbdProc;
+
+	XkbRadioGroupPtr radioGroups;
+	CARD8		 nRadioGroups;
+	CARD8		 clearMods;
+	CARD8		 setMods;
+	INT16		 groupChange;
+
+	CARD16		 dfltPtrDelta;
+
+	double		 mouseKeysCurve;
+	double		 mouseKeysCurveFactor;
+	INT16		 mouseKeysDX;
+	INT16		 mouseKeysDY;
+	CARD8		 mouseKeysFlags;
+	Bool		 mouseKeysAccel;
+	CARD8		 mouseKeysCounter;
+
+	CARD8		 lockedPtrButtons;
+	CARD8		 shiftKeyCount;
+	KeyCode		 mouseKey;
+	KeyCode		 inactiveKey;
+	KeyCode		 slowKey;
+	KeyCode		 repeatKey;
+	CARD8		 krgTimerActive;
+	CARD8		 beepType;
+	CARD8		 beepCount;
+
+	CARD32		 flags;
+	CARD32		 lastPtrEventTime;
+	CARD32		 lastShiftEventTime;
+	OsTimerPtr	 beepTimer;
+	OsTimerPtr	 mouseKeyTimer;
+	OsTimerPtr	 slowKeysTimer;
+	OsTimerPtr	 bounceKeysTimer;
+	OsTimerPtr	 repeatKeyTimer;
+	OsTimerPtr	 krgTimer;
+
+	int		 szFilters;
+	XkbFilterPtr	 filters;
+} XkbSrvInfoRec, *XkbSrvInfoPtr;
+
+#define	XkbSLI_IsDefault	(1L<<0)
+#define	XkbSLI_HasOwnState	(1L<<1)
+
+typedef struct	_XkbSrvLedInfo {
+	CARD16			flags;
+	CARD16			class;
+	CARD16			id;
+	union {
+	    KbdFeedbackPtr	kf;
+	    LedFeedbackPtr	lf;
+	} 			fb;
+
+	CARD32			physIndicators;
+	CARD32			autoState;
+	CARD32			explicitState;
+	CARD32			effectiveState;
+
+	CARD32			mapsPresent;
+	CARD32			namesPresent;
+	XkbIndicatorMapPtr	maps;
+	Atom *			names;
+
+	CARD32			usesBase;
+	CARD32			usesLatched;
+	CARD32			usesLocked;
+	CARD32			usesEffective;
+	CARD32			usesCompat;
+	CARD32			usesControls;
+
+	CARD32			usedComponents;
+} XkbSrvLedInfoRec, *XkbSrvLedInfoPtr;
+
+/*
+ * Settings for xkbClientFlags field (used by DIX)
+ * These flags _must_ not overlap with XkbPCF_*
+ */
+#define	_XkbClientInitialized		(1<<15)
+
+#define	_XkbWantsDetectableAutoRepeat(c)\
+	((c)->xkbClientFlags&XkbPCF_DetectableAutoRepeatMask)
+
+/*
+ * Settings for flags field
+ */
+#define	_XkbStateNotifyInProgress	(1<<0)
+
+typedef struct
+{
+    ProcessInputProc processInputProc;
+    /* If processInputProc is set to something different than realInputProc,
+     * UNWRAP and COND_WRAP will not touch processInputProc and update only
+     * realInputProc.  This ensures that
+     *   processInputProc == (frozen ? EnqueueEvent : realInputProc)
+     *
+     * WRAP_PROCESS_INPUT_PROC should only be called during initialization,
+     * since it may destroy this invariant.
+     */
+    ProcessInputProc realInputProc;
+    DeviceUnwrapProc unwrapProc;
+} xkbDeviceInfoRec, *xkbDeviceInfoPtr;
+
+#define WRAP_PROCESS_INPUT_PROC(device, oldprocs, proc, unwrapproc) \
+	device->public.processInputProc = proc; \
+	oldprocs->processInputProc = \
+	oldprocs->realInputProc = device->public.realInputProc; \
+	device->public.realInputProc = proc; \
+	oldprocs->unwrapProc = device->unwrapProc; \
+	device->unwrapProc = unwrapproc;
+
+#define COND_WRAP_PROCESS_INPUT_PROC(device, oldprocs, proc, unwrapproc) \
+	if (device->public.processInputProc == device->public.realInputProc)\
+	    device->public.processInputProc = proc; \
+	oldprocs->processInputProc = \
+	oldprocs->realInputProc = device->public.realInputProc; \
+	device->public.realInputProc = proc; \
+	oldprocs->unwrapProc = device->unwrapProc; \
+	device->unwrapProc = unwrapproc;
+
+#define UNWRAP_PROCESS_INPUT_PROC(device, oldprocs, backupproc) \
+        backupproc = device->public.realInputProc; \
+	if (device->public.processInputProc == device->public.realInputProc)\
+	    device->public.processInputProc = oldprocs->realInputProc; \
+	device->public.realInputProc = oldprocs->realInputProc; \
+	device->unwrapProc = oldprocs->unwrapProc;
+
+extern _X_EXPORT DevPrivateKeyRec xkbDevicePrivateKeyRec;
+#define xkbDevicePrivateKey (&xkbDevicePrivateKeyRec)
+
+#define XKBDEVICEINFO(dev) ((xkbDeviceInfoPtr)dixLookupPrivate(&(dev)->devPrivates, xkbDevicePrivateKey))
+
+extern void xkbUnwrapProc(DeviceIntPtr, DeviceHandleProc, pointer);
+
+/***====================================================================***/
+
+
+/***====================================================================***/
+
+#define XkbAX_KRGMask	 (XkbSlowKeysMask|XkbBounceKeysMask)
+#define	XkbAllFilteredEventsMask \
+	(XkbAccessXKeysMask|XkbRepeatKeysMask|XkbMouseKeysAccelMask|XkbAX_KRGMask)
+
+/***====================================================================***/
+
+extern _X_EXPORT int	XkbReqCode;
+extern _X_EXPORT int	XkbEventBase;
+extern _X_EXPORT int	XkbKeyboardErrorCode;
+extern _X_EXPORT char *	XkbBaseDirectory;
+extern _X_EXPORT char *	XkbBinDirectory;
+
+extern _X_EXPORT CARD32	xkbDebugFlags;
+
+#define	_XkbLibError(c,l,d) /* Epoch fail */
+#define	_XkbErrCode2(a,b) ((XID)((((unsigned int)(a))<<24)|((b)&0xffffff)))
+#define	_XkbErrCode3(a,b,c)	_XkbErrCode2(a,(((unsigned int)(b))<<16)|(c))
+#define	_XkbErrCode4(a,b,c,d) _XkbErrCode3(a,b,((((unsigned int)(c))<<8)|(d)))
+
+extern	_X_EXPORT int	DeviceKeyPress,DeviceKeyRelease,DeviceMotionNotify;
+extern	_X_EXPORT int	DeviceButtonPress,DeviceButtonRelease;
+
+#define	Status		int
+
+extern _X_EXPORT void XkbUseMsg(
+    void
+);
+
+extern _X_EXPORT int XkbProcessArguments(
+    int				/* argc */,
+    char **			/* argv */,
+    int				/* i */
+);
+
+extern _X_EXPORT Bool   XkbInitPrivates(void);
+
+extern _X_EXPORT void	XkbSetExtension(DeviceIntPtr device, ProcessInputProc proc);
+
+extern _X_EXPORT void	XkbFreeCompatMap(
+    XkbDescPtr			/* xkb */,
+    unsigned int		/* which */,
+    Bool			/* freeMap */
+);
+
+extern _X_EXPORT void XkbFreeNames(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which */,
+	Bool			/* freeMap */
+);
+
+extern _X_EXPORT int _XkbLookupAnyDevice(
+    DeviceIntPtr *pDev,
+    int id,
+    ClientPtr client,
+    Mask access_mode,
+    int *xkb_err
+);
+
+extern _X_EXPORT int _XkbLookupKeyboard(
+    DeviceIntPtr *pDev,
+    int id,
+    ClientPtr client,
+    Mask access_mode,
+    int *xkb_err
+);
+
+extern _X_EXPORT int _XkbLookupBellDevice(
+    DeviceIntPtr *pDev,
+    int id,
+    ClientPtr client,
+    Mask access_mode,
+    int *xkb_err
+);
+
+extern _X_EXPORT int _XkbLookupLedDevice(
+    DeviceIntPtr *pDev,
+    int id,
+    ClientPtr client,
+    Mask access_mode,
+    int *xkb_err
+);
+
+extern _X_EXPORT int _XkbLookupButtonDevice(
+    DeviceIntPtr *pDev,
+    int id,
+    ClientPtr client,
+    Mask access_mode,
+    int *xkb_err
+);
+
+extern _X_EXPORT XkbDescPtr XkbAllocKeyboard(
+	void
+);
+
+extern _X_EXPORT Status XkbAllocClientMap(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which */,
+	unsigned int		/* nTypes */
+);
+
+extern _X_EXPORT Status XkbAllocServerMap(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which */,
+	unsigned int		/* nNewActions */
+);
+
+extern _X_EXPORT void	XkbFreeClientMap(
+    XkbDescPtr			/* xkb */,
+    unsigned int		/* what */,
+    Bool			/* freeMap */
+);
+
+extern _X_EXPORT void	XkbFreeServerMap(
+    XkbDescPtr			/* xkb */,
+    unsigned int		/* what */,
+    Bool			/* freeMap */
+);
+
+extern _X_EXPORT Status XkbAllocIndicatorMaps(
+	XkbDescPtr		/* xkb */
+);
+
+extern _X_EXPORT Status	XkbAllocCompatMap(
+    XkbDescPtr			/* xkb */,
+    unsigned int		/* which */,
+    unsigned int		/* nInterpret */
+);
+
+extern _X_EXPORT Status XkbAllocNames(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which */,
+	int			/* nTotalRG */,
+	int			/* nTotalAliases */
+);
+
+extern _X_EXPORT Status	XkbAllocControls(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which*/
+);
+
+extern _X_EXPORT Status	XkbCopyKeyTypes(
+    XkbKeyTypePtr		/* from */,
+    XkbKeyTypePtr		/* into */,
+    int				/* num_types */
+);
+
+extern _X_EXPORT Status	XkbResizeKeyType(
+    XkbDescPtr		/* xkb */,
+    int			/* type_ndx */,
+    int			/* map_count */,
+    Bool		/* want_preserve */,
+    int			/* new_num_lvls */
+);
+
+extern _X_EXPORT void	XkbFreeKeyboard(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* which */,
+	Bool			/* freeDesc */
+);
+
+extern _X_EXPORT  void XkbSetActionKeyMods(
+	XkbDescPtr		/* xkb */,
+	XkbAction *		/* act */,
+	unsigned int 		/* mods */
+);
+
+extern _X_EXPORT unsigned int XkbMaskForVMask(
+    XkbDescPtr		/* xkb */,
+    unsigned int	/* vmask */
+);
+
+extern _X_EXPORT Bool XkbVirtualModsToReal(
+	XkbDescPtr	/* xkb */,
+	unsigned int	/* virtua_mask */,
+	unsigned int *	/* mask_rtrn */
+);
+
+extern _X_EXPORT unsigned int	XkbAdjustGroup(
+    int			/* group */,
+    XkbControlsPtr	/* ctrls */
+);
+
+extern _X_EXPORT KeySym *XkbResizeKeySyms(
+    XkbDescPtr		/* xkb */,
+    int 		/* key */,
+    int 		/* needed */
+);
+
+extern _X_EXPORT XkbAction *XkbResizeKeyActions(
+    XkbDescPtr		/* xkb */,
+    int 		/* key */,
+    int 		/* needed */
+);
+
+extern _X_EXPORT void XkbUpdateKeyTypesFromCore(
+    DeviceIntPtr	/* pXDev */,
+    KeySymsPtr          /* syms */,
+    KeyCode 		/* first */,
+    CARD8 		/* num */,
+    XkbChangesPtr	/* pChanges */
+);
+
+extern _X_EXPORT void XkbUpdateDescActions(
+    XkbDescPtr		/* xkb */,
+    KeyCode		/* first */,
+    CARD8		/* num */,
+    XkbChangesPtr	/* changes */
+);
+
+extern _X_EXPORT void XkbUpdateActions(
+    DeviceIntPtr	/* pXDev */,
+    KeyCode 		/* first */,
+    CARD8 		/* num */,
+    XkbChangesPtr  	/* pChanges */,
+    unsigned int *	/* needChecksRtrn */,
+    XkbEventCausePtr	/* cause */
+);
+
+extern _X_EXPORT KeySymsPtr XkbGetCoreMap(
+    DeviceIntPtr        /* keybd */
+);
+
+extern _X_EXPORT void XkbApplyMappingChange(
+    DeviceIntPtr	/* pXDev */,
+    KeySymsPtr          /* map */,
+    KeyCode		/* firstKey */,
+    CARD8		/* num */,
+    CARD8 *             /* modmap */,
+    ClientPtr		/* client */
+);
+
+extern _X_EXPORT void XkbSetIndicators(
+    DeviceIntPtr		/* pXDev */,
+    CARD32			/* affect */,
+    CARD32			/* values */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbUpdateIndicators(
+    DeviceIntPtr		/* keybd */,
+    CARD32		 	/* changed */,
+    Bool			/* check_edevs */,
+    XkbChangesPtr		/* pChanges */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbAllocSrvLedInfo(
+    DeviceIntPtr		/* dev */,
+    KbdFeedbackPtr		/* kf */,
+    LedFeedbackPtr		/* lf */,
+    unsigned int		/* needed_parts */
+);
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbCopySrvLedInfo(
+    DeviceIntPtr		/* dev */,
+    XkbSrvLedInfoPtr		/* src */,
+    KbdFeedbackPtr		/* kf */,
+    LedFeedbackPtr		/* lf */
+);
+
+
+extern _X_EXPORT XkbSrvLedInfoPtr XkbFindSrvLedInfo(
+    DeviceIntPtr		/* dev */,
+    unsigned int		/* class */,
+    unsigned int		/* id */,
+    unsigned int		/* needed_parts */
+);
+
+extern _X_EXPORT void XkbApplyLedNameChanges(
+    DeviceIntPtr		/* dev */,
+    XkbSrvLedInfoPtr		/* sli */,
+    unsigned int		/* changed_names */,
+    xkbExtensionDeviceNotify *	/* ed */,
+    XkbChangesPtr		/* changes */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbApplyLedMapChanges(
+    DeviceIntPtr		/* dev */,
+    XkbSrvLedInfoPtr		/* sli */,
+    unsigned int		/* changed_maps */,
+    xkbExtensionDeviceNotify *	/* ed */,
+    XkbChangesPtr		/* changes */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbApplyLedStateChanges(
+    DeviceIntPtr		/* dev */,
+    XkbSrvLedInfoPtr		/* sli */,
+    unsigned int		/* changed_leds */,
+    xkbExtensionDeviceNotify *	/* ed */,
+    XkbChangesPtr		/* changes */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbFlushLedEvents(
+    DeviceIntPtr		/* dev */,
+    DeviceIntPtr		/* kbd */,
+    XkbSrvLedInfoPtr		/* sli */,
+    xkbExtensionDeviceNotify *	/* ed */,
+    XkbChangesPtr		/* changes */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT unsigned int XkbIndicatorsToUpdate(
+    DeviceIntPtr		/* dev */,
+    unsigned long		/* state_changes */,
+    Bool			/* enabled_ctrl_changes */
+);
+
+extern _X_EXPORT void XkbComputeDerivedState(
+    XkbSrvInfoPtr		/* xkbi */
+);
+
+extern _X_EXPORT void XkbCheckSecondaryEffects(
+    XkbSrvInfoPtr		/* xkbi */,
+    unsigned int		/* which */,
+    XkbChangesPtr		/* changes */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbCheckIndicatorMaps(
+    DeviceIntPtr		/* dev */,
+    XkbSrvLedInfoPtr		/* sli */,
+    unsigned int		/* which */
+);
+
+extern _X_EXPORT unsigned int XkbStateChangedFlags(
+    XkbStatePtr			/* old */,
+    XkbStatePtr			/* new */
+);
+
+extern _X_EXPORT void XkbSendStateNotify(
+       DeviceIntPtr	/* kbd */,
+       xkbStateNotify *	/* pSN */
+);
+
+extern _X_EXPORT void XkbSendMapNotify(
+       DeviceIntPtr	/* kbd */,
+       xkbMapNotify *	/* ev */
+);
+
+extern _X_EXPORT int  XkbComputeControlsNotify(
+	DeviceIntPtr		/* kbd */,
+	XkbControlsPtr		/* old */,
+	XkbControlsPtr		/* new */,
+	xkbControlsNotify *	/* pCN */,
+	Bool			/* forceCtrlProc */
+);
+
+extern _X_EXPORT void XkbSendControlsNotify(
+       DeviceIntPtr		/* kbd */,
+       xkbControlsNotify *	/* ev */
+);
+
+extern _X_EXPORT void XkbSendCompatMapNotify(
+	DeviceIntPtr		/* kbd */,
+	xkbCompatMapNotify *	/* ev */
+);
+
+extern _X_EXPORT void XkbHandleBell(
+       BOOL		/* force */,
+       BOOL		/* eventOnly */,
+       DeviceIntPtr	/* kbd */,
+       CARD8		/* percent */,
+       pointer 		/* ctrl */,
+       CARD8		/* class */,
+       Atom		/* name */,
+       WindowPtr	/* pWin */,
+       ClientPtr	/* pClient */
+);
+
+extern _X_EXPORT void XkbSendAccessXNotify(
+       DeviceIntPtr		/* kbd */,
+       xkbAccessXNotify *	/* pEv */
+);
+
+extern _X_EXPORT void XkbSendNamesNotify(
+       DeviceIntPtr	/* kbd */,
+       xkbNamesNotify *	/* ev */
+);
+
+extern _X_EXPORT void XkbSendActionMessage(
+       DeviceIntPtr		/* kbd */,
+       xkbActionMessage *	/* ev */
+);
+
+extern _X_EXPORT void XkbSendExtensionDeviceNotify(
+       DeviceIntPtr			/* kbd */,
+       ClientPtr			/* client */,
+       xkbExtensionDeviceNotify *	/* ev */
+);
+
+extern _X_EXPORT void XkbSendNotification(
+    DeviceIntPtr		/* kbd */,
+    XkbChangesPtr		/* pChanges */,
+    XkbEventCausePtr		/* cause */
+);
+
+extern _X_EXPORT void XkbProcessKeyboardEvent(
+    DeviceEvent*		/* event */,
+    DeviceIntPtr		/* keybd */
+);
+
+extern _X_EXPORT void XkbHandleActions(
+    DeviceIntPtr		/* dev */,
+    DeviceIntPtr		/* kbd */,
+    DeviceEvent*		/* event */
+);
+
+extern _X_EXPORT Bool XkbEnableDisableControls(
+    XkbSrvInfoPtr	/* xkbi */,
+    unsigned long	/* change */,
+    unsigned long	/* newValues */,
+    XkbChangesPtr	/* changes */,
+    XkbEventCausePtr	/* cause */
+);
+
+extern _X_EXPORT void AccessXInit(
+    DeviceIntPtr        /* dev */
+);
+
+extern _X_EXPORT Bool AccessXFilterPressEvent(
+    DeviceEvent*	/* event */,
+    DeviceIntPtr	/* keybd */
+);
+
+extern _X_EXPORT Bool AccessXFilterReleaseEvent(
+    DeviceEvent*	/* event */,
+    DeviceIntPtr	/* keybd */
+);
+
+extern _X_EXPORT void AccessXCancelRepeatKey(
+    XkbSrvInfoPtr	/* xkbi */,
+    KeyCode		/* key */
+);
+
+extern _X_EXPORT void AccessXComputeCurveFactor(
+    XkbSrvInfoPtr	/* xkbi */,
+    XkbControlsPtr	/* ctrls */
+);
+
+extern _X_EXPORT XkbInterestPtr XkbFindClientResource(
+       DevicePtr	/* inDev */,
+       ClientPtr	/* client */
+);
+
+extern _X_EXPORT XkbInterestPtr XkbAddClientResource(
+       DevicePtr	/* inDev */,
+       ClientPtr	/* client */,
+       XID		/* id */
+);
+
+extern _X_EXPORT int XkbRemoveResourceClient(
+       DevicePtr	/* inDev */,
+       XID		/* id */
+);
+
+extern _X_EXPORT int XkbDDXAccessXBeep(
+    DeviceIntPtr        /* dev */,
+    unsigned int	/* what */,
+    unsigned int	/* which */
+);
+
+extern _X_EXPORT int XkbDDXUsesSoftRepeat(
+    DeviceIntPtr	/* dev */
+);
+
+extern _X_EXPORT void XkbDDXKeybdCtrlProc(
+	DeviceIntPtr	/* dev */,
+	KeybdCtrl *	/* ctrl */
+);
+
+extern _X_EXPORT void XkbDDXChangeControls(
+	DeviceIntPtr	/* dev */,
+	XkbControlsPtr 	/* old */,
+	XkbControlsPtr 	/* new */
+);
+
+extern _X_EXPORT void XkbDDXUpdateDeviceIndicators(
+	DeviceIntPtr		/* dev */,
+	XkbSrvLedInfoPtr	/* sli */,
+	CARD32			/* newState */
+);
+
+extern _X_EXPORT int XkbDDXTerminateServer(
+	DeviceIntPtr	/* dev */,
+	KeyCode		/* key */,
+	XkbAction *	/* act */
+);
+
+extern _X_EXPORT int XkbDDXSwitchScreen(
+	DeviceIntPtr	/* dev */,
+	KeyCode		/* key */,
+	XkbAction *	/* act */
+);
+
+extern _X_EXPORT int XkbDDXPrivate(
+	DeviceIntPtr	/* dev */,
+	KeyCode		/* key */,
+	XkbAction *	/* act */
+);
+
+extern _X_EXPORT void XkbDisableComputedAutoRepeats(
+	DeviceIntPtr 	/* pXDev */,
+	unsigned int	/* key */
+);
+
+extern _X_EXPORT void XkbSetRepeatKeys(
+	DeviceIntPtr 	/* pXDev */,
+	int		/* key */,
+	int	 	/* onoff */
+);
+
+extern _X_EXPORT int XkbLatchModifiers(
+	DeviceIntPtr 	/* pXDev */,
+	CARD8 		/* mask */,
+	CARD8 		/* latches */
+);
+
+extern _X_EXPORT int XkbLatchGroup(
+	DeviceIntPtr  	/* pXDev */,
+	int	  	/* group */
+);
+
+extern _X_EXPORT void XkbClearAllLatchesAndLocks(
+	DeviceIntPtr		/* dev */,
+	XkbSrvInfoPtr		/* xkbi */,
+	Bool			/* genEv */,
+	XkbEventCausePtr	/* cause */
+);
+
+extern _X_EXPORT void	XkbGetRulesDflts(
+        XkbRMLVOSet *           /* rmlvo */
+);
+
+extern _X_EXPORT void   XkbFreeRMLVOSet(
+        XkbRMLVOSet *           /* rmlvo */,
+        Bool                    /* freeRMLVO */
+);
+
+extern _X_EXPORT void	XkbSetRulesDflts(
+        XkbRMLVOSet *           /* rmlvo */
+);
+
+extern _X_EXPORT void	XkbDeleteRulesDflts(
+	void
+);
+
+extern _X_EXPORT int SProcXkbDispatch(
+	ClientPtr		/* client */
+);
+
+extern _X_EXPORT XkbGeometryPtr XkbLookupNamedGeometry(
+	DeviceIntPtr		/* dev */,
+	Atom			/* name */,
+	Bool *			/* shouldFree */
+);
+
+extern _X_EXPORT char *	_XkbDupString(
+	const char *		/* str */
+);
+
+extern _X_EXPORT void	XkbConvertCase(
+	KeySym 			/* sym */,
+	KeySym *		/* lower */,
+	KeySym *		/* upper */
+);
+
+extern _X_EXPORT Status	 XkbChangeKeycodeRange(
+	XkbDescPtr		/* xkb */,
+	int 			/* minKC */,
+	int 			/* maxKC */,
+	XkbChangesPtr		/* changes */
+);
+
+extern _X_EXPORT void XkbFreeSrvLedInfo(
+	XkbSrvLedInfoPtr	/* sli */
+);
+
+extern _X_EXPORT void XkbFreeInfo(
+	XkbSrvInfoPtr		/* xkbi */
+);
+
+extern _X_EXPORT Status XkbChangeTypesOfKey(
+	XkbDescPtr		/* xkb */,
+	int			/* key */,
+	int			/* nGroups */,
+	unsigned int		/* groups */,
+	int *			/* newTypesIn */,
+	XkbMapChangesPtr	/* changes */
+);
+
+extern _X_EXPORT int XkbKeyTypesForCoreSymbols(
+	XkbDescPtr		/* xkb */,
+	int			/* map_width */,
+	KeySym *		/* core_syms */,
+	unsigned int		/* protected */,
+	int *			/* types_inout */,
+	KeySym *		/* xkb_syms_rtrn */
+);
+
+extern _X_EXPORT Bool XkbApplyCompatMapToKey(
+	XkbDescPtr		/* xkb */,
+	KeyCode			/* key */,
+	XkbChangesPtr		/* changes */
+);
+
+extern _X_EXPORT Bool XkbApplyVirtualModChanges(
+	XkbDescPtr		/* xkb */,
+	unsigned int		/* changed */,
+	XkbChangesPtr		/* changes */
+);
+
+extern _X_EXPORT void XkbSendNewKeyboardNotify(
+	DeviceIntPtr		/* kbd */,
+	xkbNewKeyboardNotify *	/* pNKN */
+);
+
+extern Bool XkbCopyKeymap(
+        XkbDescPtr              /* dst */,
+        XkbDescPtr              /* src */);
+
+extern _X_EXPORT Bool XkbCopyDeviceKeymap(
+        DeviceIntPtr            /* dst */,
+        DeviceIntPtr            /* src */);
+
+extern void XkbFilterEvents(
+        ClientPtr               /* pClient */,
+        int                     /* nEvents */,
+        xEvent*                 /* xE */);
+
+extern int XkbGetEffectiveGroup(
+        XkbSrvInfoPtr           /* xkbi */,
+        XkbStatePtr             /* xkbstate */,
+        CARD8                   /* keycode */);
+
+extern void XkbMergeLockedPtrBtns(
+        DeviceIntPtr            /* master */);
+
+extern void XkbFakeDeviceButton(
+        DeviceIntPtr            /* dev */,
+        int                     /* press */,
+        int                     /* button */);
+
+
+#include "xkbfile.h"
+#include "xkbrules.h"
+
+#define	_XkbListKeycodes	0
+#define	_XkbListTypes		1
+#define	_XkbListCompat		2
+#define	_XkbListSymbols		3
+#define	_XkbListGeometry	4
+#define	_XkbListNumComponents	5
+
+typedef struct _XkbSrvListInfo {
+	int		szPool;
+	int		nPool;
+	char *		pool;
+
+	int		maxRtrn;
+	int		nTotal;
+
+	char *		pattern[_XkbListNumComponents];
+	int		nFound[_XkbListNumComponents];
+} XkbSrvListInfoRec,*XkbSrvListInfoPtr;
+
+extern _X_EXPORT Status	XkbDDXList(
+	DeviceIntPtr		/* dev */,
+	XkbSrvListInfoPtr	/* listing */,
+	ClientPtr		/* client */
+);
+
+extern _X_EXPORT unsigned int XkbDDXLoadKeymapByNames(
+	DeviceIntPtr		/* keybd */,
+	XkbComponentNamesPtr	/* names */,
+	unsigned int		/* want */,
+	unsigned int		/* need */,
+	XkbDescPtr *		/* finfoRtrn */,
+	char *			/* keymapNameRtrn */,
+	int 			/* keymapNameRtrnLen */
+);
+
+extern _X_EXPORT Bool XkbDDXNamesFromRules(
+	DeviceIntPtr		/* keybd */,
+	char *			/* rules */,
+	XkbRF_VarDefsPtr	/* defs */,
+	XkbComponentNamesPtr	/* names */
+);
+
+extern _X_EXPORT XkbDescPtr XkbCompileKeymap(
+        DeviceIntPtr    /* dev */,
+        XkbRMLVOSet *   /* rmlvo */
+);
+
+#endif /* _XKBSRV_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shrotpackYX.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shrotpackYX.h
@@ -0,0 +1,160 @@
+/*
+ * Copyright © 2004 Philip Blundell
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Philip Blundell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Philip Blundell makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * PHILIP BLUNDELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL PHILIP BLUNDELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include    <X11/X.h>
+#include    "scrnintstr.h"
+#include    "windowstr.h"
+#include    "dixfontstr.h"
+#include    "mi.h"
+#include    "regionstr.h"
+#include    "globals.h"
+#include    "gcstruct.h"
+#include    "shadow.h"
+#include    "fb.h"
+
+#if ROTATE == 270
+
+#define WINSTEPX(stride)    (stride)
+#define WINSTART(x,y)       (((pScreen->height - 1) - y) + (x * winStride))
+#define WINSTEPY()	    -1
+
+#elif ROTATE == 90
+
+#define WINSTEPX(stride)    (-stride)
+#define WINSTEPY()	    1
+#define WINSTART(x,y)       (((pScreen->width - 1 - x) * winStride) + y)
+
+#else
+
+#error This rotation is not supported here
+
+#endif
+
+#ifdef __arm__
+#define PREFETCH
+#endif
+
+void
+FUNC (ScreenPtr	    pScreen,
+      shadowBufPtr  pBuf);
+
+void
+FUNC (ScreenPtr	    pScreen,
+      shadowBufPtr  pBuf)
+{
+    RegionPtr	damage = shadowDamage(pBuf);
+    PixmapPtr	pShadow = pBuf->pPixmap;
+    int		nbox = RegionNumRects (damage);
+    BoxPtr	pbox = RegionRects (damage);
+    FbBits	*shaBits;
+    Data	*shaBase, *shaLine, *sha;
+    FbStride	shaStride, winStride;
+    int		shaBpp;
+    int		shaXoff, shaYoff;   /* XXX assumed to be zero */
+    int		x, y, w, h;
+    Data	*winBase, *win, *winLine;
+    CARD32	winSize;
+
+    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
+    shaBase = (Data *) shaBits;
+    shaStride = shaStride * sizeof (FbBits) / sizeof (Data);
+
+    winBase = (Data *) (*pBuf->window) (pScreen, 0, 0,
+					SHADOW_WINDOW_WRITE,
+					&winSize, pBuf->closure);
+    winStride = (Data *) (*pBuf->window) (pScreen, 1, 0,
+					  SHADOW_WINDOW_WRITE,
+					  &winSize, pBuf->closure) - winBase;
+
+    while (nbox--)
+    {
+        x = pbox->x1;
+        y = pbox->y1;
+        w = (pbox->x2 - pbox->x1);
+        h = pbox->y2 - pbox->y1;
+
+	shaLine = shaBase + (y * shaStride) + x;
+#ifdef PREFETCH
+	__builtin_prefetch (shaLine);
+#endif
+	winLine = winBase + WINSTART(x, y);
+
+        while (h--)
+        {
+	    sha = shaLine;
+	    win = winLine;
+
+            while (sha < (shaLine + w - 16))
+            {
+#ifdef PREFETCH
+		__builtin_prefetch (sha + shaStride);
+#endif
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+            }
+
+            while (sha < (shaLine + w))
+            {
+		*win = *sha++;
+		win += WINSTEPX(winStride);
+            }
+
+	    y++;
+	    shaLine += shaStride;
+	    winLine += WINSTEPY();
+        }
+        pbox++;
+    } /*  nbox */
+}
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sleepuntil.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sleepuntil.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2001 The XFree86 Project, Inc.  All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to
+ * deal in the Software without restriction, including without limitation the
+ * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
+ * sell copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+ * XFREE86 PROJECT BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the XFree86 Project shall
+ * not be used in advertising or otherwise to promote the sale, use or other
+ * dealings in this Software without prior written authorization from the
+ * XFree86 Project.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _SLEEPUNTIL_H_
+#define _SLEEPUNTIL_H_ 1
+
+#include "dix.h"
+
+extern int ClientSleepUntil(
+    ClientPtr client,
+    TimeStamp *revive,
+    void (*notifyFunc)(
+	ClientPtr /* client */,
+	pointer   /* closure */
+	),
+    pointer Closure
+);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dpmsproc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dpmsproc.h
@@ -0,0 +1,15 @@
+/* Prototypes for functions that the DDX must provide */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DPMSPROC_H_
+#define _DPMSPROC_H_
+
+#include "dixstruct.h"
+
+int  DPMSSet(ClientPtr client, int level);
+Bool DPMSSupported(void);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Sbus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Sbus.h
@@ -0,0 +1,69 @@
+/*
+ * Platform specific SBUS and OpenPROM access declarations.
+ *
+ * Copyright (C) 2000 Jakub Jelinek (jakub@redhat.com)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * JAKUB JELINEK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_SBUS_H
+#define _XF86_SBUS_H
+
+#if defined(linux)
+#include <asm/types.h>
+#include <linux/fb.h>
+#include <asm/fbio.h>
+#include <asm/openpromio.h>
+#elif defined(SVR4)
+#include <sys/fbio.h>
+#include <sys/openpromio.h>
+#elif defined(__OpenBSD__) && defined(__sparc64__)
+/* XXX */
+#elif defined(CSRG_BASED)
+#if defined(__FreeBSD__)
+#include <sys/types.h>
+#include <sys/fbio.h>
+#include <dev/ofw/openpromio.h>
+#else
+#include <machine/fbio.h>
+#endif
+#else
+#include <sun/fbio.h>
+#endif
+
+#ifndef FBTYPE_SUNGP3
+#define FBTYPE_SUNGP3 -1
+#endif
+#ifndef FBTYPE_MDICOLOR
+#define FBTYPE_MDICOLOR -1
+#endif
+#ifndef FBTYPE_SUNLEO
+#define FBTYPE_SUNLEO -1
+#endif
+#ifndef FBTYPE_TCXCOLOR
+#define FBTYPE_TCXCOLOR -1
+#endif
+#ifndef FBTYPE_CREATOR
+#define FBTYPE_CREATOR -1
+#endif
+
+#endif /* _XF86_SBUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/int10Defines.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/int10Defines.h
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2000-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _INT10DEFINES_H_
+#define _INT10DEFINES_H_ 1
+
+#ifdef _VM86_LINUX
+
+#include <asm/vm86.h>
+
+#define CPU_R(type,name,num) \
+	(((type *)&(((struct vm86_struct *)REG->cpuRegs)->regs.name))[num])
+#define CPU_RD(name,num) CPU_R(CARD32,name,num)
+#define CPU_RW(name,num) CPU_R(CARD16,name,num)
+#define CPU_RB(name,num) CPU_R(CARD8,name,num)
+
+#define X86_EAX CPU_RD(eax,0)
+#define X86_EBX CPU_RD(ebx,0)
+#define X86_ECX CPU_RD(ecx,0)
+#define X86_EDX CPU_RD(edx,0)
+#define X86_ESI CPU_RD(esi,0)
+#define X86_EDI CPU_RD(edi,0)
+#define X86_EBP CPU_RD(ebp,0)
+#define X86_EIP CPU_RD(eip,0)
+#define X86_ESP CPU_RD(esp,0)
+#define X86_EFLAGS CPU_RD(eflags,0)
+
+#define X86_FLAGS CPU_RW(eflags,0)
+#define X86_AX CPU_RW(eax,0)
+#define X86_BX CPU_RW(ebx,0)
+#define X86_CX CPU_RW(ecx,0)
+#define X86_DX CPU_RW(edx,0)
+#define X86_SI CPU_RW(esi,0)
+#define X86_DI CPU_RW(edi,0)
+#define X86_BP CPU_RW(ebp,0)
+#define X86_IP CPU_RW(eip,0)
+#define X86_SP CPU_RW(esp,0)
+#define X86_CS CPU_RW(cs,0)
+#define X86_DS CPU_RW(ds,0)
+#define X86_ES CPU_RW(es,0)
+#define X86_SS CPU_RW(ss,0)
+#define X86_FS CPU_RW(fs,0)
+#define X86_GS CPU_RW(gs,0)
+
+#define X86_AL CPU_RB(eax,0)
+#define X86_BL CPU_RB(ebx,0)
+#define X86_CL CPU_RB(ecx,0)
+#define X86_DL CPU_RB(edx,0)
+
+#define X86_AH CPU_RB(eax,1)
+#define X86_BH CPU_RB(ebx,1)
+#define X86_CH CPU_RB(ecx,1)
+#define X86_DH CPU_RB(edx,1)
+
+#elif defined(_X86EMU)
+
+#include "xf86x86emu.h"
+
+#endif
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_size_get.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_size_get.h
@@ -0,0 +1,102 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_SIZE_GET_H_ )
+#  define _INDIRECT_SIZE_GET_H_
+
+/**
+ * \file
+ * Prototypes for functions used to determine the number of data elements in
+ * various GLX protocol messages.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
+
+#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#    define FASTCALL __attribute__((fastcall))
+#  else
+#    define FASTCALL
+#  endif
+
+#  if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))) && defined(__ELF__)
+#    define INTERNAL  __attribute__((visibility("internal")))
+#  else
+#    define INTERNAL
+#  endif
+
+extern INTERNAL PURE FASTCALL GLint __glGetBooleanv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetDoublev_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetFloatv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetIntegerv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetLightfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetLightiv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetMaterialfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetMaterialiv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexEnvfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexEnviv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexGendv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexGenfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexGeniv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexLevelParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetTexLevelParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetColorTableParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetColorTableParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint
+__glGetConvolutionParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint
+__glGetConvolutionParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetHistogramParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetHistogramParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetMinmaxParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetMinmaxParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetProgramivARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribdvARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribfvARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribivARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetQueryObjectivARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetQueryObjectuivARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetQueryivARB_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetProgramivNV_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribdvNV_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribfvNV_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glGetVertexAttribivNV_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint
+__glGetFramebufferAttachmentParameterivEXT_size(GLenum);
+
+#  undef PURE
+#  undef FASTCALL
+#  undef INTERNAL
+
+#endif /* !defined( _INDIRECT_SIZE_GET_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisetclientpointer.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisetclientpointer.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETCPTR_H
+#define SETCPTR_H 1
+
+int SProcXISetClientPointer(ClientPtr /* client */);
+int ProcXISetClientPointer(ClientPtr /* client */);
+
+#endif /* SETCPTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-keyboard.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/lnx-keyboard.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright 2001 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to Linux keyboard driver.  \see lnx-keyboard.c */
+
+#ifndef _LNX_KEYBOARD_H_
+#define _LNX_KEYBOARD_H_
+
+extern pointer kbdLinuxCreatePrivate(DeviceIntPtr pKeyboard);
+extern void    kbdLinuxDestroyPrivate(pointer private);
+
+extern void    kbdLinuxInit(DevicePtr pDev);
+extern void    kbdLinuxGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern int     kbdLinuxOn(DevicePtr pDev);
+extern void    kbdLinuxOff(DevicePtr pDev);
+
+extern void    kbdLinuxVTPreSwitch(pointer p);
+extern void    kbdLinuxVTPostSwitch(pointer p);
+extern int     kbdLinuxVTSwitch(pointer p, int vt,
+                                dmxVTSwitchReturnProcPtr switch_return,
+                                pointer switch_return_data);
+
+extern void    kbdLinuxRead(DevicePtr pDev,
+                            dmxMotionProcPtr motion,
+                            dmxEnqueueProcPtr enqueue,
+                            dmxCheckSpecialProcPtr checkspecial,
+                            DMXBlockType block);
+
+extern void    kbdLinuxCtrl(DevicePtr pDev, KeybdCtrl *ctrl);
+extern void    kbdLinuxBell(DevicePtr pDev, int percent,
+                            int volume, int pitch, int duration);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxvisuals.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxvisuals.h
@@ -0,0 +1,50 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLX_VISUALS_H
+#define _GLX_VISUALS_H
+
+int glxVisualsMatch( __GLXvisualConfig *v1, __GLXvisualConfig *v2 );
+
+VisualID glxMatchGLXVisualInConfigList( __GLXvisualConfig *pGlxVisual, __GLXvisualConfig *configs, int nconfigs );
+
+VisualID glxMatchVisualInConfigList( ScreenPtr pScreen, VisualPtr pVisual, __GLXvisualConfig *configs, int nconfigs );
+
+VisualPtr glxMatchVisual( ScreenPtr pScreen, VisualPtr pVisual, ScreenPtr pMatchScreen );
+
+void glxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
+                 void **privates);
+
+Bool glxInitVisuals(int *nvisualp, VisualPtr *visualp,
+			 VisualID *defaultVisp,
+			 int ndepth, DepthPtr pdepth,
+			 int rootDepth);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86VGAarbiter.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86VGAarbiter.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2009 Tiago Vignatti
+ *
+ * Permission is hereby granted, free of charge, to any person
+ * obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without
+ * restriction, including without limitation the rights to use,
+ * copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following
+ * conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef __XF86VGAARBITER_H
+#define __XF86VGAARBITER_H
+
+#include "screenint.h"
+#include "misc.h"
+#include "xf86.h"
+
+/* Functions */
+extern void xf86VGAarbiterInit(void);
+extern void xf86VGAarbiterFini(void);
+void xf86VGAarbiterScrnInit(ScrnInfoPtr pScrn);
+extern Bool xf86VGAarbiterWrapFunctions(void);
+extern void xf86VGAarbiterLock(ScrnInfoPtr pScrn);
+extern void xf86VGAarbiterUnlock(ScrnInfoPtr pScrn);
+
+/* allow a driver to remove itself from arbiter - really should be
+ * done in the kernel though */
+extern _X_EXPORT void xf86VGAarbiterDeviceDecodes(ScrnInfoPtr pScrn);
+/* DRI and arbiter are really not possible together,
+ * you really want to remove the card from arbitration if you can */
+extern _X_EXPORT Bool xf86VGAarbiterAllowDRI(ScreenPtr pScreen);
+
+#endif /* __XF86VGAARBITER_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86PciInfo.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86PciInfo.h
@@ -0,0 +1,731 @@
+
+/*
+ * Copyright (c) 1995-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains macros for the PCI Vendor and Device IDs for video
+ * cards plus a few other things that are needed in drivers or elsewhere.
+ * This information is used in several ways:
+ *   1. It is used by drivers and/or other code.
+ *   2. It is used by the pciid2c.pl script to determine what vendor data to
+ *      include in the pcidata module that the X server loads.
+ *   3. A side-effect of 2. affects how config-generation works for
+ *      otherwise "unknown" cards.
+ *
+ * Don't add entries here for vendors that don't make video cards,
+ * or for non-video devices unless they're needed by a driver or elsewhere.
+ * A comprehensive set of PCI vendor, device and subsystem data is
+ * auto-generated from the ../etc/pci.ids file using the pciids2c.pl script,
+ * and is used in scanpci utility.  Don't modify the pci.ids file.  If 
+ * new/corrected entries are required, add them to ../etc/extrapci.ids.
+ */
+
+#ifndef _XF86_PCIINFO_H
+#define _XF86_PCIINFO_H
+
+/* PCI Pseudo Vendor */
+#define PCI_VENDOR_GENERIC		0x00FF
+
+#define PCI_VENDOR_REAL3D		0x003D
+#define PCI_VENDOR_COMPAQ		0x0E11
+#define PCI_VENDOR_ATI			0x1002
+#define PCI_VENDOR_AVANCE		0x1005
+#define PCI_VENDOR_TSENG		0x100C
+#define PCI_VENDOR_NS			0x100B
+#define PCI_VENDOR_WEITEK		0x100E
+#define PCI_VENDOR_VIDEOLOGIC		0x1010
+#define PCI_VENDOR_DIGITAL		0x1011
+#define PCI_VENDOR_CIRRUS		0x1013
+#define PCI_VENDOR_AMD			0x1022
+#define PCI_VENDOR_TRIDENT		0x1023
+#define PCI_VENDOR_ALI			0x1025
+#define PCI_VENDOR_DELL			0x1028
+#define PCI_VENDOR_MATROX		0x102B
+#define PCI_VENDOR_CHIPSTECH		0x102C
+#define PCI_VENDOR_MIRO			0x1031
+#define PCI_VENDOR_NEC			0x1033
+#define PCI_VENDOR_SIS			0x1039
+#define PCI_VENDOR_HP			0x103C
+#define PCI_VENDOR_SGS			0x104A
+#define PCI_VENDOR_TI			0x104C
+#define PCI_VENDOR_SONY			0x104D
+#define PCI_VENDOR_OAK			0x104E
+#define PCI_VENDOR_MOTOROLA		0x1057
+#define PCI_VENDOR_NUMNINE		0x105D
+#define PCI_VENDOR_CYRIX		0x1078
+#define PCI_VENDOR_SUN			0x108E
+#define PCI_VENDOR_DIAMOND		0x1092
+#define PCI_VENDOR_BROOKTREE		0x109E
+#define PCI_VENDOR_NEOMAGIC		0x10C8
+#define PCI_VENDOR_NVIDIA		0x10DE
+#define PCI_VENDOR_IMS			0x10E0
+#define PCI_VENDOR_INTEGRAPHICS 	0x10EA
+#define PCI_VENDOR_ALLIANCE		0x1142
+#define PCI_VENDOR_RENDITION		0x1163
+#define PCI_VENDOR_3DFX			0x121A
+#define PCI_VENDOR_SMI			0x126F
+#define PCI_VENDOR_TRITECH		0x1292
+#define PCI_VENDOR_NVIDIA_SGS		0x12D2
+#define PCI_VENDOR_VMWARE		0x15AD
+#define PCI_VENDOR_AST			0x1A03
+#define PCI_VENDOR_3DLABS		0x3D3D
+#define PCI_VENDOR_AVANCE_2		0x4005
+#define PCI_VENDOR_HERCULES		0x4843
+#define PCI_VENDOR_S3			0x5333
+#define PCI_VENDOR_INTEL		0x8086
+#define PCI_VENDOR_ARK			0xEDD8
+
+
+/* Generic */
+#define PCI_CHIP_VGA			0x0000
+#define PCI_CHIP_8514			0x0001
+
+/* Real 3D */
+#define PCI_CHIP_I740_PCI		0x00D1
+
+/* Compaq */
+#define PCI_CHIP_QV1280			0x3033
+
+/* ATI */
+#define PCI_CHIP_RV380_3150             0x3150
+#define PCI_CHIP_RV380_3151             0x3151
+#define PCI_CHIP_RV380_3152             0x3152
+#define PCI_CHIP_RV380_3153             0x3153
+#define PCI_CHIP_RV380_3154             0x3154
+#define PCI_CHIP_RV380_3156             0x3156
+#define PCI_CHIP_RV380_3E50             0x3E50
+#define PCI_CHIP_RV380_3E51             0x3E51
+#define PCI_CHIP_RV380_3E52             0x3E52
+#define PCI_CHIP_RV380_3E53             0x3E53
+#define PCI_CHIP_RV380_3E54             0x3E54
+#define PCI_CHIP_RV380_3E56             0x3E56
+#define PCI_CHIP_RS100_4136		0x4136
+#define PCI_CHIP_RS200_4137		0x4137
+#define PCI_CHIP_R300_AD		0x4144
+#define PCI_CHIP_R300_AE		0x4145
+#define PCI_CHIP_R300_AF		0x4146
+#define PCI_CHIP_R300_AG		0x4147
+#define PCI_CHIP_R350_AH                0x4148
+#define PCI_CHIP_R350_AI                0x4149
+#define PCI_CHIP_R350_AJ                0x414A
+#define PCI_CHIP_R350_AK                0x414B
+#define PCI_CHIP_RV350_AP               0x4150
+#define PCI_CHIP_RV350_AQ               0x4151
+#define PCI_CHIP_RV360_AR               0x4152
+#define PCI_CHIP_RV350_AS               0x4153
+#define PCI_CHIP_RV350_AT               0x4154
+#define PCI_CHIP_RV350_4155             0x4155
+#define PCI_CHIP_RV350_AV               0x4156
+#define PCI_CHIP_MACH32			0x4158
+#define PCI_CHIP_RS250_4237		0x4237
+#define PCI_CHIP_R200_BB		0x4242
+#define PCI_CHIP_R200_BC		0x4243
+#define PCI_CHIP_RS100_4336		0x4336
+#define PCI_CHIP_RS200_4337		0x4337
+#define PCI_CHIP_MACH64CT		0x4354
+#define PCI_CHIP_MACH64CX		0x4358
+#define PCI_CHIP_RS250_4437		0x4437
+#define PCI_CHIP_MACH64ET		0x4554
+#define PCI_CHIP_MACH64GB		0x4742
+#define PCI_CHIP_MACH64GD		0x4744
+#define PCI_CHIP_MACH64GI		0x4749
+#define PCI_CHIP_MACH64GL		0x474C
+#define PCI_CHIP_MACH64GM		0x474D
+#define PCI_CHIP_MACH64GN		0x474E
+#define PCI_CHIP_MACH64GO		0x474F
+#define PCI_CHIP_MACH64GP		0x4750
+#define PCI_CHIP_MACH64GQ		0x4751
+#define PCI_CHIP_MACH64GR		0x4752
+#define PCI_CHIP_MACH64GS		0x4753
+#define PCI_CHIP_MACH64GT		0x4754
+#define PCI_CHIP_MACH64GU		0x4755
+#define PCI_CHIP_MACH64GV		0x4756
+#define PCI_CHIP_MACH64GW		0x4757
+#define PCI_CHIP_MACH64GX		0x4758
+#define PCI_CHIP_MACH64GY		0x4759
+#define PCI_CHIP_MACH64GZ		0x475A
+#define PCI_CHIP_RV250_Id		0x4964
+#define PCI_CHIP_RV250_Ie		0x4965
+#define PCI_CHIP_RV250_If		0x4966
+#define PCI_CHIP_RV250_Ig		0x4967
+#define PCI_CHIP_R420_JH                0x4A48
+#define PCI_CHIP_R420_JI                0x4A49
+#define PCI_CHIP_R420_JJ                0x4A4A
+#define PCI_CHIP_R420_JK                0x4A4B
+#define PCI_CHIP_R420_JL                0x4A4C
+#define PCI_CHIP_R420_JM                0x4A4D
+#define PCI_CHIP_R420_JN                0x4A4E
+#define PCI_CHIP_R420_4A4F              0x4A4F
+#define PCI_CHIP_R420_JP                0x4A50
+#define PCI_CHIP_R420_4A54              0x4A54
+#define PCI_CHIP_R481_4B49              0x4B49
+#define PCI_CHIP_R481_4B4A              0x4B4A
+#define PCI_CHIP_R481_4B4B              0x4B4B
+#define PCI_CHIP_R481_4B4C              0x4B4C
+#define PCI_CHIP_MACH64LB		0x4C42
+#define PCI_CHIP_MACH64LD		0x4C44
+#define PCI_CHIP_RAGE128LE		0x4C45
+#define PCI_CHIP_RAGE128LF		0x4C46
+#define PCI_CHIP_MACH64LG		0x4C47
+#define PCI_CHIP_MACH64LI		0x4C49
+#define PCI_CHIP_MACH64LM		0x4C4D
+#define PCI_CHIP_MACH64LN		0x4C4E
+#define PCI_CHIP_MACH64LP		0x4C50
+#define PCI_CHIP_MACH64LQ		0x4C51
+#define PCI_CHIP_MACH64LR		0x4C52
+#define PCI_CHIP_MACH64LS		0x4C53
+#define PCI_CHIP_RADEON_LW		0x4C57
+#define PCI_CHIP_RADEON_LX		0x4C58
+#define PCI_CHIP_RADEON_LY		0x4C59
+#define PCI_CHIP_RADEON_LZ		0x4C5A
+#define PCI_CHIP_RV250_Ld		0x4C64
+#define PCI_CHIP_RV250_Le		0x4C65
+#define PCI_CHIP_RV250_Lf		0x4C66
+#define PCI_CHIP_RV250_Lg		0x4C67
+#define PCI_CHIP_RV250_Ln		0x4C6E
+#define PCI_CHIP_RAGE128MF		0x4D46
+#define PCI_CHIP_RAGE128ML		0x4D4C
+#define PCI_CHIP_R300_ND		0x4E44
+#define PCI_CHIP_R300_NE		0x4E45
+#define PCI_CHIP_R300_NF		0x4E46
+#define PCI_CHIP_R300_NG		0x4E47
+#define PCI_CHIP_R350_NH                0x4E48  
+#define PCI_CHIP_R350_NI                0x4E49  
+#define PCI_CHIP_R360_NJ                0x4E4A  
+#define PCI_CHIP_R350_NK                0x4E4B  
+#define PCI_CHIP_RV350_NP               0x4E50
+#define PCI_CHIP_RV350_NQ               0x4E51
+#define PCI_CHIP_RV350_NR               0x4E52
+#define PCI_CHIP_RV350_NS               0x4E53
+#define PCI_CHIP_RV350_NT               0x4E54
+#define PCI_CHIP_RV350_NV               0x4E56
+#define PCI_CHIP_RAGE128PA		0x5041
+#define PCI_CHIP_RAGE128PB		0x5042
+#define PCI_CHIP_RAGE128PC		0x5043
+#define PCI_CHIP_RAGE128PD		0x5044
+#define PCI_CHIP_RAGE128PE		0x5045
+#define PCI_CHIP_RAGE128PF		0x5046
+#define PCI_CHIP_RAGE128PG		0x5047
+#define PCI_CHIP_RAGE128PH		0x5048
+#define PCI_CHIP_RAGE128PI		0x5049
+#define PCI_CHIP_RAGE128PJ		0x504A
+#define PCI_CHIP_RAGE128PK		0x504B
+#define PCI_CHIP_RAGE128PL		0x504C
+#define PCI_CHIP_RAGE128PM		0x504D
+#define PCI_CHIP_RAGE128PN		0x504E
+#define PCI_CHIP_RAGE128PO		0x504F
+#define PCI_CHIP_RAGE128PP		0x5050
+#define PCI_CHIP_RAGE128PQ		0x5051
+#define PCI_CHIP_RAGE128PR		0x5052
+#define PCI_CHIP_RAGE128PS		0x5053
+#define PCI_CHIP_RAGE128PT		0x5054
+#define PCI_CHIP_RAGE128PU		0x5055
+#define PCI_CHIP_RAGE128PV		0x5056
+#define PCI_CHIP_RAGE128PW		0x5057
+#define PCI_CHIP_RAGE128PX		0x5058
+#define PCI_CHIP_RADEON_QD		0x5144
+#define PCI_CHIP_RADEON_QE		0x5145
+#define PCI_CHIP_RADEON_QF		0x5146
+#define PCI_CHIP_RADEON_QG		0x5147
+#define PCI_CHIP_R200_QH		0x5148
+#define PCI_CHIP_R200_QI		0x5149
+#define PCI_CHIP_R200_QJ		0x514A
+#define PCI_CHIP_R200_QK		0x514B
+#define PCI_CHIP_R200_QL		0x514C
+#define PCI_CHIP_R200_QM		0x514D
+#define PCI_CHIP_R200_QN		0x514E
+#define PCI_CHIP_R200_QO		0x514F
+#define PCI_CHIP_RV200_QW		0x5157
+#define PCI_CHIP_RV200_QX		0x5158
+#define PCI_CHIP_RV100_QY		0x5159
+#define PCI_CHIP_RV100_QZ		0x515A
+#define PCI_CHIP_RN50_515E		0x515E
+#define PCI_CHIP_RAGE128RE		0x5245
+#define PCI_CHIP_RAGE128RF		0x5246
+#define PCI_CHIP_RAGE128RG		0x5247
+#define PCI_CHIP_RAGE128RK		0x524B
+#define PCI_CHIP_RAGE128RL		0x524C
+#define PCI_CHIP_RAGE128SE		0x5345
+#define PCI_CHIP_RAGE128SF		0x5346
+#define PCI_CHIP_RAGE128SG		0x5347
+#define PCI_CHIP_RAGE128SH		0x5348
+#define PCI_CHIP_RAGE128SK		0x534B
+#define PCI_CHIP_RAGE128SL		0x534C
+#define PCI_CHIP_RAGE128SM		0x534D
+#define PCI_CHIP_RAGE128SN		0x534E
+#define PCI_CHIP_RAGE128TF		0x5446
+#define PCI_CHIP_RAGE128TL		0x544C
+#define PCI_CHIP_RAGE128TR		0x5452
+#define PCI_CHIP_RAGE128TS		0x5453
+#define PCI_CHIP_RAGE128TT		0x5454
+#define PCI_CHIP_RAGE128TU		0x5455
+#define PCI_CHIP_RV370_5460             0x5460
+#define PCI_CHIP_RV370_5461             0x5461
+#define PCI_CHIP_RV370_5462             0x5462
+#define PCI_CHIP_RV370_5463             0x5463
+#define PCI_CHIP_RV370_5464             0x5464
+#define PCI_CHIP_RV370_5465             0x5465
+#define PCI_CHIP_RV370_5466             0x5466
+#define PCI_CHIP_RV370_5467             0x5467
+#define PCI_CHIP_R423_UH                0x5548
+#define PCI_CHIP_R423_UI                0x5549
+#define PCI_CHIP_R423_UJ                0x554A
+#define PCI_CHIP_R423_UK                0x554B
+#define PCI_CHIP_R430_554C              0x554C
+#define PCI_CHIP_R430_554D              0x554D
+#define PCI_CHIP_R430_554E              0x554E
+#define PCI_CHIP_R430_554F              0x554F
+#define PCI_CHIP_R423_5550              0x5550
+#define PCI_CHIP_R423_UQ                0x5551
+#define PCI_CHIP_R423_UR                0x5552
+#define PCI_CHIP_R423_UT                0x5554
+#define PCI_CHIP_RV410_564A             0x564A
+#define PCI_CHIP_RV410_564B             0x564B
+#define PCI_CHIP_RV410_564F             0x564F
+#define PCI_CHIP_RV410_5652             0x5652
+#define PCI_CHIP_RV410_5653             0x5653
+#define PCI_CHIP_MACH64VT		0x5654
+#define PCI_CHIP_MACH64VU		0x5655
+#define PCI_CHIP_MACH64VV		0x5656
+#define PCI_CHIP_RS300_5834		0x5834
+#define PCI_CHIP_RS300_5835		0x5835
+#define PCI_CHIP_RS300_5836		0x5836
+#define PCI_CHIP_RS300_5837		0x5837
+#define PCI_CHIP_RS480_5954             0x5954
+#define PCI_CHIP_RS480_5955             0x5955
+#define PCI_CHIP_RV280_5960		0x5960
+#define PCI_CHIP_RV280_5961		0x5961
+#define PCI_CHIP_RV280_5962		0x5962
+#define PCI_CHIP_RV280_5964		0x5964
+#define PCI_CHIP_RV280_5965 		0x5965
+#define PCI_CHIP_RN50_5969		0x5969
+#define PCI_CHIP_RS482_5974             0x5974
+#define PCI_CHIP_RS482_5975             0x5975
+#define PCI_CHIP_RS400_5A41             0x5A41
+#define PCI_CHIP_RS400_5A42             0x5A42
+#define PCI_CHIP_RC410_5A61             0x5A61
+#define PCI_CHIP_RC410_5A62             0x5A62
+#define PCI_CHIP_RV370_5B60             0x5B60
+#define PCI_CHIP_RV370_5B61             0x5B61
+#define PCI_CHIP_RV370_5B62             0x5B62
+#define PCI_CHIP_RV370_5B63             0x5B63
+#define PCI_CHIP_RV370_5B64             0x5B64
+#define PCI_CHIP_RV370_5B65             0x5B65
+#define PCI_CHIP_RV370_5B66             0x5B66
+#define PCI_CHIP_RV370_5B67             0x5B67
+#define PCI_CHIP_RV280_5C61		0x5C61
+#define PCI_CHIP_RV280_5C63		0x5C63
+#define PCI_CHIP_R430_5D48              0x5D48
+#define PCI_CHIP_R430_5D49              0x5D49
+#define PCI_CHIP_R430_5D4A              0x5D4A
+#define PCI_CHIP_R480_5D4C              0x5D4C
+#define PCI_CHIP_R480_5D4D              0x5D4D
+#define PCI_CHIP_R480_5D4E              0x5D4E
+#define PCI_CHIP_R480_5D4F              0x5D4F
+#define PCI_CHIP_R480_5D50              0x5D50
+#define PCI_CHIP_R480_5D52              0x5D52
+#define PCI_CHIP_R423_5D57              0x5D57
+#define PCI_CHIP_RV410_5E48             0x5E48
+#define PCI_CHIP_RV410_5E4A             0x5E4A
+#define PCI_CHIP_RV410_5E4B             0x5E4B
+#define PCI_CHIP_RV410_5E4C             0x5E4C
+#define PCI_CHIP_RV410_5E4D             0x5E4D
+#define PCI_CHIP_RV410_5E4F             0x5E4F
+#define PCI_CHIP_RS350_7834             0x7834
+#define PCI_CHIP_RS350_7835             0x7835
+
+/* ASPEED Technology (AST) */
+#define PCI_CHIP_AST2000		0x2000
+
+/* Avance Logic */
+#define PCI_CHIP_ALG2064		0x2064
+#define PCI_CHIP_ALG2301		0x2301
+#define PCI_CHIP_ALG2501		0x2501
+
+/* Tseng */
+#define PCI_CHIP_ET4000_W32P_A		0x3202
+#define PCI_CHIP_ET4000_W32P_B		0x3205
+#define PCI_CHIP_ET4000_W32P_D		0x3206
+#define PCI_CHIP_ET4000_W32P_C		0x3207
+#define PCI_CHIP_ET6000			0x3208
+#define PCI_CHIP_ET6300			0x4702
+
+/* Weitek */
+#define PCI_CHIP_P9000			0x9001
+#define PCI_CHIP_P9100			0x9100
+
+/* Digital */
+#define PCI_CHIP_DC21050		0x0001
+#define PCI_CHIP_DEC21030		0x0004
+#define PCI_CHIP_TGA2			0x000D
+
+/* Cirrus Logic */
+#define PCI_CHIP_GD7548			0x0038
+#define PCI_CHIP_GD7555			0x0040
+#define PCI_CHIP_GD5430			0x00A0
+#define PCI_CHIP_GD5434_4		0x00A4
+#define PCI_CHIP_GD5434_8		0x00A8
+#define PCI_CHIP_GD5436			0x00AC
+#define PCI_CHIP_GD5446			0x00B8
+#define PCI_CHIP_GD5480			0x00BC
+#define PCI_CHIP_GD5462			0x00D0
+#define PCI_CHIP_GD5464			0x00D4
+#define PCI_CHIP_GD5464BD		0x00D5
+#define PCI_CHIP_GD5465			0x00D6
+#define PCI_CHIP_6729			0x1100
+#define PCI_CHIP_6832			0x1110
+#define PCI_CHIP_GD7542			0x1200
+#define PCI_CHIP_GD7543			0x1202
+#define PCI_CHIP_GD7541			0x1204
+
+/* AMD */
+#define PCI_CHIP_AMD761			0x700E
+
+/* Trident */
+#define PCI_CHIP_2100			0x2100
+#define PCI_CHIP_8400			0x8400
+#define PCI_CHIP_8420			0x8420
+#define PCI_CHIP_8500			0x8500
+#define PCI_CHIP_8520			0x8520
+#define PCI_CHIP_8600			0x8600
+#define PCI_CHIP_8620			0x8620
+#define PCI_CHIP_8820			0x8820
+#define PCI_CHIP_9320			0x9320
+#define PCI_CHIP_9388			0x9388
+#define PCI_CHIP_9397			0x9397
+#define PCI_CHIP_939A			0x939A
+#define PCI_CHIP_9420			0x9420
+#define PCI_CHIP_9440			0x9440
+#define PCI_CHIP_9520			0x9520
+#define PCI_CHIP_9525			0x9525
+#define PCI_CHIP_9540			0x9540
+#define PCI_CHIP_9660			0x9660
+#define PCI_CHIP_9750			0x9750
+#define PCI_CHIP_9850			0x9850
+#define PCI_CHIP_9880			0x9880
+#define PCI_CHIP_9910			0x9910
+
+/* ALI */
+#define PCI_CHIP_M1435			0x1435
+
+/* Matrox */
+#define PCI_CHIP_MGA2085		0x0518
+#define PCI_CHIP_MGA2064		0x0519
+#define PCI_CHIP_MGA1064		0x051A
+#define PCI_CHIP_MGA2164		0x051B
+#define PCI_CHIP_MGA2164_AGP		0x051F
+#define PCI_CHIP_MGAG200_PCI		0x0520
+#define PCI_CHIP_MGAG200		0x0521
+#define PCI_CHIP_MGAG400		0x0525
+#define PCI_CHIP_MGAG550		0x2527
+#define PCI_CHIP_IMPRESSION		0x0D10
+#define PCI_CHIP_MGAG100_PCI		0x1000
+#define PCI_CHIP_MGAG100		0x1001
+
+#define PCI_CARD_G400_TH		0x2179
+#define PCI_CARD_MILL_G200_SD		0xFF00
+#define PCI_CARD_PROD_G100_SD		0xFF01
+#define PCI_CARD_MYST_G200_SD		0xFF02
+#define PCI_CARD_MILL_G200_SG		0xFF03
+#define PCI_CARD_MARV_G200_SD		0xFF04
+
+/* Chips & Tech */
+#define PCI_CHIP_65545			0x00D8
+#define PCI_CHIP_65548			0x00DC
+#define PCI_CHIP_65550			0x00E0
+#define PCI_CHIP_65554			0x00E4
+#define PCI_CHIP_65555			0x00E5
+#define PCI_CHIP_68554			0x00F4
+#define PCI_CHIP_69000			0x00C0
+#define PCI_CHIP_69030			0x0C30
+
+/* Miro */
+#define PCI_CHIP_ZR36050		0x5601
+
+/* NEC */
+#define PCI_CHIP_POWER_VR		0x0046
+
+/* SiS */
+#define PCI_CHIP_SG86C201		0x0001
+#define PCI_CHIP_SG86C202		0x0002
+#define PCI_CHIP_SG85C503		0x0008
+#define PCI_CHIP_SIS5597		0x0200
+/* Agregado por Carlos Duclos & Manuel Jander */
+#define PCI_CHIP_SIS82C204		0x0204
+#define PCI_CHIP_SG86C205		0x0205
+#define PCI_CHIP_SG86C215		0x0215
+#define PCI_CHIP_SG86C225		0x0225
+#define PCI_CHIP_85C501			0x0406
+#define PCI_CHIP_85C496			0x0496
+#define PCI_CHIP_85C601			0x0601
+#define PCI_CHIP_85C5107		0x5107
+#define PCI_CHIP_85C5511		0x5511
+#define PCI_CHIP_85C5513		0x5513
+#define PCI_CHIP_SIS5571		0x5571
+#define PCI_CHIP_SIS5597_2		0x5597
+#define PCI_CHIP_SIS530			0x6306
+#define PCI_CHIP_SIS6326		0x6326
+#define PCI_CHIP_SIS7001		0x7001
+#define PCI_CHIP_SIS300			0x0300
+#define PCI_CHIP_SIS315H		0x0310
+#define PCI_CHIP_SIS315PRO		0x0325
+#define PCI_CHIP_SIS330			0x0330
+#define PCI_CHIP_SIS630			0x6300
+#define PCI_CHIP_SIS540			0x5300
+#define PCI_CHIP_SIS550			0x5315 
+#define PCI_CHIP_SIS650			0x6325 
+#define PCI_CHIP_SIS730			0x7300
+
+/* Hewlett-Packard */
+#define PCI_CHIP_ELROY			0x1054
+#define PCI_CHIP_ZX1_SBA		0x1229
+#define PCI_CHIP_ZX1_IOC		0x122A
+#define PCI_CHIP_ZX1_LBA		0x122E	/* a.k.a. Mercury */
+#define PCI_CHIP_ZX1_AGP8		0x12B4	/* a.k.a. QuickSilver */
+#define PCI_CHIP_ZX2_LBA		0x12EE
+#define PCI_CHIP_ZX2_SBA		0x4030
+#define PCI_CHIP_ZX2_IOC		0x4031
+#define PCI_CHIP_ZX2_PCIE		0x4037
+
+/* SGS */
+#define PCI_CHIP_STG2000		0x0008
+#define PCI_CHIP_STG1764		0x0009
+#define PCI_CHIP_KYROII			0x0010
+
+/* Texas Instruments */
+#define PCI_CHIP_TI_PERMEDIA		0x3D04
+#define PCI_CHIP_TI_PERMEDIA2		0x3D07
+
+/* Oak */
+#define PCI_CHIP_OTI107			0x0107
+
+/* Number Nine */
+#define PCI_CHIP_I128			0x2309
+#define PCI_CHIP_I128_2			0x2339
+#define PCI_CHIP_I128_T2R		0x493D
+#define PCI_CHIP_I128_T2R4		0x5348
+
+/* Sun */
+#define PCI_CHIP_EBUS			0x1000
+#define PCI_CHIP_HAPPY_MEAL		0x1001
+#define PCI_CHIP_SIMBA			0x5000
+#define PCI_CHIP_PSYCHO			0x8000
+#define PCI_CHIP_SCHIZO			0x8001
+#define PCI_CHIP_SABRE			0xA000
+#define PCI_CHIP_HUMMINGBIRD		0xA001
+
+/* BrookTree */
+#define PCI_CHIP_BT848			0x0350
+#define PCI_CHIP_BT849			0x0351
+
+/* NVIDIA */
+#define PCI_CHIP_NV1			0x0008
+#define PCI_CHIP_DAC64			0x0009
+#define PCI_CHIP_TNT			0x0020
+#define PCI_CHIP_TNT2			0x0028
+#define PCI_CHIP_UTNT2			0x0029
+#define PCI_CHIP_VTNT2			0x002C
+#define PCI_CHIP_UVTNT2			0x002D
+#define PCI_CHIP_ITNT2			0x00A0
+#define PCI_CHIP_GEFORCE_256		0x0100
+#define PCI_CHIP_GEFORCE_DDR		0x0101
+#define PCI_CHIP_QUADRO			0x0103
+#define PCI_CHIP_GEFORCE2_MX		0x0110
+#define PCI_CHIP_GEFORCE2_MX_100	0x0111
+#define PCI_CHIP_GEFORCE2_GO		0x0112
+#define PCI_CHIP_QUADRO2_MXR		0x0113
+#define PCI_CHIP_GEFORCE2_GTS		0x0150
+#define PCI_CHIP_GEFORCE2_TI		0x0151
+#define PCI_CHIP_GEFORCE2_ULTRA		0x0152
+#define PCI_CHIP_QUADRO2_PRO		0x0153
+#define PCI_CHIP_GEFORCE4_MX_460	0x0170
+#define PCI_CHIP_GEFORCE4_MX_440	0x0171
+#define PCI_CHIP_GEFORCE4_MX_420	0x0172
+#define PCI_CHIP_GEFORCE4_440_GO	0x0174
+#define PCI_CHIP_GEFORCE4_420_GO	0x0175
+#define PCI_CHIP_GEFORCE4_420_GO_M32	0x0176
+#define PCI_CHIP_QUADRO4_500XGL		0x0178
+#define PCI_CHIP_GEFORCE4_440_GO_M64	0x0179
+#define PCI_CHIP_QUADRO4_200		0x017A
+#define PCI_CHIP_QUADRO4_550XGL		0x017B
+#define PCI_CHIP_QUADRO4_500_GOGL	0x017C
+#define PCI_CHIP_IGEFORCE2		0x01A0
+#define PCI_CHIP_GEFORCE3		0x0200
+#define PCI_CHIP_GEFORCE3_TI_200	0x0201
+#define PCI_CHIP_GEFORCE3_TI_500	0x0202
+#define PCI_CHIP_QUADRO_DCC		0x0203
+#define PCI_CHIP_GEFORCE4_TI_4600	0x0250
+#define PCI_CHIP_GEFORCE4_TI_4400	0x0251
+#define PCI_CHIP_GEFORCE4_TI_4200	0x0253
+#define PCI_CHIP_QUADRO4_900XGL		0x0258
+#define PCI_CHIP_QUADRO4_750XGL		0x0259
+#define PCI_CHIP_QUADRO4_700XGL		0x025B
+
+/* NVIDIA & SGS */
+#define PCI_CHIP_RIVA128		0x0018
+
+/* IMS */
+#define PCI_CHIP_IMSTT128		0x9128
+#define PCI_CHIP_IMSTT3D		0x9135
+
+/* Alliance Semiconductor */
+#define PCI_CHIP_AP6410			0x3210
+#define PCI_CHIP_AP6422			0x6422
+#define PCI_CHIP_AT24			0x6424
+#define PCI_CHIP_AT3D			0x643D
+
+/* 3dfx Interactive */
+#define PCI_CHIP_VOODOO_GRAPHICS	0x0001
+#define PCI_CHIP_VOODOO2		0x0002
+#define PCI_CHIP_BANSHEE		0x0003
+#define PCI_CHIP_VOODOO3		0x0005
+#define PCI_CHIP_VOODOO5		0x0009
+
+#define PCI_CARD_VOODOO3_2000		0x0036
+#define PCI_CARD_VOODOO3_3000		0x003A
+
+/* Rendition */
+#define PCI_CHIP_V1000			0x0001
+#define PCI_CHIP_V2x00			0x2000
+
+/* 3Dlabs */
+#define PCI_CHIP_300SX			0x0001
+#define PCI_CHIP_500TX			0x0002
+#define PCI_CHIP_DELTA			0x0003
+#define PCI_CHIP_PERMEDIA		0x0004
+#define PCI_CHIP_MX			0x0006
+#define PCI_CHIP_PERMEDIA2		0x0007
+#define PCI_CHIP_GAMMA			0x0008
+#define PCI_CHIP_PERMEDIA2V		0x0009
+#define PCI_CHIP_PERMEDIA3		0x000A
+#define PCI_CHIP_PERMEDIA4		0x000C
+#define PCI_CHIP_R4			0x000D
+#define PCI_CHIP_GAMMA2			0x000E
+#define PCI_CHIP_R4ALT			0x0011
+
+/* S3 */
+#define PCI_CHIP_PLATO			0x0551
+#define PCI_CHIP_VIRGE			0x5631
+#define PCI_CHIP_TRIO			0x8811
+#define PCI_CHIP_AURORA64VP		0x8812
+#define PCI_CHIP_TRIO64UVP		0x8814
+#define PCI_CHIP_VIRGE_VX		0x883D
+#define PCI_CHIP_868			0x8880
+#define PCI_CHIP_928			0x88B0
+#define PCI_CHIP_864_0			0x88C0
+#define PCI_CHIP_864_1			0x88C1
+#define PCI_CHIP_964_0			0x88D0
+#define PCI_CHIP_964_1			0x88D1
+#define PCI_CHIP_968			0x88F0
+#define PCI_CHIP_TRIO64V2_DXGX		0x8901
+#define PCI_CHIP_PLATO_PX		0x8902
+#define PCI_CHIP_Trio3D			0x8904
+#define PCI_CHIP_VIRGE_DXGX		0x8A01
+#define PCI_CHIP_VIRGE_GX2		0x8A10
+#define PCI_CHIP_Trio3D_2X		0x8A13
+#define PCI_CHIP_SAVAGE3D		0x8A20
+#define PCI_CHIP_SAVAGE3D_MV		0x8A21
+#define PCI_CHIP_SAVAGE4		0x8A22
+#define PCI_CHIP_PROSAVAGE_PM		0x8A25
+#define PCI_CHIP_PROSAVAGE_KM		0x8A26
+#define PCI_CHIP_VIRGE_MX		0x8C01
+#define PCI_CHIP_VIRGE_MXPLUS		0x8C02
+#define PCI_CHIP_VIRGE_MXP		0x8C03
+#define PCI_CHIP_SAVAGE_MX_MV		0x8C10
+#define PCI_CHIP_SAVAGE_MX		0x8C11
+#define PCI_CHIP_SAVAGE_IX_MV		0x8C12
+#define PCI_CHIP_SAVAGE_IX		0x8C13
+#define PCI_CHIP_SUPSAV_MX128		0x8C22
+#define PCI_CHIP_SUPSAV_MX64		0x8C24
+#define PCI_CHIP_SUPSAV_MX64C		0x8C26
+#define PCI_CHIP_SUPSAV_IX128SDR	0x8C2A
+#define PCI_CHIP_SUPSAV_IX128DDR	0x8C2B
+#define PCI_CHIP_SUPSAV_IX64SDR		0x8C2C
+#define PCI_CHIP_SUPSAV_IX64DDR		0x8C2D
+#define PCI_CHIP_SUPSAV_IXCSDR		0x8C2E
+#define PCI_CHIP_SUPSAV_IXCDDR		0x8C2F
+#define PCI_CHIP_S3TWISTER_P		0x8D01
+#define PCI_CHIP_S3TWISTER_K		0x8D02
+#define PCI_CHIP_PROSAVAGE_DDR		0x8D03
+#define PCI_CHIP_PROSAVAGE_DDRK		0x8D04
+#define PCI_CHIP_SAVAGE2000		0x9102
+
+/* ARK Logic */
+#define PCI_CHIP_1000PV			0xA091
+#define PCI_CHIP_2000PV			0xA099
+#define PCI_CHIP_2000MT			0xA0A1
+#define PCI_CHIP_2000MI			0xA0A9
+
+/* Tritech Microelectronics */
+#define PCI_CHIP_TR25202		0xFC02
+
+/* Neomagic */
+#define PCI_CHIP_NM2070			0x0001
+#define PCI_CHIP_NM2090			0x0002
+#define PCI_CHIP_NM2093			0x0003
+#define PCI_CHIP_NM2097			0x0083
+#define PCI_CHIP_NM2160			0x0004
+#define PCI_CHIP_NM2200			0x0005
+#define PCI_CHIP_NM2230			0x0025
+#define PCI_CHIP_NM2360			0x0006
+#define PCI_CHIP_NM2380			0x0016
+
+/* Intel */
+#define PCI_CHIP_I815_BRIDGE		0x1130
+#define PCI_CHIP_I815			0x1132
+#define PCI_CHIP_82801_P2P		0x244E
+#define PCI_CHIP_845_G_BRIDGE		0x2560
+#define PCI_CHIP_845_G			0x2562
+#define PCI_CHIP_I830_M_BRIDGE		0x3575
+#define PCI_CHIP_I830_M			0x3577
+#define PCI_CHIP_I810_BRIDGE		0x7120
+#define PCI_CHIP_I810			0x7121
+#define PCI_CHIP_I810_DC100_BRIDGE	0x7122
+#define PCI_CHIP_I810_DC100		0x7123
+#define PCI_CHIP_I810_E_BRIDGE		0x7124
+#define PCI_CHIP_I810_E			0x7125
+#define PCI_CHIP_I740_AGP		0x7800
+#define PCI_CHIP_460GX_PXB		0x84CB
+#define PCI_CHIP_460GX_SAC		0x84E0
+#define PCI_CHIP_460GX_GXB_2		0x84E2	/* PCI function 2 */
+#define PCI_CHIP_460GX_WXB		0x84E6
+#define PCI_CHIP_460GX_GXB_1		0x84EA	/* PCI function 1 */
+
+/* Silicon Motion Inc. */
+#define PCI_CHIP_SMI910			0x0910
+#define PCI_CHIP_SMI810			0x0810
+#define PCI_CHIP_SMI820			0x0820
+#define PCI_CHIP_SMI710			0x0710
+#define PCI_CHIP_SMI712			0x0712
+#define PCI_CHIP_SMI720			0x0720
+#define PCI_CHIP_SMI731			0x0730
+
+/* VMware */
+#define PCI_CHIP_VMWARE0405		0x0405
+#define PCI_CHIP_VMWARE0710		0x0710
+
+#endif /* _XF86_PCIINFO_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Axp.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Axp.h
@@ -0,0 +1,34 @@
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_AXP_H_
+#define _XF86_AXP_H_
+
+typedef enum {
+  SYS_NONE,
+  TSUNAMI,
+  LCA,
+  APECS,
+  T2,
+  T2_GAMMA,
+  CIA,
+  MCPCIA,
+  JENSEN,
+  POLARIS,
+  PYXIS,
+  PYXIS_CIA,
+  IRONGATE
+} axpDevice;
+  
+typedef struct {
+  axpDevice id;
+  unsigned long hae_thresh;
+  unsigned long hae_mask;
+  unsigned long size;
+} axpParams;
+
+extern axpParams xf86AXPParams[];
+
+#endif
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxpict.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxpict.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ *  This file provides access to the externally visible RENDER support
+ *  functions, global variables and macros for DMX.
+ *  
+ *  FIXME: Move function definitions for non-externally visible function
+ *  to .c file. */
+
+#ifndef DMXPICT_H
+#define DMXPICT_H
+
+/** Picture private structure */
+typedef struct _dmxPictPriv {
+    Picture  pict;		/**< Picture ID from back-end server */
+    Mask     savedMask;         /**< Mask of picture attributes saved for
+				 *   lazy window creation. */
+} dmxPictPrivRec, *dmxPictPrivPtr;
+
+
+/** Glyph Set private structure */
+typedef struct _dmxGlyphPriv {
+    GlyphSet  *glyphSets; /**< Glyph Set IDs from back-end server */
+} dmxGlyphPrivRec, *dmxGlyphPrivPtr;
+
+
+extern void dmxInitRender(void);
+extern void dmxResetRender(void);
+
+extern Bool dmxPictureInit(ScreenPtr pScreen,
+			   PictFormatPtr formats, int nformats);
+
+extern void dmxCreatePictureList(WindowPtr pWindow);
+extern Bool dmxDestroyPictureList(WindowPtr pWindow);
+
+extern int dmxCreatePicture(PicturePtr pPicture);
+extern void dmxDestroyPicture(PicturePtr pPicture);
+extern int dmxChangePictureClip(PicturePtr pPicture, int clipType,
+				pointer value, int n);
+extern void dmxDestroyPictureClip(PicturePtr pPicture);
+extern void dmxChangePicture(PicturePtr pPicture, Mask mask);
+extern void dmxValidatePicture(PicturePtr pPicture, Mask mask);
+extern void dmxComposite(CARD8 op,
+			 PicturePtr pSrc, PicturePtr pMask, PicturePtr pDst,
+			 INT16 xSrc, INT16 ySrc,
+			 INT16 xMask, INT16 yMask,
+			 INT16 xDst, INT16 yDst,
+			 CARD16 width, CARD16 height);
+extern void dmxGlyphs(CARD8 op,
+		      PicturePtr pSrc, PicturePtr pDst,
+		      PictFormatPtr maskFormat,
+		      INT16 xSrc, INT16 ySrc,
+		      int nlists, GlyphListPtr lists, GlyphPtr *glyphs);
+extern void dmxCompositeRects(CARD8 op,
+			      PicturePtr pDst,
+			      xRenderColor *color,
+			      int nRect, xRectangle *rects);
+extern Bool dmxInitIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+extern void dmxCloseIndexed(ScreenPtr pScreen, PictFormatPtr pFormat);
+extern void dmxUpdateIndexed(ScreenPtr pScreen, PictFormatPtr pFormat,
+			     int ndef, xColorItem *pdef);
+extern void dmxTrapezoids(CARD8 op,
+			  PicturePtr pSrc, PicturePtr pDst,
+			  PictFormatPtr maskFormat,
+			  INT16 xSrc, INT16 ySrc,
+			  int ntrap, xTrapezoid *traps);
+extern void dmxTriangles(CARD8 op,
+			 PicturePtr pSrc, PicturePtr pDst,
+			 PictFormatPtr maskFormat,
+			 INT16 xSrc, INT16 ySrc,
+			 int ntri, xTriangle *tris);
+extern void dmxTriStrip(CARD8 op,
+			PicturePtr pSrc, PicturePtr pDst,
+			PictFormatPtr maskFormat,
+			INT16 xSrc, INT16 ySrc,
+			int npoint, xPointFixed *points);
+extern void dmxTriFan(CARD8 op,
+		      PicturePtr pSrc, PicturePtr pDst,
+		      PictFormatPtr maskFormat,
+		      INT16 xSrc, INT16 ySrc,
+		      int npoint, xPointFixed *points);
+
+extern int dmxBECreateGlyphSet(int idx, GlyphSetPtr glyphSet);
+extern Bool dmxBEFreeGlyphSet(ScreenPtr pScreen, GlyphSetPtr glyphSet);
+extern int dmxBECreatePicture(PicturePtr pPicture);
+extern Bool dmxBEFreePicture(PicturePtr pPicture);
+
+/** Get the picture private data given a picture pointer */
+#define DMX_GET_PICT_PRIV(_pPict)					\
+    (dmxPictPrivPtr)dixLookupPrivate(&(_pPict)->devPrivates, dmxPictPrivateKey)
+
+/** Set the glyphset private data given a glyphset pointer */
+#define DMX_SET_GLYPH_PRIV(_pGlyph, _pPriv)				\
+    GlyphSetSetPrivate((_pGlyph), dmxGlyphSetPrivateKey, (_pPriv))
+/** Get the glyphset private data given a glyphset pointer */
+#define DMX_GET_GLYPH_PRIV(_pGlyph)					\
+    (dmxGlyphPrivPtr)GlyphSetGetPrivate((_pGlyph), dmxGlyphSetPrivateKey)
+
+#endif /* DMXPICT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_table.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_table.h
@@ -0,0 +1,106 @@
+/*
+ * (C) Copyright IBM Corporation 2005, 2006
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/**
+ * \file indirect_table.h
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#ifndef INDIRECT_TABLE_H
+#define INDIRECT_TABLE_H
+
+#include <inttypes.h>
+
+/**
+ */
+struct __glXDispatchInfo {
+    /**
+     * Number of significant bits in the protocol opcode.  Opcodes with values
+     * larger than ((1 << bits) - 1) are invalid.
+     */
+    unsigned bits;
+
+    /**
+     */
+    const int_fast16_t * dispatch_tree;
+    
+    /**
+     * Array of protocol decode and dispatch functions index by the opcode
+     * search tree (i.e., \c dispatch_tree).  The first element in each pair
+     * is the non-byte-swapped version, and the second element is the
+     * byte-swapped version.
+     */
+    const void *(*dispatch_functions)[2];
+
+    /**
+     * Pointer to size validation data.  This table is indexed with the same
+     * value as ::dispatch_functions.
+     *
+     * The first element in the pair is the size, in bytes, of the fixed-size
+     * portion of the protocol.
+     *
+     * For opcodes that have a variable-size portion, the second value is an
+     * index in \c size_func_table to calculate that size.  If there is no
+     * variable-size portion, this index will be ~0.
+     *
+     * \note
+     * If size checking is not to be performed on this type of protocol
+     * data, this pointer will be \c NULL.
+     */
+    const int_fast16_t (*size_table)[2];
+
+    /**
+     * Array of functions used to calculate the variable-size portion of
+     * protocol messages.  Indexed by the second element of the entries
+     * in \c ::size_table.
+     *
+     * \note
+     * If size checking is not to be performed on this type of protocol
+     * data, this pointer will be \c NULL.
+     */
+    const gl_proto_size_func *size_func_table;
+};
+
+/**
+ * Sentinel value for an empty leaf in the \c dispatch_tree.
+ */
+#define EMPTY_LEAF         INT_FAST16_MIN
+
+/**
+ * Declare the index \c x as a leaf index.
+ */
+#define LEAF(x)            -x
+
+/**
+ * Determine if an index is a leaf index.
+ */
+#define IS_LEAF_INDEX(x)   ((x) <= 0)
+
+extern const struct __glXDispatchInfo Single_dispatch_info;
+extern const struct __glXDispatchInfo Render_dispatch_info;
+extern const struct __glXDispatchInfo VendorPriv_dispatch_info;
+
+#endif /* INDIRECT_TABLE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipoly.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipoly.h
@@ -0,0 +1,207 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+
+/*
+ *     fill.h
+ *
+ *     Created by Brian Kelleher; Oct 1985
+ *
+ *     Include file for filled polygon routines.
+ *
+ *     These are the data structures needed to scan
+ *     convert regions.  Two different scan conversion
+ *     methods are available -- the even-odd method, and
+ *     the winding number method.
+ *     The even-odd rule states that a point is inside
+ *     the polygon if a ray drawn from that point in any
+ *     direction will pass through an odd number of
+ *     path segments.
+ *     By the winding number rule, a point is decided
+ *     to be inside the polygon if a ray drawn from that
+ *     point in any direction passes through a different
+ *     number of clockwise and counter-clockwise path
+ *     segments.
+ *
+ *     These data structures are adapted somewhat from
+ *     the algorithm in (Foley/Van Dam) for scan converting
+ *     polygons.
+ *     The basic algorithm is to start at the top (smallest y)
+ *     of the polygon, stepping down to the bottom of
+ *     the polygon by incrementing the y coordinate.  We
+ *     keep a list of edges which the current scanline crosses,
+ *     sorted by x.  This list is called the Active Edge Table (AET)
+ *     As we change the y-coordinate, we update each entry in 
+ *     in the active edge table to reflect the edges new xcoord.
+ *     This list must be sorted at each scanline in case
+ *     two edges intersect.
+ *     We also keep a data structure known as the Edge Table (ET),
+ *     which keeps track of all the edges which the current
+ *     scanline has not yet reached.  The ET is basically a
+ *     list of ScanLineList structures containing a list of
+ *     edges which are entered at a given scanline.  There is one
+ *     ScanLineList per scanline at which an edge is entered.
+ *     When we enter a new edge, we move it from the ET to the AET.
+ *
+ *     From the AET, we can implement the even-odd rule as in
+ *     (Foley/Van Dam).
+ *     The winding number rule is a little trickier.  We also
+ *     keep the EdgeTableEntries in the AET linked by the
+ *     nextWETE (winding EdgeTableEntry) link.  This allows
+ *     the edges to be linked just as before for updating
+ *     purposes, but only uses the edges linked by the nextWETE
+ *     link as edges representing spans of the polygon to
+ *     drawn (as with the even-odd rule).
+ */
+
+/*
+ * for the winding number rule
+ */
+#define CLOCKWISE          1
+#define COUNTERCLOCKWISE  -1 
+
+typedef struct _EdgeTableEntry {
+     int ymax;             /* ycoord at which we exit this edge. */
+     BRESINFO bres;        /* Bresenham info to run the edge     */
+     struct _EdgeTableEntry *next;       /* next in the list     */
+     struct _EdgeTableEntry *back;       /* for insertion sort   */
+     struct _EdgeTableEntry *nextWETE;   /* for winding num rule */
+     int ClockWise;        /* flag for winding number rule       */
+} EdgeTableEntry;
+
+
+typedef struct _ScanLineList{
+     int scanline;              /* the scanline represented */
+     EdgeTableEntry *edgelist;  /* header node              */
+     struct _ScanLineList *next;  /* next in the list       */
+} ScanLineList;
+
+
+typedef struct {
+     int ymax;                 /* ymax for the polygon     */
+     int ymin;                 /* ymin for the polygon     */
+     ScanLineList scanlines;   /* header node              */
+} EdgeTable;
+
+
+/*
+ * Here is a struct to help with storage allocation
+ * so we can allocate a big chunk at a time, and then take
+ * pieces from this heap when we need to.
+ */
+#define SLLSPERBLOCK 25
+
+typedef struct _ScanLineListBlock {
+     ScanLineList SLLs[SLLSPERBLOCK];
+     struct _ScanLineListBlock *next;
+} ScanLineListBlock;
+
+/*
+ * number of points to buffer before sending them off
+ * to scanlines() :  Must be an even number
+ */
+#define NUMPTSTOBUFFER 200
+
+
+/*
+ *
+ *     a few macros for the inner loops of the fill code where
+ *     performance considerations don't allow a procedure call.
+ *
+ *     Evaluate the given edge at the given scanline.
+ *     If the edge has expired, then we leave it and fix up
+ *     the active edge table; otherwise, we increment the
+ *     x value to be ready for the next scanline.
+ *     The winding number rule is in effect, so we must notify
+ *     the caller when the edge has been removed so he
+ *     can reorder the Winding Active Edge Table.
+ */
+#define EVALUATEEDGEWINDING(pAET, pPrevAET, y, fixWAET) { \
+   if (pAET->ymax == y) {          /* leaving this edge */ \
+      pPrevAET->next = pAET->next; \
+      pAET = pPrevAET->next; \
+      fixWAET = 1; \
+      if (pAET) \
+         pAET->back = pPrevAET; \
+   } \
+   else { \
+      BRESINCRPGONSTRUCT(pAET->bres); \
+      pPrevAET = pAET; \
+      pAET = pAET->next; \
+   } \
+}
+
+
+/*
+ *     Evaluate the given edge at the given scanline.
+ *     If the edge has expired, then we leave it and fix up
+ *     the active edge table; otherwise, we increment the
+ *     x value to be ready for the next scanline.
+ *     The even-odd rule is in effect.
+ */
+#define EVALUATEEDGEEVENODD(pAET, pPrevAET, y) { \
+   if (pAET->ymax == y) {          /* leaving this edge */ \
+      pPrevAET->next = pAET->next; \
+      pAET = pPrevAET->next; \
+      if (pAET) \
+         pAET->back = pPrevAET; \
+   } \
+   else { \
+      BRESINCRPGONSTRUCT(pAET->bres); \
+      pPrevAET = pAET; \
+      pAET = pAET->next; \
+   } \
+}
+
+/* mipolyutil.c */
+
+extern _X_EXPORT Bool miCreateETandAET(
+    int /*count*/,
+    DDXPointPtr /*pts*/,
+    EdgeTable * /*ET*/,
+    EdgeTableEntry * /*AET*/,
+    EdgeTableEntry * /*pETEs*/,
+    ScanLineListBlock * /*pSLLBlock*/
+);
+
+extern _X_EXPORT void miloadAET(
+    EdgeTableEntry * /*AET*/,
+    EdgeTableEntry * /*ETEs*/
+);
+
+extern _X_EXPORT void micomputeWAET(
+    EdgeTableEntry * /*AET*/
+);
+
+extern _X_EXPORT int miInsertionSort(
+    EdgeTableEntry * /*AET*/
+);
+
+extern _X_EXPORT void miFreeStorage(
+    ScanLineListBlock * /*pSLLBlock*/
+);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdev.h
@@ -0,0 +1,52 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEV_H
+#define GRABDEV_H 1
+
+int SProcXGrabDevice(ClientPtr	/* client */
+    );
+
+int ProcXGrabDevice(ClientPtr	/* client */
+    );
+
+int CreateMaskFromList(ClientPtr /* client */ ,
+		       XEventClass * /* list */ ,
+		       int /* count */ ,
+		       struct tmask /* mask */ [],
+		       DeviceIntPtr /* dev */ ,
+		       int	/* req */
+    );
+
+void SRepXGrabDevice(ClientPtr /* client */ ,
+		     int /* size */ ,
+		     xGrabDeviceReply *	/* rep */
+    );
+
+#endif /* GRABDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/listdev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/listdev.h
@@ -0,0 +1,46 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef LISTDEV_H
+#define LISTDEV_H 1
+
+#define VPC	20	/* Max # valuators per chunk */
+
+int SProcXListInputDevices(ClientPtr	/* client */
+    );
+
+int ProcXListInputDevices(ClientPtr	/* client */
+    );
+
+void SRepXListInputDevices(ClientPtr /* client */ ,
+			   int /* size */ ,
+			   xListInputDevicesReply *	/* rep */
+    );
+
+#endif /* LISTDEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/geext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/geext.h
@@ -0,0 +1,83 @@
+/*
+
+Copyright 2007 Peter Hutterer <peter@cs.unisa.edu.au>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of the author shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from the author.
+
+*/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GEEXT_H_
+#define _GEEXT_H_
+#include <X11/extensions/geproto.h>
+
+/** Struct to keep information about registered extensions */
+typedef struct _GEExtension {
+    /** Event swapping routine */
+    void (*evswap)(xGenericEvent* from, xGenericEvent* to);
+} GEExtension, *GEExtensionPtr;
+
+
+/* All registered extensions and their handling functions. */
+extern _X_EXPORT GEExtension GEExtensions[MAXEXTENSIONS];
+
+/* Typecast to generic event */
+#define GEV(ev) ((xGenericEvent*)(ev))
+/* Returns the extension offset from the event */
+#define GEEXT(ev) (GEV(ev)->extension)
+
+/* Return zero-based extension offset (offset - 128). Only for use in arrays */
+#define GEEXTIDX(ev) (GEEXT(ev) & 0x7F)
+/* True if mask is set for extension on window */
+#define GEMaskIsSet(pWin, extension, mask) \
+    ((pWin)->optional && \
+     (pWin)->optional->geMasks && \
+     ((pWin)->optional->geMasks->eventMasks[(extension) & 0x7F] & (mask)))
+
+/* Returns first client */
+#define GECLIENT(pWin) \
+    (((pWin)->optional) ? (pWin)->optional->geMasks->geClients : NULL)
+
+/* Returns the event_fill for the given event */
+#define GEEventFill(ev) \
+    GEExtensions[GEEXTIDX(ev)].evfill
+
+#define GEIsType(ev, ext, ev_type) \
+        ((GEV(ev)->type == GenericEvent) &&  \
+         GEEXT(ev) == (ext) && \
+         GEV(ev)->evtype == (ev_type))
+
+
+/* Interface for other extensions */
+extern _X_EXPORT void GERegisterExtension(
+        int extension,
+        void (*ev_dispatch)(xGenericEvent* from, xGenericEvent* to));
+
+extern _X_EXPORT void GEInitEvent(xGenericEvent* ev, int extension);
+
+extern _X_EXPORT void GEExtensionInit(void);
+
+#endif /* _GEEXT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exa_priv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exa_priv.h
@@ -0,0 +1,725 @@
+/*
+ *
+ * Copyright (C) 2000 Keith Packard, member of The XFree86 Project, Inc.
+ *               2005 Zack Rusin, Trolltech
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef EXAPRIV_H
+#define EXAPRIV_H
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "exa.h"
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#ifdef MITSHM
+#include "shmint.h"
+#endif
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "servermd.h"
+#include "mibstore.h"
+#include "colormapst.h"
+#include "gcstruct.h"
+#include "input.h"
+#include "mipointer.h"
+#include "mi.h"
+#include "dix.h"
+#include "fb.h"
+#include "fboverlay.h"
+#include "fbpict.h"
+#include "glyphstr.h"
+#include "damage.h"
+
+#define DEBUG_TRACE_FALL	0
+#define DEBUG_MIGRATE		0
+#define DEBUG_PIXMAP		0
+#define DEBUG_OFFSCREEN		0
+#define DEBUG_GLYPH_CACHE	0
+
+#if DEBUG_TRACE_FALL
+#define EXA_FALLBACK(x)     					\
+do {								\
+	ErrorF("EXA fallback at %s: ", __FUNCTION__);		\
+	ErrorF x;						\
+} while (0)
+
+char
+exaDrawableLocation(DrawablePtr pDrawable);
+#else
+#define EXA_FALLBACK(x)
+#endif
+
+#if DEBUG_PIXMAP
+#define DBG_PIXMAP(a) ErrorF a
+#else
+#define DBG_PIXMAP(a)
+#endif
+
+#ifndef EXA_MAX_FB
+#define EXA_MAX_FB   FB_OVERLAY_MAX
+#endif
+
+#ifdef DEBUG
+#define EXA_FatalErrorDebug(x) FatalError x
+#define EXA_FatalErrorDebugWithRet(x, ret) FatalError x
+#else
+#define EXA_FatalErrorDebug(x) ErrorF x
+#define EXA_FatalErrorDebugWithRet(x, ret) \
+do { \
+    ErrorF x; \
+    return ret; \
+} while (0)
+#endif
+
+/**
+ * This is the list of migration heuristics supported by EXA.  See
+ * exaDoMigration() for what their implementations do.
+ */
+enum ExaMigrationHeuristic {
+    ExaMigrationGreedy,
+    ExaMigrationAlways,
+    ExaMigrationSmart
+};
+
+typedef struct {
+    unsigned char sha1[20];
+} ExaCachedGlyphRec, *ExaCachedGlyphPtr;
+
+typedef struct {
+    /* The identity of the cache, statically configured at initialization */
+    unsigned int format;
+    int glyphWidth;
+    int glyphHeight;
+
+    int size; /* Size of cache; eventually this should be dynamically determined */
+
+    /* Hash table mapping from glyph sha1 to position in the glyph; we use
+     * open addressing with a hash table size determined based on size and large
+     * enough so that we always have a good amount of free space, so we can
+     * use linear probing. (Linear probing is preferrable to double hashing
+     * here because it allows us to easily remove entries.)
+     */
+    int *hashEntries;
+    int hashSize;
+    
+    ExaCachedGlyphPtr glyphs;
+    int glyphCount; /* Current number of glyphs */
+    
+    PicturePtr picture;   /* Where the glyphs of the cache are stored */
+    int yOffset;          /* y location within the picture where the cache starts */
+    int columns;          /* Number of columns the glyphs are layed out in */
+    int evictionPosition; /* Next random position to evict a glyph */
+} ExaGlyphCacheRec, *ExaGlyphCachePtr;
+
+#define EXA_NUM_GLYPH_CACHES 4
+
+#define EXA_FALLBACK_COPYWINDOW (1 << 0)
+#define EXA_ACCEL_COPYWINDOW (1 << 1)
+
+typedef struct _ExaMigrationRec {
+    Bool as_dst;
+    Bool as_src;
+    PixmapPtr pPix;
+    RegionPtr pReg;
+} ExaMigrationRec, *ExaMigrationPtr;
+
+typedef void (*EnableDisableFBAccessProcPtr)(int, Bool);
+typedef struct {
+    ExaDriverPtr info;
+    ScreenBlockHandlerProcPtr	 SavedBlockHandler;
+    ScreenWakeupHandlerProcPtr	 SavedWakeupHandler;
+    CreateGCProcPtr 		 SavedCreateGC;
+    CloseScreenProcPtr 		 SavedCloseScreen;
+    GetImageProcPtr 		 SavedGetImage;
+    GetSpansProcPtr 		 SavedGetSpans;
+    CreatePixmapProcPtr 	 SavedCreatePixmap;
+    DestroyPixmapProcPtr 	 SavedDestroyPixmap;
+    CopyWindowProcPtr 		 SavedCopyWindow;
+    ChangeWindowAttributesProcPtr SavedChangeWindowAttributes;
+    BitmapToRegionProcPtr        SavedBitmapToRegion;
+    CreateScreenResourcesProcPtr SavedCreateScreenResources;
+    ModifyPixmapHeaderProcPtr    SavedModifyPixmapHeader;
+    SourceValidateProcPtr        SavedSourceValidate;
+    CompositeProcPtr             SavedComposite;
+    TrianglesProcPtr		 SavedTriangles;
+    GlyphsProcPtr                SavedGlyphs;
+    TrapezoidsProcPtr            SavedTrapezoids;
+    AddTrapsProcPtr		 SavedAddTraps;
+    void (*do_migration) (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+    Bool (*pixmap_has_gpu_copy) (PixmapPtr pPixmap);
+    void (*do_move_in_pixmap) (PixmapPtr pPixmap);
+    void (*do_move_out_pixmap) (PixmapPtr pPixmap);
+    void (*prepare_access_reg)(PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+    Bool			 swappedOut;
+    enum ExaMigrationHeuristic	 migration;
+    Bool			 checkDirtyCorrectness;
+    unsigned			 disableFbCount;
+    Bool			 optimize_migration;
+    unsigned			 offScreenCounter;
+    unsigned			 numOffscreenAvailable;
+    CARD32			 lastDefragment;
+    CARD32			 nextDefragment;
+    PixmapPtr			 deferred_mixed_pixmap;
+
+    /* Reference counting for accessed pixmaps */
+    struct {
+	PixmapPtr pixmap;
+	int count;
+	Bool retval;
+    } access[EXA_NUM_PREPARE_INDICES];
+
+    /* Holds information on fallbacks that cannot be relayed otherwise. */
+    unsigned int fallback_flags;
+    unsigned int fallback_counter;
+
+    ExaGlyphCacheRec             glyphCaches[EXA_NUM_GLYPH_CACHES];
+
+    /**
+     * Regions affected by fallback composite source / mask operations.
+     */
+
+    RegionRec srcReg;
+    RegionRec maskReg;
+    PixmapPtr srcPix;
+
+} ExaScreenPrivRec, *ExaScreenPrivPtr;
+
+/*
+ * This is the only completely portable way to
+ * compute this info.
+ */
+#ifndef BitsPerPixel
+#define BitsPerPixel(d) (\
+    PixmapWidthPaddingInfo[d].notPower2 ? \
+    (PixmapWidthPaddingInfo[d].bytesPerPixel * 8) : \
+    ((1 << PixmapWidthPaddingInfo[d].padBytesLog2) * 8 / \
+    (PixmapWidthPaddingInfo[d].padRoundUp+1)))
+#endif
+
+extern DevPrivateKeyRec exaScreenPrivateKeyRec;
+#define exaScreenPrivateKey (&exaScreenPrivateKeyRec)
+extern DevPrivateKeyRec exaPixmapPrivateKeyRec;
+#define exaPixmapPrivateKey (&exaPixmapPrivateKeyRec)
+extern DevPrivateKeyRec exaGCPrivateKeyRec;
+#define exaGCPrivateKey (&exaGCPrivateKeyRec)
+
+#define ExaGetScreenPriv(s) ((ExaScreenPrivPtr)dixLookupPrivate(&(s)->devPrivates, exaScreenPrivateKey))
+#define ExaScreenPriv(s)	ExaScreenPrivPtr    pExaScr = ExaGetScreenPriv(s)
+
+#define ExaGetGCPriv(gc) ((ExaGCPrivPtr)dixLookupPrivate(&(gc)->devPrivates, exaGCPrivateKey))
+#define ExaGCPriv(gc) ExaGCPrivPtr pExaGC = ExaGetGCPriv(gc)
+
+/*
+ * Some macros to deal with function wrapping.
+ */
+#define wrap(priv, real, mem, func) {\
+    priv->Saved##mem = real->mem; \
+    real->mem = func; \
+}
+
+#define unwrap(priv, real, mem) {\
+    real->mem = priv->Saved##mem; \
+}
+
+#define swap(priv, real, mem) {\
+    void *tmp = priv->Saved##mem; \
+    priv->Saved##mem = real->mem; \
+    real->mem = tmp; \
+}
+
+#define EXA_PRE_FALLBACK(_screen_) \
+    ExaScreenPriv(_screen_); \
+    pExaScr->fallback_counter++;
+
+#define EXA_POST_FALLBACK(_screen_) \
+    pExaScr->fallback_counter--;
+
+#define EXA_PRE_FALLBACK_GC(_gc_) \
+    ExaScreenPriv(_gc_->pScreen); \
+    ExaGCPriv(_gc_); \
+    pExaScr->fallback_counter++; \
+    swap(pExaGC, _gc_, ops);
+
+#define EXA_POST_FALLBACK_GC(_gc_) \
+    pExaScr->fallback_counter--; \
+    swap(pExaGC, _gc_, ops);
+
+/** Align an offset to an arbitrary alignment */
+#define EXA_ALIGN(offset, align) (((offset) + (align) - 1) - \
+	(((offset) + (align) - 1) % (align)))
+/** Align an offset to a power-of-two alignment */
+#define EXA_ALIGN2(offset, align) (((offset) + (align) - 1) & ~((align) - 1))
+
+#define EXA_PIXMAP_SCORE_MOVE_IN    10
+#define EXA_PIXMAP_SCORE_MAX	    20
+#define EXA_PIXMAP_SCORE_MOVE_OUT   -10
+#define EXA_PIXMAP_SCORE_MIN	    -20
+#define EXA_PIXMAP_SCORE_PINNED	    1000
+#define EXA_PIXMAP_SCORE_INIT	    1001
+
+#define ExaGetPixmapPriv(p) ((ExaPixmapPrivPtr)dixLookupPrivate(&(p)->devPrivates, exaPixmapPrivateKey))
+#define ExaSetPixmapPriv(p,a) dixSetPrivate(&(p)->devPrivates, exaPixmapPrivateKey, a)
+#define ExaPixmapPriv(p)	ExaPixmapPrivPtr pExaPixmap = ExaGetPixmapPriv(p)
+
+#define EXA_RANGE_PITCH (1 << 0)
+#define EXA_RANGE_WIDTH (1 << 1)
+#define EXA_RANGE_HEIGHT (1 << 2)
+
+typedef struct {
+    ExaOffscreenArea *area;
+    int		    score;	/**< score for the move-in vs move-out heuristic */
+    Bool	    use_gpu_copy;
+
+    CARD8	    *sys_ptr;	/**< pointer to pixmap data in system memory */
+    int		    sys_pitch;	/**< pitch of pixmap in system memory */
+
+    CARD8	    *fb_ptr;	/**< pointer to pixmap data in framebuffer memory */
+    int		    fb_pitch;	/**< pitch of pixmap in framebuffer memory */
+    unsigned int    fb_size;	/**< size of pixmap in framebuffer memory */
+
+    /**
+     * Holds information about whether this pixmap can be used for
+     * acceleration (== 0) or not (> 0).
+     *
+     * Contains a OR'ed combination of the following values:
+     * EXA_RANGE_PITCH - set if the pixmap's pitch is out of range
+     * EXA_RANGE_WIDTH - set if the pixmap's width is out of range
+     * EXA_RANGE_HEIGHT - set if the pixmap's height is out of range
+     */
+    unsigned int    accel_blocked;
+
+    /**
+     * The damage record contains the areas of the pixmap's current location
+     * (framebuffer or system) that have been damaged compared to the other
+     * location.
+     */
+    DamagePtr	    pDamage;
+    /**
+     * The valid regions mark the valid bits (at least, as they're derived from
+     * damage, which may be overreported) of a pixmap's system and FB copies.
+     */
+    RegionRec	    validSys, validFB;
+    /**
+     * Driver private storage per EXA pixmap
+     */
+    void *driverPriv;
+} ExaPixmapPrivRec, *ExaPixmapPrivPtr;
+
+typedef struct {
+    /* GC values from the layer below. */
+    GCOps *Savedops;
+    GCFuncs *Savedfuncs;
+} ExaGCPrivRec, *ExaGCPrivPtr;
+
+typedef struct {
+    PicturePtr pDst;
+    INT16 xSrc;
+    INT16 ySrc;
+    INT16 xMask;
+    INT16 yMask;
+    INT16 xDst;
+    INT16 yDst;
+    INT16 width;
+    INT16 height;
+} ExaCompositeRectRec, *ExaCompositeRectPtr;
+
+/**
+ * exaDDXDriverInit must be implemented by the DDX using EXA, and is the place
+ * to set EXA options or hook in screen functions to handle using EXA as the AA.
+  */
+void exaDDXDriverInit (ScreenPtr pScreen);
+
+/* exa_unaccel.c */
+void
+exaPrepareAccessGC(GCPtr pGC);
+
+void
+exaFinishAccessGC(GCPtr pGC);
+
+void
+ExaCheckFillSpans  (DrawablePtr pDrawable, GCPtr pGC, int nspans,
+		   DDXPointPtr ppt, int *pwidth, int fSorted);
+
+void
+ExaCheckSetSpans (DrawablePtr pDrawable, GCPtr pGC, char *psrc,
+		 DDXPointPtr ppt, int *pwidth, int nspans, int fSorted);
+
+void
+ExaCheckPutImage (DrawablePtr pDrawable, GCPtr pGC, int depth,
+		 int x, int y, int w, int h, int leftPad, int format,
+		 char *bits);
+
+void
+ExaCheckCopyNtoN (DrawablePtr pSrc, DrawablePtr pDst,  GCPtr pGC,
+	     BoxPtr	pbox, int nbox, int dx, int dy, Bool	reverse, 
+	     Bool upsidedown, Pixel bitplane, void *closure);
+
+RegionPtr
+ExaCheckCopyArea (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+		 int srcx, int srcy, int w, int h, int dstx, int dsty);
+
+RegionPtr
+ExaCheckCopyPlane (DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+		  int srcx, int srcy, int w, int h, int dstx, int dsty,
+		  unsigned long bitPlane);
+
+void
+ExaCheckPolyPoint (DrawablePtr pDrawable, GCPtr pGC, int mode, int npt,
+		  DDXPointPtr pptInit);
+
+void
+ExaCheckPolylines (DrawablePtr pDrawable, GCPtr pGC,
+		  int mode, int npt, DDXPointPtr ppt);
+
+void
+ExaCheckPolySegment (DrawablePtr pDrawable, GCPtr pGC,
+		    int nsegInit, xSegment *pSegInit);
+
+void
+ExaCheckPolyArc (DrawablePtr pDrawable, GCPtr pGC,
+		int narcs, xArc *pArcs);
+
+void
+ExaCheckPolyFillRect (DrawablePtr pDrawable, GCPtr pGC,
+		     int nrect, xRectangle *prect);
+
+void
+ExaCheckImageGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
+		      int x, int y, unsigned int nglyph,
+		      CharInfoPtr *ppci, pointer pglyphBase);
+
+void
+ExaCheckPolyGlyphBlt (DrawablePtr pDrawable, GCPtr pGC,
+		     int x, int y, unsigned int nglyph,
+		     CharInfoPtr *ppci, pointer pglyphBase);
+
+void
+ExaCheckPushPixels (GCPtr pGC, PixmapPtr pBitmap,
+		   DrawablePtr pDrawable,
+		   int w, int h, int x, int y);
+
+void
+ExaCheckCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+void
+ExaCheckGetImage(DrawablePtr pDrawable, int x, int y, int w, int h,
+		unsigned int format, unsigned long planeMask, char *d);
+
+void
+ExaCheckGetSpans (DrawablePtr pDrawable,
+		 int wMax,
+		 DDXPointPtr ppt,
+		 int *pwidth,
+		 int nspans,
+		 char *pdstStart);
+
+void
+ExaCheckAddTraps (PicturePtr	pPicture,
+		  INT16		x_off,
+		  INT16		y_off,
+		  int		ntrap,
+		  xTrap		*traps);
+
+/* exa_accel.c */
+
+static _X_INLINE Bool
+exaGCReadsDestination(DrawablePtr pDrawable, unsigned long planemask,
+		      unsigned int fillStyle, unsigned char alu,
+		      unsigned int clientClipType)
+{
+    return ((alu != GXcopy && alu != GXclear && alu != GXset &&
+	     alu != GXcopyInverted) || fillStyle == FillStippled ||
+	    clientClipType != CT_NONE || !EXA_PM_IS_SOLID(pDrawable, planemask));
+}
+
+void
+exaCopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+Bool
+exaFillRegionTiled (DrawablePtr	pDrawable, RegionPtr pRegion, PixmapPtr pTile,
+		    DDXPointPtr pPatOrg, CARD32 planemask, CARD32 alu,
+		    unsigned int clientClipType);
+
+void
+exaGetImage (DrawablePtr pDrawable, int x, int y, int w, int h,
+	     unsigned int format, unsigned long planeMask, char *d);
+
+RegionPtr
+exaCopyArea(DrawablePtr pSrcDrawable, DrawablePtr pDstDrawable, GCPtr pGC,
+	    int srcx, int srcy, int width, int height, int dstx, int dsty);
+
+Bool
+exaHWCopyNtoN (DrawablePtr    pSrcDrawable,
+	     DrawablePtr    pDstDrawable,
+	     GCPtr	    pGC,
+	     BoxPtr	    pbox,
+	     int	    nbox,
+	     int	    dx,
+	     int	    dy,
+	     Bool	    reverse,
+	     Bool	    upsidedown);
+
+void
+exaCopyNtoN (DrawablePtr    pSrcDrawable,
+	     DrawablePtr    pDstDrawable,
+	     GCPtr	    pGC,
+	     BoxPtr	    pbox,
+	     int	    nbox,
+	     int	    dx,
+	     int	    dy,
+	     Bool	    reverse,
+	     Bool	    upsidedown,
+	     Pixel	    bitplane,
+	     void	    *closure);
+
+extern const GCOps exaOps;
+
+void
+ExaCheckComposite (CARD8      op,
+		  PicturePtr pSrc,
+		  PicturePtr pMask,
+		  PicturePtr pDst,
+		  INT16      xSrc,
+		  INT16      ySrc,
+		  INT16      xMask,
+		  INT16      yMask,
+		  INT16      xDst,
+		  INT16      yDst,
+		  CARD16     width,
+		  CARD16     height);
+
+void
+ExaCheckGlyphs (CARD8	      op,
+		PicturePtr    pSrc,
+		PicturePtr    pDst,
+		PictFormatPtr maskFormat,
+		INT16	      xSrc,
+		INT16	      ySrc,
+		int	      nlist,
+		GlyphListPtr  list,
+		GlyphPtr      *glyphs);
+
+/* exa_offscreen.c */
+void
+ExaOffscreenSwapOut (ScreenPtr pScreen);
+
+void
+ExaOffscreenSwapIn (ScreenPtr pScreen);
+
+ExaOffscreenArea*
+ExaOffscreenDefragment (ScreenPtr pScreen);
+
+Bool
+exaOffscreenInit(ScreenPtr pScreen);
+
+void
+ExaOffscreenFini (ScreenPtr pScreen);
+
+/* exa.c */
+Bool
+ExaDoPrepareAccess(PixmapPtr pPixmap, int index);
+
+void
+exaPrepareAccess(DrawablePtr pDrawable, int index);
+
+void
+exaFinishAccess(DrawablePtr pDrawable, int index);
+
+void
+exaDestroyPixmap(PixmapPtr pPixmap);
+
+void
+exaPixmapDirty(PixmapPtr pPix, int x1, int y1, int x2, int y2);
+
+void
+exaGetDrawableDeltas (DrawablePtr pDrawable, PixmapPtr pPixmap,
+		      int *xp, int *yp);
+
+Bool
+exaPixmapHasGpuCopy(PixmapPtr p);
+
+PixmapPtr
+exaGetOffscreenPixmap (DrawablePtr pDrawable, int *xp, int *yp);
+
+PixmapPtr
+exaGetDrawablePixmap(DrawablePtr pDrawable);
+
+void
+exaSetFbPitch(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
+              int w, int h, int bpp);
+
+void
+exaSetAccelBlock(ExaScreenPrivPtr pExaScr, ExaPixmapPrivPtr pExaPixmap,
+                 int w, int h, int bpp);
+
+void
+exaDoMigration (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+Bool
+exaPixmapIsPinned (PixmapPtr pPix);
+
+extern const GCFuncs exaGCFuncs;
+
+/* exa_classic.c */
+PixmapPtr
+exaCreatePixmap_classic(ScreenPtr pScreen, int w, int h, int depth,
+		unsigned usage_hint);
+
+Bool
+exaModifyPixmapHeader_classic(PixmapPtr pPixmap, int width, int height, int depth,
+		      int bitsPerPixel, int devKind, pointer pPixData);
+
+Bool
+exaDestroyPixmap_classic (PixmapPtr pPixmap);
+
+Bool
+exaPixmapHasGpuCopy_classic(PixmapPtr pPixmap);
+
+/* exa_driver.c */
+PixmapPtr
+exaCreatePixmap_driver(ScreenPtr pScreen, int w, int h, int depth,
+		unsigned usage_hint);
+
+Bool
+exaModifyPixmapHeader_driver(PixmapPtr pPixmap, int width, int height, int depth,
+		      int bitsPerPixel, int devKind, pointer pPixData);
+
+Bool
+exaDestroyPixmap_driver (PixmapPtr pPixmap);
+
+Bool
+exaPixmapHasGpuCopy_driver(PixmapPtr pPixmap);
+
+/* exa_mixed.c */
+PixmapPtr
+exaCreatePixmap_mixed(ScreenPtr pScreen, int w, int h, int depth,
+		unsigned usage_hint);
+
+Bool
+exaModifyPixmapHeader_mixed(PixmapPtr pPixmap, int width, int height, int depth,
+		      int bitsPerPixel, int devKind, pointer pPixData);
+
+Bool
+exaDestroyPixmap_mixed(PixmapPtr pPixmap);
+
+Bool
+exaPixmapHasGpuCopy_mixed(PixmapPtr pPixmap);
+
+/* exa_migration_mixed.c */
+void
+exaCreateDriverPixmap_mixed(PixmapPtr pPixmap);
+
+void
+exaDoMigration_mixed(ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+void
+exaMoveInPixmap_mixed(PixmapPtr pPixmap);
+
+void
+exaDamageReport_mixed(DamagePtr pDamage, RegionPtr pRegion, void *closure);
+
+void
+exaPrepareAccessReg_mixed(PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+/* exa_render.c */
+Bool
+exaOpReadsDestination (CARD8 op);
+
+void
+exaComposite(CARD8	op,
+	     PicturePtr pSrc,
+	     PicturePtr pMask,
+	     PicturePtr pDst,
+	     INT16	xSrc,
+	     INT16	ySrc,
+	     INT16	xMask,
+	     INT16	yMask,
+	     INT16	xDst,
+	     INT16	yDst,
+	     CARD16	width,
+	     CARD16	height);
+
+void
+exaCompositeRects(CARD8	              op,
+		  PicturePtr	      Src,
+		  PicturePtr	      pMask,
+		  PicturePtr	      pDst,
+		  int                 nrect,
+		  ExaCompositeRectPtr rects);
+
+void
+exaTrapezoids (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+               PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
+               int ntrap, xTrapezoid *traps);
+
+void
+exaTriangles (CARD8 op, PicturePtr pSrc, PicturePtr pDst,
+	      PictFormatPtr maskFormat, INT16 xSrc, INT16 ySrc,
+	      int ntri, xTriangle *tris);
+
+/* exa_glyph.c */
+void
+exaGlyphsInit(ScreenPtr pScreen);
+
+void
+exaGlyphsFini (ScreenPtr pScreen);
+
+void
+exaGlyphs (CARD8	op,
+	  PicturePtr	pSrc,
+	  PicturePtr	pDst,
+	  PictFormatPtr	maskFormat,
+	  INT16		xSrc,
+	  INT16		ySrc,
+	  int		nlist,
+	  GlyphListPtr	list,
+	  GlyphPtr	*glyphs);
+
+/* exa_migration_classic.c */
+void
+exaCopyDirtyToSys (ExaMigrationPtr migrate);
+
+void
+exaCopyDirtyToFb (ExaMigrationPtr migrate);
+
+void
+exaDoMigration_classic (ExaMigrationPtr pixmaps, int npixmaps, Bool can_accel);
+
+void
+exaPixmapSave (ScreenPtr pScreen, ExaOffscreenArea *area);
+
+void
+exaMoveOutPixmap_classic (PixmapPtr pPixmap);
+
+void
+exaMoveInPixmap_classic (PixmapPtr pPixmap);
+
+void
+exaPrepareAccessReg_classic(PixmapPtr pPixmap, int index, RegionPtr pReg);
+
+#endif /* EXAPRIV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exa.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/exa.h
@@ -0,0 +1,843 @@
+/*
+ *
+ * Copyright (C) 2000 Keith Packard
+ *               2004 Eric Anholt
+ *               2005 Zack Rusin
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of copyright holders not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission. Copyright holders make no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+/** @file
+ * This is the header containing the public API of EXA for exa drivers.
+ */
+
+#ifndef EXA_H
+#define EXA_H
+
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "windowstr.h"
+#include "gcstruct.h"
+#include "picturestr.h"
+#include "fb.h"
+
+#define EXA_VERSION_MAJOR   2
+#define EXA_VERSION_MINOR   5
+#define EXA_VERSION_RELEASE 0
+
+typedef struct _ExaOffscreenArea ExaOffscreenArea;
+
+typedef void (*ExaOffscreenSaveProc) (ScreenPtr pScreen, ExaOffscreenArea *area);
+
+typedef enum _ExaOffscreenState {
+    ExaOffscreenAvail,
+    ExaOffscreenRemovable,
+    ExaOffscreenLocked
+} ExaOffscreenState;
+
+struct _ExaOffscreenArea {
+    int                 base_offset;	/* allocation base */
+    int                 offset;         /* aligned offset */
+    int                 size;           /* total allocation size */
+    unsigned            last_use;
+    pointer             privData;
+
+    ExaOffscreenSaveProc save;
+
+    ExaOffscreenState   state;
+
+    ExaOffscreenArea    *next;
+
+    unsigned            eviction_cost;
+
+    ExaOffscreenArea    *prev;          /* Double-linked list for defragmentation */
+    int                 align;          /* required alignment */
+};
+
+/**
+ * The ExaDriver structure is allocated through exaDriverAlloc(), and then
+ * fllled in by drivers.
+ */
+typedef struct _ExaDriver {
+    /**
+     * exa_major and exa_minor should be set by the driver to the version of
+     * EXA which the driver was compiled for (or configures itself at runtime
+     * to support).  This allows EXA to extend the structure for new features
+     * without breaking ABI for drivers compiled against older versions.
+     */
+    int exa_major, exa_minor;
+
+    /**
+     * memoryBase is the address of the beginning of framebuffer memory.
+     * The visible screen should be within memoryBase to memoryBase +
+     * memorySize.
+     */
+    CARD8         *memoryBase;
+
+    /**
+     * offScreenBase is the offset from memoryBase of the beginning of the area
+     * to be managed by EXA's linear offscreen memory manager.
+     *
+     * In XFree86 DDX drivers, this is probably:
+     *   (pScrn->displayWidth * cpp * pScrn->virtualY)
+     */
+    unsigned long  offScreenBase;
+
+    /**
+     * memorySize is the length (in bytes) of framebuffer memory beginning
+     * from memoryBase.
+     *
+     * The offscreen memory manager will manage the area beginning at
+     * (memoryBase + offScreenBase), with a length of (memorySize -
+     * offScreenBase)
+     *
+     * In XFree86 DDX drivers, this is probably (pScrn->videoRam * 1024)
+     */
+    unsigned long memorySize;
+
+    /**
+     * pixmapOffsetAlign is the byte alignment necessary for pixmap offsets
+     * within framebuffer.
+     *
+     * Hardware typically has a required alignment of offsets, which may or may
+     * not be a power of two.  EXA will ensure that pixmaps managed by the
+     * offscreen memory manager meet this alignment requirement.
+     */
+    int pixmapOffsetAlign;
+
+    /**
+     * pixmapPitchAlign is the byte alignment necessary for pixmap pitches
+     * within the framebuffer.
+     *
+     * Hardware typically has a required alignment of pitches for acceleration.
+     * For 3D hardware, Composite acceleration often requires that source and
+     * mask pixmaps (textures) have a power-of-two pitch, which can be demanded
+     * using EXA_OFFSCREEN_ALIGN_POT.  These pitch requirements only apply to
+     * pixmaps managed by the offscreen memory manager.  Thus, it is up to the
+     * driver to ensure that the visible screen has an appropriate pitch for
+     * acceleration.
+     */
+    int pixmapPitchAlign;
+
+    /**
+     * The flags field is bitfield of boolean values controlling EXA's behavior.
+     *
+     * The flags in clude EXA_OFFSCREEN_PIXMAPS, EXA_OFFSCREEN_ALIGN_POT, and
+     * EXA_TWO_BITBLT_DIRECTIONS.
+     */
+    int flags;
+
+    /** @{ */
+    /**
+     * maxX controls the X coordinate limitation for rendering from the card.
+     * The driver should never receive a request for rendering beyond maxX
+     * in the X direction from the origin of a pixmap.
+     */
+    int maxX;
+
+    /**
+     * maxY controls the Y coordinate limitation for rendering from the card.
+     * The driver should never receive a request for rendering beyond maxY
+     * in the Y direction from the origin of a pixmap.
+     */
+    int maxY;
+    /** @} */
+
+    /* private */
+    ExaOffscreenArea *offScreenAreas;
+    Bool              needsSync;
+    int               lastMarker;
+
+    /** @name Solid
+     * @{
+     */
+    /**
+     * PrepareSolid() sets up the driver for doing a solid fill.
+     * @param pPixmap Destination pixmap
+     * @param alu raster operation
+     * @param planemask write mask for the fill
+     * @param fg "foreground" color for the fill
+     *
+     * This call should set up the driver for doing a series of solid fills
+     * through the Solid() call.  The alu raster op is one of the GX*
+     * graphics functions listed in X.h, and typically maps to a similar
+     * single-byte "ROP" setting in all hardware.  The planemask controls
+     * which bits of the destination should be affected, and will only represent
+     * the bits up to the depth of pPixmap.  The fg is the pixel value of the
+     * foreground color referred to in ROP descriptions.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareSolid() call is required of all drivers, but it may fail for any
+     * reason.  Failure results in a fallback to software rendering.
+     */
+    Bool        (*PrepareSolid) (PixmapPtr      pPixmap,
+                                 int            alu,
+                                 Pixel          planemask,
+                                 Pixel          fg);
+
+    /**
+     * Solid() performs a solid fill set up in the last PrepareSolid() call.
+     *
+     * @param pPixmap destination pixmap
+     * @param x1 left coordinate
+     * @param y1 top coordinate
+     * @param x2 right coordinate
+     * @param y2 bottom coordinate
+     *
+     * Performs the fill set up by the last PrepareSolid() call, covering the
+     * area from (x1,y1) to (x2,y2) in pPixmap.  Note that the coordinates are
+     * in the coordinate space of the destination pixmap, so the driver will
+     * need to set up the hardware's offset and pitch for the destination
+     * coordinates according to the pixmap's offset and pitch within
+     * framebuffer.  This likely means using exaGetPixmapOffset() and
+     * exaGetPixmapPitch().
+     *
+     * This call is required if PrepareSolid() ever succeeds.
+     */
+    void        (*Solid) (PixmapPtr      pPixmap, int x1, int y1, int x2, int y2);
+
+    /**
+     * DoneSolid() finishes a set of solid fills.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneSolid() call is called at the end of a series of consecutive
+     * Solid() calls following a successful PrepareSolid().  This allows drivers
+     * to finish up emitting drawing commands that were buffered, or clean up
+     * state from PrepareSolid().
+     *
+     * This call is required if PrepareSolid() ever succeeds.
+     */
+    void        (*DoneSolid) (PixmapPtr      pPixmap);
+    /** @} */
+
+    /** @name Copy
+     * @{
+     */
+    /**
+     * PrepareCopy() sets up the driver for doing a copy within video 
+     * memory.
+     *
+     * @param pSrcPixmap source pixmap
+     * @param pDstPixmap destination pixmap
+     * @param dx X copy direction
+     * @param dy Y copy direction
+     * @param alu raster operation
+     * @param planemask write mask for the fill
+     *
+     * This call should set up the driver for doing a series of copies from the
+     * the pSrcPixmap to the pDstPixmap.  The dx flag will be positive if the
+     * hardware should do the copy from the left to the right, and dy will be
+     * positive if the copy should be done from the top to the bottom.  This
+     * is to deal with self-overlapping copies when pSrcPixmap == pDstPixmap.
+     * If your hardware can only support blits that are (left to right, top to
+     * bottom) or (right to left, bottom to top), then you should set
+     * #EXA_TWO_BITBLT_DIRECTIONS, and EXA will break down Copy operations to
+     * ones that meet those requirements.  The alu raster op is one of the GX*
+     * graphics functions listed in X.h, and typically maps to a similar
+     * single-byte "ROP" setting in all hardware.  The planemask controls which
+     * bits of the destination should be affected, and will only represent the
+     * bits up to the depth of pPixmap.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareCopy() call is required of all drivers, but it may fail for any
+     * reason.  Failure results in a fallback to software rendering.
+     */
+    Bool        (*PrepareCopy) (PixmapPtr       pSrcPixmap,
+                                PixmapPtr       pDstPixmap,
+                                int             dx,
+                                int             dy,
+                                int             alu,
+                                Pixel           planemask);
+
+    /**
+     * Copy() performs a copy set up in the last PrepareCopy call.
+     *
+     * @param pDstPixmap destination pixmap
+     * @param srcX source X coordinate
+     * @param srcY source Y coordinate
+     * @param dstX destination X coordinate
+     * @param dstY destination Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied.
+     *
+     * Performs the copy set up by the last PrepareCopy() call, copying the
+     * rectangle from (srcX, srcY) to (srcX + width, srcY + width) in the source
+     * pixmap to the same-sized rectangle at (dstX, dstY) in the destination
+     * pixmap.  Those rectangles may overlap in memory, if
+     * pSrcPixmap == pDstPixmap.  Note that this call does not receive the
+     * pSrcPixmap as an argument -- if it's needed in this function, it should
+     * be stored in the driver private during PrepareCopy().  As with Solid(),
+     * the coordinates are in the coordinate space of each pixmap, so the driver
+     * will need to set up source and destination pitches and offsets from those
+     * pixmaps, probably using exaGetPixmapOffset() and exaGetPixmapPitch().
+     *
+     * This call is required if PrepareCopy ever succeeds.
+     */
+    void        (*Copy) (PixmapPtr       pDstPixmap,
+                         int    srcX,
+                         int    srcY,
+                         int    dstX,
+                         int    dstY,
+                         int    width,
+                         int    height);
+
+    /**
+     * DoneCopy() finishes a set of copies.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneCopy() call is called at the end of a series of consecutive
+     * Copy() calls following a successful PrepareCopy().  This allows drivers
+     * to finish up emitting drawing commands that were buffered, or clean up
+     * state from PrepareCopy().
+     *
+     * This call is required if PrepareCopy() ever succeeds.
+     */
+    void        (*DoneCopy) (PixmapPtr       pDstPixmap);
+    /** @} */
+
+    /** @name Composite
+     * @{
+     */
+    /**
+     * CheckComposite() checks to see if a composite operation could be
+     * accelerated.
+     *
+     * @param op Render operation
+     * @param pSrcPicture source Picture
+     * @param pMaskPicture mask picture
+     * @param pDstPicture destination Picture
+     *
+     * The CheckComposite() call checks if the driver could handle acceleration
+     * of op with the given source, mask, and destination pictures.  This allows
+     * drivers to check source and destination formats, supported operations,
+     * transformations, and component alpha state, and send operations it can't
+     * support to software rendering early on.  This avoids costly pixmap
+     * migration to the wrong places when the driver can't accelerate
+     * operations.  Note that because migration hasn't happened, the driver
+     * can't know during CheckComposite() what the offsets and pitches of the
+     * pixmaps are going to be.
+     *
+     * See PrepareComposite() for more details on likely issues that drivers
+     * will have in accelerating Composite operations.
+     *
+     * The CheckComposite() call is recommended if PrepareComposite() is
+     * implemented, but is not required.
+     */
+    Bool        (*CheckComposite) (int          op,
+                                   PicturePtr   pSrcPicture,
+                                   PicturePtr   pMaskPicture,
+                                   PicturePtr   pDstPicture);
+
+    /**
+     * PrepareComposite() sets up the driver for doing a Composite operation
+     * described in the Render extension protocol spec.
+     *
+     * @param op Render operation
+     * @param pSrcPicture source Picture
+     * @param pMaskPicture mask picture
+     * @param pDstPicture destination Picture
+     * @param pSrc source pixmap
+     * @param pMask mask pixmap
+     * @param pDst destination pixmap
+     *
+     * This call should set up the driver for doing a series of Composite
+     * operations, as described in the Render protocol spec, with the given
+     * pSrcPicture, pMaskPicture, and pDstPicture.  The pSrc, pMask, and
+     * pDst are the pixmaps containing the pixel data, and should be used for
+     * setting the offset and pitch used for the coordinate spaces for each of
+     * the Pictures.
+     *
+     * Notes on interpreting Picture structures:
+     * - The Picture structures will always have a valid pDrawable.
+     * - The Picture structures will never have alphaMap set.
+     * - The mask Picture (and therefore pMask) may be NULL, in which case the
+     *   operation is simply src OP dst instead of src IN mask OP dst, and
+     *   mask coordinates should be ignored.
+     * - pMarkPicture may have componentAlpha set, which greatly changes
+     *   the behavior of the Composite operation.  componentAlpha has no effect
+     *   when set on pSrcPicture or pDstPicture.
+     * - The source and mask Pictures may have a transformation set
+     *   (Picture->transform != NULL), which means that the source coordinates
+     *   should be transformed by that transformation, resulting in scaling,
+     *   rotation, etc.  The PictureTransformPoint() call can transform
+     *   coordinates for you.  Transforms have no effect on Pictures when used
+     *   as a destination.
+     * - The source and mask pictures may have a filter set.  PictFilterNearest
+     *   and PictFilterBilinear are defined in the Render protocol, but others
+     *   may be encountered, and must be handled correctly (usually by
+     *   PrepareComposite failing, and falling back to software).  Filters have
+     *   no effect on Pictures when used as a destination.
+     * - The source and mask Pictures may have repeating set, which must be
+     *   respected.  Many chipsets will be unable to support repeating on
+     *   pixmaps that have a width or height that is not a power of two.
+     *
+     * If your hardware can't support source pictures (textures) with
+     * non-power-of-two pitches, you should set #EXA_OFFSCREEN_ALIGN_POT.
+     *
+     * Note that many drivers will need to store some of the data in the driver
+     * private record, for sending to the hardware with each drawing command.
+     *
+     * The PrepareComposite() call is not required.  However, it is highly
+     * recommended for performance of antialiased font rendering and performance
+     * of cairo applications.  Failure results in a fallback to software
+     * rendering.
+     */
+    Bool        (*PrepareComposite) (int                op,
+                                     PicturePtr         pSrcPicture,
+                                     PicturePtr         pMaskPicture,
+                                     PicturePtr         pDstPicture,
+                                     PixmapPtr          pSrc,
+                                     PixmapPtr          pMask,
+                                     PixmapPtr          pDst);
+
+    /**
+     * Composite() performs a Composite operation set up in the last
+     * PrepareComposite() call.
+     *
+     * @param pDstPixmap destination pixmap
+     * @param srcX source X coordinate
+     * @param srcY source Y coordinate
+     * @param maskX source X coordinate
+     * @param maskY source Y coordinate
+     * @param dstX destination X coordinate
+     * @param dstY destination Y coordinate
+     * @param width destination rectangle width
+     * @param height destination rectangle height
+     *
+     * Performs the Composite operation set up by the last PrepareComposite()
+     * call, to the rectangle from (dstX, dstY) to (dstX + width, dstY + height)
+     * in the destination Pixmap.  Note that if a transformation was set on
+     * the source or mask Pictures, the source rectangles may not be the same
+     * size as the destination rectangles and filtering.  Getting the coordinate
+     * transformation right at the subpixel level can be tricky, and rendercheck
+     * can test this for you.
+     *
+     * This call is required if PrepareComposite() ever succeeds.
+     */
+    void        (*Composite) (PixmapPtr         pDst,
+                              int       srcX,
+                              int        srcY,
+                              int        maskX,
+                              int        maskY,
+                              int        dstX,
+                              int        dstY,
+                              int        width,
+                              int        height);
+
+    /**
+     * DoneComposite() finishes a set of Composite operations.
+     *
+     * @param pPixmap destination pixmap.
+     *
+     * The DoneComposite() call is called at the end of a series of consecutive
+     * Composite() calls following a successful PrepareComposite().  This allows
+     * drivers to finish up emitting drawing commands that were buffered, or
+     * clean up state from PrepareComposite().
+     *
+     * This call is required if PrepareComposite() ever succeeds.
+     */
+    void        (*DoneComposite) (PixmapPtr         pDst);
+    /** @} */
+
+    /**
+     * UploadToScreen() loads a rectangle of data from src into pDst.
+     *
+     * @param pDst destination pixmap
+     * @param x destination X coordinate.
+     * @param y destination Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied
+     * @param src pointer to the beginning of the source data
+     * @param src_pitch pitch (in bytes) of the lines of source data.
+     *
+     * UploadToScreen() copies data in system memory beginning at src (with
+     * pitch src_pitch) into the destination pixmap from (x, y) to
+     * (x + width, y + height).  This is typically done with hostdata uploads,
+     * where the CPU sets up a blit command on the hardware with instructions
+     * that the blit data will be fed through some sort of aperture on the card.
+     *
+     * If UploadToScreen() is performed asynchronously, it is up to the driver
+     * to call exaMarkSync().  This is in contrast to most other acceleration
+     * calls in EXA.
+     *
+     * UploadToScreen() can aid in pixmap migration, but is most important for
+     * the performance of exaGlyphs() (antialiased font drawing) by allowing
+     * pipelining of data uploads, avoiding a sync of the card after each glyph.
+     * 
+     * @return TRUE if the driver successfully uploaded the data.  FALSE
+     * indicates that EXA should fall back to doing the upload in software.
+     *
+     * UploadToScreen() is not required, but is recommended if Composite
+     * acceleration is supported.
+     */
+    Bool        (*UploadToScreen) (PixmapPtr            pDst,
+				   int                  x,
+				   int                  y,
+				   int                  w,
+				   int                  h,
+                                   char                 *src,
+                                   int                  src_pitch);
+
+    /**
+     * UploadToScratch() is no longer used and will be removed next time the EXA
+     * major version needs to be bumped.
+     */
+    Bool        (*UploadToScratch) (PixmapPtr           pSrc,
+                                    PixmapPtr           pDst);
+
+    /**
+     * DownloadFromScreen() loads a rectangle of data from pSrc into dst
+     *
+     * @param pSrc source pixmap
+     * @param x source X coordinate.
+     * @param y source Y coordinate
+     * @param width width of the rectangle to be copied
+     * @param height height of the rectangle to be copied
+     * @param dst pointer to the beginning of the destination data
+     * @param dst_pitch pitch (in bytes) of the lines of destination data.
+     *
+     * DownloadFromScreen() copies data from offscreen memory in pSrc from
+     * (x, y) to (x + width, y + height), to system memory starting at
+     * dst (with pitch dst_pitch).  This would usually be done
+     * using scatter-gather DMA, supported by a DRM call, or by blitting to AGP
+     * and then synchronously reading from AGP.  Because the implementation
+     * might be synchronous, EXA leaves it up to the driver to call
+     * exaMarkSync() if DownloadFromScreen() was asynchronous.  This is in
+     * contrast to most other acceleration calls in EXA.
+     *
+     * DownloadFromScreen() can aid in the largest bottleneck in pixmap
+     * migration, which is the read from framebuffer when evicting pixmaps from
+     * framebuffer memory.  Thus, it is highly recommended, even though
+     * implementations are typically complicated.
+     * 
+     * @return TRUE if the driver successfully downloaded the data.  FALSE
+     * indicates that EXA should fall back to doing the download in software.
+     *
+     * DownloadFromScreen() is not required, but is highly recommended.
+     */
+    Bool (*DownloadFromScreen)(PixmapPtr pSrc,
+                               int x,  int y,
+                               int w,  int h,
+                               char *dst,  int dst_pitch);
+
+    /**
+     * MarkSync() requests that the driver mark a synchronization point,
+     * returning an driver-defined integer marker which could be requested for
+     * synchronization to later in WaitMarker().  This might be used in the
+     * future to avoid waiting for full hardware stalls before accessing pixmap
+     * data with the CPU, but is not important in the current incarnation of
+     * EXA.
+     *
+     * Note that drivers should call exaMarkSync() when they have done some
+     * acceleration, rather than their own MarkSync() handler, as otherwise EXA
+     * will be unaware of the driver's acceleration and not sync to it during
+     * fallbacks.
+     *
+     * MarkSync() is optional.
+     */
+    int		(*MarkSync)   (ScreenPtr pScreen);
+
+    /**
+     * WaitMarker() waits for all rendering before the given marker to have
+     * completed.  If the driver does not implement MarkSync(), marker is
+     * meaningless, and all rendering by the hardware should be completed before
+     * WaitMarker() returns.
+     *
+     * Note that drivers should call exaWaitSync() to wait for all acceleration
+     * to finish, as otherwise EXA will be unaware of the driver having
+     * synchronized, resulting in excessive WaitMarker() calls.
+     *
+     * WaitMarker() is required of all drivers.
+     */
+    void	(*WaitMarker) (ScreenPtr pScreen, int marker);
+
+    /** @{ */
+    /**
+     * PrepareAccess() is called before CPU access to an offscreen pixmap.
+     *
+     * @param pPix the pixmap being accessed
+     * @param index the index of the pixmap being accessed.
+     *
+     * PrepareAccess() will be called before CPU access to an offscreen pixmap.
+     * This can be used to set up hardware surfaces for byteswapping or
+     * untiling, or to adjust the pixmap's devPrivate.ptr for the purpose of
+     * making CPU access use a different aperture.
+     *
+     * The index is one of #EXA_PREPARE_DEST, #EXA_PREPARE_SRC,
+     * #EXA_PREPARE_MASK, #EXA_PREPARE_AUX_DEST, #EXA_PREPARE_AUX_SRC, or
+     * #EXA_PREPARE_AUX_MASK. Since only up to #EXA_NUM_PREPARE_INDICES pixmaps
+     * will have PrepareAccess() called on them per operation, drivers can have
+     * a small, statically-allocated space to maintain state for PrepareAccess()
+     * and FinishAccess() in.  Note that PrepareAccess() is only called once per
+     * pixmap and operation, regardless of whether the pixmap is used as a
+     * destination and/or source, and the index may not reflect the usage.
+     *
+     * PrepareAccess() may fail.  An example might be the case of hardware that
+     * can set up 1 or 2 surfaces for CPU access, but not 3.  If PrepareAccess()
+     * fails, EXA will migrate the pixmap to system memory.
+     * DownloadFromScreen() must be implemented and must not fail if a driver
+     * wishes to fail in PrepareAccess().  PrepareAccess() must not fail when
+     * pPix is the visible screen, because the visible screen can not be
+     * migrated.
+     *
+     * @return TRUE if PrepareAccess() successfully prepared the pixmap for CPU
+     * drawing.
+     * @return FALSE if PrepareAccess() is unsuccessful and EXA should use
+     * DownloadFromScreen() to migate the pixmap out.
+     */
+    Bool	(*PrepareAccess)(PixmapPtr pPix, int index);
+
+    /**
+     * FinishAccess() is called after CPU access to an offscreen pixmap.
+     *
+     * @param pPix the pixmap being accessed
+     * @param index the index of the pixmap being accessed.
+     *
+     * FinishAccess() will be called after finishing CPU access of an offscreen
+     * pixmap set up by PrepareAccess().  Note that the FinishAccess() will not be
+     * called if PrepareAccess() failed and the pixmap was migrated out.
+     */
+    void	(*FinishAccess)(PixmapPtr pPix, int index);
+
+    /**
+     * PixmapIsOffscreen() is an optional driver replacement to
+     * exaPixmapHasGpuCopy(). Set to NULL if you want the standard behaviour
+     * of exaPixmapHasGpuCopy().
+     *
+     * @param pPix the pixmap
+     * @return TRUE if the given drawable is in framebuffer memory.
+     *
+     * exaPixmapHasGpuCopy() is used to determine if a pixmap is in offscreen
+     * memory, meaning that acceleration could probably be done to it, and that it
+     * will need to be wrapped by PrepareAccess()/FinishAccess() when accessing it
+     * with the CPU.
+     *
+     *
+     */
+    Bool	(*PixmapIsOffscreen)(PixmapPtr pPix);
+
+	/** @name PrepareAccess() and FinishAccess() indices
+	 * @{
+	 */
+	/**
+	 * EXA_PREPARE_DEST is the index for a pixmap that may be drawn to or
+	 * read from.
+	 */ 
+	#define EXA_PREPARE_DEST	0
+	/**
+	 * EXA_PREPARE_SRC is the index for a pixmap that may be read from
+	 */
+	#define EXA_PREPARE_SRC		1
+	/**
+	 * EXA_PREPARE_SRC is the index for a second pixmap that may be read
+	 * from.
+	 */
+	#define EXA_PREPARE_MASK	2
+	/**
+	 * EXA_PREPARE_AUX* are additional indices for other purposes, e.g.
+	 * separate alpha maps with Composite operations.
+	 */
+	#define EXA_PREPARE_AUX_DEST	3
+	#define EXA_PREPARE_AUX_SRC	4
+	#define EXA_PREPARE_AUX_MASK	5
+	#define EXA_NUM_PREPARE_INDICES	6
+	/** @} */
+
+    /**
+     * maxPitchPixels controls the pitch limitation for rendering from
+     * the card.
+     * The driver should never receive a request for rendering a pixmap
+     * that has a pitch (in pixels) beyond maxPitchPixels.
+     *
+     * Setting this field is optional -- if your hardware doesn't have
+     * a pitch limitation in pixels, don't set this. If neither this value
+     * nor maxPitchBytes is set, then maxPitchPixels is set to maxX.
+     * If set, it must not be smaller than maxX.
+     *
+     * @sa maxPitchBytes
+     */
+    int maxPitchPixels;
+
+    /**
+     * maxPitchBytes controls the pitch limitation for rendering from
+     * the card.
+     * The driver should never receive a request for rendering a pixmap
+     * that has a pitch (in bytes) beyond maxPitchBytes.
+     *
+     * Setting this field is optional -- if your hardware doesn't have
+     * a pitch limitation in bytes, don't set this.
+     * If set, it must not be smaller than maxX * 4.
+     * There's no default value for maxPitchBytes.
+     *
+     * @sa maxPitchPixels
+     */
+    int maxPitchBytes;
+
+    /* Hooks to allow driver to its own pixmap memory management */
+    void *(*CreatePixmap)(ScreenPtr pScreen, int size, int align);
+    void (*DestroyPixmap)(ScreenPtr pScreen, void *driverPriv);
+    /**
+     * Returning a pixmap with non-NULL devPrivate.ptr implies a pixmap which is
+     * not offscreen, which will never be accelerated and Prepare/FinishAccess won't
+     * be called.
+     */
+    Bool (*ModifyPixmapHeader)(PixmapPtr pPixmap, int width, int height,
+                              int depth, int bitsPerPixel, int devKind,
+                              pointer pPixData);
+
+    /* hooks for drivers with tiling support:
+     * driver MUST fill out new_fb_pitch with valid pitch of pixmap
+     */
+    void *(*CreatePixmap2)(ScreenPtr pScreen, int width, int height,
+			   int depth, int usage_hint, int bitsPerPixel,
+			   int *new_fb_pitch);
+    /** @} */
+} ExaDriverRec, *ExaDriverPtr;
+
+/** @name EXA driver flags
+ * @{
+ */
+/**
+ * EXA_OFFSCREEN_PIXMAPS indicates to EXA that the driver can support 
+ * offscreen pixmaps.
+ */
+#define EXA_OFFSCREEN_PIXMAPS		(1 << 0)
+
+/**
+ * EXA_OFFSCREEN_ALIGN_POT indicates to EXA that the driver needs pixmaps
+ * to have a power-of-two pitch.
+ */
+#define EXA_OFFSCREEN_ALIGN_POT		(1 << 1)
+
+/**
+ * EXA_TWO_BITBLT_DIRECTIONS indicates to EXA that the driver can only
+ * support copies that are (left-to-right, top-to-bottom) or
+ * (right-to-left, bottom-to-top).
+ */
+#define EXA_TWO_BITBLT_DIRECTIONS	(1 << 2)
+
+/**
+ * EXA_HANDLES_PIXMAPS indicates to EXA that the driver can handle
+ * all pixmap addressing and migration.
+ */
+#define EXA_HANDLES_PIXMAPS             (1 << 3)
+
+/**
+ * EXA_SUPPORTS_PREPARE_AUX indicates to EXA that the driver can handle the
+ * EXA_PREPARE_AUX* indices in the Prepare/FinishAccess hooks. If there are no
+ * such hooks, this flag has no effect.
+ */
+#define EXA_SUPPORTS_PREPARE_AUX        (1 << 4)
+
+/**
+ * EXA_SUPPORTS_OFFSCREEN_OVERLAPS indicates to EXA that the driver Copy hooks
+ * can handle the source and destination occupying overlapping offscreen memory
+ * areas. This allows the offscreen memory defragmentation code to defragment
+ * areas where the defragmented position overlaps the fragmented position.
+ *
+ * Typically this is supported by traditional 2D engines but not by 3D engines.
+ */
+#define EXA_SUPPORTS_OFFSCREEN_OVERLAPS (1 << 5)
+
+/**
+ * EXA_MIXED_PIXMAPS will hide unacceleratable pixmaps from drivers and manage the
+ * problem known software fallbacks like trapezoids. This only migrates pixmaps one way
+ * into a driver pixmap and then pins it.
+ */
+#define EXA_MIXED_PIXMAPS (1 << 6)
+
+/** @} */
+
+/* in exa.c */
+extern _X_EXPORT ExaDriverPtr
+exaDriverAlloc(void);
+
+extern _X_EXPORT Bool
+exaDriverInit(ScreenPtr      pScreen,
+              ExaDriverPtr   pScreenInfo);
+
+extern _X_EXPORT void
+exaDriverFini(ScreenPtr      pScreen);
+
+extern _X_EXPORT void
+exaMarkSync(ScreenPtr pScreen);
+extern _X_EXPORT void
+exaWaitSync(ScreenPtr pScreen);
+
+extern _X_EXPORT unsigned long
+exaGetPixmapOffset(PixmapPtr pPix);
+
+extern _X_EXPORT unsigned long
+exaGetPixmapPitch(PixmapPtr pPix);
+
+extern _X_EXPORT unsigned long
+exaGetPixmapSize(PixmapPtr pPix);
+
+extern _X_EXPORT void *
+exaGetPixmapDriverPrivate(PixmapPtr p);
+
+
+/* in exa_offscreen.c */
+extern _X_EXPORT ExaOffscreenArea *
+exaOffscreenAlloc(ScreenPtr pScreen, int size, int align,
+                  Bool locked,
+                  ExaOffscreenSaveProc save,
+                  pointer privData);
+
+extern _X_EXPORT ExaOffscreenArea *
+exaOffscreenFree(ScreenPtr pScreen, ExaOffscreenArea *area);
+
+extern _X_EXPORT void
+ExaOffscreenMarkUsed (PixmapPtr pPixmap);
+
+extern _X_EXPORT void
+exaEnableDisableFBAccess (int index, Bool enable);
+
+extern _X_EXPORT Bool
+exaDrawableIsOffscreen (DrawablePtr pDrawable);
+
+/* in exa.c */
+extern _X_EXPORT void
+exaMoveInPixmap (PixmapPtr pPixmap);
+
+extern _X_EXPORT void
+exaMoveOutPixmap (PixmapPtr pPixmap);
+
+
+/* in exa_unaccel.c */
+extern _X_EXPORT CARD32
+exaGetPixmapFirstPixel (PixmapPtr pPixmap);
+
+
+/**
+ * Returns TRUE if the given planemask covers all the significant bits in the
+ * pixel values for pDrawable.
+ */
+#define EXA_PM_IS_SOLID(_pDrawable, _pm) \
+	(((_pm) & FbFullMask((_pDrawable)->depth)) == \
+	 FbFullMask((_pDrawable)->depth))
+
+#endif /* EXA_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/devbell.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/devbell.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DEVBELL_H
+#define DEVBELL_H 1
+
+int SProcXDeviceBell(ClientPtr	/* client */
+    );
+
+int ProcXDeviceBell(ClientPtr	/* client */
+    );
+
+#endif /* DEVBELL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xfixesint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xfixesint.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright © 2002 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XFIXESINT_H_
+#define _XFIXESINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/xfixesproto.h>
+#include "windowstr.h"
+#include "selection.h"
+#include "xfixes.h"
+
+extern int		XFixesEventBase;
+
+typedef struct _XFixesClient {
+    CARD32	major_version;
+    CARD32	minor_version;
+} XFixesClientRec, *XFixesClientPtr;
+
+#define GetXFixesClient(pClient) ((XFixesClientPtr)dixLookupPrivate(&(pClient)->devPrivates, XFixesClientPrivateKey))
+
+extern int	(*ProcXFixesVector[XFixesNumberRequests])(ClientPtr);
+
+/* Initialize extension at server startup time */
+
+void
+XFixesExtensionInit(void);
+
+/* Save set */
+int
+ProcXFixesChangeSaveSet(ClientPtr client);
+    
+int
+SProcXFixesChangeSaveSet(ClientPtr client);
+    
+/* Selection events */
+int
+ProcXFixesSelectSelectionInput (ClientPtr client);
+
+int
+SProcXFixesSelectSelectionInput (ClientPtr client);
+
+void
+SXFixesSelectionNotifyEvent (xXFixesSelectionNotifyEvent *from,
+			     xXFixesSelectionNotifyEvent *to);
+Bool
+XFixesSelectionInit (void);
+
+/* Cursor notification */
+Bool
+XFixesCursorInit (void);
+    
+int
+ProcXFixesSelectCursorInput (ClientPtr client);
+
+int
+SProcXFixesSelectCursorInput (ClientPtr client);
+
+void
+SXFixesCursorNotifyEvent (xXFixesCursorNotifyEvent *from,
+			  xXFixesCursorNotifyEvent *to);
+
+int
+ProcXFixesGetCursorImage (ClientPtr client);
+
+int
+SProcXFixesGetCursorImage (ClientPtr client);
+
+/* Cursor names (Version 2) */
+
+int
+ProcXFixesSetCursorName (ClientPtr client);
+
+int
+SProcXFixesSetCursorName (ClientPtr client);
+
+int
+ProcXFixesGetCursorName (ClientPtr client);
+
+int
+SProcXFixesGetCursorName (ClientPtr client);
+
+int
+ProcXFixesGetCursorImageAndName (ClientPtr client);
+
+int
+SProcXFixesGetCursorImageAndName (ClientPtr client);
+
+/* Cursor replacement (Version 2) */
+
+int
+ProcXFixesChangeCursor (ClientPtr client);
+
+int
+SProcXFixesChangeCursor (ClientPtr client);
+
+int
+ProcXFixesChangeCursorByName (ClientPtr client);
+
+int
+SProcXFixesChangeCursorByName (ClientPtr client);
+
+/* Region objects (Version 2* */
+Bool
+XFixesRegionInit (void);
+
+int
+ProcXFixesCreateRegion (ClientPtr client);
+
+int
+SProcXFixesCreateRegion (ClientPtr client);
+
+int
+ProcXFixesCreateRegionFromBitmap (ClientPtr client);
+
+int
+SProcXFixesCreateRegionFromBitmap (ClientPtr client);
+
+int
+ProcXFixesCreateRegionFromWindow (ClientPtr client);
+
+int
+SProcXFixesCreateRegionFromWindow (ClientPtr client);
+
+int
+ProcXFixesCreateRegionFromGC (ClientPtr client);
+
+int
+SProcXFixesCreateRegionFromGC (ClientPtr client);
+
+int
+ProcXFixesCreateRegionFromPicture (ClientPtr client);
+
+int
+SProcXFixesCreateRegionFromPicture (ClientPtr client);
+
+int
+ProcXFixesDestroyRegion (ClientPtr client);
+
+int
+SProcXFixesDestroyRegion (ClientPtr client);
+
+int
+ProcXFixesSetRegion (ClientPtr client);
+
+int
+SProcXFixesSetRegion (ClientPtr client);
+
+int
+ProcXFixesCopyRegion (ClientPtr client);
+
+int
+SProcXFixesCopyRegion (ClientPtr client);
+
+int
+ProcXFixesCombineRegion (ClientPtr client);
+
+int
+SProcXFixesCombineRegion (ClientPtr client);
+
+int
+ProcXFixesInvertRegion (ClientPtr client);
+
+int
+SProcXFixesInvertRegion (ClientPtr client);
+
+int
+ProcXFixesTranslateRegion (ClientPtr client);
+
+int
+SProcXFixesTranslateRegion (ClientPtr client);
+
+int
+ProcXFixesRegionExtents (ClientPtr client);
+
+int
+SProcXFixesRegionExtents (ClientPtr client);
+
+int
+ProcXFixesFetchRegion (ClientPtr client);
+
+int
+SProcXFixesFetchRegion (ClientPtr client);
+
+int
+ProcXFixesSetGCClipRegion (ClientPtr client);
+
+int
+SProcXFixesSetGCClipRegion (ClientPtr client);
+
+int
+ProcXFixesSetWindowShapeRegion (ClientPtr client);
+
+int
+SProcXFixesSetWindowShapeRegion (ClientPtr client);
+
+int
+ProcXFixesSetPictureClipRegion (ClientPtr client);
+
+int
+SProcXFixesSetPictureClipRegion (ClientPtr client);
+
+int
+ProcXFixesExpandRegion (ClientPtr client);
+
+int
+SProcXFixesExpandRegion (ClientPtr client);
+
+/* Cursor Visibility (Version 4) */
+
+int 
+ProcXFixesHideCursor (ClientPtr client);
+
+int 
+SProcXFixesHideCursor (ClientPtr client);
+
+int 
+ProcXFixesShowCursor (ClientPtr client);
+
+int 
+SProcXFixesShowCursor (ClientPtr client);
+
+#endif /* _XFIXESINT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fourcc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fourcc.h
@@ -0,0 +1,160 @@
+
+/*
+ * Copyright (c) 2000-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+   This header file contains listings of STANDARD guids for video formats.
+   Please do not place non-registered, or incomplete entries in this file.
+   A list of some popular fourcc's are at: http://www.webartz.com/fourcc/
+   For an explanation of fourcc <-> guid mappings see RFC2361.
+*/
+
+#ifndef _XF86_FOURCC_H_
+#define _XF86_FOURCC_H_ 1
+
+#define FOURCC_YUY2 0x32595559
+#define XVIMAGE_YUY2 \
+   { \
+	FOURCC_YUY2, \
+        XvYUV, \
+	LSBFirst, \
+	{'Y','U','Y','2', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	16, \
+	XvPacked, \
+	1, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 1, 1, \
+	{'Y','U','Y','V', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_YV12 0x32315659
+#define XVIMAGE_YV12 \
+   { \
+	FOURCC_YV12, \
+        XvYUV, \
+	LSBFirst, \
+	{'Y','V','1','2', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	12, \
+	XvPlanar, \
+	3, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 2, 2, \
+	{'Y','V','U', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_I420 0x30323449
+#define XVIMAGE_I420 \
+   { \
+	FOURCC_I420, \
+        XvYUV, \
+	LSBFirst, \
+	{'I','4','2','0', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	12, \
+	XvPlanar, \
+	3, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 2, 2, \
+	{'Y','U','V', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+
+#define FOURCC_UYVY 0x59565955
+#define XVIMAGE_UYVY \
+   { \
+	FOURCC_UYVY, \
+        XvYUV, \
+	LSBFirst, \
+	{'U','Y','V','Y', \
+	  0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+	16, \
+	XvPacked, \
+	1, \
+	0, 0, 0, 0, \
+	8, 8, 8, \
+	1, 2, 2, \
+	1, 1, 1, \
+	{'U','Y','V','Y', \
+	  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+	XvTopToBottom \
+   }
+
+#define FOURCC_IA44 0x34344149
+#define XVIMAGE_IA44 \
+   { \
+        FOURCC_IA44, \
+        XvYUV, \
+        LSBFirst, \
+        {'I','A','4','4', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        8, \
+        XvPacked, \
+        1, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 1, 1, \
+        1, 1, 1, \
+        {'A','I', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+#define FOURCC_AI44 0x34344941
+#define XVIMAGE_AI44 \
+   { \
+        FOURCC_AI44, \
+        XvYUV, \
+        LSBFirst, \
+        {'A','I','4','4', \
+          0x00,0x00,0x00,0x10,0x80,0x00,0x00,0xAA,0x00,0x38,0x9B,0x71}, \
+        8, \
+        XvPacked, \
+        1, \
+        0, 0, 0, 0, \
+        8, 8, 8, \
+        1, 1, 1, \
+        1, 1, 1, \
+        {'I','A', \
+          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}, \
+        XvTopToBottom \
+   }
+
+#endif /* _XF86_FOURCC_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Modes.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Modes.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright  2006 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Authors:
+ *    Eric Anholt <eric@anholt.net>
+ *
+ */
+
+#ifndef _XF86MODES_H_
+#define _XF86MODES_H_
+
+#include <stddef.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "xf86.h"
+#include "xorgVersion.h"
+#include "edid.h"
+#include "xf86Parser.h"
+#if XF86_MODES_RENAME
+#include "xf86Rename.h"
+#endif
+
+extern _X_EXPORT double xf86ModeHSync(const DisplayModeRec *mode);
+extern _X_EXPORT double xf86ModeVRefresh(const DisplayModeRec *mode);
+extern _X_EXPORT unsigned int xf86ModeBandwidth(DisplayModePtr mode, int depth);
+
+extern _X_EXPORT int
+xf86ModeWidth (const DisplayModeRec *mode, Rotation rotation);
+    
+extern _X_EXPORT int
+xf86ModeHeight (const DisplayModeRec *mode, Rotation rotation);
+
+extern _X_EXPORT DisplayModePtr xf86DuplicateMode(const DisplayModeRec *pMode);
+extern _X_EXPORT DisplayModePtr xf86DuplicateModes(ScrnInfoPtr pScrn,
+				       DisplayModePtr modeList);
+extern _X_EXPORT void xf86SetModeDefaultName(DisplayModePtr mode);
+extern _X_EXPORT void xf86SetModeCrtc(DisplayModePtr p, int adjustFlags);
+extern _X_EXPORT Bool xf86ModesEqual(const DisplayModeRec *pMode1,
+		    const DisplayModeRec *pMode2);
+extern _X_EXPORT void xf86PrintModeline(int scrnIndex,DisplayModePtr mode);
+extern _X_EXPORT DisplayModePtr xf86ModesAdd(DisplayModePtr modes, DisplayModePtr new);
+
+extern _X_EXPORT DisplayModePtr xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC);
+extern _X_EXPORT DisplayModePtr xf86CVTMode(int HDisplay, int VDisplay, float VRefresh,
+			   Bool Reduced, Bool Interlaced);
+extern _X_EXPORT DisplayModePtr xf86GTFMode(int h_pixels, int v_lines, float freq, int interlaced, int margins);
+
+extern _X_EXPORT Bool
+xf86ModeIsReduced(const DisplayModeRec *mode);
+
+extern _X_EXPORT void
+xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+		       int flags);
+
+extern _X_EXPORT void
+xf86ValidateModesClocks(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+			int *min, int *max, int n_ranges);
+
+extern _X_EXPORT void
+xf86ValidateModesSize(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+		      int maxX, int maxY, int maxPitch);
+
+extern _X_EXPORT void
+xf86ValidateModesSync(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+		      MonPtr mon);
+
+extern _X_EXPORT void
+xf86ValidateModesBandwidth(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+			   unsigned int bandwidth, int depth);
+
+extern _X_EXPORT void
+xf86ValidateModesReducedBlanking(ScrnInfoPtr pScrn, DisplayModePtr modeList);
+
+extern _X_EXPORT void
+xf86PruneInvalidModes(ScrnInfoPtr pScrn, DisplayModePtr *modeList,
+		      Bool verbose);
+
+extern _X_EXPORT DisplayModePtr
+xf86PruneDuplicateModes(DisplayModePtr modes);
+
+extern _X_EXPORT void
+xf86ValidateModesFlags(ScrnInfoPtr pScrn, DisplayModePtr modeList,
+		       int flags);
+
+extern _X_EXPORT void
+xf86ValidateModesUserConfig(ScrnInfoPtr pScrn, DisplayModePtr modeList);
+
+extern _X_EXPORT DisplayModePtr
+xf86GetMonitorModes (ScrnInfoPtr pScrn, XF86ConfMonitorPtr conf_monitor);
+
+extern _X_EXPORT DisplayModePtr
+xf86GetDefaultModes (void);
+
+extern _X_EXPORT void
+xf86DDCApplyQuirks(int scrnIndex, xf86MonPtr DDC);
+
+#endif /* _XF86MODES_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessCommon.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rootlessCommon.h
@@ -0,0 +1,290 @@
+/*
+ * Common internal rootless definitions and code
+ */
+/*
+ * Copyright (c) 2001 Greg Parker. All Rights Reserved.
+ * Copyright (c) 2002-2004 Torrey T. Lyons. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * THE ABOVE LISTED COPYRIGHT HOLDER(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name(s) of the above copyright
+ * holders shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written authorization.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdint.h>
+#ifndef _ROOTLESSCOMMON_H
+#define _ROOTLESSCOMMON_H
+
+#include "misc.h"
+#include "rootless.h"
+#include "fb.h"
+
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+
+// Debug output, or not.
+#ifdef ROOTLESSDEBUG
+#define RL_DEBUG_MSG ErrorF
+#else
+#define RL_DEBUG_MSG(a, ...)
+#endif
+
+
+// Global variables
+extern DevPrivateKeyRec rootlessGCPrivateKeyRec;
+#define rootlessGCPrivateKey (&rootlessGCPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessScreenPrivateKeyRec;
+#define rootlessScreenPrivateKey (&rootlessScreenPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessWindowPrivateKeyRec;
+#define rootlessWindowPrivateKey (&rootlessWindowPrivateKeyRec)
+
+extern DevPrivateKeyRec rootlessWindowOldPixmapPrivateKeyRec;
+#define rootlessWindowOldPixmapPrivateKey (&rootlessWindowOldPixmapPrivateKeyRec)
+
+
+// RootlessGCRec: private per-gc data
+typedef struct {
+    GCFuncs *originalFuncs;
+    GCOps *originalOps;
+} RootlessGCRec;
+
+
+// RootlessScreenRec: per-screen private data
+typedef struct _RootlessScreenRec {
+    // Rootless implementation functions
+    RootlessFrameProcsPtr imp;
+
+    // Wrapped screen functions
+    CreateScreenResourcesProcPtr CreateScreenResources;
+    CloseScreenProcPtr CloseScreen;
+
+    CreateWindowProcPtr CreateWindow;
+    DestroyWindowProcPtr DestroyWindow;
+    RealizeWindowProcPtr RealizeWindow;
+    UnrealizeWindowProcPtr UnrealizeWindow;
+    MoveWindowProcPtr MoveWindow;
+    ResizeWindowProcPtr ResizeWindow;
+    RestackWindowProcPtr RestackWindow;
+    ReparentWindowProcPtr ReparentWindow;
+    ChangeBorderWidthProcPtr ChangeBorderWidth;
+    PositionWindowProcPtr PositionWindow;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+
+    CreateGCProcPtr CreateGC;
+    CopyWindowProcPtr CopyWindow;
+    GetImageProcPtr GetImage;
+    SourceValidateProcPtr SourceValidate;
+
+    MarkOverlappedWindowsProcPtr MarkOverlappedWindows;
+    ValidateTreeProcPtr ValidateTree;
+
+    SetShapeProcPtr SetShape;
+
+    CompositeProcPtr Composite;
+    GlyphsProcPtr Glyphs;
+
+    InstallColormapProcPtr InstallColormap;
+    UninstallColormapProcPtr UninstallColormap;
+    StoreColorsProcPtr StoreColors;
+
+    void *pixmap_data;
+    unsigned int pixmap_data_size;
+
+    ColormapPtr colormap;
+
+    void *redisplay_timer;
+    unsigned int redisplay_timer_set :1;
+    unsigned int redisplay_queued :1;
+    unsigned int redisplay_expired :1;
+    unsigned int colormap_changed :1;
+} RootlessScreenRec, *RootlessScreenPtr;
+
+// "Definition of the Porting Layer for the X11 Sample Server" says
+// unwrap and rewrap of screen functions is unnecessary, but
+// screen->CreateGC changes after a call to cfbCreateGC.
+
+#define SCREEN_UNWRAP(screen, fn) \
+    screen->fn = SCREENREC(screen)->fn;
+
+#define SCREEN_WRAP(screen, fn) \
+    SCREENREC(screen)->fn = screen->fn; \
+    screen->fn = Rootless##fn
+
+
+// Accessors for screen and window privates
+
+#define SCREENREC(pScreen) ((RootlessScreenRec *) \
+    dixLookupPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey))
+
+#define SETSCREENREC(pScreen, v) \
+    dixSetPrivate(&(pScreen)->devPrivates, rootlessScreenPrivateKey, v)
+
+#define WINREC(pWin) ((RootlessWindowRec *) \
+    dixLookupPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey))
+
+#define SETWINREC(pWin, v) \
+    dixSetPrivate(&(pWin)->devPrivates, rootlessWindowPrivateKey, v)
+
+// Call a rootless implementation function.
+// Many rootless implementation functions are allowed to be NULL.
+#define CallFrameProc(pScreen, proc, params)            \
+    if (SCREENREC(pScreen)->frameProcs.proc) {          \
+        RL_DEBUG_MSG("calling frame proc " #proc " ");  \
+        SCREENREC(pScreen)->frameProcs.proc params;     \
+    }
+
+
+// BoxRec manipulators
+// Copied from shadowfb
+
+#define TRIM_BOX(box, pGC) { \
+    BoxPtr extents = &pGC->pCompositeClip->extents;\
+    if(box.x1 < extents->x1) box.x1 = extents->x1; \
+    if(box.x2 > extents->x2) box.x2 = extents->x2; \
+    if(box.y1 < extents->y1) box.y1 = extents->y1; \
+    if(box.y2 > extents->y2) box.y2 = extents->y2; \
+}
+
+#define TRANSLATE_BOX(box, pDraw) { \
+    box.x1 += pDraw->x; \
+    box.x2 += pDraw->x; \
+    box.y1 += pDraw->y; \
+    box.y2 += pDraw->y; \
+}
+
+#define TRIM_AND_TRANSLATE_BOX(box, pDraw, pGC) { \
+    TRANSLATE_BOX(box, pDraw); \
+    TRIM_BOX(box, pGC); \
+}
+
+#define BOX_NOT_EMPTY(box) \
+    (((box.x2 - box.x1) > 0) && ((box.y2 - box.y1) > 0))
+
+
+// HUGE_ROOT and NORMAL_ROOT
+// We don't want to clip windows to the edge of the screen.
+// HUGE_ROOT temporarily makes the root window really big.
+// This is needed as a wrapper around any function that calls
+// SetWinSize or SetBorderSize which clip a window against its
+// parents, including the root.
+
+extern RegionRec rootlessHugeRoot;
+
+#define HUGE_ROOT(pWin)                         \
+    do {                                        \
+        WindowPtr w = pWin;                     \
+        while (w->parent)                       \
+            w = w->parent;                      \
+        saveRoot = w->winSize;                  \
+        w->winSize = rootlessHugeRoot;          \
+    } while (0)
+
+#define NORMAL_ROOT(pWin)                       \
+    do {                                        \
+        WindowPtr w = pWin;                     \
+        while (w->parent)                       \
+            w = w->parent;                      \
+        w->winSize = saveRoot;                  \
+    } while (0)
+
+
+// Returns TRUE if this window is a top-level window (i.e. child of the root)
+// The root is not a top-level window.
+#define IsTopLevel(pWin) \
+    ((pWin)  &&  (pWin)->parent  &&  !(pWin)->parent->parent)
+
+// Returns TRUE if this window is a root window
+#define IsRoot(pWin) \
+    ((pWin) == (pWin)->drawable.pScreen->root)
+
+
+/*
+ * SetPixmapBaseToScreen
+ *  Move the given pixmap's base address to where pixel (0, 0)
+ *  would be if the pixmap's actual data started at (x, y).
+ *  Can't access the bits before the first word of the drawable's data in
+ *  rootless mode, so make sure our base address is always 32-bit aligned.
+ */
+#define SetPixmapBaseToScreen(pix, _x, _y) {                                \
+    PixmapPtr   _pPix = (PixmapPtr) (pix);                                  \
+    _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -              \
+                            ((int)(_x) * _pPix->drawable.bitsPerPixel/8 +   \
+                             (int)(_y) * _pPix->devKind);                   \
+    if (_pPix->drawable.bitsPerPixel != FB_UNIT) {                          \
+        size_t _diff = ((size_t) _pPix->devPrivate.ptr) &               \
+                         (FB_UNIT / CHAR_BIT - 1);                          \
+        _pPix->devPrivate.ptr = (char *) (_pPix->devPrivate.ptr) -          \
+                                _diff;                                      \
+        _pPix->drawable.x = _diff /                                         \
+                            (_pPix->drawable.bitsPerPixel / CHAR_BIT);      \
+    }                                                                       \
+}
+
+
+// Returns TRUE if this window is visible inside a frame
+// (e.g. it is visible and has a top-level or root parent)
+Bool IsFramedWindow(WindowPtr pWin);
+
+// Routines that cause regions to get redrawn.
+// DamageRegion and DamageRect are in global coordinates.
+// DamageBox is in window-local coordinates.
+void RootlessDamageRegion(WindowPtr pWindow, RegionPtr pRegion);
+void RootlessDamageRect(WindowPtr pWindow, int x, int y, int w, int h);
+void RootlessDamageBox(WindowPtr pWindow, BoxPtr pBox);
+void RootlessRedisplay(WindowPtr pWindow);
+void RootlessRedisplayScreen(ScreenPtr pScreen);
+
+void RootlessQueueRedisplay(ScreenPtr pScreen);
+
+/* Return the colormap currently installed on the given screen. */
+ColormapPtr RootlessGetColormap (ScreenPtr pScreen);
+
+/* Convert colormap to ARGB. */
+Bool RootlessResolveColormap (ScreenPtr pScreen, int first_color,
+			      int n_colors, uint32_t *colors);
+
+void RootlessFlushWindowColormap (WindowPtr pWin);
+void RootlessFlushScreenColormaps (ScreenPtr pScreen);
+
+// Move a window to its proper location on the screen.
+void RootlessRepositionWindow(WindowPtr pWin);
+
+// Move the window to it's correct place in the physical stacking order.
+void RootlessReorderWindow(WindowPtr pWin);
+
+void RootlessScreenExpose (ScreenPtr pScreen);
+void RootlessHideAllWindows (void);
+void RootlessShowAllWindows (void);
+void RootlessUpdateRooted (Bool state);
+
+void RootlessEnableRoot (ScreenPtr pScreen);
+void RootlessDisableRoot (ScreenPtr pScreen);
+
+void RootlessSetPixmapOfAncestors(WindowPtr pWin);
+
+#endif /* _ROOTLESSCOMMON_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mibstore.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mibstore.h
@@ -0,0 +1,25 @@
+/*-
+ * mibstore.h --
+ *	Header file for users of the MI backing-store scheme.
+ *
+ * Copyright (c) 1987 by the Regents of the University of California
+ *
+ * Permission to use, copy, modify, and distribute this
+ * software and its documentation for any purpose and without
+ * fee is hereby granted, provided that the above copyright
+ * notice appear in all copies.  The University of California
+ * makes no representations about the suitability of this
+ * software for any purpose.  It is provided "as is" without
+ * express or implied warranty.
+ */
+
+#ifndef _MIBSTORE_H
+#define _MIBSTORE_H
+
+#include "screenint.h"
+
+extern _X_EXPORT void miInitializeBackingStore(
+    ScreenPtr /*pScreen*/
+);
+
+#endif /* _MIBSTORE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extinit.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extinit.h
@@ -0,0 +1,47 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/********************************************************************
+ * Interface of extinit.c
+ */
+
+#ifndef EXTINIT_H
+#define EXTINIT_H
+
+#include "extnsionst.h"
+
+extern void
+XInputExtensionInit(
+	void
+	);
+
+extern _X_EXPORT void
+AssignTypeAndName (
+	DeviceIntPtr           /* dev */,
+	Atom                   /* type */,
+	char *                 /* name */
+	);
+
+#endif /* EXTINIT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Privstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Privstr.h
@@ -0,0 +1,170 @@
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the private XFree86 data structures/types.
+ * None of the data structures here should be used by video drivers.
+ */ 
+
+#ifndef _XF86PRIVSTR_H
+#define _XF86PRIVSTR_H
+
+#include "xf86str.h"
+
+typedef enum {
+    LogNone,
+    LogFlush,
+    LogSync
+} Log;
+
+typedef enum {
+    XF86_GlxVisualsMinimal,
+    XF86_GlxVisualsTypical,
+    XF86_GlxVisualsAll,
+} XF86_GlxVisuals;
+
+/*
+ * xf86InfoRec contains global parameters which the video drivers never
+ * need to access.  Global parameters which the video drivers do need
+ * should be individual globals.
+ */
+
+typedef struct {
+    int			consoleFd;
+    int			vtno;
+    Bool		vtSysreq;
+
+    /* event handler part */
+    int			lastEventTime;
+    Bool		vtRequestsPending;
+#ifdef sun
+    int			vtPendingNum;
+#endif
+    Bool		dontVTSwitch;
+    Bool		dontZap;
+    Bool		dontZoom;
+    Bool		notrapSignals;	/* don't exit cleanly - die at fault */
+    Bool		caughtSignal;
+
+    /* graphics part */
+    ScreenPtr		currentScreen;
+#if defined(CSRG_BASED) || defined(__FreeBSD_kernel__)
+    int			screenFd;	/* fd for memory mapped access to
+					 * vga card */
+    int			consType;	/* Which console driver? */
+#endif
+
+    /* Other things */
+    Bool		allowMouseOpenFail;
+    Bool		vidModeEnabled;		/* VidMode extension enabled */
+    Bool		vidModeAllowNonLocal;	/* allow non-local VidMode
+						 * connections */
+    Bool		miscModInDevEnabled;	/* Allow input devices to be
+						 * changed */
+    Bool		miscModInDevAllowNonLocal;
+    Bool		useSIGIO;		/* Use SIGIO for handling
+						   input device events */
+    Pix24Flags		pixmap24;
+    MessageType		pix24From;
+#ifdef SUPPORT_PC98
+    Bool		pc98;
+#endif
+    Bool		pmFlag;
+    Log			log;
+    Bool		kbdCustomKeycodes;
+    Bool		disableRandR;
+    MessageType		randRFrom;
+    Bool		aiglx;
+    MessageType		aiglxFrom;
+    XF86_GlxVisuals	glxVisuals;
+    MessageType		glxVisualsFrom;
+    
+    Bool		useDefaultFontPath;
+    MessageType		useDefaultFontPathFrom;
+    Bool        ignoreABI;
+
+    Bool        allowEmptyInput;  /* Allow the server to start with no input
+                                   * devices. */
+    Bool        autoAddDevices; /* Whether to succeed NIDR, or ignore. */
+    Bool        autoEnableDevices; /* Whether to enable, or let the client
+                                    * control. */
+
+    Bool		dri2;
+    MessageType		dri2From;
+} xf86InfoRec, *xf86InfoPtr;
+
+#ifdef DPMSExtension
+/* Private info for DPMS */
+typedef struct {
+    CloseScreenProcPtr	CloseScreen;
+    Bool		Enabled;
+    int			Flags;
+} DPMSRec, *DPMSPtr;
+#endif
+
+#ifdef XF86VIDMODE
+/* Private info for Video Mode Extentsion */
+typedef struct {
+    DisplayModePtr	First;
+    DisplayModePtr	Next;
+    int			Flags;
+    CloseScreenProcPtr	CloseScreen;
+} VidModeRec, *VidModePtr;
+#endif
+
+/* Information for root window properties. */
+typedef struct _RootWinProp {
+    struct _RootWinProp *	next;
+    char *			name;
+    Atom			type;
+    short			format;
+    long			size;
+    pointer			data;
+} RootWinProp, *RootWinPropPtr;
+
+/* ISC's cc can't handle ~ of UL constants, so explicitly type cast them. */
+#define XLED1   ((unsigned long) 0x00000001)
+#define XLED2   ((unsigned long) 0x00000002)
+#define XLED3   ((unsigned long) 0x00000004)
+#define XLED4	((unsigned long) 0x00000008)
+#define XCAPS   ((unsigned long) 0x20000000)
+#define XNUM    ((unsigned long) 0x40000000)
+#define XSCR    ((unsigned long) 0x80000000)
+#define XCOMP	((unsigned long) 0x00008000)
+
+/* BSD console driver types (consType) */
+#if defined(CSRG_BASED) || defined(__FreeBSD_kernel__)
+#define PCCONS		   0
+#define CODRV011	   1
+#define CODRV01X	   2
+#define SYSCONS		   8
+#define PCVT		  16
+#define WSCONS		  32
+#endif
+
+#endif /* _XF86PRIVSTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xorgVersion.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xorgVersion.h
@@ -0,0 +1,49 @@
+
+/*
+ * Copyright (c) 2004, X.Org Foundation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef XORG_VERSION_H
+# define XORG_VERSION_H
+
+# ifndef XORG_VERSION_CURRENT
+#  error
+# endif
+
+# define XORG_VERSION_NUMERIC(major,minor,patch,snap,dummy) \
+	(((major) * 10000000) + ((minor) * 100000) + ((patch) * 1000) + snap)
+
+# define XORG_GET_MAJOR_VERSION(vers)	((vers) / 10000000)
+# define XORG_GET_MINOR_VERSION(vers)	(((vers) % 10000000) / 100000)
+# define XORG_GET_PATCH_VERSION(vers)	(((vers) % 100000) / 1000)
+# define XORG_GET_SNAP_VERSION(vers)	((vers) % 1000)
+
+# define XORG_VERSION_MAJOR	XORG_GET_MAJOR_VERSION(XORG_VERSION_CURRENT)
+# define XORG_VERSION_MINOR	XORG_GET_MINOR_VERSION(XORG_VERSION_CURRENT)
+# define XORG_VERSION_PATCH	XORG_GET_PATCH_VERSION(XORG_VERSION_CURRENT)
+# define XORG_VERSION_SNAP	XORG_GET_SNAP_VERSION(XORG_VERSION_CURRENT)
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/resource.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/resource.h
@@ -0,0 +1,282 @@
+/***********************************************************
+
+Copyright 1987, 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987, 1989 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef RESOURCE_H
+#define RESOURCE_H 1
+#include "misc.h"
+#include "dixaccess.h"
+
+/*****************************************************************
+ * STUFF FOR RESOURCES 
+ *****************************************************************/
+
+/* classes for Resource routines */
+
+typedef unsigned long RESTYPE;
+
+#define RC_VANILLA	((RESTYPE)0)
+#define RC_CACHED	((RESTYPE)1<<31)
+#define RC_DRAWABLE	((RESTYPE)1<<30)
+/*  Use class RC_NEVERRETAIN for resources that should not be retained
+ *  regardless of the close down mode when the client dies.  (A client's
+ *  event selections on objects that it doesn't own are good candidates.)
+ *  Extensions can use this too!
+ */
+#define RC_NEVERRETAIN	((RESTYPE)1<<29)
+#define RC_LASTPREDEF	RC_NEVERRETAIN
+#define RC_ANY		(~(RESTYPE)0)
+
+/* types for Resource routines */
+
+#define RT_WINDOW	((RESTYPE)1|RC_DRAWABLE)
+#define RT_PIXMAP	((RESTYPE)2|RC_DRAWABLE)
+#define RT_GC		((RESTYPE)3)
+#undef RT_FONT
+#undef RT_CURSOR
+#define RT_FONT		((RESTYPE)4)
+#define RT_CURSOR	((RESTYPE)5)
+#define RT_COLORMAP	((RESTYPE)6)
+#define RT_CMAPENTRY	((RESTYPE)7)
+#define RT_OTHERCLIENT	((RESTYPE)8|RC_NEVERRETAIN)
+#define RT_PASSIVEGRAB	((RESTYPE)9|RC_NEVERRETAIN)
+#define RT_LASTPREDEF	((RESTYPE)9)
+#define RT_NONE		((RESTYPE)0)
+
+/* bits and fields within a resource id */
+#define RESOURCE_AND_CLIENT_COUNT   29			/* 29 bits for XIDs */
+#if MAXCLIENTS == 64
+#define RESOURCE_CLIENT_BITS	6
+#endif
+#if MAXCLIENTS == 128
+#define RESOURCE_CLIENT_BITS	7
+#endif
+#if MAXCLIENTS == 256
+#define RESOURCE_CLIENT_BITS	8
+#endif
+#if MAXCLIENTS == 512
+#define RESOURCE_CLIENT_BITS	9
+#endif
+/* client field offset */
+#define CLIENTOFFSET	    (RESOURCE_AND_CLIENT_COUNT - RESOURCE_CLIENT_BITS)
+/* resource field */
+#define RESOURCE_ID_MASK	((1 << CLIENTOFFSET) - 1)
+/* client field */
+#define RESOURCE_CLIENT_MASK	(((1 << RESOURCE_CLIENT_BITS) - 1) << CLIENTOFFSET)
+/* extract the client mask from an XID */
+#define CLIENT_BITS(id) ((id) & RESOURCE_CLIENT_MASK)
+/* extract the client id from an XID */
+#define CLIENT_ID(id) ((int)(CLIENT_BITS(id) >> CLIENTOFFSET))
+#define SERVER_BIT		(Mask)0x40000000	/* use illegal bit */
+
+#ifdef INVALID
+#undef INVALID	/* needed on HP/UX */
+#endif
+
+/* Invalid resource id */
+#define INVALID	(0)
+
+#define BAD_RESOURCE 0xe0000000
+
+/* Resource state callback */
+extern _X_EXPORT CallbackListPtr ResourceStateCallback;
+
+typedef enum {ResourceStateAdding,
+	      ResourceStateFreeing} ResourceState;
+
+typedef struct {
+    ResourceState state;
+    XID id;
+    RESTYPE type;
+    pointer value;
+} ResourceStateInfoRec;
+
+typedef int (*DeleteType)(
+    pointer /*value*/,
+    XID /*id*/);
+
+typedef void (*FindResType)(
+    pointer /*value*/,
+    XID /*id*/,
+    pointer /*cdata*/);
+
+typedef void (*FindAllRes)(
+    pointer /*value*/,
+    XID /*id*/,
+    RESTYPE /*type*/,
+    pointer /*cdata*/);
+
+typedef Bool (*FindComplexResType)(
+    pointer /*value*/,
+    XID /*id*/,
+    pointer /*cdata*/);
+
+extern _X_EXPORT RESTYPE CreateNewResourceType(
+    DeleteType /*deleteFunc*/, char * /*name*/);
+
+extern _X_EXPORT void SetResourceTypeErrorValue(
+    RESTYPE /*type*/, int /*errorValue*/);
+
+extern _X_EXPORT RESTYPE CreateNewResourceClass(void);
+
+extern _X_EXPORT Bool InitClientResources(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT XID FakeClientID(
+    int /*client*/);
+
+/* Quartz support on Mac OS X uses the CarbonCore
+   framework whose AddResource function conflicts here. */
+#ifdef __APPLE__
+#define AddResource Darwin_X_AddResource
+#endif
+extern _X_EXPORT Bool AddResource(
+    XID /*id*/,
+    RESTYPE /*type*/,
+    pointer /*value*/);
+
+extern _X_EXPORT void FreeResource(
+    XID /*id*/,
+    RESTYPE /*skipDeleteFuncType*/);
+
+extern _X_EXPORT void FreeResourceByType(
+    XID /*id*/,
+    RESTYPE /*type*/,
+    Bool /*skipFree*/);
+
+extern _X_EXPORT Bool ChangeResourceValue(
+    XID /*id*/,
+    RESTYPE /*rtype*/,
+    pointer /*value*/);
+
+extern _X_EXPORT void FindClientResourcesByType(
+    ClientPtr /*client*/,
+    RESTYPE /*type*/,
+    FindResType /*func*/,
+    pointer /*cdata*/);
+
+extern _X_EXPORT void FindAllClientResources(
+    ClientPtr /*client*/,
+    FindAllRes /*func*/,
+    pointer /*cdata*/);
+
+extern _X_EXPORT void FreeClientNeverRetainResources(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT void FreeClientResources(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT void FreeAllResources(void);
+
+extern _X_EXPORT Bool LegalNewID(
+    XID /*id*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT pointer LookupClientResourceComplex(
+    ClientPtr client,
+    RESTYPE type,
+    FindComplexResType func,
+    pointer cdata);
+
+extern _X_EXPORT int dixLookupResourceByType(
+    pointer *result,
+    XID id,
+    RESTYPE rtype,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT int dixLookupResourceByClass(
+    pointer *result,
+    XID id,
+    RESTYPE rclass,
+    ClientPtr client,
+    Mask access_mode);
+
+extern _X_EXPORT void GetXIDRange(
+    int /*client*/,
+    Bool /*server*/,
+    XID * /*minp*/,
+    XID * /*maxp*/);
+
+extern _X_EXPORT unsigned int GetXIDList(
+    ClientPtr /*client*/,
+    unsigned int /*count*/,
+    XID * /*pids*/);
+
+extern _X_EXPORT RESTYPE lastResourceType;
+extern _X_EXPORT RESTYPE TypeMask;
+
+/*
+ * These are deprecated compatibility functions and will be removed soon!
+ * Please use the noted replacements instead.
+ */
+
+/* replaced by dixLookupResourceByType */
+extern _X_EXPORT pointer SecurityLookupIDByType(
+    ClientPtr client,
+    XID id,
+    RESTYPE rtype,
+    Mask access_mode) _X_DEPRECATED;
+
+/* replaced by dixLookupResourceByClass */
+extern _X_EXPORT pointer SecurityLookupIDByClass(
+    ClientPtr client,
+    XID id,
+    RESTYPE classes,
+    Mask access_mode) _X_DEPRECATED;
+
+/* replaced by dixLookupResourceByType */
+extern _X_EXPORT pointer LookupIDByType(
+    XID id,
+    RESTYPE rtype) _X_DEPRECATED;
+
+/* replaced by dixLookupResourceByClass */
+extern _X_EXPORT pointer LookupIDByClass(
+    XID id,
+    RESTYPE classes) _X_DEPRECATED;
+
+#endif /* RESOURCE_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bstorestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/bstorestr.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 1987 by the Regents of the University of California
+ *
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted, provided
+ * that the above copyright notice appear in all copies.  The University of
+ * California makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ */
+
+/*
+ * Moved here from mi to allow wrapping of lower level backing store functions.
+ * -- 1997.10.27  Marc Aurele La France (tsi@xfree86.org)
+ */
+
+#ifndef _BSTORESTR_H_
+#define _BSTORESTR_H_
+
+#include "gc.h"
+#include "pixmap.h"
+#include "region.h"
+#include "window.h"
+
+typedef    void (* BackingStoreSaveAreasProcPtr)(
+	PixmapPtr /*pBackingPixmap*/,
+	RegionPtr /*pObscured*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pWin*/);
+
+typedef    void (* BackingStoreRestoreAreasProcPtr)(
+	PixmapPtr /*pBackingPixmap*/,
+	RegionPtr /*pExposed*/,
+	int /*x*/,
+	int /*y*/,
+	WindowPtr /*pWin*/);
+
+typedef    void (* BackingStoreSetClipmaskRgnProcPtr)(
+	GCPtr /*pBackingGC*/,
+	RegionPtr /*pbackingCompositeClip*/);
+
+typedef    PixmapPtr (* BackingStoreGetImagePixmapProcPtr)(void);
+
+typedef    PixmapPtr (* BackingStoreGetSpansPixmapProcPtr)(void);
+
+typedef struct _BSFuncs {
+	BackingStoreSaveAreasProcPtr SaveAreas;
+	BackingStoreRestoreAreasProcPtr RestoreAreas;
+	BackingStoreSetClipmaskRgnProcPtr SetClipmaskRgn;
+	BackingStoreGetImagePixmapProcPtr GetImagePixmap;
+	BackingStoreGetSpansPixmapProcPtr GetSpansPixmap;
+} BSFuncRec, *BSFuncPtr;
+
+#endif /* _BSTORESTR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxfbconfig.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxfbconfig.h
@@ -0,0 +1,38 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef _GLXFBCONFIG_H
+
+#include <GL/glxint.h>
+
+int AreFBConfigsMatch( __GLXFBConfig *c1, __GLXFBConfig *c2 );
+__GLXFBConfig *FindMatchingFBConfig( __GLXFBConfig *c, __GLXFBConfig *configs, int nconfigs );
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getkmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getkmap.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETKMAP_H
+#define GETKMAP_H 1
+
+int SProcXGetDeviceKeyMapping(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceKeyMapping(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceKeyMapping(ClientPtr /* client */ ,
+			      int /* size */ ,
+			      xGetDeviceKeyMappingReply *	/* rep */
+    );
+
+#endif /* GETKMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getfctl.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getfctl.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETFCTL_H
+#define GETFCTL_H 1
+
+int SProcXGetFeedbackControl(ClientPtr	/* client */
+    );
+
+int ProcXGetFeedbackControl(ClientPtr	/* client */
+    );
+
+void SRepXGetFeedbackControl(ClientPtr /* client */ ,
+			     int /* size */ ,
+			     xGetFeedbackControlReply *	/* rep */
+    );
+
+#endif /* GETFCTL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcmap.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2002-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Header file for colormap support.  \see dmxcmap.c. */
+
+#ifndef DMXCMAP_H
+#define DMXCMAP_H
+
+#include "colormapst.h"
+
+/** Colormap private area. */
+typedef struct _dmxColormapPriv {
+    Colormap  cmap;
+} dmxColormapPrivRec, *dmxColormapPrivPtr;
+
+
+extern Bool dmxCreateColormap(ColormapPtr pColormap);
+extern void dmxDestroyColormap(ColormapPtr pColormap);
+extern void dmxInstallColormap(ColormapPtr pColormap);
+extern void dmxStoreColors(ColormapPtr pColormap, int ndef, xColorItem *pdef);
+
+extern Bool dmxCreateDefColormap(ScreenPtr pScreen);
+
+extern Bool dmxBECreateColormap(ColormapPtr pColormap);
+extern Bool dmxBEFreeColormap(ColormapPtr pColormap);
+
+/** Set colormap private structure. */
+#define DMX_SET_COLORMAP_PRIV(_pCMap, _pCMapPriv)			\
+    dixSetPrivate(&(_pCMap)->devPrivates, dmxColormapPrivateKey, _pCMapPriv)
+
+/** Get colormap private structure. */
+#define DMX_GET_COLORMAP_PRIV(_pCMap) (dmxColormapPrivPtr)		\
+    dixLookupPrivate(&(_pCMap)->devPrivates, dmxColormapPrivateKey)
+
+#endif /* DMXCMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxprop.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxprop.h
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2002,2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for property support.  \see dmxprop.c */
+
+#ifndef _DMXPROP_H_
+#define _DMXPROP_H_
+extern int  dmxPropertyDisplay(DMXScreenInfo *dmxScreen);
+extern void dmxPropertyWindow(DMXScreenInfo *dmxScreen);
+extern void *dmxPropertyIterate(DMXScreenInfo *start,
+                                void *(*f)(DMXScreenInfo *dmxScreen,
+                                           void *closure),
+                                void *closure);
+extern int dmxPropertySameDisplay(DMXScreenInfo *dmxScreen, const char *name);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86CursorPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86CursorPriv.h
@@ -0,0 +1,51 @@
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86CURSORPRIV_H
+#define _XF86CURSORPRIV_H
+
+#include "xf86Cursor.h"
+#include "mipointrst.h"
+
+typedef struct {
+    Bool			SWCursor;
+    Bool			isUp;
+    Bool			showTransparent;
+    short			HotX;
+    short			HotY;
+    short			x;
+    short			y;
+    CursorPtr			CurrentCursor, CursorToRestore;
+    xf86CursorInfoPtr		CursorInfoPtr;
+    CloseScreenProcPtr          CloseScreen;
+    RecolorCursorProcPtr	RecolorCursor;
+    InstallColormapProcPtr	InstallColormap;
+    QueryBestSizeProcPtr	QueryBestSize;
+    miPointerSpriteFuncPtr	spriteFuncs;
+    Bool			PalettedCursor;
+    ColormapPtr			pInstalledMap;
+    Bool                	(*SwitchMode)(int, DisplayModePtr,int);
+    xf86EnableDisableFBAccessProc *EnableDisableFBAccess;
+    CursorPtr                   SavedCursor;
+
+    /* Number of requests to force HW cursor */
+    int				ForceHWCursorCount;
+    Bool			HWCursorForced;
+
+    pointer			transparentData;
+} xf86CursorScreenRec, *xf86CursorScreenPtr;
+
+void xf86SetCursor(ScreenPtr pScreen, CursorPtr pCurs, int x, int y);
+void xf86SetTransparentCursor(ScreenPtr pScreen);
+void xf86MoveCursor(ScreenPtr pScreen, int x, int y);
+void xf86RecolorCursor(ScreenPtr pScreen, CursorPtr pCurs, Bool displayed);
+Bool xf86InitHardwareCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr);
+
+CARD32 xf86ReverseBitOrder(CARD32 data);
+
+extern _X_EXPORT DevPrivateKeyRec xf86CursorScreenKeyRec;
+#define xf86CursorScreenKey (&xf86CursorScreenKeyRec)
+
+#endif /* _XF86CURSORPRIV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/privates.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/privates.h
@@ -0,0 +1,268 @@
+/***********************************************************
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************/
+
+#ifndef PRIVATES_H
+#define PRIVATES_H 1
+
+#include <X11/Xdefs.h>
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include "misc.h"
+
+/*****************************************************************
+ * STUFF FOR PRIVATES
+ *****************************************************************/
+
+typedef struct _Private PrivateRec, *PrivatePtr;
+
+typedef enum {
+    /* XSELinux uses the same private keys for numerous objects */
+    PRIVATE_XSELINUX,
+
+    /* Otherwise, you get a private in just the requested structure
+     */
+    /* These can have objects created before all of the keys are registered */
+    PRIVATE_SCREEN,
+    PRIVATE_EXTENSION,
+    PRIVATE_COLORMAP,
+
+    /* These cannot have any objects before all relevant keys are registered */
+    PRIVATE_DEVICE,
+    PRIVATE_CLIENT,
+    PRIVATE_PROPERTY,
+    PRIVATE_SELECTION,
+    PRIVATE_WINDOW,
+    PRIVATE_PIXMAP,
+    PRIVATE_GC,
+    PRIVATE_CURSOR,
+    PRIVATE_CURSOR_BITS,
+
+    /* extension privates */
+    PRIVATE_DBE_WINDOW,
+    PRIVATE_DAMAGE,
+    PRIVATE_GLYPH,
+    PRIVATE_GLYPHSET,
+    PRIVATE_PICTURE,
+
+    /* last private type */
+    PRIVATE_LAST,
+} DevPrivateType;
+
+typedef struct _DevPrivateKeyRec {
+    int			offset;
+    int			size;
+    Bool		initialized;
+    Bool		allocated;
+    DevPrivateType	type;
+    struct _DevPrivateKeyRec	*next;
+} DevPrivateKeyRec, *DevPrivateKey;
+
+/*
+ * Let drivers know how to initialize private keys
+ */
+
+#define HAS_DEVPRIVATEKEYREC		1
+#define HAS_DIXREGISTERPRIVATEKEY	1
+
+/*
+ * Register a new private index for the private type.
+ *
+ * This initializes the specified key and optionally requests pre-allocated
+ * private space for your driver/module. If you request no extra space, you
+ * may set and get a single pointer value using this private key. Otherwise,
+ * you can get the address of the extra space and store whatever data you like
+ * there.
+ *
+ * You may call dixRegisterPrivateKey more than once on the same key, but the
+ * size and type must match or the server will abort.
+ *
+ * dixRegisterPrivateKey returns FALSE if it fails to allocate memory
+ * during its operation.
+ */
+extern _X_EXPORT Bool
+dixRegisterPrivateKey(DevPrivateKey key, DevPrivateType type, unsigned size);
+
+/*
+ * Check whether a private key has been registered
+ */
+static inline Bool
+dixPrivateKeyRegistered(DevPrivateKey key)
+{
+    return key->initialized;
+}
+
+/*
+ * Allocate a new private key.
+ *
+ * This manages the storage of the key object itself, freeing it when the
+ * privates system is restarted at server reset time. All other keys
+ * are expected to be statically allocated as the privates must be
+ * reset after all objects have been freed
+ */
+extern _X_EXPORT DevPrivateKey
+dixCreatePrivateKey(DevPrivateType type, unsigned size);
+
+/*
+ * Get the address of the private storage.
+ *
+ * For keys with pre-defined storage, this gets the base of that storage
+ * Otherwise, it returns the place where the private pointer is stored.
+ */
+static inline void *
+dixGetPrivateAddr(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert(key->initialized);
+    return (char *) (*privates) + key->offset;
+}
+
+/*
+ * Fetch a private pointer stored in the object
+ *
+ * Returns the pointer stored with dixSetPrivate.
+ * This must only be used with keys that have
+ * no pre-defined storage
+ */
+static inline void *
+dixGetPrivate(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert (key->size == 0);
+    return *(void **) dixGetPrivateAddr(privates, key);
+}
+
+/*
+ * Associate 'val' with 'key' in 'privates' so that later calls to
+ * dixLookupPrivate(privates, key) will return 'val'.
+ */
+static inline void
+dixSetPrivate(PrivatePtr *privates, const DevPrivateKey key, pointer val)
+{
+    assert (key->size == 0);
+    *(pointer *) dixGetPrivateAddr(privates, key) = val;
+}
+
+#include "dix.h"
+#include "resource.h"
+
+/*
+ * Lookup a pointer to the private record.
+ *
+ * For privates with defined storage, return the address of the
+ * storage. For privates without defined storage, return the pointer
+ * contents
+ */
+static inline pointer
+dixLookupPrivate(PrivatePtr *privates, const DevPrivateKey key)
+{
+    if (key->size)
+	return dixGetPrivateAddr(privates, key);
+    else
+	return dixGetPrivate(privates, key);
+}
+
+/*
+ * Look up the address of the pointer to the storage
+ *
+ * This returns the place where the private pointer is stored,
+ * which is only valid for privates without predefined storage.
+ */
+static inline pointer *
+dixLookupPrivateAddr(PrivatePtr *privates, const DevPrivateKey key)
+{
+    assert (key->size == 0);
+    return (pointer *)dixGetPrivateAddr(privates, key);
+}
+
+/*
+ * Allocates private data separately from main object.
+ *
+ * For objects created during server initialization, this allows those
+ * privates to be re-allocated as new private keys are registered.
+ *
+ * This includes screens, the serverClient, default colormaps and
+ * extensions entries.
+ */
+extern _X_EXPORT Bool
+dixAllocatePrivates(PrivatePtr *privates, DevPrivateType type);
+
+/*
+ * Frees separately allocated private data
+ */
+extern _X_EXPORT void
+dixFreePrivates(PrivatePtr privates, DevPrivateType type);
+
+/*
+ * Initialize privates by zeroing them
+ */
+extern _X_EXPORT void
+_dixInitPrivates(PrivatePtr *privates, void *addr, DevPrivateType type);
+
+#define dixInitPrivates(o, v, type) _dixInitPrivates(&(o)->devPrivates, (v), type);
+
+/*
+ * Clean up privates
+ */
+extern _X_EXPORT void
+_dixFiniPrivates(PrivatePtr privates, DevPrivateType type);
+
+#define dixFiniPrivates(o,t)	_dixFiniPrivates((o)->devPrivates,t)
+
+/*
+ * Allocates private data at object creation time. Required
+ * for almost all objects, except for the list described
+ * above for dixAllocatePrivates.
+ */
+extern _X_EXPORT void *
+_dixAllocateObjectWithPrivates(unsigned size, unsigned clear, unsigned offset, DevPrivateType type);
+
+#define dixAllocateObjectWithPrivates(t, type) (t *) _dixAllocateObjectWithPrivates(sizeof(t), sizeof(t), offsetof(t, devPrivates), type)
+
+extern _X_EXPORT void
+_dixFreeObjectWithPrivates(void *object, PrivatePtr privates, DevPrivateType type);
+
+#define dixFreeObjectWithPrivates(o,t) _dixFreeObjectWithPrivates(o, (o)->devPrivates, t)
+
+/*
+ * Return size of privates for the specified type
+ */
+extern _X_EXPORT int
+dixPrivatesSize(DevPrivateType type);
+
+/*
+ * Dump out private stats to ErrorF
+ */
+extern void
+dixPrivateUsage(void);
+
+/*
+ * Resets the privates subsystem.  dixResetPrivates is called from the main loop
+ * before each server generation.  This function must only be called by main().
+ */
+extern _X_EXPORT void
+dixResetPrivates(void);
+
+/*
+ * Looks up the offset where the devPrivates field is located.
+ *
+ * Returns -1 if the specified resource has no dev privates.
+ * The position of the devPrivates field varies by structure
+ * and calling code might only know the resource type, not the
+ * structure definition.
+ */
+extern _X_EXPORT int
+dixLookupPrivateOffset(RESTYPE type);
+
+/*
+ * Convenience macro for adding an offset to an object pointer
+ * when making a call to one of the devPrivates functions
+ */
+#define DEVPRIV_AT(ptr, offset) ((PrivatePtr *)((char *)(ptr) + offset))
+
+#endif /* PRIVATES_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shrotpack.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shrotpack.h
@@ -0,0 +1,187 @@
+/*
+ *
+ * Copyright © 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * Thanks to Daniel Chemko <dchemko@intrinsyc.com> for making the 90 and 180
+ * orientations work.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdlib.h>
+
+#include    <X11/X.h>
+#include    "scrnintstr.h"
+#include    "windowstr.h"
+#include    <X11/fonts/font.h>
+#include    "dixfontstr.h"
+#include    <X11/fonts/fontstruct.h>
+#include    "mi.h"
+#include    "regionstr.h"
+#include    "globals.h"
+#include    "gcstruct.h"
+#include    "shadow.h"
+#include    "fb.h"
+
+#define DANDEBUG         0
+
+#if ROTATE == 270
+
+#define SCRLEFT(x,y,w,h)    (pScreen->height - ((y) + (h)))
+#define SCRY(x,y,w,h)	    (x)
+#define SCRWIDTH(x,y,w,h)   (h)
+#define FIRSTSHA(x,y,w,h)   (((y) + (h) - 1) * shaStride + (x))
+#define STEPDOWN(x,y,w,h)   ((w)--)
+#define NEXTY(x,y,w,h)	    ((x)++)
+#define SHASTEPX(stride)    -(stride)
+#define SHASTEPY(stride)    (1)
+
+#elif ROTATE == 90
+
+#define SCRLEFT(x,y,w,h)    (y)
+#define SCRY(x,y,w,h)	    (pScreen->width - ((x) + (w)) - 1)
+#define SCRWIDTH(x,y,w,h)   (h)
+#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x + w - 1))
+#define STEPDOWN(x,y,w,h)   ((w)--)
+#define NEXTY(x,y,w,h)	    ((void)(x))
+#define SHASTEPX(stride)    (stride)
+#define SHASTEPY(stride)    (-1)
+
+#elif ROTATE == 180
+
+#define SCRLEFT(x,y,w,h)    (pScreen->width - ((x) + (w)))
+#define SCRY(x,y,w,h)	    (pScreen->height - ((y) + (h)) - 1)
+#define SCRWIDTH(x,y,w,h)   (w)
+#define FIRSTSHA(x,y,w,h)   ((y + h - 1) * shaStride + (x + w - 1))
+#define STEPDOWN(x,y,w,h)   ((h)--)
+#define NEXTY(x,y,w,h)	    ((void)(y))
+#define SHASTEPX(stride)    (-1)
+#define SHASTEPY(stride)    -(stride)
+
+#else
+
+#define SCRLEFT(x,y,w,h)    (x)
+#define SCRY(x,y,w,h)	    (y)
+#define SCRWIDTH(x,y,w,h)   (w)
+#define FIRSTSHA(x,y,w,h)   ((y) * shaStride + (x))
+#define STEPDOWN(x,y,w,h)   ((h)--)
+#define NEXTY(x,y,w,h)	    ((y)++)
+#define SHASTEPX(stride)    (1)
+#define SHASTEPY(stride)    (stride)
+
+#endif
+
+void
+FUNC (ScreenPtr	    pScreen,
+      shadowBufPtr  pBuf)
+{
+    RegionPtr	damage = shadowDamage (pBuf);
+    PixmapPtr	pShadow = pBuf->pPixmap;
+    int		nbox = RegionNumRects (damage);
+    BoxPtr	pbox = RegionRects (damage);
+    FbBits	*shaBits;
+    Data	*shaBase, *shaLine, *sha;
+    FbStride	shaStride;
+    int		scrBase, scrLine, scr;
+    int		shaBpp;
+    int		shaXoff, shaYoff;   /* XXX assumed to be zero */
+    int		x, y, w, h, width;
+    int         i;
+    Data	*winBase = NULL, *win;
+    CARD32	winSize;
+
+    fbGetDrawable (&pShadow->drawable, shaBits, shaStride, shaBpp, shaXoff, shaYoff);
+    shaBase = (Data *) shaBits;
+    shaStride = shaStride * sizeof (FbBits) / sizeof (Data);
+#if (DANDEBUG > 1)
+    ErrorF ("-> Entering Shadow Update:\r\n   |- Origins: pShadow=%x, pScreen=%x, damage=%x\r\n   |- Metrics: shaStride=%d, shaBase=%x, shaBpp=%d\r\n   |                                                     \n", pShadow, pScreen, damage, shaStride, shaBase, shaBpp);
+#endif
+    while (nbox--)
+    {
+        x = pbox->x1;
+        y = pbox->y1;
+        w = (pbox->x2 - pbox->x1);
+        h = pbox->y2 - pbox->y1;
+        
+#if (DANDEBUG > 2)
+        ErrorF ("   |-> Redrawing box - Metrics: X=%d, Y=%d, Width=%d, Height=%d\n", x, y, w, h);
+#endif
+        scrLine = SCRLEFT(x,y,w,h);
+        shaLine = shaBase + FIRSTSHA(x,y,w,h);
+        
+        while (STEPDOWN(x,y,w,h))
+        {
+            winSize = 0;
+            scrBase = 0;
+            width = SCRWIDTH(x,y,w,h);
+            scr = scrLine;
+            sha = shaLine;
+#if (DANDEBUG > 3)
+            ErrorF ("   |   |-> StepDown - Metrics: width=%d, scr=%x, sha=%x\n", width, scr, sha);
+#endif
+            while (width)
+            {
+                /*  how much remains in this window */
+                i = scrBase + winSize - scr;
+                if (i <= 0 || scr < scrBase)
+                {
+                    winBase = (Data *) (*pBuf->window) (pScreen,
+							SCRY(x,y,w,h),
+							scr * sizeof (Data),
+							SHADOW_WINDOW_WRITE,
+							&winSize,
+							pBuf->closure);
+                    if(!winBase)
+                        return;
+                    scrBase = scr;
+                    winSize /= sizeof (Data);
+                    i = winSize;
+#if(DANDEBUG > 4)
+                    ErrorF ("   |   |   |-> Starting New Line - Metrics: winBase=%x, scrBase=%x, winSize=%d\r\n   |   |   |   Xstride=%d, Ystride=%d, w=%d h=%d\n", winBase, scrBase, winSize, SHASTEPX(shaStride), SHASTEPY(shaStride), w, h);
+#endif
+                }
+                win = winBase + (scr - scrBase);
+                if (i > width)
+                    i = width;
+                width -= i;
+                scr += i;
+#if(DANDEBUG > 5)
+		ErrorF ("   |   |   |-> Writing Line - Metrics: win=%x, sha=%x\n", win, sha);
+#endif
+                while (i--)
+                {
+#if(DANDEBUG > 6)
+		    ErrorF ("   |   |   |-> Writing Pixel - Metrics: win=%x, sha=%d, remaining=%d\n", win, sha, i);
+#endif
+                    *win++ = *sha;
+                    sha += SHASTEPX(shaStride);
+                } /*  i */
+            } /*  width */
+            shaLine += SHASTEPY(shaStride);
+            NEXTY(x,y,w,h);
+        } /*  STEPDOWN */
+        pbox++;
+    } /*  nbox */
+}
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcommon.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxcommon.h
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2002,2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to functions used by backend and console input devices.
+ * \see dmxcommon.c \see dmxbackend.c \see dmxconsole.c */
+
+#ifndef _DMXCOMMON_H_
+#define _DMXCOMMON_H_
+
+#define DMX_COMMON_OTHER                    \
+    Display                 *display;       \
+    Window                  window;         \
+    DMXScreenInfo           *be;            \
+    DMXLocalInputInfoPtr    dmxLocal;       \
+    int                     initPointerX;   \
+    int                     initPointerY;   \
+    long                    eventMask;      \
+    KeybdCtrl               kctrl;          \
+    PtrCtrl                 mctrl;          \
+    int                     kctrlset;       \
+    int                     mctrlset;       \
+    KeybdCtrl               savedKctrl;     \
+    XModifierKeymap         *savedModMap;   \
+    int                     stateSaved
+
+#define DMX_COMMON_XKB                      \
+    DMX_COMMON_OTHER;                       \
+    XkbDescPtr              xkb;            \
+    XkbIndicatorRec         savedIndicators
+
+#define DMX_COMMON_PRIVATE                  \
+    DMX_COMMON_XKB;                         \
+    XDevice                 *xi
+
+#define GETONLYPRIVFROMPRIVATE                                          \
+    myPrivate            *priv     = private
+
+#define GETPRIVFROMPRIVATE                                              \
+    GETONLYPRIVFROMPRIVATE;                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[priv->dmxLocal->inputIdx]
+
+#define GETDMXLOCALFROMPDEVICE                                          \
+    DevicePtr            pDev      = &pDevice->public;                  \
+    DMXLocalInputInfoPtr dmxLocal  = pDev->devicePrivate
+
+#define GETDMXINPUTFROMPRIV                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[priv->dmxLocal->inputIdx]
+
+#define GETDMXINPUTFROMPDEVICE                                          \
+    GETDMXLOCALFROMPDEVICE;                                             \
+    DMXInputInfo         *dmxInput = &dmxInputs[dmxLocal->inputIdx]
+
+#define GETDMXLOCALFROMPDEV                                             \
+    DMXLocalInputInfoPtr dmxLocal  = pDev->devicePrivate
+
+#define GETDMXINPUTFROMPDEV                                             \
+    GETDMXLOCALFROMPDEV;                                                \
+    DMXInputInfo         *dmxInput = &dmxInputs[dmxLocal->inputIdx]
+
+#define GETPRIVFROMPDEV                                                 \
+    GETDMXLOCALFROMPDEV;                                                \
+    myPrivate            *priv     = dmxLocal->private
+
+#define DMX_KEYBOARD_EVENT_MASK                                         \
+    (KeyPressMask | KeyReleaseMask | KeymapStateMask)
+
+#define DMX_POINTER_EVENT_MASK                                          \
+    (ButtonPressMask | ButtonReleaseMask | PointerMotionMask)
+
+extern void    dmxCommonKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void    dmxCommonKbdGetMap(DevicePtr pDev,
+                                  KeySymsPtr pKeySyms, CARD8 *pModMap);
+extern void    dmxCommonKbdCtrl(DevicePtr pDev, KeybdCtrl *ctrl);
+extern void    dmxCommonKbdBell(DevicePtr pDev, int percent,
+                                int volume, int pitch, int duration);
+extern int     dmxCommonKbdOn(DevicePtr pDev);
+extern void    dmxCommonKbdOff(DevicePtr pDev);
+extern void    dmxCommonMouGetMap(DevicePtr pDev,
+                                  unsigned char *map, int *nButtons);
+extern void    dmxCommonMouCtrl(DevicePtr pDev, PtrCtrl *ctrl);
+extern int     dmxCommonMouOn(DevicePtr pDev);
+extern void    dmxCommonMouOff(DevicePtr pDev);
+extern int     dmxFindPointerScreen(int x, int y);
+
+extern int     dmxCommonOthOn(DevicePtr pDev);
+extern void    dmxCommonOthOff(DevicePtr pDev);
+extern void    dmxCommonOthGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+
+                                /* helper functions */
+extern pointer dmxCommonCopyPrivate(DeviceIntPtr pDevice);
+extern void    dmxCommonSaveState(pointer private);
+extern void    dmxCommonRestoreState(pointer private);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/modinit.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/modinit.h
@@ -0,0 +1,82 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef INITARGS
+#define INITARGS void
+#endif
+
+#include <X11/extensions/shapeproto.h>
+
+#ifdef XTEST
+extern void XTestExtensionInit(INITARGS);
+#include <X11/extensions/xtestproto.h>
+#endif
+
+#if 1
+extern void XTestExtension1Init(INITARGS);
+#endif
+
+#ifdef SCREENSAVER
+extern void ScreenSaverExtensionInit (INITARGS);
+#include <X11/extensions/saver.h>
+#endif
+
+#ifdef XF86VIDMODE
+extern void	XFree86VidModeExtensionInit(INITARGS);
+#include <X11/extensions/xf86vmproto.h>
+#endif
+
+#ifdef XFreeXDGA
+extern void XFree86DGAExtensionInit(INITARGS);
+extern void XFree86DGARegister(INITARGS);
+#include <X11/extensions/xf86dgaproto.h>
+#endif
+
+#ifdef DPMSExtension
+extern void DPMSExtensionInit(INITARGS);
+#include <X11/extensions/dpmsconst.h>
+#endif
+
+#ifdef XV
+extern void XvExtensionInit(INITARGS);
+extern void XvMCExtensionInit(INITARGS);
+extern void XvRegister(INITARGS);
+#include <X11/extensions/Xv.h>
+#include <X11/extensions/XvMC.h>
+#endif
+
+#ifdef RES
+extern void ResExtensionInit(INITARGS);
+#include <X11/extensions/XResproto.h>
+#endif
+
+#ifdef SHM
+extern void ShmExtensionInit(INITARGS);
+#include <X11/extensions/shmproto.h>
+extern void ShmRegisterFuncs(
+    ScreenPtr pScreen,
+    ShmFuncsPtr funcs);
+#endif
+
+#ifdef XSELINUX
+extern void SELinuxExtensionInit(INITARGS);
+#include "xselinux.h"
+#endif
+
+#ifdef XEVIE
+extern void XevieExtensionInit(INITARGS);
+#endif
+
+#if 1
+extern void SecurityExtensionInit(INITARGS);
+#endif
+
+#if 1
+extern void PanoramiXExtensionInit(int argc, char *argv[]);
+#endif
+
+#if 1
+extern void XkbExtensionInit(INITARGS);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/edid.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/edid.h
@@ -0,0 +1,662 @@
+/*
+ * edid.h: defines to parse an EDID block 
+ *
+ * This file contains all information to interpret a standard EDIC block 
+ * transmitted by a display device via DDC (Display Data Channel). So far 
+ * there is no information to deal with optional EDID blocks.  
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ */
+
+#ifndef _EDID_H_
+#define _EDID_H_ 
+
+#include <X11/Xmd.h>
+
+#ifndef _X_EXPORT
+# include <X11/Xfuncproto.h>
+#endif
+
+/* read complete EDID record */
+#define EDID1_LEN 128
+#define BITS_PER_BYTE 9
+#define NUM BITS_PER_BYTE*EDID1_LEN
+#define HEADER 6
+
+#define STD_TIMINGS 8
+#define DET_TIMINGS 4
+
+#ifdef _PARSE_EDID_
+
+/* header: 0x00 0xFF 0xFF 0xFF 0xFF 0xFF 0xFF 0x00  */
+#define HEADER_SECTION 0
+#define HEADER_LENGTH 8
+
+/* vendor section */
+#define VENDOR_SECTION (HEADER_SECTION + HEADER_LENGTH)
+#define V_MANUFACTURER 0
+#define V_PROD_ID (V_MANUFACTURER + 2)
+#define V_SERIAL (V_PROD_ID + 2)
+#define V_WEEK (V_SERIAL + 4)
+#define V_YEAR (V_WEEK + 1)
+#define VENDOR_LENGTH (V_YEAR + 1)
+
+/* EDID version */
+#define VERSION_SECTION (VENDOR_SECTION + VENDOR_LENGTH)
+#define V_VERSION 0
+#define V_REVISION (V_VERSION + 1)
+#define VERSION_LENGTH (V_REVISION + 1)
+
+/* display information */
+#define DISPLAY_SECTION (VERSION_SECTION + VERSION_LENGTH)
+#define D_INPUT 0
+#define D_HSIZE (D_INPUT + 1)
+#define D_VSIZE (D_HSIZE + 1)
+#define D_GAMMA (D_VSIZE + 1)
+#define FEAT_S (D_GAMMA + 1)
+#define D_RG_LOW (FEAT_S + 1)
+#define D_BW_LOW (D_RG_LOW + 1)
+#define D_REDX (D_BW_LOW + 1)
+#define D_REDY (D_REDX + 1)
+#define D_GREENX (D_REDY + 1)
+#define D_GREENY (D_GREENX + 1)
+#define D_BLUEX (D_GREENY + 1)
+#define D_BLUEY (D_BLUEX + 1)
+#define D_WHITEX (D_BLUEY + 1)
+#define D_WHITEY (D_WHITEX + 1)
+#define DISPLAY_LENGTH (D_WHITEY + 1)
+
+/* supported VESA and other standard timings */
+#define ESTABLISHED_TIMING_SECTION (DISPLAY_SECTION + DISPLAY_LENGTH)
+#define E_T1 0
+#define E_T2 (E_T1 + 1)
+#define E_TMANU (E_T2 + 1)
+#define E_TIMING_LENGTH (E_TMANU + 1) 
+
+/* non predefined standard timings supported by display */
+#define STD_TIMING_SECTION (ESTABLISHED_TIMING_SECTION + E_TIMING_LENGTH)
+#define STD_TIMING_INFO_LEN 2
+#define STD_TIMING_INFO_NUM STD_TIMINGS
+#define STD_TIMING_LENGTH (STD_TIMING_INFO_LEN * STD_TIMING_INFO_NUM)
+
+/* detailed timing info of non standard timings */
+#define DET_TIMING_SECTION (STD_TIMING_SECTION + STD_TIMING_LENGTH)
+#define DET_TIMING_INFO_LEN 18
+#define MONITOR_DESC_LEN DET_TIMING_INFO_LEN
+#define DET_TIMING_INFO_NUM DET_TIMINGS
+#define DET_TIMING_LENGTH (DET_TIMING_INFO_LEN * DET_TIMING_INFO_NUM)
+
+/* number of EDID sections to follow */
+#define NO_EDID (DET_TIMING_SECTION + DET_TIMING_LENGTH)
+/* one byte checksum */
+#define CHECKSUM (NO_EDID + 1)  
+
+#if (CHECKSUM != (EDID1_LEN - 1))
+# error "EDID1 length != 128!" 
+#endif
+
+
+#define SECTION(x,y) (Uchar *)(x + y)
+#define GET_ARRAY(y) ((Uchar *)(c + y))
+#define GET(y) *(Uchar *)(c + y)
+
+/* extract information from vendor section */
+#define _PROD_ID(x) x[0] + (x[1] << 8);
+#define PROD_ID _PROD_ID(GET_ARRAY(V_PROD_ID))
+#define _SERIAL_NO(x) x[0] + (x[1] << 8) + (x[2] << 16) + (x[3] << 24)
+#define SERIAL_NO _SERIAL_NO(GET_ARRAY(V_SERIAL))
+#define _YEAR(x) (x & 0xFF) + 1990
+#define YEAR _YEAR(GET(V_YEAR))
+#define WEEK GET(V_WEEK) & 0xFF
+#define _L1(x) ((x[0] & 0x7C) >> 2) + '@'
+#define _L2(x) ((x[0] & 0x03) << 3) + ((x[1] & 0xE0) >> 5) + '@'
+#define _L3(x) (x[1] & 0x1F) + '@';
+#define L1 _L1(GET_ARRAY(V_MANUFACTURER))
+#define L2 _L2(GET_ARRAY(V_MANUFACTURER))
+#define L3 _L3(GET_ARRAY(V_MANUFACTURER))
+
+/* extract information from version section */
+#define VERSION GET(V_VERSION)
+#define REVISION GET(V_REVISION)
+
+/* extract information from display section */
+#define _INPUT_TYPE(x) ((x & 0x80) >> 7)
+#define INPUT_TYPE _INPUT_TYPE(GET(D_INPUT))
+#define _INPUT_VOLTAGE(x) ((x & 0x60) >> 5)
+#define INPUT_VOLTAGE _INPUT_VOLTAGE(GET(D_INPUT))
+#define _SETUP(x) ((x & 0x10) >> 4)
+#define SETUP _SETUP(GET(D_INPUT))
+#define _SYNC(x) (x  & 0x0F)
+#define SYNC _SYNC(GET(D_INPUT))
+#define _DFP(x) (x & 0x01)
+#define DFP _DFP(GET(D_INPUT))
+#define _BPC(x) ((x & 0x70) >> 4)
+#define BPC _BPC(GET(D_INPUT))
+#define _DIGITAL_INTERFACE(x) (x & 0x0F)
+#define DIGITAL_INTERFACE _DIGITAL_INTERFACE(GET(D_INPUT))
+#define _GAMMA(x) (x == 0xff ? 0.0 : ((x + 100.0)/100.0))
+#define GAMMA _GAMMA(GET(D_GAMMA))
+#define HSIZE_MAX GET(D_HSIZE)
+#define VSIZE_MAX GET(D_VSIZE)
+#define _DPMS(x) ((x & 0xE0) >> 5)
+#define DPMS _DPMS(GET(FEAT_S))
+#define _DISPLAY_TYPE(x) ((x & 0x18) >> 3)
+#define DISPLAY_TYPE _DISPLAY_TYPE(GET(FEAT_S))
+#define _MSC(x) (x & 0x7)
+#define MSC _MSC(GET(FEAT_S))
+
+
+/* color characteristics */
+#define CC_L(x,y) ((x & (0x03 << y)) >> y)
+#define CC_H(x) (x << 2)
+#define I_CC(x,y,z) CC_H(y) | CC_L(x,z)
+#define F_CC(x) ((x)/1024.0)
+#define REDX F_CC(I_CC((GET(D_RG_LOW)),(GET(D_REDX)),6))
+#define REDY F_CC(I_CC((GET(D_RG_LOW)),(GET(D_REDY)),4))
+#define GREENX F_CC(I_CC((GET(D_RG_LOW)),(GET(D_GREENX)),2))
+#define GREENY F_CC(I_CC((GET(D_RG_LOW)),(GET(D_GREENY)),0))
+#define BLUEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_BLUEX)),6))
+#define BLUEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_BLUEY)),4))
+#define WHITEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEX)),2))
+#define WHITEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEY)),0))
+
+/* extract information from standard timing section */
+#define T1 GET(E_T1)
+#define T2 GET(E_T2)
+#define T_MANU GET(E_TMANU)
+
+/* extract information from estabished timing section */
+#define _VALID_TIMING(x) !(((x[0] == 0x01) && (x[1] == 0x01)) \
+                        || ((x[0] == 0x00) && (x[1] == 0x00)) \
+                        || ((x[0] == 0x20) && (x[1] == 0x20)) )
+#define VALID_TIMING _VALID_TIMING(c)
+#define _HSIZE1(x) ((x[0] + 31) * 8)
+#define HSIZE1 _HSIZE1(c)
+#define RATIO(x) ((x[1] & 0xC0) >> 6)
+#define RATIO1_1 0
+/* EDID Ver. 1.3 redefined this */
+#define RATIO16_10 RATIO1_1
+#define RATIO4_3 1
+#define RATIO5_4 2
+#define RATIO16_9 3
+#define _VSIZE1(x,y,r) switch(RATIO(x)){ \
+  case RATIO1_1: y =  ((v->version > 1 || v->revision > 2) \
+		       ? (_HSIZE1(x) * 10) / 16 : _HSIZE1(x)); break; \
+  case RATIO4_3: y = _HSIZE1(x) * 3 / 4; break; \
+  case RATIO5_4: y = _HSIZE1(x) * 4 / 5; break; \
+  case RATIO16_9: y = _HSIZE1(x) * 9 / 16; break; \
+  }
+#define VSIZE1(x) _VSIZE1(c,x,v)
+#define _REFRESH_R(x) (x[1] & 0x3F) + 60
+#define REFRESH_R  _REFRESH_R(c)
+#define _ID_LOW(x) x[0]
+#define ID_LOW _ID_LOW(c)
+#define _ID_HIGH(x) (x[1] << 8)
+#define ID_HIGH _ID_HIGH(c)
+#define STD_TIMING_ID (ID_LOW | ID_HIGH)
+#define _NEXT_STD_TIMING(x)  (x = (x + STD_TIMING_INFO_LEN))
+#define NEXT_STD_TIMING _NEXT_STD_TIMING(c)
+
+
+/* EDID Ver. >= 1.2 */
+/**
+ * Returns true if the pointer is the start of a monitor descriptor block
+ * instead of a detailed timing descriptor.
+ *
+ * Checking the reserved pad fields for zeroes fails on some monitors with
+ * broken empty ASCII strings.  Only the first two bytes are reliable.
+ */
+#define _IS_MONITOR_DESC(x) (x[0] == 0 && x[1] == 0)
+#define IS_MONITOR_DESC _IS_MONITOR_DESC(c)
+#define _PIXEL_CLOCK(x) (x[0] + (x[1] << 8)) * 10000
+#define PIXEL_CLOCK _PIXEL_CLOCK(c)
+#define _H_ACTIVE(x) (x[2] + ((x[4] & 0xF0) << 4))
+#define H_ACTIVE _H_ACTIVE(c)
+#define _H_BLANK(x) (x[3] + ((x[4] & 0x0F) << 8))
+#define H_BLANK _H_BLANK(c)
+#define _V_ACTIVE(x) (x[5] + ((x[7] & 0xF0) << 4))
+#define V_ACTIVE _V_ACTIVE(c)
+#define _V_BLANK(x) (x[6] + ((x[7] & 0x0F) << 8))
+#define V_BLANK _V_BLANK(c)
+#define _H_SYNC_OFF(x) (x[8] + ((x[11] & 0xC0) << 2))
+#define H_SYNC_OFF _H_SYNC_OFF(c)
+#define _H_SYNC_WIDTH(x) (x[9] + ((x[11] & 0x30) << 4))
+#define H_SYNC_WIDTH _H_SYNC_WIDTH(c)
+#define _V_SYNC_OFF(x) ((x[10] >> 4) + ((x[11] & 0x0C) << 2))
+#define V_SYNC_OFF _V_SYNC_OFF(c)
+#define _V_SYNC_WIDTH(x) ((x[10] & 0x0F) + ((x[11] & 0x03) << 4))
+#define V_SYNC_WIDTH _V_SYNC_WIDTH(c)
+#define _H_SIZE(x) (x[12] + ((x[14] & 0xF0) << 4))
+#define H_SIZE _H_SIZE(c)
+#define _V_SIZE(x) (x[13] + ((x[14] & 0x0F) << 8))
+#define V_SIZE _V_SIZE(c)
+#define _H_BORDER(x) (x[15])
+#define H_BORDER _H_BORDER(c)
+#define _V_BORDER(x) (x[16])
+#define V_BORDER _V_BORDER(c)
+#define _INTERLACED(x) ((x[17] & 0x80) >> 7)
+#define INTERLACED _INTERLACED(c)
+#define _STEREO(x) ((x[17] & 0x60) >> 5)
+#define STEREO _STEREO(c)
+#define _STEREO1(x) (x[17] & 0x1)
+#define STEREO1 _STEREO(c)
+#define _SYNC_T(x) ((x[17] & 0x18) >> 3)
+#define SYNC_T _SYNC_T(c)
+#define _MISC(x) ((x[17] & 0x06) >> 1)
+#define MISC _MISC(c)
+
+#define _MONITOR_DESC_TYPE(x) x[3]
+#define MONITOR_DESC_TYPE _MONITOR_DESC_TYPE(c)
+#define SERIAL_NUMBER 0xFF
+#define ASCII_STR 0xFE
+#define MONITOR_RANGES 0xFD
+#define _MIN_V_OFFSET(x) ((!!(x[4] & 0x01)) * 255)
+#define _MAX_V_OFFSET(x) ((!!(x[4] & 0x02)) * 255)
+#define _MIN_H_OFFSET(x) ((!!(x[4] & 0x04)) * 255)
+#define _MAX_H_OFFSET(x) ((!!(x[4] & 0x08)) * 255)
+#define _MIN_V(x) x[5]
+#define MIN_V (_MIN_V(c) + _MIN_V_OFFSET(c))
+#define _MAX_V(x) x[6]
+#define MAX_V (_MAX_V(c) + _MAX_V_OFFSET(c))
+#define _MIN_H(x) x[7]
+#define MIN_H (_MIN_H(c) + _MIN_H_OFFSET(c))
+#define _MAX_H(x) x[8]
+#define MAX_H (_MAX_H(c) + _MAX_H_OFFSET(c))
+#define _MAX_CLOCK(x) x[9]
+#define MAX_CLOCK _MAX_CLOCK(c) 
+#define _HAVE_2ND_GTF(x) (x[10] == 0x02)
+#define HAVE_2ND_GTF _HAVE_2ND_GTF(c)
+#define _F_2ND_GTF(x) (x[12] * 2)
+#define F_2ND_GTF _F_2ND_GTF(c)
+#define _C_2ND_GTF(x) (x[13] / 2)
+#define C_2ND_GTF _C_2ND_GTF(c)
+#define _M_2ND_GTF(x) (x[14] + (x[15] << 8))
+#define M_2ND_GTF _M_2ND_GTF(c)
+#define _K_2ND_GTF(x) (x[16])
+#define K_2ND_GTF _K_2ND_GTF(c)
+#define _J_2ND_GTF(x) (x[17] / 2)
+#define J_2ND_GTF _J_2ND_GTF(c)
+#define _HAVE_CVT(x) (x[10] == 0x04)
+#define HAVE_CVT _HAVE_CVT(c)
+#define _MAX_CLOCK_KHZ(x) (x[12] >> 2)
+#define MAX_CLOCK_KHZ (MAX_CLOCK * 10000) - (_MAX_CLOCK_KHZ(c) * 250)
+#define _MAXWIDTH(x) ((x[13] == 0 ? 0 : x[13] + ((x[12] & 0x03) << 8)) * 8)
+#define MAXWIDTH _MAXWIDTH(c)
+#define _SUPPORTED_ASPECT(x) x[14]
+#define SUPPORTED_ASPECT _SUPPORTED_ASPECT(c)
+#define  SUPPORTED_ASPECT_4_3   0x80
+#define  SUPPORTED_ASPECT_16_9  0x40
+#define  SUPPORTED_ASPECT_16_10 0x20
+#define  SUPPORTED_ASPECT_5_4   0x10
+#define  SUPPORTED_ASPECT_15_9  0x08
+#define _PREFERRED_ASPECT(x) ((x[15] & 0xe0) >> 5)
+#define PREFERRED_ASPECT _PREFERRED_ASPECT(c)
+#define  PREFERRED_ASPECT_4_3   0
+#define  PREFERRED_ASPECT_16_9  1
+#define  PREFERRED_ASPECT_16_10 2
+#define  PREFERRED_ASPECT_5_4   3
+#define  PREFERRED_ASPECT_15_9  4
+#define _SUPPORTED_BLANKING(x) ((x[15] & 0x18) >> 3)
+#define SUPPORTED_BLANKING _SUPPORTED_BLANKING(c)
+#define  CVT_STANDARD 0x01
+#define  CVT_REDUCED  0x02
+#define _SUPPORTED_SCALING(x) ((x[16] & 0xf0) >> 4)
+#define SUPPORTED_SCALING _SUPPORTED_SCALING(c)
+#define  SCALING_HSHRINK  0x08
+#define  SCALING_HSTRETCH 0x04
+#define  SCALING_VSHRINK  0x02
+#define  SCALING_VSTRETCH 0x01
+#define _PREFERRED_REFRESH(x) x[17]
+#define PREFERRED_REFRESH _PREFERRED_REFRESH(c)
+
+#define MONITOR_NAME 0xFC
+#define ADD_COLOR_POINT 0xFB
+#define WHITEX F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEX)),2))
+#define WHITEY F_CC(I_CC((GET(D_BW_LOW)),(GET(D_WHITEY)),0))
+#define _WHITEX_ADD(x,y) F_CC(I_CC(((*(x + y))),(*(x + y + 1)),2))
+#define _WHITEY_ADD(x,y) F_CC(I_CC(((*(x + y))),(*(x + y + 2)),0))
+#define _WHITE_INDEX1(x) x[5]
+#define WHITE_INDEX1 _WHITE_INDEX1(c)
+#define _WHITE_INDEX2(x) x[10]
+#define WHITE_INDEX2 _WHITE_INDEX2(c)
+#define WHITEX1 _WHITEX_ADD(c,6)
+#define WHITEY1 _WHITEY_ADD(c,6)
+#define WHITEX2 _WHITEX_ADD(c,12)
+#define WHITEY2 _WHITEY_ADD(c,12)
+#define _WHITE_GAMMA1(x) _GAMMA(x[9])
+#define WHITE_GAMMA1 _WHITE_GAMMA1(c) 
+#define _WHITE_GAMMA2(x) _GAMMA(x[14])
+#define WHITE_GAMMA2 _WHITE_GAMMA2(c)
+#define ADD_STD_TIMINGS 0xFA
+#define COLOR_MANAGEMENT_DATA 0xF9
+#define CVT_3BYTE_DATA 0xF8
+#define ADD_EST_TIMINGS 0xF7
+#define ADD_DUMMY 0x10
+
+#define _NEXT_DT_MD_SECTION(x) (x = (x + DET_TIMING_INFO_LEN))
+#define NEXT_DT_MD_SECTION _NEXT_DT_MD_SECTION(c)
+
+#endif /* _PARSE_EDID_ */
+
+/* input type */
+#define DIGITAL(x) x
+
+/* DFP */
+#define DFP1(x) x
+
+/* input voltage level */
+#define V070 0  /* 0.700V/0.300V */
+#define V071 1  /* 0.714V/0.286V */
+#define V100 2  /* 1.000V/0.400V */
+#define V007 3 /* 0.700V/0.000V */
+
+/* Signal level setup */
+#define SIG_SETUP(x) (x)
+
+/* sync characteristics */
+#define SEP_SYNC(x) (x & 0x08)
+#define COMP_SYNC(x) (x & 0x04)
+#define SYNC_O_GREEN(x) (x & 0x02)
+#define SYNC_SERR(x) (x & 0x01)
+
+/* DPMS features */
+#define DPMS_STANDBY(x) (x & 0x04)
+#define DPMS_SUSPEND(x) (x & 0x02)
+#define DPMS_OFF(x) (x & 0x01)
+
+/* display type, analog */
+#define DISP_MONO 0
+#define DISP_RGB 1
+#define DISP_MULTCOLOR 2
+
+/* display color encodings, digital */
+#define DISP_YCRCB444 0x01
+#define DISP_YCRCB422 0x02
+
+/* Msc stuff EDID Ver > 1.1 */
+#define STD_COLOR_SPACE(x) (x & 0x4)
+#define PREFERRED_TIMING_MODE(x) (x & 0x2)
+#define GFT_SUPPORTED(x) (x & 0x1)
+#define GTF_SUPPORTED(x) (x & 0x1)
+#define CVT_SUPPORTED(x) (x & 0x1)
+
+/* detailed timing misc */
+#define IS_INTERLACED(x)  (x) 
+#define IS_STEREO(x)  (x) 
+#define IS_RIGHT_STEREO(x) (x & 0x01)
+#define IS_LEFT_STEREO(x) (x & 0x02)
+#define IS_4WAY_STEREO(x) (x & 0x03)
+#define IS_RIGHT_ON_SYNC(x) IS_RIGHT_STEREO(x)
+#define IS_LEFT_ON_SYNC(x) IS_LEFT_STEREO(x)
+
+
+typedef unsigned int Uint;
+typedef unsigned char Uchar;
+
+struct vendor {
+  char name[4];
+  int prod_id;
+  Uint serial;
+  int week;
+  int year;
+};
+
+struct edid_version {
+  int version;
+  int revision;
+};
+
+struct disp_features {
+  unsigned int input_type:1;
+  unsigned int input_voltage:2;
+  unsigned int input_setup:1;
+  unsigned int input_sync:5;
+  unsigned int input_dfp:1;
+  unsigned int input_bpc:3;
+  unsigned int input_interface:4;
+  /* 15 bit hole */
+  int hsize;
+  int vsize;
+  float gamma;
+  unsigned int dpms:3;
+  unsigned int display_type:2;
+  unsigned int msc:3;
+  float redx;
+  float redy;
+  float greenx;
+  float greeny;
+  float bluex;
+  float bluey;
+  float whitex;
+  float whitey;
+};
+
+struct established_timings {
+  Uchar t1;
+  Uchar t2;
+  Uchar t_manu;
+};
+
+struct std_timings {
+  int hsize;
+  int vsize;
+  int refresh;
+  CARD16 id;
+};
+
+struct detailed_timings {
+  int clock;
+  int h_active;
+  int h_blanking;
+  int v_active;
+  int v_blanking;
+  int h_sync_off;
+  int h_sync_width;
+  int v_sync_off;
+  int v_sync_width;
+  int h_size;
+  int v_size;
+  int h_border;
+  int v_border;
+  unsigned int interlaced:1;
+  unsigned int stereo:2;
+  unsigned int sync:2;
+  unsigned int misc:2;
+  unsigned int stereo_1:1;
+};
+
+#define DT 0
+#define DS_SERIAL 0xFF
+#define DS_ASCII_STR 0xFE
+#define DS_NAME 0xFC
+#define DS_RANGES 0xFD
+#define DS_WHITE_P 0xFB
+#define DS_STD_TIMINGS 0xFA
+#define DS_CMD 0xF9
+#define DS_CVT 0xF8
+#define DS_EST_III 0xF7
+#define DS_DUMMY 0x10
+#define DS_UNKOWN 0x100 /* type is an int */
+#define DS_VENDOR 0x101
+#define DS_VENDOR_MAX 0x110
+
+struct monitor_ranges {
+  int min_v;
+  int max_v;
+  int min_h;
+  int max_h;
+  int max_clock;    /* in mhz */
+  int gtf_2nd_f;
+  int gtf_2nd_c;
+  int gtf_2nd_m;
+  int gtf_2nd_k;
+  int gtf_2nd_j;
+  int max_clock_khz;
+  int maxwidth;	    /* in pixels */
+  char supported_aspect;
+  char preferred_aspect;
+  char supported_blanking;
+  char supported_scaling;
+  int preferred_refresh; /* in hz */
+};
+
+struct whitePoints{
+  int   index;
+  float white_x;
+  float white_y;
+  float white_gamma;
+};
+
+struct cvt_timings {
+    int width;
+    int height;
+    int rate;
+    int rates;
+};
+
+/*
+ * Be careful when adding new sections; this structure can't grow, it's
+ * embedded in the middle of xf86Monitor which is ABI.  Sizes below are
+ * in bytes, for ILP32 systems.  If all else fails just copy the section
+ * literally like serial and friends.
+ */
+struct detailed_monitor_section {
+  int type;
+  union {
+    struct detailed_timings d_timings;	/* 56 */
+    Uchar serial[13];
+    Uchar ascii_data[13];
+    Uchar name[13];
+    struct monitor_ranges ranges;	/* 56 */
+    struct std_timings std_t[5];	/* 80 */
+    struct whitePoints wp[2];		/* 32 */
+    /* color management data */
+    struct cvt_timings cvt[4];		/* 64 */
+    Uchar est_iii[6];			/* 6 */
+  } section;				/* max: 80 */
+};
+
+/* flags */
+#define MONITOR_EDID_COMPLETE_RAWDATA	0x01
+/* old, don't use */
+#define EDID_COMPLETE_RAWDATA		0x01
+#define MONITOR_DISPLAYID		0x02
+
+/*
+ * For DisplayID devices, only the scrnIndex, flags, and rawData fields
+ * are meaningful.  For EDID, they all are.
+ */
+typedef struct {
+  int scrnIndex;
+  struct vendor vendor;
+  struct edid_version ver;
+  struct disp_features features;
+  struct established_timings timings1;
+  struct std_timings timings2[8];
+  struct detailed_monitor_section det_mon[4];
+  unsigned long flags;
+  int no_sections;
+  Uchar *rawData;
+} xf86Monitor, *xf86MonPtr;
+
+extern _X_EXPORT xf86MonPtr ConfiguredMonitor;
+
+#define EXT_TAG 0
+#define EXT_REV 1
+#define CEA_EXT   0x02
+#define VTB_EXT   0x10
+#define DI_EXT    0x40
+#define LS_EXT    0x50
+#define MI_EXT    0x60
+
+#define CEA_EXT_MIN_DATA_OFFSET 4
+#define CEA_EXT_MAX_DATA_OFFSET 127
+#define CEA_EXT_DET_TIMING_NUM 6
+
+#define IEEE_ID_HDMI    0x000C03
+#define CEA_AUDIO_BLK   1
+#define CEA_VIDEO_BLK   2
+#define CEA_VENDOR_BLK  3
+#define CEA_SPEAKER_ALLOC_BLK 4
+#define CEA_VESA_DTC_BLK 5
+#define VENDOR_SUPPORT_AI(x) ((x) >> 7)
+#define VENDOR_SUPPORT_DC_48bit(x)  ( ( (x) >> 6) & 0x01)
+#define VENDOR_SUPPORT_DC_36bit(x)  ( ( (x) >> 5) & 0x01)
+#define VENDOR_SUPPORT_DC_30bit(x)  ( ( (x) >> 4) & 0x01)
+#define VENDOR_SUPPORT_DC_Y444(x)   ( ( (x) >> 3) & 0x01)
+#define VENDOR_LATENCY_PRESENT(x)     ( (x) >> 7)
+#define VENDOR_LATENCY_PRESENT_I(x) ( ( (x) >> 6) & 0x01)
+#define HDMI_MAX_TMDS_UNIT   (5000)
+
+struct cea_video_block {
+  Uchar video_code;
+};
+
+struct cea_audio_block_descriptor {
+  Uchar audio_code[3];
+};
+
+struct cea_audio_block {
+  struct cea_audio_block_descriptor descriptor[10];
+};
+
+struct cea_vendor_block_hdmi {
+  __extension__ Uchar portB:4;
+  __extension__ Uchar portA:4;
+  __extension__ Uchar portD:4;
+  __extension__ Uchar portC:4;
+  Uchar  support_flags;
+  Uchar  max_tmds_clock;
+  Uchar  latency_present;
+  Uchar  video_latency;
+  Uchar  audio_latency;
+  Uchar  interlaced_video_latency;
+  Uchar  interlaced_audio_latency;
+};
+
+struct cea_vendor_block {
+  unsigned char ieee_id[3];
+  union {
+      struct cea_vendor_block_hdmi hdmi;
+      /* any other vendor blocks we know about */
+  } dummy;
+};
+
+struct cea_speaker_block
+{
+  __extension__ Uchar FLR:1;
+  __extension__ Uchar LFE:1;
+  __extension__ Uchar FC:1;
+  __extension__ Uchar RLR:1;
+  __extension__ Uchar RC:1;
+  __extension__ Uchar FLRC:1;
+  __extension__ Uchar RLRC:1;
+  __extension__ Uchar FLRW:1;
+  __extension__ Uchar FLRH:1;
+  __extension__ Uchar TC:1;
+  __extension__ Uchar FCH:1;
+  __extension__ Uchar Resv:5;
+  __extension__ Uchar ResvByte;
+};
+
+struct cea_data_block {
+  __extension__ Uchar len:5;
+  __extension__ Uchar tag:3;
+  union{
+    struct cea_video_block video;
+    struct cea_audio_block audio;
+    struct cea_vendor_block vendor;
+    struct cea_speaker_block speaker;
+  }u;
+};
+
+struct cea_ext_body {
+  Uchar tag;
+  Uchar rev;
+  Uchar dt_offset;
+  Uchar flags;
+  struct cea_data_block data_collection;
+};
+
+#endif /* _EDID_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Bus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Bus.h
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the bus-related data structures/types.
+ * Everything contained here is private to xf86Bus.c.  In particular the
+ * video drivers must not include this file.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _XF86_BUS_H
+#define _XF86_BUS_H
+
+#include "xf86pciBus.h"
+#if defined(__sparc__) || defined(__sparc)
+#include "xf86sbusBus.h"
+#endif
+
+typedef struct {
+    DriverPtr                   driver;
+    int                         chipset;
+    int                         entityProp;
+    EntityProc                  entityInit;
+    EntityProc                  entityEnter;
+    EntityProc                  entityLeave;
+    pointer                     private;
+    Bool                        active;
+    Bool                        inUse;
+    BusRec                      bus;
+    int                         lastScrnFlag;
+    DevUnion *                  entityPrivates;
+    int                         numInstances;
+    GDevPtr *                   devices;   
+    IOADDRESS                   domainIO;
+} EntityRec, *EntityPtr;
+
+#define ACCEL_IS_SHARABLE 0x100
+#define IS_SHARED_ACCEL 0x200
+#define SA_PRIM_INIT_DONE 0x400
+
+extern EntityPtr *xf86Entities;
+extern int xf86NumEntities;
+extern BusRec primaryBus;
+
+int xf86AllocateEntity(void);
+BusType StringToBusType(const char* busID, const char **retID);
+
+#endif /* _XF86_BUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Parser.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Parser.h
@@ -0,0 +1,530 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/* 
+ * This file contains the external interfaces for the XFree86 configuration
+ * file parser.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86Parser_h_
+#define _xf86Parser_h_
+
+#include <X11/Xdefs.h>
+#include "xf86Optrec.h"
+#include "list.h"
+
+#define HAVE_PARSER_DECLS
+
+typedef struct
+{
+	char *file_logfile;
+	char *file_modulepath;
+	char *file_fontpath;
+	char *file_comment;
+	char *file_xkbdir;
+}
+XF86ConfFilesRec, *XF86ConfFilesPtr;
+
+/* Values for load_type */
+#define XF86_LOAD_MODULE	0
+#define XF86_LOAD_DRIVER	1
+#define XF86_DISABLE_MODULE	2
+
+typedef struct
+{
+	GenericListRec list;
+	int load_type;
+	char *load_name;
+	XF86OptionPtr load_opt;
+	char *load_comment;
+        int ignore;
+}
+XF86LoadRec, *XF86LoadPtr;
+
+typedef struct
+{
+	XF86LoadPtr mod_load_lst;
+    XF86LoadPtr mod_disable_lst;
+	char *mod_comment;
+}
+XF86ConfModuleRec, *XF86ConfModulePtr;
+
+#define CONF_IMPLICIT_KEYBOARD	"Implicit Core Keyboard"
+
+#define CONF_IMPLICIT_POINTER	"Implicit Core Pointer"
+
+#define XF86CONF_PHSYNC    0x0001
+#define XF86CONF_NHSYNC    0x0002
+#define XF86CONF_PVSYNC    0x0004
+#define XF86CONF_NVSYNC    0x0008
+#define XF86CONF_INTERLACE 0x0010
+#define XF86CONF_DBLSCAN   0x0020
+#define XF86CONF_CSYNC     0x0040
+#define XF86CONF_PCSYNC    0x0080
+#define XF86CONF_NCSYNC    0x0100
+#define XF86CONF_HSKEW     0x0200	/* hskew provided */
+#define XF86CONF_BCAST     0x0400
+#define XF86CONF_CUSTOM    0x0800	/* timing numbers customized by editor */
+#define XF86CONF_VSCAN     0x1000
+
+typedef struct
+{
+	GenericListRec list;
+	char *ml_identifier;
+	int ml_clock;
+	int ml_hdisplay;
+	int ml_hsyncstart;
+	int ml_hsyncend;
+	int ml_htotal;
+	int ml_vdisplay;
+	int ml_vsyncstart;
+	int ml_vsyncend;
+	int ml_vtotal;
+	int ml_vscan;
+	int ml_flags;
+	int ml_hskew;
+	char *ml_comment;
+}
+XF86ConfModeLineRec, *XF86ConfModeLinePtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *vp_identifier;
+	XF86OptionPtr vp_option_lst;
+	char *vp_comment;
+}
+XF86ConfVideoPortRec, *XF86ConfVideoPortPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *va_identifier;
+	char *va_vendor;
+	char *va_board;
+	char *va_busid;
+	char *va_driver;
+	XF86OptionPtr va_option_lst;
+	XF86ConfVideoPortPtr va_port_lst;
+	char *va_fwdref;
+	char *va_comment;
+}
+XF86ConfVideoAdaptorRec, *XF86ConfVideoAdaptorPtr;
+
+#define CONF_MAX_HSYNC 8
+#define CONF_MAX_VREFRESH 8
+
+typedef struct
+{
+	float hi, lo;
+}
+parser_range;
+
+typedef struct
+{
+	int red, green, blue;
+}
+parser_rgb;
+
+typedef struct
+{
+	GenericListRec list;
+	char *modes_identifier;
+	XF86ConfModeLinePtr mon_modeline_lst;
+	char *modes_comment;
+}
+XF86ConfModesRec, *XF86ConfModesPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *ml_modes_str;
+	XF86ConfModesPtr ml_modes;
+}
+XF86ConfModesLinkRec, *XF86ConfModesLinkPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *mon_identifier;
+	char *mon_vendor;
+	char *mon_modelname;
+	int mon_width;				/* in mm */
+	int mon_height;				/* in mm */
+	XF86ConfModeLinePtr mon_modeline_lst;
+	int mon_n_hsync;
+	parser_range mon_hsync[CONF_MAX_HSYNC];
+	int mon_n_vrefresh;
+	parser_range mon_vrefresh[CONF_MAX_VREFRESH];
+	float mon_gamma_red;
+	float mon_gamma_green;
+	float mon_gamma_blue;
+	XF86OptionPtr mon_option_lst;
+	XF86ConfModesLinkPtr mon_modes_sect_lst;
+	char *mon_comment;
+}
+XF86ConfMonitorRec, *XF86ConfMonitorPtr;
+
+#define CONF_MAXDACSPEEDS 4
+#define CONF_MAXCLOCKS    128
+
+typedef struct
+{
+	GenericListRec list;
+	char *dev_identifier;
+	char *dev_vendor;
+	char *dev_board;
+	char *dev_chipset;
+	char *dev_busid;
+	char *dev_card;
+	char *dev_driver;
+	char *dev_ramdac;
+	int dev_dacSpeeds[CONF_MAXDACSPEEDS];
+	int dev_videoram;
+	int dev_textclockfreq;
+	unsigned long dev_bios_base;
+	unsigned long dev_mem_base;
+	unsigned long dev_io_base;
+	char *dev_clockchip;
+	int dev_clocks;
+	int dev_clock[CONF_MAXCLOCKS];
+	int dev_chipid;
+	int dev_chiprev;
+	int dev_irq;
+	int dev_screen;
+	XF86OptionPtr dev_option_lst;
+	char *dev_comment;
+}
+XF86ConfDeviceRec, *XF86ConfDevicePtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *mode_name;
+}
+XF86ModeRec, *XF86ModePtr;
+
+typedef struct
+{
+	GenericListRec list;
+	int disp_frameX0;
+	int disp_frameY0;
+	int disp_virtualX;
+	int disp_virtualY;
+	int disp_depth;
+	int disp_bpp;
+	char *disp_visual;
+	parser_rgb disp_weight;
+	parser_rgb disp_black;
+	parser_rgb disp_white;
+	XF86ModePtr disp_mode_lst;
+	XF86OptionPtr disp_option_lst;
+	char *disp_comment;
+}
+XF86ConfDisplayRec, *XF86ConfDisplayPtr;
+
+typedef struct
+{
+	XF86OptionPtr flg_option_lst;
+	char *flg_comment;
+}
+XF86ConfFlagsRec, *XF86ConfFlagsPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *al_adaptor_str;
+	XF86ConfVideoAdaptorPtr al_adaptor;
+}
+XF86ConfAdaptorLinkRec, *XF86ConfAdaptorLinkPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *scrn_identifier;
+	char *scrn_obso_driver;
+	int scrn_defaultdepth;
+	int scrn_defaultbpp;
+	int scrn_defaultfbbpp;
+	char *scrn_monitor_str;
+	XF86ConfMonitorPtr scrn_monitor;
+	char *scrn_device_str;
+	XF86ConfDevicePtr scrn_device;
+	XF86ConfAdaptorLinkPtr scrn_adaptor_lst;
+	XF86ConfDisplayPtr scrn_display_lst;
+	XF86OptionPtr scrn_option_lst;
+	char *scrn_comment;
+	int scrn_virtualX, scrn_virtualY;
+}
+XF86ConfScreenRec, *XF86ConfScreenPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *inp_identifier;
+	char *inp_driver;
+	XF86OptionPtr inp_option_lst;
+	char *inp_comment;
+}
+XF86ConfInputRec, *XF86ConfInputPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	XF86ConfInputPtr iref_inputdev;
+	char *iref_inputdev_str;
+	XF86OptionPtr iref_option_lst;
+}
+XF86ConfInputrefRec, *XF86ConfInputrefPtr;
+
+typedef struct
+{
+	Bool set;
+	Bool val;
+}
+xf86TriState;
+
+typedef struct
+{
+	struct list entry;
+	char **values;
+}
+xf86MatchGroup;
+
+typedef struct
+{
+	GenericListRec list;
+	char *identifier;
+	char *driver;
+	struct list match_product;
+	struct list match_vendor;
+	struct list match_device;
+	struct list match_os;
+	struct list match_pnpid;
+	struct list match_usbid;
+	struct list match_driver;
+	struct list match_tag;
+	xf86TriState is_keyboard;
+	xf86TriState is_pointer;
+	xf86TriState is_joystick;
+	xf86TriState is_tablet;
+	xf86TriState is_touchpad;
+	xf86TriState is_touchscreen;
+	XF86OptionPtr option_lst;
+	char *comment;
+}
+XF86ConfInputClassRec, *XF86ConfInputClassPtr;
+
+/* Values for adj_where */
+#define CONF_ADJ_OBSOLETE	-1
+#define CONF_ADJ_ABSOLUTE	0
+#define CONF_ADJ_RIGHTOF	1
+#define CONF_ADJ_LEFTOF		2
+#define CONF_ADJ_ABOVE		3
+#define CONF_ADJ_BELOW		4
+#define CONF_ADJ_RELATIVE	5
+
+typedef struct
+{
+	GenericListRec list;
+	int adj_scrnum;
+	XF86ConfScreenPtr adj_screen;
+	char *adj_screen_str;
+	XF86ConfScreenPtr adj_top;
+	char *adj_top_str;
+	XF86ConfScreenPtr adj_bottom;
+	char *adj_bottom_str;
+	XF86ConfScreenPtr adj_left;
+	char *adj_left_str;
+	XF86ConfScreenPtr adj_right;
+	char *adj_right_str;
+	int adj_where;
+	int adj_x;
+	int adj_y;
+	char *adj_refscreen;
+}
+XF86ConfAdjacencyRec, *XF86ConfAdjacencyPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *inactive_device_str;
+	XF86ConfDevicePtr inactive_device;
+}
+XF86ConfInactiveRec, *XF86ConfInactivePtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *lay_identifier;
+	XF86ConfAdjacencyPtr lay_adjacency_lst;
+	XF86ConfInactivePtr lay_inactive_lst;
+	XF86ConfInputrefPtr lay_input_lst;
+	XF86OptionPtr lay_option_lst;
+	char *lay_comment;
+}
+XF86ConfLayoutRec, *XF86ConfLayoutPtr;
+
+typedef struct 
+{ 
+	GenericListRec list; 
+	char *vs_name;
+	char *vs_identifier;
+	XF86OptionPtr vs_option_lst;
+	char *vs_comment;
+}
+XF86ConfVendSubRec, *XF86ConfVendSubPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	char *vnd_identifier;
+	XF86OptionPtr vnd_option_lst;
+	XF86ConfVendSubPtr vnd_sub_lst;
+	char *vnd_comment;
+}
+XF86ConfVendorRec, *XF86ConfVendorPtr;
+
+typedef struct
+{
+	GenericListRec list;
+	int buf_count;
+	int buf_size;
+	char *buf_flags;
+	char *buf_comment;
+}
+XF86ConfBuffersRec, *XF86ConfBuffersPtr;
+
+typedef struct
+{
+	char *dri_group_name;
+	int dri_group;
+	int dri_mode;
+	XF86ConfBuffersPtr dri_buffers_lst;
+	char *dri_comment;
+}
+XF86ConfDRIRec, *XF86ConfDRIPtr;
+
+typedef struct
+{
+	XF86OptionPtr ext_option_lst;
+	char *extensions_comment;
+}
+XF86ConfExtensionsRec, *XF86ConfExtensionsPtr;
+
+typedef struct
+{
+	XF86ConfFilesPtr conf_files;
+	XF86ConfModulePtr conf_modules;
+	XF86ConfFlagsPtr conf_flags;
+	XF86ConfVideoAdaptorPtr conf_videoadaptor_lst;
+	XF86ConfModesPtr conf_modes_lst;
+	XF86ConfMonitorPtr conf_monitor_lst;
+	XF86ConfDevicePtr conf_device_lst;
+	XF86ConfScreenPtr conf_screen_lst;
+	XF86ConfInputPtr conf_input_lst;
+	XF86ConfInputClassPtr conf_inputclass_lst;
+	XF86ConfLayoutPtr conf_layout_lst;
+	XF86ConfVendorPtr conf_vendor_lst;
+	XF86ConfDRIPtr conf_dri;
+	XF86ConfExtensionsPtr conf_extensions;
+	char *conf_comment;
+}
+XF86ConfigRec, *XF86ConfigPtr;
+
+typedef struct
+{
+	int token;			/* id of the token */
+	char *name;			/* pointer to the LOWERCASED name */
+}
+xf86ConfigSymTabRec, *xf86ConfigSymTabPtr;
+
+/*
+ * prototypes for public functions
+ */
+extern void xf86initConfigFiles(void);
+extern const char *xf86openConfigFile(const char *path, const char *cmdline,
+				      const char *projroot);
+extern const char *xf86openConfigDirFiles(const char *path, const char *cmdline,
+					  const char *projroot);
+extern void xf86setBuiltinConfig(const char *config[]);
+extern XF86ConfigPtr xf86readConfigFile(void);
+extern void xf86closeConfigFile(void);
+extern void xf86freeConfig(XF86ConfigPtr p);
+extern int xf86writeConfigFile(const char *, XF86ConfigPtr);
+extern _X_EXPORT XF86ConfDevicePtr xf86findDevice(const char *ident, XF86ConfDevicePtr p);
+extern _X_EXPORT XF86ConfLayoutPtr xf86findLayout(const char *name, XF86ConfLayoutPtr list);
+extern _X_EXPORT XF86ConfMonitorPtr xf86findMonitor(const char *ident, XF86ConfMonitorPtr p);
+extern _X_EXPORT XF86ConfModesPtr xf86findModes(const char *ident, XF86ConfModesPtr p);
+extern _X_EXPORT XF86ConfModeLinePtr xf86findModeLine(const char *ident, XF86ConfModeLinePtr p);
+extern _X_EXPORT XF86ConfScreenPtr xf86findScreen(const char *ident, XF86ConfScreenPtr p);
+extern _X_EXPORT XF86ConfInputPtr xf86findInput(const char *ident, XF86ConfInputPtr p);
+extern _X_EXPORT XF86ConfInputPtr xf86findInputByDriver(const char *driver, XF86ConfInputPtr p);
+extern _X_EXPORT XF86ConfVideoAdaptorPtr xf86findVideoAdaptor(const char *ident,
+						XF86ConfVideoAdaptorPtr p);
+extern int xf86layoutAddInputDevices(XF86ConfigPtr config, XF86ConfLayoutPtr layout);
+
+extern _X_EXPORT GenericListPtr xf86addListItem(GenericListPtr head, GenericListPtr c_new);
+extern _X_EXPORT int xf86itemNotSublist(GenericListPtr list_1, GenericListPtr list_2);
+
+extern _X_EXPORT int xf86pathIsAbsolute(const char *path);
+extern _X_EXPORT int xf86pathIsSafe(const char *path);
+extern _X_EXPORT char *xf86addComment(char *cur, char *add);
+extern _X_EXPORT Bool xf86getBoolValue(Bool *val, const char *str);
+
+#endif /* _xf86Parser_h_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glprocs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glprocs.h
@@ -0,0 +1,2260 @@
+/* DO NOT EDIT - This file generated automatically by gl_procs.py (from Mesa) script */
+
+/*
+ * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+ * (C) Copyright IBM Corporation 2004, 2006
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL, IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+
+/* This file is only included by glapi.c and is used for
+ * the GetProcAddress() function
+ */
+
+typedef struct {
+    GLint Name_offset;
+#if defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING)
+    _glapi_proc Address;
+#endif
+    GLuint Offset;
+} glprocs_table_t;
+
+#if   !defined(NEED_FUNCTION_POINTER) && !defined(GLX_INDIRECT_RENDERING)
+#  define NAME_FUNC_OFFSET(n,f1,f2,f3,o) { n , o }
+#elif  defined(NEED_FUNCTION_POINTER) && !defined(GLX_INDIRECT_RENDERING)
+#  define NAME_FUNC_OFFSET(n,f1,f2,f3,o) { n , (_glapi_proc) f1 , o }
+#elif  defined(NEED_FUNCTION_POINTER) &&  defined(GLX_INDIRECT_RENDERING)
+#  define NAME_FUNC_OFFSET(n,f1,f2,f3,o) { n , (_glapi_proc) f2 , o }
+#elif !defined(NEED_FUNCTION_POINTER) &&  defined(GLX_INDIRECT_RENDERING)
+#  define NAME_FUNC_OFFSET(n,f1,f2,f3,o) { n , (_glapi_proc) f3 , o }
+#endif
+
+
+
+static const char gl_string_table[] =
+    "glNewList\0"
+    "glEndList\0"
+    "glCallList\0"
+    "glCallLists\0"
+    "glDeleteLists\0"
+    "glGenLists\0"
+    "glListBase\0"
+    "glBegin\0"
+    "glBitmap\0"
+    "glColor3b\0"
+    "glColor3bv\0"
+    "glColor3d\0"
+    "glColor3dv\0"
+    "glColor3f\0"
+    "glColor3fv\0"
+    "glColor3i\0"
+    "glColor3iv\0"
+    "glColor3s\0"
+    "glColor3sv\0"
+    "glColor3ub\0"
+    "glColor3ubv\0"
+    "glColor3ui\0"
+    "glColor3uiv\0"
+    "glColor3us\0"
+    "glColor3usv\0"
+    "glColor4b\0"
+    "glColor4bv\0"
+    "glColor4d\0"
+    "glColor4dv\0"
+    "glColor4f\0"
+    "glColor4fv\0"
+    "glColor4i\0"
+    "glColor4iv\0"
+    "glColor4s\0"
+    "glColor4sv\0"
+    "glColor4ub\0"
+    "glColor4ubv\0"
+    "glColor4ui\0"
+    "glColor4uiv\0"
+    "glColor4us\0"
+    "glColor4usv\0"
+    "glEdgeFlag\0"
+    "glEdgeFlagv\0"
+    "glEnd\0"
+    "glIndexd\0"
+    "glIndexdv\0"
+    "glIndexf\0"
+    "glIndexfv\0"
+    "glIndexi\0"
+    "glIndexiv\0"
+    "glIndexs\0"
+    "glIndexsv\0"
+    "glNormal3b\0"
+    "glNormal3bv\0"
+    "glNormal3d\0"
+    "glNormal3dv\0"
+    "glNormal3f\0"
+    "glNormal3fv\0"
+    "glNormal3i\0"
+    "glNormal3iv\0"
+    "glNormal3s\0"
+    "glNormal3sv\0"
+    "glRasterPos2d\0"
+    "glRasterPos2dv\0"
+    "glRasterPos2f\0"
+    "glRasterPos2fv\0"
+    "glRasterPos2i\0"
+    "glRasterPos2iv\0"
+    "glRasterPos2s\0"
+    "glRasterPos2sv\0"
+    "glRasterPos3d\0"
+    "glRasterPos3dv\0"
+    "glRasterPos3f\0"
+    "glRasterPos3fv\0"
+    "glRasterPos3i\0"
+    "glRasterPos3iv\0"
+    "glRasterPos3s\0"
+    "glRasterPos3sv\0"
+    "glRasterPos4d\0"
+    "glRasterPos4dv\0"
+    "glRasterPos4f\0"
+    "glRasterPos4fv\0"
+    "glRasterPos4i\0"
+    "glRasterPos4iv\0"
+    "glRasterPos4s\0"
+    "glRasterPos4sv\0"
+    "glRectd\0"
+    "glRectdv\0"
+    "glRectf\0"
+    "glRectfv\0"
+    "glRecti\0"
+    "glRectiv\0"
+    "glRects\0"
+    "glRectsv\0"
+    "glTexCoord1d\0"
+    "glTexCoord1dv\0"
+    "glTexCoord1f\0"
+    "glTexCoord1fv\0"
+    "glTexCoord1i\0"
+    "glTexCoord1iv\0"
+    "glTexCoord1s\0"
+    "glTexCoord1sv\0"
+    "glTexCoord2d\0"
+    "glTexCoord2dv\0"
+    "glTexCoord2f\0"
+    "glTexCoord2fv\0"
+    "glTexCoord2i\0"
+    "glTexCoord2iv\0"
+    "glTexCoord2s\0"
+    "glTexCoord2sv\0"
+    "glTexCoord3d\0"
+    "glTexCoord3dv\0"
+    "glTexCoord3f\0"
+    "glTexCoord3fv\0"
+    "glTexCoord3i\0"
+    "glTexCoord3iv\0"
+    "glTexCoord3s\0"
+    "glTexCoord3sv\0"
+    "glTexCoord4d\0"
+    "glTexCoord4dv\0"
+    "glTexCoord4f\0"
+    "glTexCoord4fv\0"
+    "glTexCoord4i\0"
+    "glTexCoord4iv\0"
+    "glTexCoord4s\0"
+    "glTexCoord4sv\0"
+    "glVertex2d\0"
+    "glVertex2dv\0"
+    "glVertex2f\0"
+    "glVertex2fv\0"
+    "glVertex2i\0"
+    "glVertex2iv\0"
+    "glVertex2s\0"
+    "glVertex2sv\0"
+    "glVertex3d\0"
+    "glVertex3dv\0"
+    "glVertex3f\0"
+    "glVertex3fv\0"
+    "glVertex3i\0"
+    "glVertex3iv\0"
+    "glVertex3s\0"
+    "glVertex3sv\0"
+    "glVertex4d\0"
+    "glVertex4dv\0"
+    "glVertex4f\0"
+    "glVertex4fv\0"
+    "glVertex4i\0"
+    "glVertex4iv\0"
+    "glVertex4s\0"
+    "glVertex4sv\0"
+    "glClipPlane\0"
+    "glColorMaterial\0"
+    "glCullFace\0"
+    "glFogf\0"
+    "glFogfv\0"
+    "glFogi\0"
+    "glFogiv\0"
+    "glFrontFace\0"
+    "glHint\0"
+    "glLightf\0"
+    "glLightfv\0"
+    "glLighti\0"
+    "glLightiv\0"
+    "glLightModelf\0"
+    "glLightModelfv\0"
+    "glLightModeli\0"
+    "glLightModeliv\0"
+    "glLineStipple\0"
+    "glLineWidth\0"
+    "glMaterialf\0"
+    "glMaterialfv\0"
+    "glMateriali\0"
+    "glMaterialiv\0"
+    "glPointSize\0"
+    "glPolygonMode\0"
+    "glPolygonStipple\0"
+    "glScissor\0"
+    "glShadeModel\0"
+    "glTexParameterf\0"
+    "glTexParameterfv\0"
+    "glTexParameteri\0"
+    "glTexParameteriv\0"
+    "glTexImage1D\0"
+    "glTexImage2D\0"
+    "glTexEnvf\0"
+    "glTexEnvfv\0"
+    "glTexEnvi\0"
+    "glTexEnviv\0"
+    "glTexGend\0"
+    "glTexGendv\0"
+    "glTexGenf\0"
+    "glTexGenfv\0"
+    "glTexGeni\0"
+    "glTexGeniv\0"
+    "glFeedbackBuffer\0"
+    "glSelectBuffer\0"
+    "glRenderMode\0"
+    "glInitNames\0"
+    "glLoadName\0"
+    "glPassThrough\0"
+    "glPopName\0"
+    "glPushName\0"
+    "glDrawBuffer\0"
+    "glClear\0"
+    "glClearAccum\0"
+    "glClearIndex\0"
+    "glClearColor\0"
+    "glClearStencil\0"
+    "glClearDepth\0"
+    "glStencilMask\0"
+    "glColorMask\0"
+    "glDepthMask\0"
+    "glIndexMask\0"
+    "glAccum\0"
+    "glDisable\0"
+    "glEnable\0"
+    "glFinish\0"
+    "glFlush\0"
+    "glPopAttrib\0"
+    "glPushAttrib\0"
+    "glMap1d\0"
+    "glMap1f\0"
+    "glMap2d\0"
+    "glMap2f\0"
+    "glMapGrid1d\0"
+    "glMapGrid1f\0"
+    "glMapGrid2d\0"
+    "glMapGrid2f\0"
+    "glEvalCoord1d\0"
+    "glEvalCoord1dv\0"
+    "glEvalCoord1f\0"
+    "glEvalCoord1fv\0"
+    "glEvalCoord2d\0"
+    "glEvalCoord2dv\0"
+    "glEvalCoord2f\0"
+    "glEvalCoord2fv\0"
+    "glEvalMesh1\0"
+    "glEvalPoint1\0"
+    "glEvalMesh2\0"
+    "glEvalPoint2\0"
+    "glAlphaFunc\0"
+    "glBlendFunc\0"
+    "glLogicOp\0"
+    "glStencilFunc\0"
+    "glStencilOp\0"
+    "glDepthFunc\0"
+    "glPixelZoom\0"
+    "glPixelTransferf\0"
+    "glPixelTransferi\0"
+    "glPixelStoref\0"
+    "glPixelStorei\0"
+    "glPixelMapfv\0"
+    "glPixelMapuiv\0"
+    "glPixelMapusv\0"
+    "glReadBuffer\0"
+    "glCopyPixels\0"
+    "glReadPixels\0"
+    "glDrawPixels\0"
+    "glGetBooleanv\0"
+    "glGetClipPlane\0"
+    "glGetDoublev\0"
+    "glGetError\0"
+    "glGetFloatv\0"
+    "glGetIntegerv\0"
+    "glGetLightfv\0"
+    "glGetLightiv\0"
+    "glGetMapdv\0"
+    "glGetMapfv\0"
+    "glGetMapiv\0"
+    "glGetMaterialfv\0"
+    "glGetMaterialiv\0"
+    "glGetPixelMapfv\0"
+    "glGetPixelMapuiv\0"
+    "glGetPixelMapusv\0"
+    "glGetPolygonStipple\0"
+    "glGetString\0"
+    "glGetTexEnvfv\0"
+    "glGetTexEnviv\0"
+    "glGetTexGendv\0"
+    "glGetTexGenfv\0"
+    "glGetTexGeniv\0"
+    "glGetTexImage\0"
+    "glGetTexParameterfv\0"
+    "glGetTexParameteriv\0"
+    "glGetTexLevelParameterfv\0"
+    "glGetTexLevelParameteriv\0"
+    "glIsEnabled\0"
+    "glIsList\0"
+    "glDepthRange\0"
+    "glFrustum\0"
+    "glLoadIdentity\0"
+    "glLoadMatrixf\0"
+    "glLoadMatrixd\0"
+    "glMatrixMode\0"
+    "glMultMatrixf\0"
+    "glMultMatrixd\0"
+    "glOrtho\0"
+    "glPopMatrix\0"
+    "glPushMatrix\0"
+    "glRotated\0"
+    "glRotatef\0"
+    "glScaled\0"
+    "glScalef\0"
+    "glTranslated\0"
+    "glTranslatef\0"
+    "glViewport\0"
+    "glArrayElement\0"
+    "glBindTexture\0"
+    "glColorPointer\0"
+    "glDisableClientState\0"
+    "glDrawArrays\0"
+    "glDrawElements\0"
+    "glEdgeFlagPointer\0"
+    "glEnableClientState\0"
+    "glIndexPointer\0"
+    "glIndexub\0"
+    "glIndexubv\0"
+    "glInterleavedArrays\0"
+    "glNormalPointer\0"
+    "glPolygonOffset\0"
+    "glTexCoordPointer\0"
+    "glVertexPointer\0"
+    "glAreTexturesResident\0"
+    "glCopyTexImage1D\0"
+    "glCopyTexImage2D\0"
+    "glCopyTexSubImage1D\0"
+    "glCopyTexSubImage2D\0"
+    "glDeleteTextures\0"
+    "glGenTextures\0"
+    "glGetPointerv\0"
+    "glIsTexture\0"
+    "glPrioritizeTextures\0"
+    "glTexSubImage1D\0"
+    "glTexSubImage2D\0"
+    "glPopClientAttrib\0"
+    "glPushClientAttrib\0"
+    "glBlendColor\0"
+    "glBlendEquation\0"
+    "glDrawRangeElements\0"
+    "glColorTable\0"
+    "glColorTableParameterfv\0"
+    "glColorTableParameteriv\0"
+    "glCopyColorTable\0"
+    "glGetColorTable\0"
+    "glGetColorTableParameterfv\0"
+    "glGetColorTableParameteriv\0"
+    "glColorSubTable\0"
+    "glCopyColorSubTable\0"
+    "glConvolutionFilter1D\0"
+    "glConvolutionFilter2D\0"
+    "glConvolutionParameterf\0"
+    "glConvolutionParameterfv\0"
+    "glConvolutionParameteri\0"
+    "glConvolutionParameteriv\0"
+    "glCopyConvolutionFilter1D\0"
+    "glCopyConvolutionFilter2D\0"
+    "glGetConvolutionFilter\0"
+    "glGetConvolutionParameterfv\0"
+    "glGetConvolutionParameteriv\0"
+    "glGetSeparableFilter\0"
+    "glSeparableFilter2D\0"
+    "glGetHistogram\0"
+    "glGetHistogramParameterfv\0"
+    "glGetHistogramParameteriv\0"
+    "glGetMinmax\0"
+    "glGetMinmaxParameterfv\0"
+    "glGetMinmaxParameteriv\0"
+    "glHistogram\0"
+    "glMinmax\0"
+    "glResetHistogram\0"
+    "glResetMinmax\0"
+    "glTexImage3D\0"
+    "glTexSubImage3D\0"
+    "glCopyTexSubImage3D\0"
+    "glActiveTextureARB\0"
+    "glClientActiveTextureARB\0"
+    "glMultiTexCoord1dARB\0"
+    "glMultiTexCoord1dvARB\0"
+    "glMultiTexCoord1fARB\0"
+    "glMultiTexCoord1fvARB\0"
+    "glMultiTexCoord1iARB\0"
+    "glMultiTexCoord1ivARB\0"
+    "glMultiTexCoord1sARB\0"
+    "glMultiTexCoord1svARB\0"
+    "glMultiTexCoord2dARB\0"
+    "glMultiTexCoord2dvARB\0"
+    "glMultiTexCoord2fARB\0"
+    "glMultiTexCoord2fvARB\0"
+    "glMultiTexCoord2iARB\0"
+    "glMultiTexCoord2ivARB\0"
+    "glMultiTexCoord2sARB\0"
+    "glMultiTexCoord2svARB\0"
+    "glMultiTexCoord3dARB\0"
+    "glMultiTexCoord3dvARB\0"
+    "glMultiTexCoord3fARB\0"
+    "glMultiTexCoord3fvARB\0"
+    "glMultiTexCoord3iARB\0"
+    "glMultiTexCoord3ivARB\0"
+    "glMultiTexCoord3sARB\0"
+    "glMultiTexCoord3svARB\0"
+    "glMultiTexCoord4dARB\0"
+    "glMultiTexCoord4dvARB\0"
+    "glMultiTexCoord4fARB\0"
+    "glMultiTexCoord4fvARB\0"
+    "glMultiTexCoord4iARB\0"
+    "glMultiTexCoord4ivARB\0"
+    "glMultiTexCoord4sARB\0"
+    "glMultiTexCoord4svARB\0"
+    "glAttachShader\0"
+    "glCreateProgram\0"
+    "glCreateShader\0"
+    "glDeleteProgram\0"
+    "glDeleteShader\0"
+    "glDetachShader\0"
+    "glGetAttachedShaders\0"
+    "glGetProgramInfoLog\0"
+    "glGetProgramiv\0"
+    "glGetShaderInfoLog\0"
+    "glGetShaderiv\0"
+    "glIsProgram\0"
+    "glIsShader\0"
+    "glStencilFuncSeparate\0"
+    "glStencilMaskSeparate\0"
+    "glStencilOpSeparate\0"
+    "glUniformMatrix2x3fv\0"
+    "glUniformMatrix2x4fv\0"
+    "glUniformMatrix3x2fv\0"
+    "glUniformMatrix3x4fv\0"
+    "glUniformMatrix4x2fv\0"
+    "glUniformMatrix4x3fv\0"
+    "glLoadTransposeMatrixdARB\0"
+    "glLoadTransposeMatrixfARB\0"
+    "glMultTransposeMatrixdARB\0"
+    "glMultTransposeMatrixfARB\0"
+    "glSampleCoverageARB\0"
+    "glCompressedTexImage1DARB\0"
+    "glCompressedTexImage2DARB\0"
+    "glCompressedTexImage3DARB\0"
+    "glCompressedTexSubImage1DARB\0"
+    "glCompressedTexSubImage2DARB\0"
+    "glCompressedTexSubImage3DARB\0"
+    "glGetCompressedTexImageARB\0"
+    "glDisableVertexAttribArrayARB\0"
+    "glEnableVertexAttribArrayARB\0"
+    "glGetProgramEnvParameterdvARB\0"
+    "glGetProgramEnvParameterfvARB\0"
+    "glGetProgramLocalParameterdvARB\0"
+    "glGetProgramLocalParameterfvARB\0"
+    "glGetProgramStringARB\0"
+    "glGetProgramivARB\0"
+    "glGetVertexAttribdvARB\0"
+    "glGetVertexAttribfvARB\0"
+    "glGetVertexAttribivARB\0"
+    "glProgramEnvParameter4dARB\0"
+    "glProgramEnvParameter4dvARB\0"
+    "glProgramEnvParameter4fARB\0"
+    "glProgramEnvParameter4fvARB\0"
+    "glProgramLocalParameter4dARB\0"
+    "glProgramLocalParameter4dvARB\0"
+    "glProgramLocalParameter4fARB\0"
+    "glProgramLocalParameter4fvARB\0"
+    "glProgramStringARB\0"
+    "glVertexAttrib1dARB\0"
+    "glVertexAttrib1dvARB\0"
+    "glVertexAttrib1fARB\0"
+    "glVertexAttrib1fvARB\0"
+    "glVertexAttrib1sARB\0"
+    "glVertexAttrib1svARB\0"
+    "glVertexAttrib2dARB\0"
+    "glVertexAttrib2dvARB\0"
+    "glVertexAttrib2fARB\0"
+    "glVertexAttrib2fvARB\0"
+    "glVertexAttrib2sARB\0"
+    "glVertexAttrib2svARB\0"
+    "glVertexAttrib3dARB\0"
+    "glVertexAttrib3dvARB\0"
+    "glVertexAttrib3fARB\0"
+    "glVertexAttrib3fvARB\0"
+    "glVertexAttrib3sARB\0"
+    "glVertexAttrib3svARB\0"
+    "glVertexAttrib4NbvARB\0"
+    "glVertexAttrib4NivARB\0"
+    "glVertexAttrib4NsvARB\0"
+    "glVertexAttrib4NubARB\0"
+    "glVertexAttrib4NubvARB\0"
+    "glVertexAttrib4NuivARB\0"
+    "glVertexAttrib4NusvARB\0"
+    "glVertexAttrib4bvARB\0"
+    "glVertexAttrib4dARB\0"
+    "glVertexAttrib4dvARB\0"
+    "glVertexAttrib4fARB\0"
+    "glVertexAttrib4fvARB\0"
+    "glVertexAttrib4ivARB\0"
+    "glVertexAttrib4sARB\0"
+    "glVertexAttrib4svARB\0"
+    "glVertexAttrib4ubvARB\0"
+    "glVertexAttrib4uivARB\0"
+    "glVertexAttrib4usvARB\0"
+    "glVertexAttribPointerARB\0"
+    "glBindBufferARB\0"
+    "glBufferDataARB\0"
+    "glBufferSubDataARB\0"
+    "glDeleteBuffersARB\0"
+    "glGenBuffersARB\0"
+    "glGetBufferParameterivARB\0"
+    "glGetBufferPointervARB\0"
+    "glGetBufferSubDataARB\0"
+    "glIsBufferARB\0"
+    "glMapBufferARB\0"
+    "glUnmapBufferARB\0"
+    "glBeginQueryARB\0"
+    "glDeleteQueriesARB\0"
+    "glEndQueryARB\0"
+    "glGenQueriesARB\0"
+    "glGetQueryObjectivARB\0"
+    "glGetQueryObjectuivARB\0"
+    "glGetQueryivARB\0"
+    "glIsQueryARB\0"
+    "glAttachObjectARB\0"
+    "glCompileShaderARB\0"
+    "glCreateProgramObjectARB\0"
+    "glCreateShaderObjectARB\0"
+    "glDeleteObjectARB\0"
+    "glDetachObjectARB\0"
+    "glGetActiveUniformARB\0"
+    "glGetAttachedObjectsARB\0"
+    "glGetHandleARB\0"
+    "glGetInfoLogARB\0"
+    "glGetObjectParameterfvARB\0"
+    "glGetObjectParameterivARB\0"
+    "glGetShaderSourceARB\0"
+    "glGetUniformLocationARB\0"
+    "glGetUniformfvARB\0"
+    "glGetUniformivARB\0"
+    "glLinkProgramARB\0"
+    "glShaderSourceARB\0"
+    "glUniform1fARB\0"
+    "glUniform1fvARB\0"
+    "glUniform1iARB\0"
+    "glUniform1ivARB\0"
+    "glUniform2fARB\0"
+    "glUniform2fvARB\0"
+    "glUniform2iARB\0"
+    "glUniform2ivARB\0"
+    "glUniform3fARB\0"
+    "glUniform3fvARB\0"
+    "glUniform3iARB\0"
+    "glUniform3ivARB\0"
+    "glUniform4fARB\0"
+    "glUniform4fvARB\0"
+    "glUniform4iARB\0"
+    "glUniform4ivARB\0"
+    "glUniformMatrix2fvARB\0"
+    "glUniformMatrix3fvARB\0"
+    "glUniformMatrix4fvARB\0"
+    "glUseProgramObjectARB\0"
+    "glValidateProgramARB\0"
+    "glBindAttribLocationARB\0"
+    "glGetActiveAttribARB\0"
+    "glGetAttribLocationARB\0"
+    "glDrawBuffersARB\0"
+    "glPolygonOffsetEXT\0"
+    "glGetPixelTexGenParameterfvSGIS\0"
+    "glGetPixelTexGenParameterivSGIS\0"
+    "glPixelTexGenParameterfSGIS\0"
+    "glPixelTexGenParameterfvSGIS\0"
+    "glPixelTexGenParameteriSGIS\0"
+    "glPixelTexGenParameterivSGIS\0"
+    "glSampleMaskSGIS\0"
+    "glSamplePatternSGIS\0"
+    "glColorPointerEXT\0"
+    "glEdgeFlagPointerEXT\0"
+    "glIndexPointerEXT\0"
+    "glNormalPointerEXT\0"
+    "glTexCoordPointerEXT\0"
+    "glVertexPointerEXT\0"
+    "glPointParameterfEXT\0"
+    "glPointParameterfvEXT\0"
+    "glLockArraysEXT\0"
+    "glUnlockArraysEXT\0"
+    "glCullParameterdvEXT\0"
+    "glCullParameterfvEXT\0"
+    "glSecondaryColor3bEXT\0"
+    "glSecondaryColor3bvEXT\0"
+    "glSecondaryColor3dEXT\0"
+    "glSecondaryColor3dvEXT\0"
+    "glSecondaryColor3fEXT\0"
+    "glSecondaryColor3fvEXT\0"
+    "glSecondaryColor3iEXT\0"
+    "glSecondaryColor3ivEXT\0"
+    "glSecondaryColor3sEXT\0"
+    "glSecondaryColor3svEXT\0"
+    "glSecondaryColor3ubEXT\0"
+    "glSecondaryColor3ubvEXT\0"
+    "glSecondaryColor3uiEXT\0"
+    "glSecondaryColor3uivEXT\0"
+    "glSecondaryColor3usEXT\0"
+    "glSecondaryColor3usvEXT\0"
+    "glSecondaryColorPointerEXT\0"
+    "glMultiDrawArraysEXT\0"
+    "glMultiDrawElementsEXT\0"
+    "glFogCoordPointerEXT\0"
+    "glFogCoorddEXT\0"
+    "glFogCoorddvEXT\0"
+    "glFogCoordfEXT\0"
+    "glFogCoordfvEXT\0"
+    "glPixelTexGenSGIX\0"
+    "glBlendFuncSeparateEXT\0"
+    "glFlushVertexArrayRangeNV\0"
+    "glVertexArrayRangeNV\0"
+    "glCombinerInputNV\0"
+    "glCombinerOutputNV\0"
+    "glCombinerParameterfNV\0"
+    "glCombinerParameterfvNV\0"
+    "glCombinerParameteriNV\0"
+    "glCombinerParameterivNV\0"
+    "glFinalCombinerInputNV\0"
+    "glGetCombinerInputParameterfvNV\0"
+    "glGetCombinerInputParameterivNV\0"
+    "glGetCombinerOutputParameterfvNV\0"
+    "glGetCombinerOutputParameterivNV\0"
+    "glGetFinalCombinerInputParameterfvNV\0"
+    "glGetFinalCombinerInputParameterivNV\0"
+    "glResizeBuffersMESA\0"
+    "glWindowPos2dMESA\0"
+    "glWindowPos2dvMESA\0"
+    "glWindowPos2fMESA\0"
+    "glWindowPos2fvMESA\0"
+    "glWindowPos2iMESA\0"
+    "glWindowPos2ivMESA\0"
+    "glWindowPos2sMESA\0"
+    "glWindowPos2svMESA\0"
+    "glWindowPos3dMESA\0"
+    "glWindowPos3dvMESA\0"
+    "glWindowPos3fMESA\0"
+    "glWindowPos3fvMESA\0"
+    "glWindowPos3iMESA\0"
+    "glWindowPos3ivMESA\0"
+    "glWindowPos3sMESA\0"
+    "glWindowPos3svMESA\0"
+    "glWindowPos4dMESA\0"
+    "glWindowPos4dvMESA\0"
+    "glWindowPos4fMESA\0"
+    "glWindowPos4fvMESA\0"
+    "glWindowPos4iMESA\0"
+    "glWindowPos4ivMESA\0"
+    "glWindowPos4sMESA\0"
+    "glWindowPos4svMESA\0"
+    "glMultiModeDrawArraysIBM\0"
+    "glMultiModeDrawElementsIBM\0"
+    "glDeleteFencesNV\0"
+    "glFinishFenceNV\0"
+    "glGenFencesNV\0"
+    "glGetFenceivNV\0"
+    "glIsFenceNV\0"
+    "glSetFenceNV\0"
+    "glTestFenceNV\0"
+    "glAreProgramsResidentNV\0"
+    "glBindProgramNV\0"
+    "glDeleteProgramsNV\0"
+    "glExecuteProgramNV\0"
+    "glGenProgramsNV\0"
+    "glGetProgramParameterdvNV\0"
+    "glGetProgramParameterfvNV\0"
+    "glGetProgramStringNV\0"
+    "glGetProgramivNV\0"
+    "glGetTrackMatrixivNV\0"
+    "glGetVertexAttribPointervNV\0"
+    "glGetVertexAttribdvNV\0"
+    "glGetVertexAttribfvNV\0"
+    "glGetVertexAttribivNV\0"
+    "glIsProgramNV\0"
+    "glLoadProgramNV\0"
+    "glProgramParameters4dvNV\0"
+    "glProgramParameters4fvNV\0"
+    "glRequestResidentProgramsNV\0"
+    "glTrackMatrixNV\0"
+    "glVertexAttrib1dNV\0"
+    "glVertexAttrib1dvNV\0"
+    "glVertexAttrib1fNV\0"
+    "glVertexAttrib1fvNV\0"
+    "glVertexAttrib1sNV\0"
+    "glVertexAttrib1svNV\0"
+    "glVertexAttrib2dNV\0"
+    "glVertexAttrib2dvNV\0"
+    "glVertexAttrib2fNV\0"
+    "glVertexAttrib2fvNV\0"
+    "glVertexAttrib2sNV\0"
+    "glVertexAttrib2svNV\0"
+    "glVertexAttrib3dNV\0"
+    "glVertexAttrib3dvNV\0"
+    "glVertexAttrib3fNV\0"
+    "glVertexAttrib3fvNV\0"
+    "glVertexAttrib3sNV\0"
+    "glVertexAttrib3svNV\0"
+    "glVertexAttrib4dNV\0"
+    "glVertexAttrib4dvNV\0"
+    "glVertexAttrib4fNV\0"
+    "glVertexAttrib4fvNV\0"
+    "glVertexAttrib4sNV\0"
+    "glVertexAttrib4svNV\0"
+    "glVertexAttrib4ubNV\0"
+    "glVertexAttrib4ubvNV\0"
+    "glVertexAttribPointerNV\0"
+    "glVertexAttribs1dvNV\0"
+    "glVertexAttribs1fvNV\0"
+    "glVertexAttribs1svNV\0"
+    "glVertexAttribs2dvNV\0"
+    "glVertexAttribs2fvNV\0"
+    "glVertexAttribs2svNV\0"
+    "glVertexAttribs3dvNV\0"
+    "glVertexAttribs3fvNV\0"
+    "glVertexAttribs3svNV\0"
+    "glVertexAttribs4dvNV\0"
+    "glVertexAttribs4fvNV\0"
+    "glVertexAttribs4svNV\0"
+    "glVertexAttribs4ubvNV\0"
+    "glAlphaFragmentOp1ATI\0"
+    "glAlphaFragmentOp2ATI\0"
+    "glAlphaFragmentOp3ATI\0"
+    "glBeginFragmentShaderATI\0"
+    "glBindFragmentShaderATI\0"
+    "glColorFragmentOp1ATI\0"
+    "glColorFragmentOp2ATI\0"
+    "glColorFragmentOp3ATI\0"
+    "glDeleteFragmentShaderATI\0"
+    "glEndFragmentShaderATI\0"
+    "glGenFragmentShadersATI\0"
+    "glPassTexCoordATI\0"
+    "glSampleMapATI\0"
+    "glSetFragmentShaderConstantATI\0"
+    "glPointParameteriNV\0"
+    "glPointParameterivNV\0"
+    "glActiveStencilFaceEXT\0"
+    "glBindVertexArrayAPPLE\0"
+    "glDeleteVertexArraysAPPLE\0"
+    "glGenVertexArraysAPPLE\0"
+    "glIsVertexArrayAPPLE\0"
+    "glGetProgramNamedParameterdvNV\0"
+    "glGetProgramNamedParameterfvNV\0"
+    "glProgramNamedParameter4dNV\0"
+    "glProgramNamedParameter4dvNV\0"
+    "glProgramNamedParameter4fNV\0"
+    "glProgramNamedParameter4fvNV\0"
+    "glDepthBoundsEXT\0"
+    "glBlendEquationSeparateEXT\0"
+    "glBindFramebufferEXT\0"
+    "glBindRenderbufferEXT\0"
+    "glCheckFramebufferStatusEXT\0"
+    "glDeleteFramebuffersEXT\0"
+    "glDeleteRenderbuffersEXT\0"
+    "glFramebufferRenderbufferEXT\0"
+    "glFramebufferTexture1DEXT\0"
+    "glFramebufferTexture2DEXT\0"
+    "glFramebufferTexture3DEXT\0"
+    "glGenFramebuffersEXT\0"
+    "glGenRenderbuffersEXT\0"
+    "glGenerateMipmapEXT\0"
+    "glGetFramebufferAttachmentParameterivEXT\0"
+    "glGetRenderbufferParameterivEXT\0"
+    "glIsFramebufferEXT\0"
+    "glIsRenderbufferEXT\0"
+    "glRenderbufferStorageEXT\0"
+    "glBlitFramebufferEXT\0"
+    "glFramebufferTextureLayerEXT\0"
+    "glStencilFuncSeparateATI\0"
+    "glProgramEnvParameters4fvEXT\0"
+    "glProgramLocalParameters4fvEXT\0"
+    "glGetQueryObjecti64vEXT\0"
+    "glGetQueryObjectui64vEXT\0"
+    "glArrayElementEXT\0"
+    "glBindTextureEXT\0"
+    "glDrawArraysEXT\0"
+    "glAreTexturesResidentEXT\0"
+    "glCopyTexImage1DEXT\0"
+    "glCopyTexImage2DEXT\0"
+    "glCopyTexSubImage1DEXT\0"
+    "glCopyTexSubImage2DEXT\0"
+    "glDeleteTexturesEXT\0"
+    "glGenTexturesEXT\0"
+    "glGetPointervEXT\0"
+    "glIsTextureEXT\0"
+    "glPrioritizeTexturesEXT\0"
+    "glTexSubImage1DEXT\0"
+    "glTexSubImage2DEXT\0"
+    "glBlendColorEXT\0"
+    "glBlendEquationEXT\0"
+    "glDrawRangeElementsEXT\0"
+    "glColorTableSGI\0"
+    "glColorTableEXT\0"
+    "glColorTableParameterfvSGI\0"
+    "glColorTableParameterivSGI\0"
+    "glCopyColorTableSGI\0"
+    "glGetColorTableSGI\0"
+    "glGetColorTableEXT\0"
+    "glGetColorTableParameterfvSGI\0"
+    "glGetColorTableParameterfvEXT\0"
+    "glGetColorTableParameterivSGI\0"
+    "glGetColorTableParameterivEXT\0"
+    "glColorSubTableEXT\0"
+    "glCopyColorSubTableEXT\0"
+    "glConvolutionFilter1DEXT\0"
+    "glConvolutionFilter2DEXT\0"
+    "glConvolutionParameterfEXT\0"
+    "glConvolutionParameterfvEXT\0"
+    "glConvolutionParameteriEXT\0"
+    "glConvolutionParameterivEXT\0"
+    "glCopyConvolutionFilter1DEXT\0"
+    "glCopyConvolutionFilter2DEXT\0"
+    "glGetConvolutionFilterEXT\0"
+    "glGetConvolutionParameterfvEXT\0"
+    "glGetConvolutionParameterivEXT\0"
+    "glGetSeparableFilterEXT\0"
+    "glSeparableFilter2DEXT\0"
+    "glGetHistogramEXT\0"
+    "glGetHistogramParameterfvEXT\0"
+    "glGetHistogramParameterivEXT\0"
+    "glGetMinmaxEXT\0"
+    "glGetMinmaxParameterfvEXT\0"
+    "glGetMinmaxParameterivEXT\0"
+    "glHistogramEXT\0"
+    "glMinmaxEXT\0"
+    "glResetHistogramEXT\0"
+    "glResetMinmaxEXT\0"
+    "glTexImage3DEXT\0"
+    "glTexSubImage3DEXT\0"
+    "glCopyTexSubImage3DEXT\0"
+    "glActiveTexture\0"
+    "glClientActiveTexture\0"
+    "glMultiTexCoord1d\0"
+    "glMultiTexCoord1dv\0"
+    "glMultiTexCoord1f\0"
+    "glMultiTexCoord1fv\0"
+    "glMultiTexCoord1i\0"
+    "glMultiTexCoord1iv\0"
+    "glMultiTexCoord1s\0"
+    "glMultiTexCoord1sv\0"
+    "glMultiTexCoord2d\0"
+    "glMultiTexCoord2dv\0"
+    "glMultiTexCoord2f\0"
+    "glMultiTexCoord2fv\0"
+    "glMultiTexCoord2i\0"
+    "glMultiTexCoord2iv\0"
+    "glMultiTexCoord2s\0"
+    "glMultiTexCoord2sv\0"
+    "glMultiTexCoord3d\0"
+    "glMultiTexCoord3dv\0"
+    "glMultiTexCoord3f\0"
+    "glMultiTexCoord3fv\0"
+    "glMultiTexCoord3i\0"
+    "glMultiTexCoord3iv\0"
+    "glMultiTexCoord3s\0"
+    "glMultiTexCoord3sv\0"
+    "glMultiTexCoord4d\0"
+    "glMultiTexCoord4dv\0"
+    "glMultiTexCoord4f\0"
+    "glMultiTexCoord4fv\0"
+    "glMultiTexCoord4i\0"
+    "glMultiTexCoord4iv\0"
+    "glMultiTexCoord4s\0"
+    "glMultiTexCoord4sv\0"
+    "glStencilOpSeparateATI\0"
+    "glLoadTransposeMatrixd\0"
+    "glLoadTransposeMatrixf\0"
+    "glMultTransposeMatrixd\0"
+    "glMultTransposeMatrixf\0"
+    "glSampleCoverage\0"
+    "glCompressedTexImage1D\0"
+    "glCompressedTexImage2D\0"
+    "glCompressedTexImage3D\0"
+    "glCompressedTexSubImage1D\0"
+    "glCompressedTexSubImage2D\0"
+    "glCompressedTexSubImage3D\0"
+    "glGetCompressedTexImage\0"
+    "glDisableVertexAttribArray\0"
+    "glEnableVertexAttribArray\0"
+    "glGetVertexAttribdv\0"
+    "glGetVertexAttribfv\0"
+    "glGetVertexAttribiv\0"
+    "glProgramParameter4dNV\0"
+    "glProgramParameter4dvNV\0"
+    "glProgramParameter4fNV\0"
+    "glProgramParameter4fvNV\0"
+    "glVertexAttrib1d\0"
+    "glVertexAttrib1dv\0"
+    "glVertexAttrib1f\0"
+    "glVertexAttrib1fv\0"
+    "glVertexAttrib1s\0"
+    "glVertexAttrib1sv\0"
+    "glVertexAttrib2d\0"
+    "glVertexAttrib2dv\0"
+    "glVertexAttrib2f\0"
+    "glVertexAttrib2fv\0"
+    "glVertexAttrib2s\0"
+    "glVertexAttrib2sv\0"
+    "glVertexAttrib3d\0"
+    "glVertexAttrib3dv\0"
+    "glVertexAttrib3f\0"
+    "glVertexAttrib3fv\0"
+    "glVertexAttrib3s\0"
+    "glVertexAttrib3sv\0"
+    "glVertexAttrib4Nbv\0"
+    "glVertexAttrib4Niv\0"
+    "glVertexAttrib4Nsv\0"
+    "glVertexAttrib4Nub\0"
+    "glVertexAttrib4Nubv\0"
+    "glVertexAttrib4Nuiv\0"
+    "glVertexAttrib4Nusv\0"
+    "glVertexAttrib4bv\0"
+    "glVertexAttrib4d\0"
+    "glVertexAttrib4dv\0"
+    "glVertexAttrib4f\0"
+    "glVertexAttrib4fv\0"
+    "glVertexAttrib4iv\0"
+    "glVertexAttrib4s\0"
+    "glVertexAttrib4sv\0"
+    "glVertexAttrib4ubv\0"
+    "glVertexAttrib4uiv\0"
+    "glVertexAttrib4usv\0"
+    "glVertexAttribPointer\0"
+    "glBindBuffer\0"
+    "glBufferData\0"
+    "glBufferSubData\0"
+    "glDeleteBuffers\0"
+    "glGenBuffers\0"
+    "glGetBufferParameteriv\0"
+    "glGetBufferPointerv\0"
+    "glGetBufferSubData\0"
+    "glIsBuffer\0"
+    "glMapBuffer\0"
+    "glUnmapBuffer\0"
+    "glBeginQuery\0"
+    "glDeleteQueries\0"
+    "glEndQuery\0"
+    "glGenQueries\0"
+    "glGetQueryObjectiv\0"
+    "glGetQueryObjectuiv\0"
+    "glGetQueryiv\0"
+    "glIsQuery\0"
+    "glCompileShader\0"
+    "glGetActiveUniform\0"
+    "glGetShaderSource\0"
+    "glGetUniformLocation\0"
+    "glGetUniformfv\0"
+    "glGetUniformiv\0"
+    "glLinkProgram\0"
+    "glShaderSource\0"
+    "glUniform1f\0"
+    "glUniform1fv\0"
+    "glUniform1i\0"
+    "glUniform1iv\0"
+    "glUniform2f\0"
+    "glUniform2fv\0"
+    "glUniform2i\0"
+    "glUniform2iv\0"
+    "glUniform3f\0"
+    "glUniform3fv\0"
+    "glUniform3i\0"
+    "glUniform3iv\0"
+    "glUniform4f\0"
+    "glUniform4fv\0"
+    "glUniform4i\0"
+    "glUniform4iv\0"
+    "glUniformMatrix2fv\0"
+    "glUniformMatrix3fv\0"
+    "glUniformMatrix4fv\0"
+    "glUseProgram\0"
+    "glValidateProgram\0"
+    "glBindAttribLocation\0"
+    "glGetActiveAttrib\0"
+    "glGetAttribLocation\0"
+    "glDrawBuffers\0"
+    "glDrawBuffersATI\0"
+    "glSampleMaskEXT\0"
+    "glSamplePatternEXT\0"
+    "glPointParameterf\0"
+    "glPointParameterfARB\0"
+    "glPointParameterfSGIS\0"
+    "glPointParameterfv\0"
+    "glPointParameterfvARB\0"
+    "glPointParameterfvSGIS\0"
+    "glSecondaryColor3b\0"
+    "glSecondaryColor3bv\0"
+    "glSecondaryColor3d\0"
+    "glSecondaryColor3dv\0"
+    "glSecondaryColor3f\0"
+    "glSecondaryColor3fv\0"
+    "glSecondaryColor3i\0"
+    "glSecondaryColor3iv\0"
+    "glSecondaryColor3s\0"
+    "glSecondaryColor3sv\0"
+    "glSecondaryColor3ub\0"
+    "glSecondaryColor3ubv\0"
+    "glSecondaryColor3ui\0"
+    "glSecondaryColor3uiv\0"
+    "glSecondaryColor3us\0"
+    "glSecondaryColor3usv\0"
+    "glSecondaryColorPointer\0"
+    "glMultiDrawArrays\0"
+    "glMultiDrawElements\0"
+    "glFogCoordPointer\0"
+    "glFogCoordd\0"
+    "glFogCoorddv\0"
+    "glFogCoordf\0"
+    "glFogCoordfv\0"
+    "glBlendFuncSeparate\0"
+    "glBlendFuncSeparateINGR\0"
+    "glWindowPos2d\0"
+    "glWindowPos2dARB\0"
+    "glWindowPos2dv\0"
+    "glWindowPos2dvARB\0"
+    "glWindowPos2f\0"
+    "glWindowPos2fARB\0"
+    "glWindowPos2fv\0"
+    "glWindowPos2fvARB\0"
+    "glWindowPos2i\0"
+    "glWindowPos2iARB\0"
+    "glWindowPos2iv\0"
+    "glWindowPos2ivARB\0"
+    "glWindowPos2s\0"
+    "glWindowPos2sARB\0"
+    "glWindowPos2sv\0"
+    "glWindowPos2svARB\0"
+    "glWindowPos3d\0"
+    "glWindowPos3dARB\0"
+    "glWindowPos3dv\0"
+    "glWindowPos3dvARB\0"
+    "glWindowPos3f\0"
+    "glWindowPos3fARB\0"
+    "glWindowPos3fv\0"
+    "glWindowPos3fvARB\0"
+    "glWindowPos3i\0"
+    "glWindowPos3iARB\0"
+    "glWindowPos3iv\0"
+    "glWindowPos3ivARB\0"
+    "glWindowPos3s\0"
+    "glWindowPos3sARB\0"
+    "glWindowPos3sv\0"
+    "glWindowPos3svARB\0"
+    "glBindProgramARB\0"
+    "glDeleteProgramsARB\0"
+    "glGenProgramsARB\0"
+    "glGetVertexAttribPointerv\0"
+    "glGetVertexAttribPointervARB\0"
+    "glIsProgramARB\0"
+    "glPointParameteri\0"
+    "glPointParameteriv\0"
+    "glBlendEquationSeparate\0"
+    "glBlendEquationSeparateATI\0"
+    ;
+
+
+#ifdef USE_MGL_NAMESPACE
+#define gl_dispatch_stub_343 mgl_dispatch_stub_343
+#define gl_dispatch_stub_344 mgl_dispatch_stub_344
+#define gl_dispatch_stub_345 mgl_dispatch_stub_345
+#define gl_dispatch_stub_356 mgl_dispatch_stub_356
+#define gl_dispatch_stub_357 mgl_dispatch_stub_357
+#define gl_dispatch_stub_358 mgl_dispatch_stub_358
+#define gl_dispatch_stub_359 mgl_dispatch_stub_359
+#define gl_dispatch_stub_361 mgl_dispatch_stub_361
+#define gl_dispatch_stub_362 mgl_dispatch_stub_362
+#define gl_dispatch_stub_363 mgl_dispatch_stub_363
+#define gl_dispatch_stub_364 mgl_dispatch_stub_364
+#define gl_dispatch_stub_365 mgl_dispatch_stub_365
+#define gl_dispatch_stub_366 mgl_dispatch_stub_366
+#define gl_dispatch_stub_562 mgl_dispatch_stub_562
+#define gl_dispatch_stub_563 mgl_dispatch_stub_563
+#define gl_dispatch_stub_564 mgl_dispatch_stub_564
+#define gl_dispatch_stub_565 mgl_dispatch_stub_565
+#define gl_dispatch_stub_566 mgl_dispatch_stub_566
+#define gl_dispatch_stub_567 mgl_dispatch_stub_567
+#define gl_dispatch_stub_568 mgl_dispatch_stub_568
+#define gl_dispatch_stub_569 mgl_dispatch_stub_569
+#define gl_dispatch_stub_580 mgl_dispatch_stub_580
+#define gl_dispatch_stub_581 mgl_dispatch_stub_581
+#define gl_dispatch_stub_606 mgl_dispatch_stub_606
+#define gl_dispatch_stub_648 mgl_dispatch_stub_648
+#define gl_dispatch_stub_649 mgl_dispatch_stub_649
+#define gl_dispatch_stub_650 mgl_dispatch_stub_650
+#define gl_dispatch_stub_651 mgl_dispatch_stub_651
+#define gl_dispatch_stub_652 mgl_dispatch_stub_652
+#define gl_dispatch_stub_653 mgl_dispatch_stub_653
+#define gl_dispatch_stub_654 mgl_dispatch_stub_654
+#define gl_dispatch_stub_655 mgl_dispatch_stub_655
+#define gl_dispatch_stub_656 mgl_dispatch_stub_656
+#define gl_dispatch_stub_733 mgl_dispatch_stub_733
+#define gl_dispatch_stub_734 mgl_dispatch_stub_734
+#define gl_dispatch_stub_735 mgl_dispatch_stub_735
+#define gl_dispatch_stub_736 mgl_dispatch_stub_736
+#define gl_dispatch_stub_737 mgl_dispatch_stub_737
+#define gl_dispatch_stub_744 mgl_dispatch_stub_744
+#define gl_dispatch_stub_745 mgl_dispatch_stub_745
+#define gl_dispatch_stub_763 mgl_dispatch_stub_763
+#define gl_dispatch_stub_765 mgl_dispatch_stub_765
+#define gl_dispatch_stub_766 mgl_dispatch_stub_766
+#define gl_dispatch_stub_767 mgl_dispatch_stub_767
+#define gl_dispatch_stub_768 mgl_dispatch_stub_768
+#define gl_dispatch_stub_769 mgl_dispatch_stub_769
+#endif /* USE_MGL_NAMESPACE */
+
+
+/* FIXME: Having these (incorrect) prototypes here is ugly. */
+#if defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING)
+extern void gl_dispatch_stub_343(void);
+extern void gl_dispatch_stub_344(void);
+extern void gl_dispatch_stub_345(void);
+extern void gl_dispatch_stub_356(void);
+extern void gl_dispatch_stub_357(void);
+extern void gl_dispatch_stub_358(void);
+extern void gl_dispatch_stub_359(void);
+extern void gl_dispatch_stub_361(void);
+extern void gl_dispatch_stub_362(void);
+extern void gl_dispatch_stub_363(void);
+extern void gl_dispatch_stub_364(void);
+extern void gl_dispatch_stub_365(void);
+extern void gl_dispatch_stub_366(void);
+extern void gl_dispatch_stub_562(void);
+extern void gl_dispatch_stub_563(void);
+extern void gl_dispatch_stub_564(void);
+extern void gl_dispatch_stub_565(void);
+extern void gl_dispatch_stub_566(void);
+extern void gl_dispatch_stub_567(void);
+extern void gl_dispatch_stub_568(void);
+extern void gl_dispatch_stub_569(void);
+extern void gl_dispatch_stub_580(void);
+extern void gl_dispatch_stub_581(void);
+extern void gl_dispatch_stub_606(void);
+extern void gl_dispatch_stub_648(void);
+extern void gl_dispatch_stub_649(void);
+extern void gl_dispatch_stub_650(void);
+extern void gl_dispatch_stub_651(void);
+extern void gl_dispatch_stub_652(void);
+extern void gl_dispatch_stub_653(void);
+extern void gl_dispatch_stub_654(void);
+extern void gl_dispatch_stub_655(void);
+extern void gl_dispatch_stub_656(void);
+extern void gl_dispatch_stub_733(void);
+extern void gl_dispatch_stub_734(void);
+extern void gl_dispatch_stub_735(void);
+extern void gl_dispatch_stub_736(void);
+extern void gl_dispatch_stub_737(void);
+extern void gl_dispatch_stub_744(void);
+extern void gl_dispatch_stub_745(void);
+extern void gl_dispatch_stub_763(void);
+extern void gl_dispatch_stub_765(void);
+extern void gl_dispatch_stub_766(void);
+extern void gl_dispatch_stub_767(void);
+extern void gl_dispatch_stub_768(void);
+extern void gl_dispatch_stub_769(void);
+#endif /* defined(NEED_FUNCTION_POINTER) || defined(GLX_INDIRECT_RENDERING) */
+
+static const glprocs_table_t static_functions[] = {
+    NAME_FUNC_OFFSET(    0, glNewList, glNewList, NULL, _gloffset_NewList),
+    NAME_FUNC_OFFSET(   10, glEndList, glEndList, NULL, _gloffset_EndList),
+    NAME_FUNC_OFFSET(   20, glCallList, glCallList, NULL, _gloffset_CallList),
+    NAME_FUNC_OFFSET(   31, glCallLists, glCallLists, NULL, _gloffset_CallLists),
+    NAME_FUNC_OFFSET(   43, glDeleteLists, glDeleteLists, NULL, _gloffset_DeleteLists),
+    NAME_FUNC_OFFSET(   57, glGenLists, glGenLists, NULL, _gloffset_GenLists),
+    NAME_FUNC_OFFSET(   68, glListBase, glListBase, NULL, _gloffset_ListBase),
+    NAME_FUNC_OFFSET(   79, glBegin, glBegin, NULL, _gloffset_Begin),
+    NAME_FUNC_OFFSET(   87, glBitmap, glBitmap, NULL, _gloffset_Bitmap),
+    NAME_FUNC_OFFSET(   96, glColor3b, glColor3b, NULL, _gloffset_Color3b),
+    NAME_FUNC_OFFSET(  106, glColor3bv, glColor3bv, NULL, _gloffset_Color3bv),
+    NAME_FUNC_OFFSET(  117, glColor3d, glColor3d, NULL, _gloffset_Color3d),
+    NAME_FUNC_OFFSET(  127, glColor3dv, glColor3dv, NULL, _gloffset_Color3dv),
+    NAME_FUNC_OFFSET(  138, glColor3f, glColor3f, NULL, _gloffset_Color3f),
+    NAME_FUNC_OFFSET(  148, glColor3fv, glColor3fv, NULL, _gloffset_Color3fv),
+    NAME_FUNC_OFFSET(  159, glColor3i, glColor3i, NULL, _gloffset_Color3i),
+    NAME_FUNC_OFFSET(  169, glColor3iv, glColor3iv, NULL, _gloffset_Color3iv),
+    NAME_FUNC_OFFSET(  180, glColor3s, glColor3s, NULL, _gloffset_Color3s),
+    NAME_FUNC_OFFSET(  190, glColor3sv, glColor3sv, NULL, _gloffset_Color3sv),
+    NAME_FUNC_OFFSET(  201, glColor3ub, glColor3ub, NULL, _gloffset_Color3ub),
+    NAME_FUNC_OFFSET(  212, glColor3ubv, glColor3ubv, NULL, _gloffset_Color3ubv),
+    NAME_FUNC_OFFSET(  224, glColor3ui, glColor3ui, NULL, _gloffset_Color3ui),
+    NAME_FUNC_OFFSET(  235, glColor3uiv, glColor3uiv, NULL, _gloffset_Color3uiv),
+    NAME_FUNC_OFFSET(  247, glColor3us, glColor3us, NULL, _gloffset_Color3us),
+    NAME_FUNC_OFFSET(  258, glColor3usv, glColor3usv, NULL, _gloffset_Color3usv),
+    NAME_FUNC_OFFSET(  270, glColor4b, glColor4b, NULL, _gloffset_Color4b),
+    NAME_FUNC_OFFSET(  280, glColor4bv, glColor4bv, NULL, _gloffset_Color4bv),
+    NAME_FUNC_OFFSET(  291, glColor4d, glColor4d, NULL, _gloffset_Color4d),
+    NAME_FUNC_OFFSET(  301, glColor4dv, glColor4dv, NULL, _gloffset_Color4dv),
+    NAME_FUNC_OFFSET(  312, glColor4f, glColor4f, NULL, _gloffset_Color4f),
+    NAME_FUNC_OFFSET(  322, glColor4fv, glColor4fv, NULL, _gloffset_Color4fv),
+    NAME_FUNC_OFFSET(  333, glColor4i, glColor4i, NULL, _gloffset_Color4i),
+    NAME_FUNC_OFFSET(  343, glColor4iv, glColor4iv, NULL, _gloffset_Color4iv),
+    NAME_FUNC_OFFSET(  354, glColor4s, glColor4s, NULL, _gloffset_Color4s),
+    NAME_FUNC_OFFSET(  364, glColor4sv, glColor4sv, NULL, _gloffset_Color4sv),
+    NAME_FUNC_OFFSET(  375, glColor4ub, glColor4ub, NULL, _gloffset_Color4ub),
+    NAME_FUNC_OFFSET(  386, glColor4ubv, glColor4ubv, NULL, _gloffset_Color4ubv),
+    NAME_FUNC_OFFSET(  398, glColor4ui, glColor4ui, NULL, _gloffset_Color4ui),
+    NAME_FUNC_OFFSET(  409, glColor4uiv, glColor4uiv, NULL, _gloffset_Color4uiv),
+    NAME_FUNC_OFFSET(  421, glColor4us, glColor4us, NULL, _gloffset_Color4us),
+    NAME_FUNC_OFFSET(  432, glColor4usv, glColor4usv, NULL, _gloffset_Color4usv),
+    NAME_FUNC_OFFSET(  444, glEdgeFlag, glEdgeFlag, NULL, _gloffset_EdgeFlag),
+    NAME_FUNC_OFFSET(  455, glEdgeFlagv, glEdgeFlagv, NULL, _gloffset_EdgeFlagv),
+    NAME_FUNC_OFFSET(  467, glEnd, glEnd, NULL, _gloffset_End),
+    NAME_FUNC_OFFSET(  473, glIndexd, glIndexd, NULL, _gloffset_Indexd),
+    NAME_FUNC_OFFSET(  482, glIndexdv, glIndexdv, NULL, _gloffset_Indexdv),
+    NAME_FUNC_OFFSET(  492, glIndexf, glIndexf, NULL, _gloffset_Indexf),
+    NAME_FUNC_OFFSET(  501, glIndexfv, glIndexfv, NULL, _gloffset_Indexfv),
+    NAME_FUNC_OFFSET(  511, glIndexi, glIndexi, NULL, _gloffset_Indexi),
+    NAME_FUNC_OFFSET(  520, glIndexiv, glIndexiv, NULL, _gloffset_Indexiv),
+    NAME_FUNC_OFFSET(  530, glIndexs, glIndexs, NULL, _gloffset_Indexs),
+    NAME_FUNC_OFFSET(  539, glIndexsv, glIndexsv, NULL, _gloffset_Indexsv),
+    NAME_FUNC_OFFSET(  549, glNormal3b, glNormal3b, NULL, _gloffset_Normal3b),
+    NAME_FUNC_OFFSET(  560, glNormal3bv, glNormal3bv, NULL, _gloffset_Normal3bv),
+    NAME_FUNC_OFFSET(  572, glNormal3d, glNormal3d, NULL, _gloffset_Normal3d),
+    NAME_FUNC_OFFSET(  583, glNormal3dv, glNormal3dv, NULL, _gloffset_Normal3dv),
+    NAME_FUNC_OFFSET(  595, glNormal3f, glNormal3f, NULL, _gloffset_Normal3f),
+    NAME_FUNC_OFFSET(  606, glNormal3fv, glNormal3fv, NULL, _gloffset_Normal3fv),
+    NAME_FUNC_OFFSET(  618, glNormal3i, glNormal3i, NULL, _gloffset_Normal3i),
+    NAME_FUNC_OFFSET(  629, glNormal3iv, glNormal3iv, NULL, _gloffset_Normal3iv),
+    NAME_FUNC_OFFSET(  641, glNormal3s, glNormal3s, NULL, _gloffset_Normal3s),
+    NAME_FUNC_OFFSET(  652, glNormal3sv, glNormal3sv, NULL, _gloffset_Normal3sv),
+    NAME_FUNC_OFFSET(  664, glRasterPos2d, glRasterPos2d, NULL, _gloffset_RasterPos2d),
+    NAME_FUNC_OFFSET(  678, glRasterPos2dv, glRasterPos2dv, NULL, _gloffset_RasterPos2dv),
+    NAME_FUNC_OFFSET(  693, glRasterPos2f, glRasterPos2f, NULL, _gloffset_RasterPos2f),
+    NAME_FUNC_OFFSET(  707, glRasterPos2fv, glRasterPos2fv, NULL, _gloffset_RasterPos2fv),
+    NAME_FUNC_OFFSET(  722, glRasterPos2i, glRasterPos2i, NULL, _gloffset_RasterPos2i),
+    NAME_FUNC_OFFSET(  736, glRasterPos2iv, glRasterPos2iv, NULL, _gloffset_RasterPos2iv),
+    NAME_FUNC_OFFSET(  751, glRasterPos2s, glRasterPos2s, NULL, _gloffset_RasterPos2s),
+    NAME_FUNC_OFFSET(  765, glRasterPos2sv, glRasterPos2sv, NULL, _gloffset_RasterPos2sv),
+    NAME_FUNC_OFFSET(  780, glRasterPos3d, glRasterPos3d, NULL, _gloffset_RasterPos3d),
+    NAME_FUNC_OFFSET(  794, glRasterPos3dv, glRasterPos3dv, NULL, _gloffset_RasterPos3dv),
+    NAME_FUNC_OFFSET(  809, glRasterPos3f, glRasterPos3f, NULL, _gloffset_RasterPos3f),
+    NAME_FUNC_OFFSET(  823, glRasterPos3fv, glRasterPos3fv, NULL, _gloffset_RasterPos3fv),
+    NAME_FUNC_OFFSET(  838, glRasterPos3i, glRasterPos3i, NULL, _gloffset_RasterPos3i),
+    NAME_FUNC_OFFSET(  852, glRasterPos3iv, glRasterPos3iv, NULL, _gloffset_RasterPos3iv),
+    NAME_FUNC_OFFSET(  867, glRasterPos3s, glRasterPos3s, NULL, _gloffset_RasterPos3s),
+    NAME_FUNC_OFFSET(  881, glRasterPos3sv, glRasterPos3sv, NULL, _gloffset_RasterPos3sv),
+    NAME_FUNC_OFFSET(  896, glRasterPos4d, glRasterPos4d, NULL, _gloffset_RasterPos4d),
+    NAME_FUNC_OFFSET(  910, glRasterPos4dv, glRasterPos4dv, NULL, _gloffset_RasterPos4dv),
+    NAME_FUNC_OFFSET(  925, glRasterPos4f, glRasterPos4f, NULL, _gloffset_RasterPos4f),
+    NAME_FUNC_OFFSET(  939, glRasterPos4fv, glRasterPos4fv, NULL, _gloffset_RasterPos4fv),
+    NAME_FUNC_OFFSET(  954, glRasterPos4i, glRasterPos4i, NULL, _gloffset_RasterPos4i),
+    NAME_FUNC_OFFSET(  968, glRasterPos4iv, glRasterPos4iv, NULL, _gloffset_RasterPos4iv),
+    NAME_FUNC_OFFSET(  983, glRasterPos4s, glRasterPos4s, NULL, _gloffset_RasterPos4s),
+    NAME_FUNC_OFFSET(  997, glRasterPos4sv, glRasterPos4sv, NULL, _gloffset_RasterPos4sv),
+    NAME_FUNC_OFFSET( 1012, glRectd, glRectd, NULL, _gloffset_Rectd),
+    NAME_FUNC_OFFSET( 1020, glRectdv, glRectdv, NULL, _gloffset_Rectdv),
+    NAME_FUNC_OFFSET( 1029, glRectf, glRectf, NULL, _gloffset_Rectf),
+    NAME_FUNC_OFFSET( 1037, glRectfv, glRectfv, NULL, _gloffset_Rectfv),
+    NAME_FUNC_OFFSET( 1046, glRecti, glRecti, NULL, _gloffset_Recti),
+    NAME_FUNC_OFFSET( 1054, glRectiv, glRectiv, NULL, _gloffset_Rectiv),
+    NAME_FUNC_OFFSET( 1063, glRects, glRects, NULL, _gloffset_Rects),
+    NAME_FUNC_OFFSET( 1071, glRectsv, glRectsv, NULL, _gloffset_Rectsv),
+    NAME_FUNC_OFFSET( 1080, glTexCoord1d, glTexCoord1d, NULL, _gloffset_TexCoord1d),
+    NAME_FUNC_OFFSET( 1093, glTexCoord1dv, glTexCoord1dv, NULL, _gloffset_TexCoord1dv),
+    NAME_FUNC_OFFSET( 1107, glTexCoord1f, glTexCoord1f, NULL, _gloffset_TexCoord1f),
+    NAME_FUNC_OFFSET( 1120, glTexCoord1fv, glTexCoord1fv, NULL, _gloffset_TexCoord1fv),
+    NAME_FUNC_OFFSET( 1134, glTexCoord1i, glTexCoord1i, NULL, _gloffset_TexCoord1i),
+    NAME_FUNC_OFFSET( 1147, glTexCoord1iv, glTexCoord1iv, NULL, _gloffset_TexCoord1iv),
+    NAME_FUNC_OFFSET( 1161, glTexCoord1s, glTexCoord1s, NULL, _gloffset_TexCoord1s),
+    NAME_FUNC_OFFSET( 1174, glTexCoord1sv, glTexCoord1sv, NULL, _gloffset_TexCoord1sv),
+    NAME_FUNC_OFFSET( 1188, glTexCoord2d, glTexCoord2d, NULL, _gloffset_TexCoord2d),
+    NAME_FUNC_OFFSET( 1201, glTexCoord2dv, glTexCoord2dv, NULL, _gloffset_TexCoord2dv),
+    NAME_FUNC_OFFSET( 1215, glTexCoord2f, glTexCoord2f, NULL, _gloffset_TexCoord2f),
+    NAME_FUNC_OFFSET( 1228, glTexCoord2fv, glTexCoord2fv, NULL, _gloffset_TexCoord2fv),
+    NAME_FUNC_OFFSET( 1242, glTexCoord2i, glTexCoord2i, NULL, _gloffset_TexCoord2i),
+    NAME_FUNC_OFFSET( 1255, glTexCoord2iv, glTexCoord2iv, NULL, _gloffset_TexCoord2iv),
+    NAME_FUNC_OFFSET( 1269, glTexCoord2s, glTexCoord2s, NULL, _gloffset_TexCoord2s),
+    NAME_FUNC_OFFSET( 1282, glTexCoord2sv, glTexCoord2sv, NULL, _gloffset_TexCoord2sv),
+    NAME_FUNC_OFFSET( 1296, glTexCoord3d, glTexCoord3d, NULL, _gloffset_TexCoord3d),
+    NAME_FUNC_OFFSET( 1309, glTexCoord3dv, glTexCoord3dv, NULL, _gloffset_TexCoord3dv),
+    NAME_FUNC_OFFSET( 1323, glTexCoord3f, glTexCoord3f, NULL, _gloffset_TexCoord3f),
+    NAME_FUNC_OFFSET( 1336, glTexCoord3fv, glTexCoord3fv, NULL, _gloffset_TexCoord3fv),
+    NAME_FUNC_OFFSET( 1350, glTexCoord3i, glTexCoord3i, NULL, _gloffset_TexCoord3i),
+    NAME_FUNC_OFFSET( 1363, glTexCoord3iv, glTexCoord3iv, NULL, _gloffset_TexCoord3iv),
+    NAME_FUNC_OFFSET( 1377, glTexCoord3s, glTexCoord3s, NULL, _gloffset_TexCoord3s),
+    NAME_FUNC_OFFSET( 1390, glTexCoord3sv, glTexCoord3sv, NULL, _gloffset_TexCoord3sv),
+    NAME_FUNC_OFFSET( 1404, glTexCoord4d, glTexCoord4d, NULL, _gloffset_TexCoord4d),
+    NAME_FUNC_OFFSET( 1417, glTexCoord4dv, glTexCoord4dv, NULL, _gloffset_TexCoord4dv),
+    NAME_FUNC_OFFSET( 1431, glTexCoord4f, glTexCoord4f, NULL, _gloffset_TexCoord4f),
+    NAME_FUNC_OFFSET( 1444, glTexCoord4fv, glTexCoord4fv, NULL, _gloffset_TexCoord4fv),
+    NAME_FUNC_OFFSET( 1458, glTexCoord4i, glTexCoord4i, NULL, _gloffset_TexCoord4i),
+    NAME_FUNC_OFFSET( 1471, glTexCoord4iv, glTexCoord4iv, NULL, _gloffset_TexCoord4iv),
+    NAME_FUNC_OFFSET( 1485, glTexCoord4s, glTexCoord4s, NULL, _gloffset_TexCoord4s),
+    NAME_FUNC_OFFSET( 1498, glTexCoord4sv, glTexCoord4sv, NULL, _gloffset_TexCoord4sv),
+    NAME_FUNC_OFFSET( 1512, glVertex2d, glVertex2d, NULL, _gloffset_Vertex2d),
+    NAME_FUNC_OFFSET( 1523, glVertex2dv, glVertex2dv, NULL, _gloffset_Vertex2dv),
+    NAME_FUNC_OFFSET( 1535, glVertex2f, glVertex2f, NULL, _gloffset_Vertex2f),
+    NAME_FUNC_OFFSET( 1546, glVertex2fv, glVertex2fv, NULL, _gloffset_Vertex2fv),
+    NAME_FUNC_OFFSET( 1558, glVertex2i, glVertex2i, NULL, _gloffset_Vertex2i),
+    NAME_FUNC_OFFSET( 1569, glVertex2iv, glVertex2iv, NULL, _gloffset_Vertex2iv),
+    NAME_FUNC_OFFSET( 1581, glVertex2s, glVertex2s, NULL, _gloffset_Vertex2s),
+    NAME_FUNC_OFFSET( 1592, glVertex2sv, glVertex2sv, NULL, _gloffset_Vertex2sv),
+    NAME_FUNC_OFFSET( 1604, glVertex3d, glVertex3d, NULL, _gloffset_Vertex3d),
+    NAME_FUNC_OFFSET( 1615, glVertex3dv, glVertex3dv, NULL, _gloffset_Vertex3dv),
+    NAME_FUNC_OFFSET( 1627, glVertex3f, glVertex3f, NULL, _gloffset_Vertex3f),
+    NAME_FUNC_OFFSET( 1638, glVertex3fv, glVertex3fv, NULL, _gloffset_Vertex3fv),
+    NAME_FUNC_OFFSET( 1650, glVertex3i, glVertex3i, NULL, _gloffset_Vertex3i),
+    NAME_FUNC_OFFSET( 1661, glVertex3iv, glVertex3iv, NULL, _gloffset_Vertex3iv),
+    NAME_FUNC_OFFSET( 1673, glVertex3s, glVertex3s, NULL, _gloffset_Vertex3s),
+    NAME_FUNC_OFFSET( 1684, glVertex3sv, glVertex3sv, NULL, _gloffset_Vertex3sv),
+    NAME_FUNC_OFFSET( 1696, glVertex4d, glVertex4d, NULL, _gloffset_Vertex4d),
+    NAME_FUNC_OFFSET( 1707, glVertex4dv, glVertex4dv, NULL, _gloffset_Vertex4dv),
+    NAME_FUNC_OFFSET( 1719, glVertex4f, glVertex4f, NULL, _gloffset_Vertex4f),
+    NAME_FUNC_OFFSET( 1730, glVertex4fv, glVertex4fv, NULL, _gloffset_Vertex4fv),
+    NAME_FUNC_OFFSET( 1742, glVertex4i, glVertex4i, NULL, _gloffset_Vertex4i),
+    NAME_FUNC_OFFSET( 1753, glVertex4iv, glVertex4iv, NULL, _gloffset_Vertex4iv),
+    NAME_FUNC_OFFSET( 1765, glVertex4s, glVertex4s, NULL, _gloffset_Vertex4s),
+    NAME_FUNC_OFFSET( 1776, glVertex4sv, glVertex4sv, NULL, _gloffset_Vertex4sv),
+    NAME_FUNC_OFFSET( 1788, glClipPlane, glClipPlane, NULL, _gloffset_ClipPlane),
+    NAME_FUNC_OFFSET( 1800, glColorMaterial, glColorMaterial, NULL, _gloffset_ColorMaterial),
+    NAME_FUNC_OFFSET( 1816, glCullFace, glCullFace, NULL, _gloffset_CullFace),
+    NAME_FUNC_OFFSET( 1827, glFogf, glFogf, NULL, _gloffset_Fogf),
+    NAME_FUNC_OFFSET( 1834, glFogfv, glFogfv, NULL, _gloffset_Fogfv),
+    NAME_FUNC_OFFSET( 1842, glFogi, glFogi, NULL, _gloffset_Fogi),
+    NAME_FUNC_OFFSET( 1849, glFogiv, glFogiv, NULL, _gloffset_Fogiv),
+    NAME_FUNC_OFFSET( 1857, glFrontFace, glFrontFace, NULL, _gloffset_FrontFace),
+    NAME_FUNC_OFFSET( 1869, glHint, glHint, NULL, _gloffset_Hint),
+    NAME_FUNC_OFFSET( 1876, glLightf, glLightf, NULL, _gloffset_Lightf),
+    NAME_FUNC_OFFSET( 1885, glLightfv, glLightfv, NULL, _gloffset_Lightfv),
+    NAME_FUNC_OFFSET( 1895, glLighti, glLighti, NULL, _gloffset_Lighti),
+    NAME_FUNC_OFFSET( 1904, glLightiv, glLightiv, NULL, _gloffset_Lightiv),
+    NAME_FUNC_OFFSET( 1914, glLightModelf, glLightModelf, NULL, _gloffset_LightModelf),
+    NAME_FUNC_OFFSET( 1928, glLightModelfv, glLightModelfv, NULL, _gloffset_LightModelfv),
+    NAME_FUNC_OFFSET( 1943, glLightModeli, glLightModeli, NULL, _gloffset_LightModeli),
+    NAME_FUNC_OFFSET( 1957, glLightModeliv, glLightModeliv, NULL, _gloffset_LightModeliv),
+    NAME_FUNC_OFFSET( 1972, glLineStipple, glLineStipple, NULL, _gloffset_LineStipple),
+    NAME_FUNC_OFFSET( 1986, glLineWidth, glLineWidth, NULL, _gloffset_LineWidth),
+    NAME_FUNC_OFFSET( 1998, glMaterialf, glMaterialf, NULL, _gloffset_Materialf),
+    NAME_FUNC_OFFSET( 2010, glMaterialfv, glMaterialfv, NULL, _gloffset_Materialfv),
+    NAME_FUNC_OFFSET( 2023, glMateriali, glMateriali, NULL, _gloffset_Materiali),
+    NAME_FUNC_OFFSET( 2035, glMaterialiv, glMaterialiv, NULL, _gloffset_Materialiv),
+    NAME_FUNC_OFFSET( 2048, glPointSize, glPointSize, NULL, _gloffset_PointSize),
+    NAME_FUNC_OFFSET( 2060, glPolygonMode, glPolygonMode, NULL, _gloffset_PolygonMode),
+    NAME_FUNC_OFFSET( 2074, glPolygonStipple, glPolygonStipple, NULL, _gloffset_PolygonStipple),
+    NAME_FUNC_OFFSET( 2091, glScissor, glScissor, NULL, _gloffset_Scissor),
+    NAME_FUNC_OFFSET( 2101, glShadeModel, glShadeModel, NULL, _gloffset_ShadeModel),
+    NAME_FUNC_OFFSET( 2114, glTexParameterf, glTexParameterf, NULL, _gloffset_TexParameterf),
+    NAME_FUNC_OFFSET( 2130, glTexParameterfv, glTexParameterfv, NULL, _gloffset_TexParameterfv),
+    NAME_FUNC_OFFSET( 2147, glTexParameteri, glTexParameteri, NULL, _gloffset_TexParameteri),
+    NAME_FUNC_OFFSET( 2163, glTexParameteriv, glTexParameteriv, NULL, _gloffset_TexParameteriv),
+    NAME_FUNC_OFFSET( 2180, glTexImage1D, glTexImage1D, NULL, _gloffset_TexImage1D),
+    NAME_FUNC_OFFSET( 2193, glTexImage2D, glTexImage2D, NULL, _gloffset_TexImage2D),
+    NAME_FUNC_OFFSET( 2206, glTexEnvf, glTexEnvf, NULL, _gloffset_TexEnvf),
+    NAME_FUNC_OFFSET( 2216, glTexEnvfv, glTexEnvfv, NULL, _gloffset_TexEnvfv),
+    NAME_FUNC_OFFSET( 2227, glTexEnvi, glTexEnvi, NULL, _gloffset_TexEnvi),
+    NAME_FUNC_OFFSET( 2237, glTexEnviv, glTexEnviv, NULL, _gloffset_TexEnviv),
+    NAME_FUNC_OFFSET( 2248, glTexGend, glTexGend, NULL, _gloffset_TexGend),
+    NAME_FUNC_OFFSET( 2258, glTexGendv, glTexGendv, NULL, _gloffset_TexGendv),
+    NAME_FUNC_OFFSET( 2269, glTexGenf, glTexGenf, NULL, _gloffset_TexGenf),
+    NAME_FUNC_OFFSET( 2279, glTexGenfv, glTexGenfv, NULL, _gloffset_TexGenfv),
+    NAME_FUNC_OFFSET( 2290, glTexGeni, glTexGeni, NULL, _gloffset_TexGeni),
+    NAME_FUNC_OFFSET( 2300, glTexGeniv, glTexGeniv, NULL, _gloffset_TexGeniv),
+    NAME_FUNC_OFFSET( 2311, glFeedbackBuffer, glFeedbackBuffer, NULL, _gloffset_FeedbackBuffer),
+    NAME_FUNC_OFFSET( 2328, glSelectBuffer, glSelectBuffer, NULL, _gloffset_SelectBuffer),
+    NAME_FUNC_OFFSET( 2343, glRenderMode, glRenderMode, NULL, _gloffset_RenderMode),
+    NAME_FUNC_OFFSET( 2356, glInitNames, glInitNames, NULL, _gloffset_InitNames),
+    NAME_FUNC_OFFSET( 2368, glLoadName, glLoadName, NULL, _gloffset_LoadName),
+    NAME_FUNC_OFFSET( 2379, glPassThrough, glPassThrough, NULL, _gloffset_PassThrough),
+    NAME_FUNC_OFFSET( 2393, glPopName, glPopName, NULL, _gloffset_PopName),
+    NAME_FUNC_OFFSET( 2403, glPushName, glPushName, NULL, _gloffset_PushName),
+    NAME_FUNC_OFFSET( 2414, glDrawBuffer, glDrawBuffer, NULL, _gloffset_DrawBuffer),
+    NAME_FUNC_OFFSET( 2427, glClear, glClear, NULL, _gloffset_Clear),
+    NAME_FUNC_OFFSET( 2435, glClearAccum, glClearAccum, NULL, _gloffset_ClearAccum),
+    NAME_FUNC_OFFSET( 2448, glClearIndex, glClearIndex, NULL, _gloffset_ClearIndex),
+    NAME_FUNC_OFFSET( 2461, glClearColor, glClearColor, NULL, _gloffset_ClearColor),
+    NAME_FUNC_OFFSET( 2474, glClearStencil, glClearStencil, NULL, _gloffset_ClearStencil),
+    NAME_FUNC_OFFSET( 2489, glClearDepth, glClearDepth, NULL, _gloffset_ClearDepth),
+    NAME_FUNC_OFFSET( 2502, glStencilMask, glStencilMask, NULL, _gloffset_StencilMask),
+    NAME_FUNC_OFFSET( 2516, glColorMask, glColorMask, NULL, _gloffset_ColorMask),
+    NAME_FUNC_OFFSET( 2528, glDepthMask, glDepthMask, NULL, _gloffset_DepthMask),
+    NAME_FUNC_OFFSET( 2540, glIndexMask, glIndexMask, NULL, _gloffset_IndexMask),
+    NAME_FUNC_OFFSET( 2552, glAccum, glAccum, NULL, _gloffset_Accum),
+    NAME_FUNC_OFFSET( 2560, glDisable, glDisable, NULL, _gloffset_Disable),
+    NAME_FUNC_OFFSET( 2570, glEnable, glEnable, NULL, _gloffset_Enable),
+    NAME_FUNC_OFFSET( 2579, glFinish, glFinish, NULL, _gloffset_Finish),
+    NAME_FUNC_OFFSET( 2588, glFlush, glFlush, NULL, _gloffset_Flush),
+    NAME_FUNC_OFFSET( 2596, glPopAttrib, glPopAttrib, NULL, _gloffset_PopAttrib),
+    NAME_FUNC_OFFSET( 2608, glPushAttrib, glPushAttrib, NULL, _gloffset_PushAttrib),
+    NAME_FUNC_OFFSET( 2621, glMap1d, glMap1d, NULL, _gloffset_Map1d),
+    NAME_FUNC_OFFSET( 2629, glMap1f, glMap1f, NULL, _gloffset_Map1f),
+    NAME_FUNC_OFFSET( 2637, glMap2d, glMap2d, NULL, _gloffset_Map2d),
+    NAME_FUNC_OFFSET( 2645, glMap2f, glMap2f, NULL, _gloffset_Map2f),
+    NAME_FUNC_OFFSET( 2653, glMapGrid1d, glMapGrid1d, NULL, _gloffset_MapGrid1d),
+    NAME_FUNC_OFFSET( 2665, glMapGrid1f, glMapGrid1f, NULL, _gloffset_MapGrid1f),
+    NAME_FUNC_OFFSET( 2677, glMapGrid2d, glMapGrid2d, NULL, _gloffset_MapGrid2d),
+    NAME_FUNC_OFFSET( 2689, glMapGrid2f, glMapGrid2f, NULL, _gloffset_MapGrid2f),
+    NAME_FUNC_OFFSET( 2701, glEvalCoord1d, glEvalCoord1d, NULL, _gloffset_EvalCoord1d),
+    NAME_FUNC_OFFSET( 2715, glEvalCoord1dv, glEvalCoord1dv, NULL, _gloffset_EvalCoord1dv),
+    NAME_FUNC_OFFSET( 2730, glEvalCoord1f, glEvalCoord1f, NULL, _gloffset_EvalCoord1f),
+    NAME_FUNC_OFFSET( 2744, glEvalCoord1fv, glEvalCoord1fv, NULL, _gloffset_EvalCoord1fv),
+    NAME_FUNC_OFFSET( 2759, glEvalCoord2d, glEvalCoord2d, NULL, _gloffset_EvalCoord2d),
+    NAME_FUNC_OFFSET( 2773, glEvalCoord2dv, glEvalCoord2dv, NULL, _gloffset_EvalCoord2dv),
+    NAME_FUNC_OFFSET( 2788, glEvalCoord2f, glEvalCoord2f, NULL, _gloffset_EvalCoord2f),
+    NAME_FUNC_OFFSET( 2802, glEvalCoord2fv, glEvalCoord2fv, NULL, _gloffset_EvalCoord2fv),
+    NAME_FUNC_OFFSET( 2817, glEvalMesh1, glEvalMesh1, NULL, _gloffset_EvalMesh1),
+    NAME_FUNC_OFFSET( 2829, glEvalPoint1, glEvalPoint1, NULL, _gloffset_EvalPoint1),
+    NAME_FUNC_OFFSET( 2842, glEvalMesh2, glEvalMesh2, NULL, _gloffset_EvalMesh2),
+    NAME_FUNC_OFFSET( 2854, glEvalPoint2, glEvalPoint2, NULL, _gloffset_EvalPoint2),
+    NAME_FUNC_OFFSET( 2867, glAlphaFunc, glAlphaFunc, NULL, _gloffset_AlphaFunc),
+    NAME_FUNC_OFFSET( 2879, glBlendFunc, glBlendFunc, NULL, _gloffset_BlendFunc),
+    NAME_FUNC_OFFSET( 2891, glLogicOp, glLogicOp, NULL, _gloffset_LogicOp),
+    NAME_FUNC_OFFSET( 2901, glStencilFunc, glStencilFunc, NULL, _gloffset_StencilFunc),
+    NAME_FUNC_OFFSET( 2915, glStencilOp, glStencilOp, NULL, _gloffset_StencilOp),
+    NAME_FUNC_OFFSET( 2927, glDepthFunc, glDepthFunc, NULL, _gloffset_DepthFunc),
+    NAME_FUNC_OFFSET( 2939, glPixelZoom, glPixelZoom, NULL, _gloffset_PixelZoom),
+    NAME_FUNC_OFFSET( 2951, glPixelTransferf, glPixelTransferf, NULL, _gloffset_PixelTransferf),
+    NAME_FUNC_OFFSET( 2968, glPixelTransferi, glPixelTransferi, NULL, _gloffset_PixelTransferi),
+    NAME_FUNC_OFFSET( 2985, glPixelStoref, glPixelStoref, NULL, _gloffset_PixelStoref),
+    NAME_FUNC_OFFSET( 2999, glPixelStorei, glPixelStorei, NULL, _gloffset_PixelStorei),
+    NAME_FUNC_OFFSET( 3013, glPixelMapfv, glPixelMapfv, NULL, _gloffset_PixelMapfv),
+    NAME_FUNC_OFFSET( 3026, glPixelMapuiv, glPixelMapuiv, NULL, _gloffset_PixelMapuiv),
+    NAME_FUNC_OFFSET( 3040, glPixelMapusv, glPixelMapusv, NULL, _gloffset_PixelMapusv),
+    NAME_FUNC_OFFSET( 3054, glReadBuffer, glReadBuffer, NULL, _gloffset_ReadBuffer),
+    NAME_FUNC_OFFSET( 3067, glCopyPixels, glCopyPixels, NULL, _gloffset_CopyPixels),
+    NAME_FUNC_OFFSET( 3080, glReadPixels, glReadPixels, NULL, _gloffset_ReadPixels),
+    NAME_FUNC_OFFSET( 3093, glDrawPixels, glDrawPixels, NULL, _gloffset_DrawPixels),
+    NAME_FUNC_OFFSET( 3106, glGetBooleanv, glGetBooleanv, NULL, _gloffset_GetBooleanv),
+    NAME_FUNC_OFFSET( 3120, glGetClipPlane, glGetClipPlane, NULL, _gloffset_GetClipPlane),
+    NAME_FUNC_OFFSET( 3135, glGetDoublev, glGetDoublev, NULL, _gloffset_GetDoublev),
+    NAME_FUNC_OFFSET( 3148, glGetError, glGetError, NULL, _gloffset_GetError),
+    NAME_FUNC_OFFSET( 3159, glGetFloatv, glGetFloatv, NULL, _gloffset_GetFloatv),
+    NAME_FUNC_OFFSET( 3171, glGetIntegerv, glGetIntegerv, NULL, _gloffset_GetIntegerv),
+    NAME_FUNC_OFFSET( 3185, glGetLightfv, glGetLightfv, NULL, _gloffset_GetLightfv),
+    NAME_FUNC_OFFSET( 3198, glGetLightiv, glGetLightiv, NULL, _gloffset_GetLightiv),
+    NAME_FUNC_OFFSET( 3211, glGetMapdv, glGetMapdv, NULL, _gloffset_GetMapdv),
+    NAME_FUNC_OFFSET( 3222, glGetMapfv, glGetMapfv, NULL, _gloffset_GetMapfv),
+    NAME_FUNC_OFFSET( 3233, glGetMapiv, glGetMapiv, NULL, _gloffset_GetMapiv),
+    NAME_FUNC_OFFSET( 3244, glGetMaterialfv, glGetMaterialfv, NULL, _gloffset_GetMaterialfv),
+    NAME_FUNC_OFFSET( 3260, glGetMaterialiv, glGetMaterialiv, NULL, _gloffset_GetMaterialiv),
+    NAME_FUNC_OFFSET( 3276, glGetPixelMapfv, glGetPixelMapfv, NULL, _gloffset_GetPixelMapfv),
+    NAME_FUNC_OFFSET( 3292, glGetPixelMapuiv, glGetPixelMapuiv, NULL, _gloffset_GetPixelMapuiv),
+    NAME_FUNC_OFFSET( 3309, glGetPixelMapusv, glGetPixelMapusv, NULL, _gloffset_GetPixelMapusv),
+    NAME_FUNC_OFFSET( 3326, glGetPolygonStipple, glGetPolygonStipple, NULL, _gloffset_GetPolygonStipple),
+    NAME_FUNC_OFFSET( 3346, glGetString, glGetString, NULL, _gloffset_GetString),
+    NAME_FUNC_OFFSET( 3358, glGetTexEnvfv, glGetTexEnvfv, NULL, _gloffset_GetTexEnvfv),
+    NAME_FUNC_OFFSET( 3372, glGetTexEnviv, glGetTexEnviv, NULL, _gloffset_GetTexEnviv),
+    NAME_FUNC_OFFSET( 3386, glGetTexGendv, glGetTexGendv, NULL, _gloffset_GetTexGendv),
+    NAME_FUNC_OFFSET( 3400, glGetTexGenfv, glGetTexGenfv, NULL, _gloffset_GetTexGenfv),
+    NAME_FUNC_OFFSET( 3414, glGetTexGeniv, glGetTexGeniv, NULL, _gloffset_GetTexGeniv),
+    NAME_FUNC_OFFSET( 3428, glGetTexImage, glGetTexImage, NULL, _gloffset_GetTexImage),
+    NAME_FUNC_OFFSET( 3442, glGetTexParameterfv, glGetTexParameterfv, NULL, _gloffset_GetTexParameterfv),
+    NAME_FUNC_OFFSET( 3462, glGetTexParameteriv, glGetTexParameteriv, NULL, _gloffset_GetTexParameteriv),
+    NAME_FUNC_OFFSET( 3482, glGetTexLevelParameterfv, glGetTexLevelParameterfv, NULL, _gloffset_GetTexLevelParameterfv),
+    NAME_FUNC_OFFSET( 3507, glGetTexLevelParameteriv, glGetTexLevelParameteriv, NULL, _gloffset_GetTexLevelParameteriv),
+    NAME_FUNC_OFFSET( 3532, glIsEnabled, glIsEnabled, NULL, _gloffset_IsEnabled),
+    NAME_FUNC_OFFSET( 3544, glIsList, glIsList, NULL, _gloffset_IsList),
+    NAME_FUNC_OFFSET( 3553, glDepthRange, glDepthRange, NULL, _gloffset_DepthRange),
+    NAME_FUNC_OFFSET( 3566, glFrustum, glFrustum, NULL, _gloffset_Frustum),
+    NAME_FUNC_OFFSET( 3576, glLoadIdentity, glLoadIdentity, NULL, _gloffset_LoadIdentity),
+    NAME_FUNC_OFFSET( 3591, glLoadMatrixf, glLoadMatrixf, NULL, _gloffset_LoadMatrixf),
+    NAME_FUNC_OFFSET( 3605, glLoadMatrixd, glLoadMatrixd, NULL, _gloffset_LoadMatrixd),
+    NAME_FUNC_OFFSET( 3619, glMatrixMode, glMatrixMode, NULL, _gloffset_MatrixMode),
+    NAME_FUNC_OFFSET( 3632, glMultMatrixf, glMultMatrixf, NULL, _gloffset_MultMatrixf),
+    NAME_FUNC_OFFSET( 3646, glMultMatrixd, glMultMatrixd, NULL, _gloffset_MultMatrixd),
+    NAME_FUNC_OFFSET( 3660, glOrtho, glOrtho, NULL, _gloffset_Ortho),
+    NAME_FUNC_OFFSET( 3668, glPopMatrix, glPopMatrix, NULL, _gloffset_PopMatrix),
+    NAME_FUNC_OFFSET( 3680, glPushMatrix, glPushMatrix, NULL, _gloffset_PushMatrix),
+    NAME_FUNC_OFFSET( 3693, glRotated, glRotated, NULL, _gloffset_Rotated),
+    NAME_FUNC_OFFSET( 3703, glRotatef, glRotatef, NULL, _gloffset_Rotatef),
+    NAME_FUNC_OFFSET( 3713, glScaled, glScaled, NULL, _gloffset_Scaled),
+    NAME_FUNC_OFFSET( 3722, glScalef, glScalef, NULL, _gloffset_Scalef),
+    NAME_FUNC_OFFSET( 3731, glTranslated, glTranslated, NULL, _gloffset_Translated),
+    NAME_FUNC_OFFSET( 3744, glTranslatef, glTranslatef, NULL, _gloffset_Translatef),
+    NAME_FUNC_OFFSET( 3757, glViewport, glViewport, NULL, _gloffset_Viewport),
+    NAME_FUNC_OFFSET( 3768, glArrayElement, glArrayElement, NULL, _gloffset_ArrayElement),
+    NAME_FUNC_OFFSET( 3783, glBindTexture, glBindTexture, NULL, _gloffset_BindTexture),
+    NAME_FUNC_OFFSET( 3797, glColorPointer, glColorPointer, NULL, _gloffset_ColorPointer),
+    NAME_FUNC_OFFSET( 3812, glDisableClientState, glDisableClientState, NULL, _gloffset_DisableClientState),
+    NAME_FUNC_OFFSET( 3833, glDrawArrays, glDrawArrays, NULL, _gloffset_DrawArrays),
+    NAME_FUNC_OFFSET( 3846, glDrawElements, glDrawElements, NULL, _gloffset_DrawElements),
+    NAME_FUNC_OFFSET( 3861, glEdgeFlagPointer, glEdgeFlagPointer, NULL, _gloffset_EdgeFlagPointer),
+    NAME_FUNC_OFFSET( 3879, glEnableClientState, glEnableClientState, NULL, _gloffset_EnableClientState),
+    NAME_FUNC_OFFSET( 3899, glIndexPointer, glIndexPointer, NULL, _gloffset_IndexPointer),
+    NAME_FUNC_OFFSET( 3914, glIndexub, glIndexub, NULL, _gloffset_Indexub),
+    NAME_FUNC_OFFSET( 3924, glIndexubv, glIndexubv, NULL, _gloffset_Indexubv),
+    NAME_FUNC_OFFSET( 3935, glInterleavedArrays, glInterleavedArrays, NULL, _gloffset_InterleavedArrays),
+    NAME_FUNC_OFFSET( 3955, glNormalPointer, glNormalPointer, NULL, _gloffset_NormalPointer),
+    NAME_FUNC_OFFSET( 3971, glPolygonOffset, glPolygonOffset, NULL, _gloffset_PolygonOffset),
+    NAME_FUNC_OFFSET( 3987, glTexCoordPointer, glTexCoordPointer, NULL, _gloffset_TexCoordPointer),
+    NAME_FUNC_OFFSET( 4005, glVertexPointer, glVertexPointer, NULL, _gloffset_VertexPointer),
+    NAME_FUNC_OFFSET( 4021, glAreTexturesResident, glAreTexturesResident, NULL, _gloffset_AreTexturesResident),
+    NAME_FUNC_OFFSET( 4043, glCopyTexImage1D, glCopyTexImage1D, NULL, _gloffset_CopyTexImage1D),
+    NAME_FUNC_OFFSET( 4060, glCopyTexImage2D, glCopyTexImage2D, NULL, _gloffset_CopyTexImage2D),
+    NAME_FUNC_OFFSET( 4077, glCopyTexSubImage1D, glCopyTexSubImage1D, NULL, _gloffset_CopyTexSubImage1D),
+    NAME_FUNC_OFFSET( 4097, glCopyTexSubImage2D, glCopyTexSubImage2D, NULL, _gloffset_CopyTexSubImage2D),
+    NAME_FUNC_OFFSET( 4117, glDeleteTextures, glDeleteTextures, NULL, _gloffset_DeleteTextures),
+    NAME_FUNC_OFFSET( 4134, glGenTextures, glGenTextures, NULL, _gloffset_GenTextures),
+    NAME_FUNC_OFFSET( 4148, glGetPointerv, glGetPointerv, NULL, _gloffset_GetPointerv),
+    NAME_FUNC_OFFSET( 4162, glIsTexture, glIsTexture, NULL, _gloffset_IsTexture),
+    NAME_FUNC_OFFSET( 4174, glPrioritizeTextures, glPrioritizeTextures, NULL, _gloffset_PrioritizeTextures),
+    NAME_FUNC_OFFSET( 4195, glTexSubImage1D, glTexSubImage1D, NULL, _gloffset_TexSubImage1D),
+    NAME_FUNC_OFFSET( 4211, glTexSubImage2D, glTexSubImage2D, NULL, _gloffset_TexSubImage2D),
+    NAME_FUNC_OFFSET( 4227, glPopClientAttrib, glPopClientAttrib, NULL, _gloffset_PopClientAttrib),
+    NAME_FUNC_OFFSET( 4245, glPushClientAttrib, glPushClientAttrib, NULL, _gloffset_PushClientAttrib),
+    NAME_FUNC_OFFSET( 4264, glBlendColor, glBlendColor, NULL, _gloffset_BlendColor),
+    NAME_FUNC_OFFSET( 4277, glBlendEquation, glBlendEquation, NULL, _gloffset_BlendEquation),
+    NAME_FUNC_OFFSET( 4293, glDrawRangeElements, glDrawRangeElements, NULL, _gloffset_DrawRangeElements),
+    NAME_FUNC_OFFSET( 4313, glColorTable, glColorTable, NULL, _gloffset_ColorTable),
+    NAME_FUNC_OFFSET( 4326, glColorTableParameterfv, glColorTableParameterfv, NULL, _gloffset_ColorTableParameterfv),
+    NAME_FUNC_OFFSET( 4350, glColorTableParameteriv, glColorTableParameteriv, NULL, _gloffset_ColorTableParameteriv),
+    NAME_FUNC_OFFSET( 4374, glCopyColorTable, glCopyColorTable, NULL, _gloffset_CopyColorTable),
+    NAME_FUNC_OFFSET( 4391, glGetColorTable, glGetColorTable, NULL, _gloffset_GetColorTable),
+    NAME_FUNC_OFFSET( 4407, glGetColorTableParameterfv, glGetColorTableParameterfv, NULL, _gloffset_GetColorTableParameterfv),
+    NAME_FUNC_OFFSET( 4434, glGetColorTableParameteriv, glGetColorTableParameteriv, NULL, _gloffset_GetColorTableParameteriv),
+    NAME_FUNC_OFFSET( 4461, glColorSubTable, glColorSubTable, NULL, _gloffset_ColorSubTable),
+    NAME_FUNC_OFFSET( 4477, glCopyColorSubTable, glCopyColorSubTable, NULL, _gloffset_CopyColorSubTable),
+    NAME_FUNC_OFFSET( 4497, glConvolutionFilter1D, glConvolutionFilter1D, NULL, _gloffset_ConvolutionFilter1D),
+    NAME_FUNC_OFFSET( 4519, glConvolutionFilter2D, glConvolutionFilter2D, NULL, _gloffset_ConvolutionFilter2D),
+    NAME_FUNC_OFFSET( 4541, glConvolutionParameterf, glConvolutionParameterf, NULL, _gloffset_ConvolutionParameterf),
+    NAME_FUNC_OFFSET( 4565, glConvolutionParameterfv, glConvolutionParameterfv, NULL, _gloffset_ConvolutionParameterfv),
+    NAME_FUNC_OFFSET( 4590, glConvolutionParameteri, glConvolutionParameteri, NULL, _gloffset_ConvolutionParameteri),
+    NAME_FUNC_OFFSET( 4614, glConvolutionParameteriv, glConvolutionParameteriv, NULL, _gloffset_ConvolutionParameteriv),
+    NAME_FUNC_OFFSET( 4639, glCopyConvolutionFilter1D, glCopyConvolutionFilter1D, NULL, _gloffset_CopyConvolutionFilter1D),
+    NAME_FUNC_OFFSET( 4665, glCopyConvolutionFilter2D, glCopyConvolutionFilter2D, NULL, _gloffset_CopyConvolutionFilter2D),
+    NAME_FUNC_OFFSET( 4691, glGetConvolutionFilter, glGetConvolutionFilter, NULL, _gloffset_GetConvolutionFilter),
+    NAME_FUNC_OFFSET( 4714, glGetConvolutionParameterfv, glGetConvolutionParameterfv, NULL, _gloffset_GetConvolutionParameterfv),
+    NAME_FUNC_OFFSET( 4742, glGetConvolutionParameteriv, glGetConvolutionParameteriv, NULL, _gloffset_GetConvolutionParameteriv),
+    NAME_FUNC_OFFSET( 4770, glGetSeparableFilter, glGetSeparableFilter, NULL, _gloffset_GetSeparableFilter),
+    NAME_FUNC_OFFSET( 4791, glSeparableFilter2D, glSeparableFilter2D, NULL, _gloffset_SeparableFilter2D),
+    NAME_FUNC_OFFSET( 4811, glGetHistogram, glGetHistogram, NULL, _gloffset_GetHistogram),
+    NAME_FUNC_OFFSET( 4826, glGetHistogramParameterfv, glGetHistogramParameterfv, NULL, _gloffset_GetHistogramParameterfv),
+    NAME_FUNC_OFFSET( 4852, glGetHistogramParameteriv, glGetHistogramParameteriv, NULL, _gloffset_GetHistogramParameteriv),
+    NAME_FUNC_OFFSET( 4878, glGetMinmax, glGetMinmax, NULL, _gloffset_GetMinmax),
+    NAME_FUNC_OFFSET( 4890, glGetMinmaxParameterfv, glGetMinmaxParameterfv, NULL, _gloffset_GetMinmaxParameterfv),
+    NAME_FUNC_OFFSET( 4913, glGetMinmaxParameteriv, glGetMinmaxParameteriv, NULL, _gloffset_GetMinmaxParameteriv),
+    NAME_FUNC_OFFSET( 4936, glHistogram, glHistogram, NULL, _gloffset_Histogram),
+    NAME_FUNC_OFFSET( 4948, glMinmax, glMinmax, NULL, _gloffset_Minmax),
+    NAME_FUNC_OFFSET( 4957, glResetHistogram, glResetHistogram, NULL, _gloffset_ResetHistogram),
+    NAME_FUNC_OFFSET( 4974, glResetMinmax, glResetMinmax, NULL, _gloffset_ResetMinmax),
+    NAME_FUNC_OFFSET( 4988, glTexImage3D, glTexImage3D, NULL, _gloffset_TexImage3D),
+    NAME_FUNC_OFFSET( 5001, glTexSubImage3D, glTexSubImage3D, NULL, _gloffset_TexSubImage3D),
+    NAME_FUNC_OFFSET( 5017, glCopyTexSubImage3D, glCopyTexSubImage3D, NULL, _gloffset_CopyTexSubImage3D),
+    NAME_FUNC_OFFSET( 5037, glActiveTextureARB, glActiveTextureARB, NULL, _gloffset_ActiveTextureARB),
+    NAME_FUNC_OFFSET( 5056, glClientActiveTextureARB, glClientActiveTextureARB, NULL, _gloffset_ClientActiveTextureARB),
+    NAME_FUNC_OFFSET( 5081, glMultiTexCoord1dARB, glMultiTexCoord1dARB, NULL, _gloffset_MultiTexCoord1dARB),
+    NAME_FUNC_OFFSET( 5102, glMultiTexCoord1dvARB, glMultiTexCoord1dvARB, NULL, _gloffset_MultiTexCoord1dvARB),
+    NAME_FUNC_OFFSET( 5124, glMultiTexCoord1fARB, glMultiTexCoord1fARB, NULL, _gloffset_MultiTexCoord1fARB),
+    NAME_FUNC_OFFSET( 5145, glMultiTexCoord1fvARB, glMultiTexCoord1fvARB, NULL, _gloffset_MultiTexCoord1fvARB),
+    NAME_FUNC_OFFSET( 5167, glMultiTexCoord1iARB, glMultiTexCoord1iARB, NULL, _gloffset_MultiTexCoord1iARB),
+    NAME_FUNC_OFFSET( 5188, glMultiTexCoord1ivARB, glMultiTexCoord1ivARB, NULL, _gloffset_MultiTexCoord1ivARB),
+    NAME_FUNC_OFFSET( 5210, glMultiTexCoord1sARB, glMultiTexCoord1sARB, NULL, _gloffset_MultiTexCoord1sARB),
+    NAME_FUNC_OFFSET( 5231, glMultiTexCoord1svARB, glMultiTexCoord1svARB, NULL, _gloffset_MultiTexCoord1svARB),
+    NAME_FUNC_OFFSET( 5253, glMultiTexCoord2dARB, glMultiTexCoord2dARB, NULL, _gloffset_MultiTexCoord2dARB),
+    NAME_FUNC_OFFSET( 5274, glMultiTexCoord2dvARB, glMultiTexCoord2dvARB, NULL, _gloffset_MultiTexCoord2dvARB),
+    NAME_FUNC_OFFSET( 5296, glMultiTexCoord2fARB, glMultiTexCoord2fARB, NULL, _gloffset_MultiTexCoord2fARB),
+    NAME_FUNC_OFFSET( 5317, glMultiTexCoord2fvARB, glMultiTexCoord2fvARB, NULL, _gloffset_MultiTexCoord2fvARB),
+    NAME_FUNC_OFFSET( 5339, glMultiTexCoord2iARB, glMultiTexCoord2iARB, NULL, _gloffset_MultiTexCoord2iARB),
+    NAME_FUNC_OFFSET( 5360, glMultiTexCoord2ivARB, glMultiTexCoord2ivARB, NULL, _gloffset_MultiTexCoord2ivARB),
+    NAME_FUNC_OFFSET( 5382, glMultiTexCoord2sARB, glMultiTexCoord2sARB, NULL, _gloffset_MultiTexCoord2sARB),
+    NAME_FUNC_OFFSET( 5403, glMultiTexCoord2svARB, glMultiTexCoord2svARB, NULL, _gloffset_MultiTexCoord2svARB),
+    NAME_FUNC_OFFSET( 5425, glMultiTexCoord3dARB, glMultiTexCoord3dARB, NULL, _gloffset_MultiTexCoord3dARB),
+    NAME_FUNC_OFFSET( 5446, glMultiTexCoord3dvARB, glMultiTexCoord3dvARB, NULL, _gloffset_MultiTexCoord3dvARB),
+    NAME_FUNC_OFFSET( 5468, glMultiTexCoord3fARB, glMultiTexCoord3fARB, NULL, _gloffset_MultiTexCoord3fARB),
+    NAME_FUNC_OFFSET( 5489, glMultiTexCoord3fvARB, glMultiTexCoord3fvARB, NULL, _gloffset_MultiTexCoord3fvARB),
+    NAME_FUNC_OFFSET( 5511, glMultiTexCoord3iARB, glMultiTexCoord3iARB, NULL, _gloffset_MultiTexCoord3iARB),
+    NAME_FUNC_OFFSET( 5532, glMultiTexCoord3ivARB, glMultiTexCoord3ivARB, NULL, _gloffset_MultiTexCoord3ivARB),
+    NAME_FUNC_OFFSET( 5554, glMultiTexCoord3sARB, glMultiTexCoord3sARB, NULL, _gloffset_MultiTexCoord3sARB),
+    NAME_FUNC_OFFSET( 5575, glMultiTexCoord3svARB, glMultiTexCoord3svARB, NULL, _gloffset_MultiTexCoord3svARB),
+    NAME_FUNC_OFFSET( 5597, glMultiTexCoord4dARB, glMultiTexCoord4dARB, NULL, _gloffset_MultiTexCoord4dARB),
+    NAME_FUNC_OFFSET( 5618, glMultiTexCoord4dvARB, glMultiTexCoord4dvARB, NULL, _gloffset_MultiTexCoord4dvARB),
+    NAME_FUNC_OFFSET( 5640, glMultiTexCoord4fARB, glMultiTexCoord4fARB, NULL, _gloffset_MultiTexCoord4fARB),
+    NAME_FUNC_OFFSET( 5661, glMultiTexCoord4fvARB, glMultiTexCoord4fvARB, NULL, _gloffset_MultiTexCoord4fvARB),
+    NAME_FUNC_OFFSET( 5683, glMultiTexCoord4iARB, glMultiTexCoord4iARB, NULL, _gloffset_MultiTexCoord4iARB),
+    NAME_FUNC_OFFSET( 5704, glMultiTexCoord4ivARB, glMultiTexCoord4ivARB, NULL, _gloffset_MultiTexCoord4ivARB),
+    NAME_FUNC_OFFSET( 5726, glMultiTexCoord4sARB, glMultiTexCoord4sARB, NULL, _gloffset_MultiTexCoord4sARB),
+    NAME_FUNC_OFFSET( 5747, glMultiTexCoord4svARB, glMultiTexCoord4svARB, NULL, _gloffset_MultiTexCoord4svARB),
+    NAME_FUNC_OFFSET( 5769, glAttachShader, glAttachShader, NULL, _gloffset_AttachShader),
+    NAME_FUNC_OFFSET( 5784, glCreateProgram, glCreateProgram, NULL, _gloffset_CreateProgram),
+    NAME_FUNC_OFFSET( 5800, glCreateShader, glCreateShader, NULL, _gloffset_CreateShader),
+    NAME_FUNC_OFFSET( 5815, glDeleteProgram, glDeleteProgram, NULL, _gloffset_DeleteProgram),
+    NAME_FUNC_OFFSET( 5831, glDeleteShader, glDeleteShader, NULL, _gloffset_DeleteShader),
+    NAME_FUNC_OFFSET( 5846, glDetachShader, glDetachShader, NULL, _gloffset_DetachShader),
+    NAME_FUNC_OFFSET( 5861, glGetAttachedShaders, glGetAttachedShaders, NULL, _gloffset_GetAttachedShaders),
+    NAME_FUNC_OFFSET( 5882, glGetProgramInfoLog, glGetProgramInfoLog, NULL, _gloffset_GetProgramInfoLog),
+    NAME_FUNC_OFFSET( 5902, glGetProgramiv, glGetProgramiv, NULL, _gloffset_GetProgramiv),
+    NAME_FUNC_OFFSET( 5917, glGetShaderInfoLog, glGetShaderInfoLog, NULL, _gloffset_GetShaderInfoLog),
+    NAME_FUNC_OFFSET( 5936, glGetShaderiv, glGetShaderiv, NULL, _gloffset_GetShaderiv),
+    NAME_FUNC_OFFSET( 5950, glIsProgram, glIsProgram, NULL, _gloffset_IsProgram),
+    NAME_FUNC_OFFSET( 5962, glIsShader, glIsShader, NULL, _gloffset_IsShader),
+    NAME_FUNC_OFFSET( 5973, glStencilFuncSeparate, glStencilFuncSeparate, NULL, _gloffset_StencilFuncSeparate),
+    NAME_FUNC_OFFSET( 5995, glStencilMaskSeparate, glStencilMaskSeparate, NULL, _gloffset_StencilMaskSeparate),
+    NAME_FUNC_OFFSET( 6017, glStencilOpSeparate, glStencilOpSeparate, NULL, _gloffset_StencilOpSeparate),
+    NAME_FUNC_OFFSET( 6037, glUniformMatrix2x3fv, glUniformMatrix2x3fv, NULL, _gloffset_UniformMatrix2x3fv),
+    NAME_FUNC_OFFSET( 6058, glUniformMatrix2x4fv, glUniformMatrix2x4fv, NULL, _gloffset_UniformMatrix2x4fv),
+    NAME_FUNC_OFFSET( 6079, glUniformMatrix3x2fv, glUniformMatrix3x2fv, NULL, _gloffset_UniformMatrix3x2fv),
+    NAME_FUNC_OFFSET( 6100, glUniformMatrix3x4fv, glUniformMatrix3x4fv, NULL, _gloffset_UniformMatrix3x4fv),
+    NAME_FUNC_OFFSET( 6121, glUniformMatrix4x2fv, glUniformMatrix4x2fv, NULL, _gloffset_UniformMatrix4x2fv),
+    NAME_FUNC_OFFSET( 6142, glUniformMatrix4x3fv, glUniformMatrix4x3fv, NULL, _gloffset_UniformMatrix4x3fv),
+    NAME_FUNC_OFFSET( 6163, glLoadTransposeMatrixdARB, glLoadTransposeMatrixdARB, NULL, _gloffset_LoadTransposeMatrixdARB),
+    NAME_FUNC_OFFSET( 6189, glLoadTransposeMatrixfARB, glLoadTransposeMatrixfARB, NULL, _gloffset_LoadTransposeMatrixfARB),
+    NAME_FUNC_OFFSET( 6215, glMultTransposeMatrixdARB, glMultTransposeMatrixdARB, NULL, _gloffset_MultTransposeMatrixdARB),
+    NAME_FUNC_OFFSET( 6241, glMultTransposeMatrixfARB, glMultTransposeMatrixfARB, NULL, _gloffset_MultTransposeMatrixfARB),
+    NAME_FUNC_OFFSET( 6267, glSampleCoverageARB, glSampleCoverageARB, NULL, _gloffset_SampleCoverageARB),
+    NAME_FUNC_OFFSET( 6287, glCompressedTexImage1DARB, glCompressedTexImage1DARB, NULL, _gloffset_CompressedTexImage1DARB),
+    NAME_FUNC_OFFSET( 6313, glCompressedTexImage2DARB, glCompressedTexImage2DARB, NULL, _gloffset_CompressedTexImage2DARB),
+    NAME_FUNC_OFFSET( 6339, glCompressedTexImage3DARB, glCompressedTexImage3DARB, NULL, _gloffset_CompressedTexImage3DARB),
+    NAME_FUNC_OFFSET( 6365, glCompressedTexSubImage1DARB, glCompressedTexSubImage1DARB, NULL, _gloffset_CompressedTexSubImage1DARB),
+    NAME_FUNC_OFFSET( 6394, glCompressedTexSubImage2DARB, glCompressedTexSubImage2DARB, NULL, _gloffset_CompressedTexSubImage2DARB),
+    NAME_FUNC_OFFSET( 6423, glCompressedTexSubImage3DARB, glCompressedTexSubImage3DARB, NULL, _gloffset_CompressedTexSubImage3DARB),
+    NAME_FUNC_OFFSET( 6452, glGetCompressedTexImageARB, glGetCompressedTexImageARB, NULL, _gloffset_GetCompressedTexImageARB),
+    NAME_FUNC_OFFSET( 6479, glDisableVertexAttribArrayARB, glDisableVertexAttribArrayARB, NULL, _gloffset_DisableVertexAttribArrayARB),
+    NAME_FUNC_OFFSET( 6509, glEnableVertexAttribArrayARB, glEnableVertexAttribArrayARB, NULL, _gloffset_EnableVertexAttribArrayARB),
+    NAME_FUNC_OFFSET( 6538, glGetProgramEnvParameterdvARB, glGetProgramEnvParameterdvARB, NULL, _gloffset_GetProgramEnvParameterdvARB),
+    NAME_FUNC_OFFSET( 6568, glGetProgramEnvParameterfvARB, glGetProgramEnvParameterfvARB, NULL, _gloffset_GetProgramEnvParameterfvARB),
+    NAME_FUNC_OFFSET( 6598, glGetProgramLocalParameterdvARB, glGetProgramLocalParameterdvARB, NULL, _gloffset_GetProgramLocalParameterdvARB),
+    NAME_FUNC_OFFSET( 6630, glGetProgramLocalParameterfvARB, glGetProgramLocalParameterfvARB, NULL, _gloffset_GetProgramLocalParameterfvARB),
+    NAME_FUNC_OFFSET( 6662, glGetProgramStringARB, glGetProgramStringARB, NULL, _gloffset_GetProgramStringARB),
+    NAME_FUNC_OFFSET( 6684, glGetProgramivARB, glGetProgramivARB, NULL, _gloffset_GetProgramivARB),
+    NAME_FUNC_OFFSET( 6702, glGetVertexAttribdvARB, glGetVertexAttribdvARB, NULL, _gloffset_GetVertexAttribdvARB),
+    NAME_FUNC_OFFSET( 6725, glGetVertexAttribfvARB, glGetVertexAttribfvARB, NULL, _gloffset_GetVertexAttribfvARB),
+    NAME_FUNC_OFFSET( 6748, glGetVertexAttribivARB, glGetVertexAttribivARB, NULL, _gloffset_GetVertexAttribivARB),
+    NAME_FUNC_OFFSET( 6771, glProgramEnvParameter4dARB, glProgramEnvParameter4dARB, NULL, _gloffset_ProgramEnvParameter4dARB),
+    NAME_FUNC_OFFSET( 6798, glProgramEnvParameter4dvARB, glProgramEnvParameter4dvARB, NULL, _gloffset_ProgramEnvParameter4dvARB),
+    NAME_FUNC_OFFSET( 6826, glProgramEnvParameter4fARB, glProgramEnvParameter4fARB, NULL, _gloffset_ProgramEnvParameter4fARB),
+    NAME_FUNC_OFFSET( 6853, glProgramEnvParameter4fvARB, glProgramEnvParameter4fvARB, NULL, _gloffset_ProgramEnvParameter4fvARB),
+    NAME_FUNC_OFFSET( 6881, glProgramLocalParameter4dARB, glProgramLocalParameter4dARB, NULL, _gloffset_ProgramLocalParameter4dARB),
+    NAME_FUNC_OFFSET( 6910, glProgramLocalParameter4dvARB, glProgramLocalParameter4dvARB, NULL, _gloffset_ProgramLocalParameter4dvARB),
+    NAME_FUNC_OFFSET( 6940, glProgramLocalParameter4fARB, glProgramLocalParameter4fARB, NULL, _gloffset_ProgramLocalParameter4fARB),
+    NAME_FUNC_OFFSET( 6969, glProgramLocalParameter4fvARB, glProgramLocalParameter4fvARB, NULL, _gloffset_ProgramLocalParameter4fvARB),
+    NAME_FUNC_OFFSET( 6999, glProgramStringARB, glProgramStringARB, NULL, _gloffset_ProgramStringARB),
+    NAME_FUNC_OFFSET( 7018, glVertexAttrib1dARB, glVertexAttrib1dARB, NULL, _gloffset_VertexAttrib1dARB),
+    NAME_FUNC_OFFSET( 7038, glVertexAttrib1dvARB, glVertexAttrib1dvARB, NULL, _gloffset_VertexAttrib1dvARB),
+    NAME_FUNC_OFFSET( 7059, glVertexAttrib1fARB, glVertexAttrib1fARB, NULL, _gloffset_VertexAttrib1fARB),
+    NAME_FUNC_OFFSET( 7079, glVertexAttrib1fvARB, glVertexAttrib1fvARB, NULL, _gloffset_VertexAttrib1fvARB),
+    NAME_FUNC_OFFSET( 7100, glVertexAttrib1sARB, glVertexAttrib1sARB, NULL, _gloffset_VertexAttrib1sARB),
+    NAME_FUNC_OFFSET( 7120, glVertexAttrib1svARB, glVertexAttrib1svARB, NULL, _gloffset_VertexAttrib1svARB),
+    NAME_FUNC_OFFSET( 7141, glVertexAttrib2dARB, glVertexAttrib2dARB, NULL, _gloffset_VertexAttrib2dARB),
+    NAME_FUNC_OFFSET( 7161, glVertexAttrib2dvARB, glVertexAttrib2dvARB, NULL, _gloffset_VertexAttrib2dvARB),
+    NAME_FUNC_OFFSET( 7182, glVertexAttrib2fARB, glVertexAttrib2fARB, NULL, _gloffset_VertexAttrib2fARB),
+    NAME_FUNC_OFFSET( 7202, glVertexAttrib2fvARB, glVertexAttrib2fvARB, NULL, _gloffset_VertexAttrib2fvARB),
+    NAME_FUNC_OFFSET( 7223, glVertexAttrib2sARB, glVertexAttrib2sARB, NULL, _gloffset_VertexAttrib2sARB),
+    NAME_FUNC_OFFSET( 7243, glVertexAttrib2svARB, glVertexAttrib2svARB, NULL, _gloffset_VertexAttrib2svARB),
+    NAME_FUNC_OFFSET( 7264, glVertexAttrib3dARB, glVertexAttrib3dARB, NULL, _gloffset_VertexAttrib3dARB),
+    NAME_FUNC_OFFSET( 7284, glVertexAttrib3dvARB, glVertexAttrib3dvARB, NULL, _gloffset_VertexAttrib3dvARB),
+    NAME_FUNC_OFFSET( 7305, glVertexAttrib3fARB, glVertexAttrib3fARB, NULL, _gloffset_VertexAttrib3fARB),
+    NAME_FUNC_OFFSET( 7325, glVertexAttrib3fvARB, glVertexAttrib3fvARB, NULL, _gloffset_VertexAttrib3fvARB),
+    NAME_FUNC_OFFSET( 7346, glVertexAttrib3sARB, glVertexAttrib3sARB, NULL, _gloffset_VertexAttrib3sARB),
+    NAME_FUNC_OFFSET( 7366, glVertexAttrib3svARB, glVertexAttrib3svARB, NULL, _gloffset_VertexAttrib3svARB),
+    NAME_FUNC_OFFSET( 7387, glVertexAttrib4NbvARB, glVertexAttrib4NbvARB, NULL, _gloffset_VertexAttrib4NbvARB),
+    NAME_FUNC_OFFSET( 7409, glVertexAttrib4NivARB, glVertexAttrib4NivARB, NULL, _gloffset_VertexAttrib4NivARB),
+    NAME_FUNC_OFFSET( 7431, glVertexAttrib4NsvARB, glVertexAttrib4NsvARB, NULL, _gloffset_VertexAttrib4NsvARB),
+    NAME_FUNC_OFFSET( 7453, glVertexAttrib4NubARB, glVertexAttrib4NubARB, NULL, _gloffset_VertexAttrib4NubARB),
+    NAME_FUNC_OFFSET( 7475, glVertexAttrib4NubvARB, glVertexAttrib4NubvARB, NULL, _gloffset_VertexAttrib4NubvARB),
+    NAME_FUNC_OFFSET( 7498, glVertexAttrib4NuivARB, glVertexAttrib4NuivARB, NULL, _gloffset_VertexAttrib4NuivARB),
+    NAME_FUNC_OFFSET( 7521, glVertexAttrib4NusvARB, glVertexAttrib4NusvARB, NULL, _gloffset_VertexAttrib4NusvARB),
+    NAME_FUNC_OFFSET( 7544, glVertexAttrib4bvARB, glVertexAttrib4bvARB, NULL, _gloffset_VertexAttrib4bvARB),
+    NAME_FUNC_OFFSET( 7565, glVertexAttrib4dARB, glVertexAttrib4dARB, NULL, _gloffset_VertexAttrib4dARB),
+    NAME_FUNC_OFFSET( 7585, glVertexAttrib4dvARB, glVertexAttrib4dvARB, NULL, _gloffset_VertexAttrib4dvARB),
+    NAME_FUNC_OFFSET( 7606, glVertexAttrib4fARB, glVertexAttrib4fARB, NULL, _gloffset_VertexAttrib4fARB),
+    NAME_FUNC_OFFSET( 7626, glVertexAttrib4fvARB, glVertexAttrib4fvARB, NULL, _gloffset_VertexAttrib4fvARB),
+    NAME_FUNC_OFFSET( 7647, glVertexAttrib4ivARB, glVertexAttrib4ivARB, NULL, _gloffset_VertexAttrib4ivARB),
+    NAME_FUNC_OFFSET( 7668, glVertexAttrib4sARB, glVertexAttrib4sARB, NULL, _gloffset_VertexAttrib4sARB),
+    NAME_FUNC_OFFSET( 7688, glVertexAttrib4svARB, glVertexAttrib4svARB, NULL, _gloffset_VertexAttrib4svARB),
+    NAME_FUNC_OFFSET( 7709, glVertexAttrib4ubvARB, glVertexAttrib4ubvARB, NULL, _gloffset_VertexAttrib4ubvARB),
+    NAME_FUNC_OFFSET( 7731, glVertexAttrib4uivARB, glVertexAttrib4uivARB, NULL, _gloffset_VertexAttrib4uivARB),
+    NAME_FUNC_OFFSET( 7753, glVertexAttrib4usvARB, glVertexAttrib4usvARB, NULL, _gloffset_VertexAttrib4usvARB),
+    NAME_FUNC_OFFSET( 7775, glVertexAttribPointerARB, glVertexAttribPointerARB, NULL, _gloffset_VertexAttribPointerARB),
+    NAME_FUNC_OFFSET( 7800, glBindBufferARB, glBindBufferARB, NULL, _gloffset_BindBufferARB),
+    NAME_FUNC_OFFSET( 7816, glBufferDataARB, glBufferDataARB, NULL, _gloffset_BufferDataARB),
+    NAME_FUNC_OFFSET( 7832, glBufferSubDataARB, glBufferSubDataARB, NULL, _gloffset_BufferSubDataARB),
+    NAME_FUNC_OFFSET( 7851, glDeleteBuffersARB, glDeleteBuffersARB, NULL, _gloffset_DeleteBuffersARB),
+    NAME_FUNC_OFFSET( 7870, glGenBuffersARB, glGenBuffersARB, NULL, _gloffset_GenBuffersARB),
+    NAME_FUNC_OFFSET( 7886, glGetBufferParameterivARB, glGetBufferParameterivARB, NULL, _gloffset_GetBufferParameterivARB),
+    NAME_FUNC_OFFSET( 7912, glGetBufferPointervARB, glGetBufferPointervARB, NULL, _gloffset_GetBufferPointervARB),
+    NAME_FUNC_OFFSET( 7935, glGetBufferSubDataARB, glGetBufferSubDataARB, NULL, _gloffset_GetBufferSubDataARB),
+    NAME_FUNC_OFFSET( 7957, glIsBufferARB, glIsBufferARB, NULL, _gloffset_IsBufferARB),
+    NAME_FUNC_OFFSET( 7971, glMapBufferARB, glMapBufferARB, NULL, _gloffset_MapBufferARB),
+    NAME_FUNC_OFFSET( 7986, glUnmapBufferARB, glUnmapBufferARB, NULL, _gloffset_UnmapBufferARB),
+    NAME_FUNC_OFFSET( 8003, glBeginQueryARB, glBeginQueryARB, NULL, _gloffset_BeginQueryARB),
+    NAME_FUNC_OFFSET( 8019, glDeleteQueriesARB, glDeleteQueriesARB, NULL, _gloffset_DeleteQueriesARB),
+    NAME_FUNC_OFFSET( 8038, glEndQueryARB, glEndQueryARB, NULL, _gloffset_EndQueryARB),
+    NAME_FUNC_OFFSET( 8052, glGenQueriesARB, glGenQueriesARB, NULL, _gloffset_GenQueriesARB),
+    NAME_FUNC_OFFSET( 8068, glGetQueryObjectivARB, glGetQueryObjectivARB, NULL, _gloffset_GetQueryObjectivARB),
+    NAME_FUNC_OFFSET( 8090, glGetQueryObjectuivARB, glGetQueryObjectuivARB, NULL, _gloffset_GetQueryObjectuivARB),
+    NAME_FUNC_OFFSET( 8113, glGetQueryivARB, glGetQueryivARB, NULL, _gloffset_GetQueryivARB),
+    NAME_FUNC_OFFSET( 8129, glIsQueryARB, glIsQueryARB, NULL, _gloffset_IsQueryARB),
+    NAME_FUNC_OFFSET( 8142, glAttachObjectARB, glAttachObjectARB, NULL, _gloffset_AttachObjectARB),
+    NAME_FUNC_OFFSET( 8160, glCompileShaderARB, glCompileShaderARB, NULL, _gloffset_CompileShaderARB),
+    NAME_FUNC_OFFSET( 8179, glCreateProgramObjectARB, glCreateProgramObjectARB, NULL, _gloffset_CreateProgramObjectARB),
+    NAME_FUNC_OFFSET( 8204, glCreateShaderObjectARB, glCreateShaderObjectARB, NULL, _gloffset_CreateShaderObjectARB),
+    NAME_FUNC_OFFSET( 8228, glDeleteObjectARB, glDeleteObjectARB, NULL, _gloffset_DeleteObjectARB),
+    NAME_FUNC_OFFSET( 8246, glDetachObjectARB, glDetachObjectARB, NULL, _gloffset_DetachObjectARB),
+    NAME_FUNC_OFFSET( 8264, glGetActiveUniformARB, glGetActiveUniformARB, NULL, _gloffset_GetActiveUniformARB),
+    NAME_FUNC_OFFSET( 8286, glGetAttachedObjectsARB, glGetAttachedObjectsARB, NULL, _gloffset_GetAttachedObjectsARB),
+    NAME_FUNC_OFFSET( 8310, glGetHandleARB, glGetHandleARB, NULL, _gloffset_GetHandleARB),
+    NAME_FUNC_OFFSET( 8325, glGetInfoLogARB, glGetInfoLogARB, NULL, _gloffset_GetInfoLogARB),
+    NAME_FUNC_OFFSET( 8341, glGetObjectParameterfvARB, glGetObjectParameterfvARB, NULL, _gloffset_GetObjectParameterfvARB),
+    NAME_FUNC_OFFSET( 8367, glGetObjectParameterivARB, glGetObjectParameterivARB, NULL, _gloffset_GetObjectParameterivARB),
+    NAME_FUNC_OFFSET( 8393, glGetShaderSourceARB, glGetShaderSourceARB, NULL, _gloffset_GetShaderSourceARB),
+    NAME_FUNC_OFFSET( 8414, glGetUniformLocationARB, glGetUniformLocationARB, NULL, _gloffset_GetUniformLocationARB),
+    NAME_FUNC_OFFSET( 8438, glGetUniformfvARB, glGetUniformfvARB, NULL, _gloffset_GetUniformfvARB),
+    NAME_FUNC_OFFSET( 8456, glGetUniformivARB, glGetUniformivARB, NULL, _gloffset_GetUniformivARB),
+    NAME_FUNC_OFFSET( 8474, glLinkProgramARB, glLinkProgramARB, NULL, _gloffset_LinkProgramARB),
+    NAME_FUNC_OFFSET( 8491, glShaderSourceARB, glShaderSourceARB, NULL, _gloffset_ShaderSourceARB),
+    NAME_FUNC_OFFSET( 8509, glUniform1fARB, glUniform1fARB, NULL, _gloffset_Uniform1fARB),
+    NAME_FUNC_OFFSET( 8524, glUniform1fvARB, glUniform1fvARB, NULL, _gloffset_Uniform1fvARB),
+    NAME_FUNC_OFFSET( 8540, glUniform1iARB, glUniform1iARB, NULL, _gloffset_Uniform1iARB),
+    NAME_FUNC_OFFSET( 8555, glUniform1ivARB, glUniform1ivARB, NULL, _gloffset_Uniform1ivARB),
+    NAME_FUNC_OFFSET( 8571, glUniform2fARB, glUniform2fARB, NULL, _gloffset_Uniform2fARB),
+    NAME_FUNC_OFFSET( 8586, glUniform2fvARB, glUniform2fvARB, NULL, _gloffset_Uniform2fvARB),
+    NAME_FUNC_OFFSET( 8602, glUniform2iARB, glUniform2iARB, NULL, _gloffset_Uniform2iARB),
+    NAME_FUNC_OFFSET( 8617, glUniform2ivARB, glUniform2ivARB, NULL, _gloffset_Uniform2ivARB),
+    NAME_FUNC_OFFSET( 8633, glUniform3fARB, glUniform3fARB, NULL, _gloffset_Uniform3fARB),
+    NAME_FUNC_OFFSET( 8648, glUniform3fvARB, glUniform3fvARB, NULL, _gloffset_Uniform3fvARB),
+    NAME_FUNC_OFFSET( 8664, glUniform3iARB, glUniform3iARB, NULL, _gloffset_Uniform3iARB),
+    NAME_FUNC_OFFSET( 8679, glUniform3ivARB, glUniform3ivARB, NULL, _gloffset_Uniform3ivARB),
+    NAME_FUNC_OFFSET( 8695, glUniform4fARB, glUniform4fARB, NULL, _gloffset_Uniform4fARB),
+    NAME_FUNC_OFFSET( 8710, glUniform4fvARB, glUniform4fvARB, NULL, _gloffset_Uniform4fvARB),
+    NAME_FUNC_OFFSET( 8726, glUniform4iARB, glUniform4iARB, NULL, _gloffset_Uniform4iARB),
+    NAME_FUNC_OFFSET( 8741, glUniform4ivARB, glUniform4ivARB, NULL, _gloffset_Uniform4ivARB),
+    NAME_FUNC_OFFSET( 8757, glUniformMatrix2fvARB, glUniformMatrix2fvARB, NULL, _gloffset_UniformMatrix2fvARB),
+    NAME_FUNC_OFFSET( 8779, glUniformMatrix3fvARB, glUniformMatrix3fvARB, NULL, _gloffset_UniformMatrix3fvARB),
+    NAME_FUNC_OFFSET( 8801, glUniformMatrix4fvARB, glUniformMatrix4fvARB, NULL, _gloffset_UniformMatrix4fvARB),
+    NAME_FUNC_OFFSET( 8823, glUseProgramObjectARB, glUseProgramObjectARB, NULL, _gloffset_UseProgramObjectARB),
+    NAME_FUNC_OFFSET( 8845, glValidateProgramARB, glValidateProgramARB, NULL, _gloffset_ValidateProgramARB),
+    NAME_FUNC_OFFSET( 8866, glBindAttribLocationARB, glBindAttribLocationARB, NULL, _gloffset_BindAttribLocationARB),
+    NAME_FUNC_OFFSET( 8890, glGetActiveAttribARB, glGetActiveAttribARB, NULL, _gloffset_GetActiveAttribARB),
+    NAME_FUNC_OFFSET( 8911, glGetAttribLocationARB, glGetAttribLocationARB, NULL, _gloffset_GetAttribLocationARB),
+    NAME_FUNC_OFFSET( 8934, glDrawBuffersARB, glDrawBuffersARB, NULL, _gloffset_DrawBuffersARB),
+    NAME_FUNC_OFFSET( 8951, glPolygonOffsetEXT, glPolygonOffsetEXT, NULL, _gloffset_PolygonOffsetEXT),
+    NAME_FUNC_OFFSET( 8970, gl_dispatch_stub_562, gl_dispatch_stub_562, NULL, _gloffset_GetPixelTexGenParameterfvSGIS),
+    NAME_FUNC_OFFSET( 9002, gl_dispatch_stub_563, gl_dispatch_stub_563, NULL, _gloffset_GetPixelTexGenParameterivSGIS),
+    NAME_FUNC_OFFSET( 9034, gl_dispatch_stub_564, gl_dispatch_stub_564, NULL, _gloffset_PixelTexGenParameterfSGIS),
+    NAME_FUNC_OFFSET( 9062, gl_dispatch_stub_565, gl_dispatch_stub_565, NULL, _gloffset_PixelTexGenParameterfvSGIS),
+    NAME_FUNC_OFFSET( 9091, gl_dispatch_stub_566, gl_dispatch_stub_566, NULL, _gloffset_PixelTexGenParameteriSGIS),
+    NAME_FUNC_OFFSET( 9119, gl_dispatch_stub_567, gl_dispatch_stub_567, NULL, _gloffset_PixelTexGenParameterivSGIS),
+    NAME_FUNC_OFFSET( 9148, gl_dispatch_stub_568, gl_dispatch_stub_568, NULL, _gloffset_SampleMaskSGIS),
+    NAME_FUNC_OFFSET( 9165, gl_dispatch_stub_569, gl_dispatch_stub_569, NULL, _gloffset_SamplePatternSGIS),
+    NAME_FUNC_OFFSET( 9185, glColorPointerEXT, glColorPointerEXT, NULL, _gloffset_ColorPointerEXT),
+    NAME_FUNC_OFFSET( 9203, glEdgeFlagPointerEXT, glEdgeFlagPointerEXT, NULL, _gloffset_EdgeFlagPointerEXT),
+    NAME_FUNC_OFFSET( 9224, glIndexPointerEXT, glIndexPointerEXT, NULL, _gloffset_IndexPointerEXT),
+    NAME_FUNC_OFFSET( 9242, glNormalPointerEXT, glNormalPointerEXT, NULL, _gloffset_NormalPointerEXT),
+    NAME_FUNC_OFFSET( 9261, glTexCoordPointerEXT, glTexCoordPointerEXT, NULL, _gloffset_TexCoordPointerEXT),
+    NAME_FUNC_OFFSET( 9282, glVertexPointerEXT, glVertexPointerEXT, NULL, _gloffset_VertexPointerEXT),
+    NAME_FUNC_OFFSET( 9301, glPointParameterfEXT, glPointParameterfEXT, NULL, _gloffset_PointParameterfEXT),
+    NAME_FUNC_OFFSET( 9322, glPointParameterfvEXT, glPointParameterfvEXT, NULL, _gloffset_PointParameterfvEXT),
+    NAME_FUNC_OFFSET( 9344, glLockArraysEXT, glLockArraysEXT, NULL, _gloffset_LockArraysEXT),
+    NAME_FUNC_OFFSET( 9360, glUnlockArraysEXT, glUnlockArraysEXT, NULL, _gloffset_UnlockArraysEXT),
+    NAME_FUNC_OFFSET( 9378, gl_dispatch_stub_580, gl_dispatch_stub_580, NULL, _gloffset_CullParameterdvEXT),
+    NAME_FUNC_OFFSET( 9399, gl_dispatch_stub_581, gl_dispatch_stub_581, NULL, _gloffset_CullParameterfvEXT),
+    NAME_FUNC_OFFSET( 9420, glSecondaryColor3bEXT, glSecondaryColor3bEXT, NULL, _gloffset_SecondaryColor3bEXT),
+    NAME_FUNC_OFFSET( 9442, glSecondaryColor3bvEXT, glSecondaryColor3bvEXT, NULL, _gloffset_SecondaryColor3bvEXT),
+    NAME_FUNC_OFFSET( 9465, glSecondaryColor3dEXT, glSecondaryColor3dEXT, NULL, _gloffset_SecondaryColor3dEXT),
+    NAME_FUNC_OFFSET( 9487, glSecondaryColor3dvEXT, glSecondaryColor3dvEXT, NULL, _gloffset_SecondaryColor3dvEXT),
+    NAME_FUNC_OFFSET( 9510, glSecondaryColor3fEXT, glSecondaryColor3fEXT, NULL, _gloffset_SecondaryColor3fEXT),
+    NAME_FUNC_OFFSET( 9532, glSecondaryColor3fvEXT, glSecondaryColor3fvEXT, NULL, _gloffset_SecondaryColor3fvEXT),
+    NAME_FUNC_OFFSET( 9555, glSecondaryColor3iEXT, glSecondaryColor3iEXT, NULL, _gloffset_SecondaryColor3iEXT),
+    NAME_FUNC_OFFSET( 9577, glSecondaryColor3ivEXT, glSecondaryColor3ivEXT, NULL, _gloffset_SecondaryColor3ivEXT),
+    NAME_FUNC_OFFSET( 9600, glSecondaryColor3sEXT, glSecondaryColor3sEXT, NULL, _gloffset_SecondaryColor3sEXT),
+    NAME_FUNC_OFFSET( 9622, glSecondaryColor3svEXT, glSecondaryColor3svEXT, NULL, _gloffset_SecondaryColor3svEXT),
+    NAME_FUNC_OFFSET( 9645, glSecondaryColor3ubEXT, glSecondaryColor3ubEXT, NULL, _gloffset_SecondaryColor3ubEXT),
+    NAME_FUNC_OFFSET( 9668, glSecondaryColor3ubvEXT, glSecondaryColor3ubvEXT, NULL, _gloffset_SecondaryColor3ubvEXT),
+    NAME_FUNC_OFFSET( 9692, glSecondaryColor3uiEXT, glSecondaryColor3uiEXT, NULL, _gloffset_SecondaryColor3uiEXT),
+    NAME_FUNC_OFFSET( 9715, glSecondaryColor3uivEXT, glSecondaryColor3uivEXT, NULL, _gloffset_SecondaryColor3uivEXT),
+    NAME_FUNC_OFFSET( 9739, glSecondaryColor3usEXT, glSecondaryColor3usEXT, NULL, _gloffset_SecondaryColor3usEXT),
+    NAME_FUNC_OFFSET( 9762, glSecondaryColor3usvEXT, glSecondaryColor3usvEXT, NULL, _gloffset_SecondaryColor3usvEXT),
+    NAME_FUNC_OFFSET( 9786, glSecondaryColorPointerEXT, glSecondaryColorPointerEXT, NULL, _gloffset_SecondaryColorPointerEXT),
+    NAME_FUNC_OFFSET( 9813, glMultiDrawArraysEXT, glMultiDrawArraysEXT, NULL, _gloffset_MultiDrawArraysEXT),
+    NAME_FUNC_OFFSET( 9834, glMultiDrawElementsEXT, glMultiDrawElementsEXT, NULL, _gloffset_MultiDrawElementsEXT),
+    NAME_FUNC_OFFSET( 9857, glFogCoordPointerEXT, glFogCoordPointerEXT, NULL, _gloffset_FogCoordPointerEXT),
+    NAME_FUNC_OFFSET( 9878, glFogCoorddEXT, glFogCoorddEXT, NULL, _gloffset_FogCoorddEXT),
+    NAME_FUNC_OFFSET( 9893, glFogCoorddvEXT, glFogCoorddvEXT, NULL, _gloffset_FogCoorddvEXT),
+    NAME_FUNC_OFFSET( 9909, glFogCoordfEXT, glFogCoordfEXT, NULL, _gloffset_FogCoordfEXT),
+    NAME_FUNC_OFFSET( 9924, glFogCoordfvEXT, glFogCoordfvEXT, NULL, _gloffset_FogCoordfvEXT),
+    NAME_FUNC_OFFSET( 9940, gl_dispatch_stub_606, gl_dispatch_stub_606, NULL, _gloffset_PixelTexGenSGIX),
+    NAME_FUNC_OFFSET( 9958, glBlendFuncSeparateEXT, glBlendFuncSeparateEXT, NULL, _gloffset_BlendFuncSeparateEXT),
+    NAME_FUNC_OFFSET( 9981, glFlushVertexArrayRangeNV, glFlushVertexArrayRangeNV, NULL, _gloffset_FlushVertexArrayRangeNV),
+    NAME_FUNC_OFFSET(10007, glVertexArrayRangeNV, glVertexArrayRangeNV, NULL, _gloffset_VertexArrayRangeNV),
+    NAME_FUNC_OFFSET(10028, glCombinerInputNV, glCombinerInputNV, NULL, _gloffset_CombinerInputNV),
+    NAME_FUNC_OFFSET(10046, glCombinerOutputNV, glCombinerOutputNV, NULL, _gloffset_CombinerOutputNV),
+    NAME_FUNC_OFFSET(10065, glCombinerParameterfNV, glCombinerParameterfNV, NULL, _gloffset_CombinerParameterfNV),
+    NAME_FUNC_OFFSET(10088, glCombinerParameterfvNV, glCombinerParameterfvNV, NULL, _gloffset_CombinerParameterfvNV),
+    NAME_FUNC_OFFSET(10112, glCombinerParameteriNV, glCombinerParameteriNV, NULL, _gloffset_CombinerParameteriNV),
+    NAME_FUNC_OFFSET(10135, glCombinerParameterivNV, glCombinerParameterivNV, NULL, _gloffset_CombinerParameterivNV),
+    NAME_FUNC_OFFSET(10159, glFinalCombinerInputNV, glFinalCombinerInputNV, NULL, _gloffset_FinalCombinerInputNV),
+    NAME_FUNC_OFFSET(10182, glGetCombinerInputParameterfvNV, glGetCombinerInputParameterfvNV, NULL, _gloffset_GetCombinerInputParameterfvNV),
+    NAME_FUNC_OFFSET(10214, glGetCombinerInputParameterivNV, glGetCombinerInputParameterivNV, NULL, _gloffset_GetCombinerInputParameterivNV),
+    NAME_FUNC_OFFSET(10246, glGetCombinerOutputParameterfvNV, glGetCombinerOutputParameterfvNV, NULL, _gloffset_GetCombinerOutputParameterfvNV),
+    NAME_FUNC_OFFSET(10279, glGetCombinerOutputParameterivNV, glGetCombinerOutputParameterivNV, NULL, _gloffset_GetCombinerOutputParameterivNV),
+    NAME_FUNC_OFFSET(10312, glGetFinalCombinerInputParameterfvNV, glGetFinalCombinerInputParameterfvNV, NULL, _gloffset_GetFinalCombinerInputParameterfvNV),
+    NAME_FUNC_OFFSET(10349, glGetFinalCombinerInputParameterivNV, glGetFinalCombinerInputParameterivNV, NULL, _gloffset_GetFinalCombinerInputParameterivNV),
+    NAME_FUNC_OFFSET(10386, glResizeBuffersMESA, glResizeBuffersMESA, NULL, _gloffset_ResizeBuffersMESA),
+    NAME_FUNC_OFFSET(10406, glWindowPos2dMESA, glWindowPos2dMESA, NULL, _gloffset_WindowPos2dMESA),
+    NAME_FUNC_OFFSET(10424, glWindowPos2dvMESA, glWindowPos2dvMESA, NULL, _gloffset_WindowPos2dvMESA),
+    NAME_FUNC_OFFSET(10443, glWindowPos2fMESA, glWindowPos2fMESA, NULL, _gloffset_WindowPos2fMESA),
+    NAME_FUNC_OFFSET(10461, glWindowPos2fvMESA, glWindowPos2fvMESA, NULL, _gloffset_WindowPos2fvMESA),
+    NAME_FUNC_OFFSET(10480, glWindowPos2iMESA, glWindowPos2iMESA, NULL, _gloffset_WindowPos2iMESA),
+    NAME_FUNC_OFFSET(10498, glWindowPos2ivMESA, glWindowPos2ivMESA, NULL, _gloffset_WindowPos2ivMESA),
+    NAME_FUNC_OFFSET(10517, glWindowPos2sMESA, glWindowPos2sMESA, NULL, _gloffset_WindowPos2sMESA),
+    NAME_FUNC_OFFSET(10535, glWindowPos2svMESA, glWindowPos2svMESA, NULL, _gloffset_WindowPos2svMESA),
+    NAME_FUNC_OFFSET(10554, glWindowPos3dMESA, glWindowPos3dMESA, NULL, _gloffset_WindowPos3dMESA),
+    NAME_FUNC_OFFSET(10572, glWindowPos3dvMESA, glWindowPos3dvMESA, NULL, _gloffset_WindowPos3dvMESA),
+    NAME_FUNC_OFFSET(10591, glWindowPos3fMESA, glWindowPos3fMESA, NULL, _gloffset_WindowPos3fMESA),
+    NAME_FUNC_OFFSET(10609, glWindowPos3fvMESA, glWindowPos3fvMESA, NULL, _gloffset_WindowPos3fvMESA),
+    NAME_FUNC_OFFSET(10628, glWindowPos3iMESA, glWindowPos3iMESA, NULL, _gloffset_WindowPos3iMESA),
+    NAME_FUNC_OFFSET(10646, glWindowPos3ivMESA, glWindowPos3ivMESA, NULL, _gloffset_WindowPos3ivMESA),
+    NAME_FUNC_OFFSET(10665, glWindowPos3sMESA, glWindowPos3sMESA, NULL, _gloffset_WindowPos3sMESA),
+    NAME_FUNC_OFFSET(10683, glWindowPos3svMESA, glWindowPos3svMESA, NULL, _gloffset_WindowPos3svMESA),
+    NAME_FUNC_OFFSET(10702, glWindowPos4dMESA, glWindowPos4dMESA, NULL, _gloffset_WindowPos4dMESA),
+    NAME_FUNC_OFFSET(10720, glWindowPos4dvMESA, glWindowPos4dvMESA, NULL, _gloffset_WindowPos4dvMESA),
+    NAME_FUNC_OFFSET(10739, glWindowPos4fMESA, glWindowPos4fMESA, NULL, _gloffset_WindowPos4fMESA),
+    NAME_FUNC_OFFSET(10757, glWindowPos4fvMESA, glWindowPos4fvMESA, NULL, _gloffset_WindowPos4fvMESA),
+    NAME_FUNC_OFFSET(10776, glWindowPos4iMESA, glWindowPos4iMESA, NULL, _gloffset_WindowPos4iMESA),
+    NAME_FUNC_OFFSET(10794, glWindowPos4ivMESA, glWindowPos4ivMESA, NULL, _gloffset_WindowPos4ivMESA),
+    NAME_FUNC_OFFSET(10813, glWindowPos4sMESA, glWindowPos4sMESA, NULL, _gloffset_WindowPos4sMESA),
+    NAME_FUNC_OFFSET(10831, glWindowPos4svMESA, glWindowPos4svMESA, NULL, _gloffset_WindowPos4svMESA),
+    NAME_FUNC_OFFSET(10850, gl_dispatch_stub_648, gl_dispatch_stub_648, NULL, _gloffset_MultiModeDrawArraysIBM),
+    NAME_FUNC_OFFSET(10875, gl_dispatch_stub_649, gl_dispatch_stub_649, NULL, _gloffset_MultiModeDrawElementsIBM),
+    NAME_FUNC_OFFSET(10902, gl_dispatch_stub_650, gl_dispatch_stub_650, NULL, _gloffset_DeleteFencesNV),
+    NAME_FUNC_OFFSET(10919, gl_dispatch_stub_651, gl_dispatch_stub_651, NULL, _gloffset_FinishFenceNV),
+    NAME_FUNC_OFFSET(10935, gl_dispatch_stub_652, gl_dispatch_stub_652, NULL, _gloffset_GenFencesNV),
+    NAME_FUNC_OFFSET(10949, gl_dispatch_stub_653, gl_dispatch_stub_653, NULL, _gloffset_GetFenceivNV),
+    NAME_FUNC_OFFSET(10964, gl_dispatch_stub_654, gl_dispatch_stub_654, NULL, _gloffset_IsFenceNV),
+    NAME_FUNC_OFFSET(10976, gl_dispatch_stub_655, gl_dispatch_stub_655, NULL, _gloffset_SetFenceNV),
+    NAME_FUNC_OFFSET(10989, gl_dispatch_stub_656, gl_dispatch_stub_656, NULL, _gloffset_TestFenceNV),
+    NAME_FUNC_OFFSET(11003, glAreProgramsResidentNV, glAreProgramsResidentNV, NULL, _gloffset_AreProgramsResidentNV),
+    NAME_FUNC_OFFSET(11027, glBindProgramNV, glBindProgramNV, NULL, _gloffset_BindProgramNV),
+    NAME_FUNC_OFFSET(11043, glDeleteProgramsNV, glDeleteProgramsNV, NULL, _gloffset_DeleteProgramsNV),
+    NAME_FUNC_OFFSET(11062, glExecuteProgramNV, glExecuteProgramNV, NULL, _gloffset_ExecuteProgramNV),
+    NAME_FUNC_OFFSET(11081, glGenProgramsNV, glGenProgramsNV, NULL, _gloffset_GenProgramsNV),
+    NAME_FUNC_OFFSET(11097, glGetProgramParameterdvNV, glGetProgramParameterdvNV, NULL, _gloffset_GetProgramParameterdvNV),
+    NAME_FUNC_OFFSET(11123, glGetProgramParameterfvNV, glGetProgramParameterfvNV, NULL, _gloffset_GetProgramParameterfvNV),
+    NAME_FUNC_OFFSET(11149, glGetProgramStringNV, glGetProgramStringNV, NULL, _gloffset_GetProgramStringNV),
+    NAME_FUNC_OFFSET(11170, glGetProgramivNV, glGetProgramivNV, NULL, _gloffset_GetProgramivNV),
+    NAME_FUNC_OFFSET(11187, glGetTrackMatrixivNV, glGetTrackMatrixivNV, NULL, _gloffset_GetTrackMatrixivNV),
+    NAME_FUNC_OFFSET(11208, glGetVertexAttribPointervNV, glGetVertexAttribPointervNV, NULL, _gloffset_GetVertexAttribPointervNV),
+    NAME_FUNC_OFFSET(11236, glGetVertexAttribdvNV, glGetVertexAttribdvNV, NULL, _gloffset_GetVertexAttribdvNV),
+    NAME_FUNC_OFFSET(11258, glGetVertexAttribfvNV, glGetVertexAttribfvNV, NULL, _gloffset_GetVertexAttribfvNV),
+    NAME_FUNC_OFFSET(11280, glGetVertexAttribivNV, glGetVertexAttribivNV, NULL, _gloffset_GetVertexAttribivNV),
+    NAME_FUNC_OFFSET(11302, glIsProgramNV, glIsProgramNV, NULL, _gloffset_IsProgramNV),
+    NAME_FUNC_OFFSET(11316, glLoadProgramNV, glLoadProgramNV, NULL, _gloffset_LoadProgramNV),
+    NAME_FUNC_OFFSET(11332, glProgramParameters4dvNV, glProgramParameters4dvNV, NULL, _gloffset_ProgramParameters4dvNV),
+    NAME_FUNC_OFFSET(11357, glProgramParameters4fvNV, glProgramParameters4fvNV, NULL, _gloffset_ProgramParameters4fvNV),
+    NAME_FUNC_OFFSET(11382, glRequestResidentProgramsNV, glRequestResidentProgramsNV, NULL, _gloffset_RequestResidentProgramsNV),
+    NAME_FUNC_OFFSET(11410, glTrackMatrixNV, glTrackMatrixNV, NULL, _gloffset_TrackMatrixNV),
+    NAME_FUNC_OFFSET(11426, glVertexAttrib1dNV, glVertexAttrib1dNV, NULL, _gloffset_VertexAttrib1dNV),
+    NAME_FUNC_OFFSET(11445, glVertexAttrib1dvNV, glVertexAttrib1dvNV, NULL, _gloffset_VertexAttrib1dvNV),
+    NAME_FUNC_OFFSET(11465, glVertexAttrib1fNV, glVertexAttrib1fNV, NULL, _gloffset_VertexAttrib1fNV),
+    NAME_FUNC_OFFSET(11484, glVertexAttrib1fvNV, glVertexAttrib1fvNV, NULL, _gloffset_VertexAttrib1fvNV),
+    NAME_FUNC_OFFSET(11504, glVertexAttrib1sNV, glVertexAttrib1sNV, NULL, _gloffset_VertexAttrib1sNV),
+    NAME_FUNC_OFFSET(11523, glVertexAttrib1svNV, glVertexAttrib1svNV, NULL, _gloffset_VertexAttrib1svNV),
+    NAME_FUNC_OFFSET(11543, glVertexAttrib2dNV, glVertexAttrib2dNV, NULL, _gloffset_VertexAttrib2dNV),
+    NAME_FUNC_OFFSET(11562, glVertexAttrib2dvNV, glVertexAttrib2dvNV, NULL, _gloffset_VertexAttrib2dvNV),
+    NAME_FUNC_OFFSET(11582, glVertexAttrib2fNV, glVertexAttrib2fNV, NULL, _gloffset_VertexAttrib2fNV),
+    NAME_FUNC_OFFSET(11601, glVertexAttrib2fvNV, glVertexAttrib2fvNV, NULL, _gloffset_VertexAttrib2fvNV),
+    NAME_FUNC_OFFSET(11621, glVertexAttrib2sNV, glVertexAttrib2sNV, NULL, _gloffset_VertexAttrib2sNV),
+    NAME_FUNC_OFFSET(11640, glVertexAttrib2svNV, glVertexAttrib2svNV, NULL, _gloffset_VertexAttrib2svNV),
+    NAME_FUNC_OFFSET(11660, glVertexAttrib3dNV, glVertexAttrib3dNV, NULL, _gloffset_VertexAttrib3dNV),
+    NAME_FUNC_OFFSET(11679, glVertexAttrib3dvNV, glVertexAttrib3dvNV, NULL, _gloffset_VertexAttrib3dvNV),
+    NAME_FUNC_OFFSET(11699, glVertexAttrib3fNV, glVertexAttrib3fNV, NULL, _gloffset_VertexAttrib3fNV),
+    NAME_FUNC_OFFSET(11718, glVertexAttrib3fvNV, glVertexAttrib3fvNV, NULL, _gloffset_VertexAttrib3fvNV),
+    NAME_FUNC_OFFSET(11738, glVertexAttrib3sNV, glVertexAttrib3sNV, NULL, _gloffset_VertexAttrib3sNV),
+    NAME_FUNC_OFFSET(11757, glVertexAttrib3svNV, glVertexAttrib3svNV, NULL, _gloffset_VertexAttrib3svNV),
+    NAME_FUNC_OFFSET(11777, glVertexAttrib4dNV, glVertexAttrib4dNV, NULL, _gloffset_VertexAttrib4dNV),
+    NAME_FUNC_OFFSET(11796, glVertexAttrib4dvNV, glVertexAttrib4dvNV, NULL, _gloffset_VertexAttrib4dvNV),
+    NAME_FUNC_OFFSET(11816, glVertexAttrib4fNV, glVertexAttrib4fNV, NULL, _gloffset_VertexAttrib4fNV),
+    NAME_FUNC_OFFSET(11835, glVertexAttrib4fvNV, glVertexAttrib4fvNV, NULL, _gloffset_VertexAttrib4fvNV),
+    NAME_FUNC_OFFSET(11855, glVertexAttrib4sNV, glVertexAttrib4sNV, NULL, _gloffset_VertexAttrib4sNV),
+    NAME_FUNC_OFFSET(11874, glVertexAttrib4svNV, glVertexAttrib4svNV, NULL, _gloffset_VertexAttrib4svNV),
+    NAME_FUNC_OFFSET(11894, glVertexAttrib4ubNV, glVertexAttrib4ubNV, NULL, _gloffset_VertexAttrib4ubNV),
+    NAME_FUNC_OFFSET(11914, glVertexAttrib4ubvNV, glVertexAttrib4ubvNV, NULL, _gloffset_VertexAttrib4ubvNV),
+    NAME_FUNC_OFFSET(11935, glVertexAttribPointerNV, glVertexAttribPointerNV, NULL, _gloffset_VertexAttribPointerNV),
+    NAME_FUNC_OFFSET(11959, glVertexAttribs1dvNV, glVertexAttribs1dvNV, NULL, _gloffset_VertexAttribs1dvNV),
+    NAME_FUNC_OFFSET(11980, glVertexAttribs1fvNV, glVertexAttribs1fvNV, NULL, _gloffset_VertexAttribs1fvNV),
+    NAME_FUNC_OFFSET(12001, glVertexAttribs1svNV, glVertexAttribs1svNV, NULL, _gloffset_VertexAttribs1svNV),
+    NAME_FUNC_OFFSET(12022, glVertexAttribs2dvNV, glVertexAttribs2dvNV, NULL, _gloffset_VertexAttribs2dvNV),
+    NAME_FUNC_OFFSET(12043, glVertexAttribs2fvNV, glVertexAttribs2fvNV, NULL, _gloffset_VertexAttribs2fvNV),
+    NAME_FUNC_OFFSET(12064, glVertexAttribs2svNV, glVertexAttribs2svNV, NULL, _gloffset_VertexAttribs2svNV),
+    NAME_FUNC_OFFSET(12085, glVertexAttribs3dvNV, glVertexAttribs3dvNV, NULL, _gloffset_VertexAttribs3dvNV),
+    NAME_FUNC_OFFSET(12106, glVertexAttribs3fvNV, glVertexAttribs3fvNV, NULL, _gloffset_VertexAttribs3fvNV),
+    NAME_FUNC_OFFSET(12127, glVertexAttribs3svNV, glVertexAttribs3svNV, NULL, _gloffset_VertexAttribs3svNV),
+    NAME_FUNC_OFFSET(12148, glVertexAttribs4dvNV, glVertexAttribs4dvNV, NULL, _gloffset_VertexAttribs4dvNV),
+    NAME_FUNC_OFFSET(12169, glVertexAttribs4fvNV, glVertexAttribs4fvNV, NULL, _gloffset_VertexAttribs4fvNV),
+    NAME_FUNC_OFFSET(12190, glVertexAttribs4svNV, glVertexAttribs4svNV, NULL, _gloffset_VertexAttribs4svNV),
+    NAME_FUNC_OFFSET(12211, glVertexAttribs4ubvNV, glVertexAttribs4ubvNV, NULL, _gloffset_VertexAttribs4ubvNV),
+    NAME_FUNC_OFFSET(12233, glAlphaFragmentOp1ATI, glAlphaFragmentOp1ATI, NULL, _gloffset_AlphaFragmentOp1ATI),
+    NAME_FUNC_OFFSET(12255, glAlphaFragmentOp2ATI, glAlphaFragmentOp2ATI, NULL, _gloffset_AlphaFragmentOp2ATI),
+    NAME_FUNC_OFFSET(12277, glAlphaFragmentOp3ATI, glAlphaFragmentOp3ATI, NULL, _gloffset_AlphaFragmentOp3ATI),
+    NAME_FUNC_OFFSET(12299, glBeginFragmentShaderATI, glBeginFragmentShaderATI, NULL, _gloffset_BeginFragmentShaderATI),
+    NAME_FUNC_OFFSET(12324, glBindFragmentShaderATI, glBindFragmentShaderATI, NULL, _gloffset_BindFragmentShaderATI),
+    NAME_FUNC_OFFSET(12348, glColorFragmentOp1ATI, glColorFragmentOp1ATI, NULL, _gloffset_ColorFragmentOp1ATI),
+    NAME_FUNC_OFFSET(12370, glColorFragmentOp2ATI, glColorFragmentOp2ATI, NULL, _gloffset_ColorFragmentOp2ATI),
+    NAME_FUNC_OFFSET(12392, glColorFragmentOp3ATI, glColorFragmentOp3ATI, NULL, _gloffset_ColorFragmentOp3ATI),
+    NAME_FUNC_OFFSET(12414, glDeleteFragmentShaderATI, glDeleteFragmentShaderATI, NULL, _gloffset_DeleteFragmentShaderATI),
+    NAME_FUNC_OFFSET(12440, glEndFragmentShaderATI, glEndFragmentShaderATI, NULL, _gloffset_EndFragmentShaderATI),
+    NAME_FUNC_OFFSET(12463, glGenFragmentShadersATI, glGenFragmentShadersATI, NULL, _gloffset_GenFragmentShadersATI),
+    NAME_FUNC_OFFSET(12487, glPassTexCoordATI, glPassTexCoordATI, NULL, _gloffset_PassTexCoordATI),
+    NAME_FUNC_OFFSET(12505, glSampleMapATI, glSampleMapATI, NULL, _gloffset_SampleMapATI),
+    NAME_FUNC_OFFSET(12520, glSetFragmentShaderConstantATI, glSetFragmentShaderConstantATI, NULL, _gloffset_SetFragmentShaderConstantATI),
+    NAME_FUNC_OFFSET(12551, glPointParameteriNV, glPointParameteriNV, NULL, _gloffset_PointParameteriNV),
+    NAME_FUNC_OFFSET(12571, glPointParameterivNV, glPointParameterivNV, NULL, _gloffset_PointParameterivNV),
+    NAME_FUNC_OFFSET(12592, gl_dispatch_stub_733, gl_dispatch_stub_733, NULL, _gloffset_ActiveStencilFaceEXT),
+    NAME_FUNC_OFFSET(12615, gl_dispatch_stub_734, gl_dispatch_stub_734, NULL, _gloffset_BindVertexArrayAPPLE),
+    NAME_FUNC_OFFSET(12638, gl_dispatch_stub_735, gl_dispatch_stub_735, NULL, _gloffset_DeleteVertexArraysAPPLE),
+    NAME_FUNC_OFFSET(12664, gl_dispatch_stub_736, gl_dispatch_stub_736, NULL, _gloffset_GenVertexArraysAPPLE),
+    NAME_FUNC_OFFSET(12687, gl_dispatch_stub_737, gl_dispatch_stub_737, NULL, _gloffset_IsVertexArrayAPPLE),
+    NAME_FUNC_OFFSET(12708, glGetProgramNamedParameterdvNV, glGetProgramNamedParameterdvNV, NULL, _gloffset_GetProgramNamedParameterdvNV),
+    NAME_FUNC_OFFSET(12739, glGetProgramNamedParameterfvNV, glGetProgramNamedParameterfvNV, NULL, _gloffset_GetProgramNamedParameterfvNV),
+    NAME_FUNC_OFFSET(12770, glProgramNamedParameter4dNV, glProgramNamedParameter4dNV, NULL, _gloffset_ProgramNamedParameter4dNV),
+    NAME_FUNC_OFFSET(12798, glProgramNamedParameter4dvNV, glProgramNamedParameter4dvNV, NULL, _gloffset_ProgramNamedParameter4dvNV),
+    NAME_FUNC_OFFSET(12827, glProgramNamedParameter4fNV, glProgramNamedParameter4fNV, NULL, _gloffset_ProgramNamedParameter4fNV),
+    NAME_FUNC_OFFSET(12855, glProgramNamedParameter4fvNV, glProgramNamedParameter4fvNV, NULL, _gloffset_ProgramNamedParameter4fvNV),
+    NAME_FUNC_OFFSET(12884, gl_dispatch_stub_744, gl_dispatch_stub_744, NULL, _gloffset_DepthBoundsEXT),
+    NAME_FUNC_OFFSET(12901, gl_dispatch_stub_745, gl_dispatch_stub_745, NULL, _gloffset_BlendEquationSeparateEXT),
+    NAME_FUNC_OFFSET(12928, glBindFramebufferEXT, glBindFramebufferEXT, NULL, _gloffset_BindFramebufferEXT),
+    NAME_FUNC_OFFSET(12949, glBindRenderbufferEXT, glBindRenderbufferEXT, NULL, _gloffset_BindRenderbufferEXT),
+    NAME_FUNC_OFFSET(12971, glCheckFramebufferStatusEXT, glCheckFramebufferStatusEXT, NULL, _gloffset_CheckFramebufferStatusEXT),
+    NAME_FUNC_OFFSET(12999, glDeleteFramebuffersEXT, glDeleteFramebuffersEXT, NULL, _gloffset_DeleteFramebuffersEXT),
+    NAME_FUNC_OFFSET(13023, glDeleteRenderbuffersEXT, glDeleteRenderbuffersEXT, NULL, _gloffset_DeleteRenderbuffersEXT),
+    NAME_FUNC_OFFSET(13048, glFramebufferRenderbufferEXT, glFramebufferRenderbufferEXT, NULL, _gloffset_FramebufferRenderbufferEXT),
+    NAME_FUNC_OFFSET(13077, glFramebufferTexture1DEXT, glFramebufferTexture1DEXT, NULL, _gloffset_FramebufferTexture1DEXT),
+    NAME_FUNC_OFFSET(13103, glFramebufferTexture2DEXT, glFramebufferTexture2DEXT, NULL, _gloffset_FramebufferTexture2DEXT),
+    NAME_FUNC_OFFSET(13129, glFramebufferTexture3DEXT, glFramebufferTexture3DEXT, NULL, _gloffset_FramebufferTexture3DEXT),
+    NAME_FUNC_OFFSET(13155, glGenFramebuffersEXT, glGenFramebuffersEXT, NULL, _gloffset_GenFramebuffersEXT),
+    NAME_FUNC_OFFSET(13176, glGenRenderbuffersEXT, glGenRenderbuffersEXT, NULL, _gloffset_GenRenderbuffersEXT),
+    NAME_FUNC_OFFSET(13198, glGenerateMipmapEXT, glGenerateMipmapEXT, NULL, _gloffset_GenerateMipmapEXT),
+    NAME_FUNC_OFFSET(13218, glGetFramebufferAttachmentParameterivEXT, glGetFramebufferAttachmentParameterivEXT, NULL, _gloffset_GetFramebufferAttachmentParameterivEXT),
+    NAME_FUNC_OFFSET(13259, glGetRenderbufferParameterivEXT, glGetRenderbufferParameterivEXT, NULL, _gloffset_GetRenderbufferParameterivEXT),
+    NAME_FUNC_OFFSET(13291, glIsFramebufferEXT, glIsFramebufferEXT, NULL, _gloffset_IsFramebufferEXT),
+    NAME_FUNC_OFFSET(13310, glIsRenderbufferEXT, glIsRenderbufferEXT, NULL, _gloffset_IsRenderbufferEXT),
+    NAME_FUNC_OFFSET(13330, glRenderbufferStorageEXT, glRenderbufferStorageEXT, NULL, _gloffset_RenderbufferStorageEXT),
+    NAME_FUNC_OFFSET(13355, gl_dispatch_stub_763, gl_dispatch_stub_763, NULL, _gloffset_BlitFramebufferEXT),
+    NAME_FUNC_OFFSET(13376, glFramebufferTextureLayerEXT, glFramebufferTextureLayerEXT, NULL, _gloffset_FramebufferTextureLayerEXT),
+    NAME_FUNC_OFFSET(13405, gl_dispatch_stub_765, gl_dispatch_stub_765, NULL, _gloffset_StencilFuncSeparateATI),
+    NAME_FUNC_OFFSET(13430, gl_dispatch_stub_766, gl_dispatch_stub_766, NULL, _gloffset_ProgramEnvParameters4fvEXT),
+    NAME_FUNC_OFFSET(13459, gl_dispatch_stub_767, gl_dispatch_stub_767, NULL, _gloffset_ProgramLocalParameters4fvEXT),
+    NAME_FUNC_OFFSET(13490, gl_dispatch_stub_768, gl_dispatch_stub_768, NULL, _gloffset_GetQueryObjecti64vEXT),
+    NAME_FUNC_OFFSET(13514, gl_dispatch_stub_769, gl_dispatch_stub_769, NULL, _gloffset_GetQueryObjectui64vEXT),
+    NAME_FUNC_OFFSET(13539, glArrayElement, glArrayElement, NULL, _gloffset_ArrayElement),
+    NAME_FUNC_OFFSET(13557, glBindTexture, glBindTexture, NULL, _gloffset_BindTexture),
+    NAME_FUNC_OFFSET(13574, glDrawArrays, glDrawArrays, NULL, _gloffset_DrawArrays),
+    NAME_FUNC_OFFSET(13590, glAreTexturesResident, glAreTexturesResidentEXT, glAreTexturesResidentEXT, _gloffset_AreTexturesResident),
+    NAME_FUNC_OFFSET(13615, glCopyTexImage1D, glCopyTexImage1D, NULL, _gloffset_CopyTexImage1D),
+    NAME_FUNC_OFFSET(13635, glCopyTexImage2D, glCopyTexImage2D, NULL, _gloffset_CopyTexImage2D),
+    NAME_FUNC_OFFSET(13655, glCopyTexSubImage1D, glCopyTexSubImage1D, NULL, _gloffset_CopyTexSubImage1D),
+    NAME_FUNC_OFFSET(13678, glCopyTexSubImage2D, glCopyTexSubImage2D, NULL, _gloffset_CopyTexSubImage2D),
+    NAME_FUNC_OFFSET(13701, glDeleteTextures, glDeleteTexturesEXT, glDeleteTexturesEXT, _gloffset_DeleteTextures),
+    NAME_FUNC_OFFSET(13721, glGenTextures, glGenTexturesEXT, glGenTexturesEXT, _gloffset_GenTextures),
+    NAME_FUNC_OFFSET(13738, glGetPointerv, glGetPointerv, NULL, _gloffset_GetPointerv),
+    NAME_FUNC_OFFSET(13755, glIsTexture, glIsTextureEXT, glIsTextureEXT, _gloffset_IsTexture),
+    NAME_FUNC_OFFSET(13770, glPrioritizeTextures, glPrioritizeTextures, NULL, _gloffset_PrioritizeTextures),
+    NAME_FUNC_OFFSET(13794, glTexSubImage1D, glTexSubImage1D, NULL, _gloffset_TexSubImage1D),
+    NAME_FUNC_OFFSET(13813, glTexSubImage2D, glTexSubImage2D, NULL, _gloffset_TexSubImage2D),
+    NAME_FUNC_OFFSET(13832, glBlendColor, glBlendColor, NULL, _gloffset_BlendColor),
+    NAME_FUNC_OFFSET(13848, glBlendEquation, glBlendEquation, NULL, _gloffset_BlendEquation),
+    NAME_FUNC_OFFSET(13867, glDrawRangeElements, glDrawRangeElements, NULL, _gloffset_DrawRangeElements),
+    NAME_FUNC_OFFSET(13890, glColorTable, glColorTable, NULL, _gloffset_ColorTable),
+    NAME_FUNC_OFFSET(13906, glColorTable, glColorTable, NULL, _gloffset_ColorTable),
+    NAME_FUNC_OFFSET(13922, glColorTableParameterfv, glColorTableParameterfv, NULL, _gloffset_ColorTableParameterfv),
+    NAME_FUNC_OFFSET(13949, glColorTableParameteriv, glColorTableParameteriv, NULL, _gloffset_ColorTableParameteriv),
+    NAME_FUNC_OFFSET(13976, glCopyColorTable, glCopyColorTable, NULL, _gloffset_CopyColorTable),
+    NAME_FUNC_OFFSET(13996, glGetColorTable, glGetColorTableEXT, glGetColorTableEXT, _gloffset_GetColorTable),
+    NAME_FUNC_OFFSET(14015, glGetColorTable, glGetColorTableEXT, glGetColorTableEXT, _gloffset_GetColorTable),
+    NAME_FUNC_OFFSET(14034, glGetColorTableParameterfv, glGetColorTableParameterfvEXT, glGetColorTableParameterfvEXT, _gloffset_GetColorTableParameterfv),
+    NAME_FUNC_OFFSET(14064, glGetColorTableParameterfv, glGetColorTableParameterfvEXT, glGetColorTableParameterfvEXT, _gloffset_GetColorTableParameterfv),
+    NAME_FUNC_OFFSET(14094, glGetColorTableParameteriv, glGetColorTableParameterivEXT, glGetColorTableParameterivEXT, _gloffset_GetColorTableParameteriv),
+    NAME_FUNC_OFFSET(14124, glGetColorTableParameteriv, glGetColorTableParameterivEXT, glGetColorTableParameterivEXT, _gloffset_GetColorTableParameteriv),
+    NAME_FUNC_OFFSET(14154, glColorSubTable, glColorSubTable, NULL, _gloffset_ColorSubTable),
+    NAME_FUNC_OFFSET(14173, glCopyColorSubTable, glCopyColorSubTable, NULL, _gloffset_CopyColorSubTable),
+    NAME_FUNC_OFFSET(14196, glConvolutionFilter1D, glConvolutionFilter1D, NULL, _gloffset_ConvolutionFilter1D),
+    NAME_FUNC_OFFSET(14221, glConvolutionFilter2D, glConvolutionFilter2D, NULL, _gloffset_ConvolutionFilter2D),
+    NAME_FUNC_OFFSET(14246, glConvolutionParameterf, glConvolutionParameterf, NULL, _gloffset_ConvolutionParameterf),
+    NAME_FUNC_OFFSET(14273, glConvolutionParameterfv, glConvolutionParameterfv, NULL, _gloffset_ConvolutionParameterfv),
+    NAME_FUNC_OFFSET(14301, glConvolutionParameteri, glConvolutionParameteri, NULL, _gloffset_ConvolutionParameteri),
+    NAME_FUNC_OFFSET(14328, glConvolutionParameteriv, glConvolutionParameteriv, NULL, _gloffset_ConvolutionParameteriv),
+    NAME_FUNC_OFFSET(14356, glCopyConvolutionFilter1D, glCopyConvolutionFilter1D, NULL, _gloffset_CopyConvolutionFilter1D),
+    NAME_FUNC_OFFSET(14385, glCopyConvolutionFilter2D, glCopyConvolutionFilter2D, NULL, _gloffset_CopyConvolutionFilter2D),
+    NAME_FUNC_OFFSET(14414, glGetConvolutionFilter, gl_dispatch_stub_356, gl_dispatch_stub_356, _gloffset_GetConvolutionFilter),
+    NAME_FUNC_OFFSET(14440, glGetConvolutionParameterfv, gl_dispatch_stub_357, gl_dispatch_stub_357, _gloffset_GetConvolutionParameterfv),
+    NAME_FUNC_OFFSET(14471, glGetConvolutionParameteriv, gl_dispatch_stub_358, gl_dispatch_stub_358, _gloffset_GetConvolutionParameteriv),
+    NAME_FUNC_OFFSET(14502, glGetSeparableFilter, gl_dispatch_stub_359, gl_dispatch_stub_359, _gloffset_GetSeparableFilter),
+    NAME_FUNC_OFFSET(14526, glSeparableFilter2D, glSeparableFilter2D, NULL, _gloffset_SeparableFilter2D),
+    NAME_FUNC_OFFSET(14549, glGetHistogram, gl_dispatch_stub_361, gl_dispatch_stub_361, _gloffset_GetHistogram),
+    NAME_FUNC_OFFSET(14567, glGetHistogramParameterfv, gl_dispatch_stub_362, gl_dispatch_stub_362, _gloffset_GetHistogramParameterfv),
+    NAME_FUNC_OFFSET(14596, glGetHistogramParameteriv, gl_dispatch_stub_363, gl_dispatch_stub_363, _gloffset_GetHistogramParameteriv),
+    NAME_FUNC_OFFSET(14625, glGetMinmax, gl_dispatch_stub_364, gl_dispatch_stub_364, _gloffset_GetMinmax),
+    NAME_FUNC_OFFSET(14640, glGetMinmaxParameterfv, gl_dispatch_stub_365, gl_dispatch_stub_365, _gloffset_GetMinmaxParameterfv),
+    NAME_FUNC_OFFSET(14666, glGetMinmaxParameteriv, gl_dispatch_stub_366, gl_dispatch_stub_366, _gloffset_GetMinmaxParameteriv),
+    NAME_FUNC_OFFSET(14692, glHistogram, glHistogram, NULL, _gloffset_Histogram),
+    NAME_FUNC_OFFSET(14707, glMinmax, glMinmax, NULL, _gloffset_Minmax),
+    NAME_FUNC_OFFSET(14719, glResetHistogram, glResetHistogram, NULL, _gloffset_ResetHistogram),
+    NAME_FUNC_OFFSET(14739, glResetMinmax, glResetMinmax, NULL, _gloffset_ResetMinmax),
+    NAME_FUNC_OFFSET(14756, glTexImage3D, glTexImage3D, NULL, _gloffset_TexImage3D),
+    NAME_FUNC_OFFSET(14772, glTexSubImage3D, glTexSubImage3D, NULL, _gloffset_TexSubImage3D),
+    NAME_FUNC_OFFSET(14791, glCopyTexSubImage3D, glCopyTexSubImage3D, NULL, _gloffset_CopyTexSubImage3D),
+    NAME_FUNC_OFFSET(14814, glActiveTextureARB, glActiveTextureARB, NULL, _gloffset_ActiveTextureARB),
+    NAME_FUNC_OFFSET(14830, glClientActiveTextureARB, glClientActiveTextureARB, NULL, _gloffset_ClientActiveTextureARB),
+    NAME_FUNC_OFFSET(14852, glMultiTexCoord1dARB, glMultiTexCoord1dARB, NULL, _gloffset_MultiTexCoord1dARB),
+    NAME_FUNC_OFFSET(14870, glMultiTexCoord1dvARB, glMultiTexCoord1dvARB, NULL, _gloffset_MultiTexCoord1dvARB),
+    NAME_FUNC_OFFSET(14889, glMultiTexCoord1fARB, glMultiTexCoord1fARB, NULL, _gloffset_MultiTexCoord1fARB),
+    NAME_FUNC_OFFSET(14907, glMultiTexCoord1fvARB, glMultiTexCoord1fvARB, NULL, _gloffset_MultiTexCoord1fvARB),
+    NAME_FUNC_OFFSET(14926, glMultiTexCoord1iARB, glMultiTexCoord1iARB, NULL, _gloffset_MultiTexCoord1iARB),
+    NAME_FUNC_OFFSET(14944, glMultiTexCoord1ivARB, glMultiTexCoord1ivARB, NULL, _gloffset_MultiTexCoord1ivARB),
+    NAME_FUNC_OFFSET(14963, glMultiTexCoord1sARB, glMultiTexCoord1sARB, NULL, _gloffset_MultiTexCoord1sARB),
+    NAME_FUNC_OFFSET(14981, glMultiTexCoord1svARB, glMultiTexCoord1svARB, NULL, _gloffset_MultiTexCoord1svARB),
+    NAME_FUNC_OFFSET(15000, glMultiTexCoord2dARB, glMultiTexCoord2dARB, NULL, _gloffset_MultiTexCoord2dARB),
+    NAME_FUNC_OFFSET(15018, glMultiTexCoord2dvARB, glMultiTexCoord2dvARB, NULL, _gloffset_MultiTexCoord2dvARB),
+    NAME_FUNC_OFFSET(15037, glMultiTexCoord2fARB, glMultiTexCoord2fARB, NULL, _gloffset_MultiTexCoord2fARB),
+    NAME_FUNC_OFFSET(15055, glMultiTexCoord2fvARB, glMultiTexCoord2fvARB, NULL, _gloffset_MultiTexCoord2fvARB),
+    NAME_FUNC_OFFSET(15074, glMultiTexCoord2iARB, glMultiTexCoord2iARB, NULL, _gloffset_MultiTexCoord2iARB),
+    NAME_FUNC_OFFSET(15092, glMultiTexCoord2ivARB, glMultiTexCoord2ivARB, NULL, _gloffset_MultiTexCoord2ivARB),
+    NAME_FUNC_OFFSET(15111, glMultiTexCoord2sARB, glMultiTexCoord2sARB, NULL, _gloffset_MultiTexCoord2sARB),
+    NAME_FUNC_OFFSET(15129, glMultiTexCoord2svARB, glMultiTexCoord2svARB, NULL, _gloffset_MultiTexCoord2svARB),
+    NAME_FUNC_OFFSET(15148, glMultiTexCoord3dARB, glMultiTexCoord3dARB, NULL, _gloffset_MultiTexCoord3dARB),
+    NAME_FUNC_OFFSET(15166, glMultiTexCoord3dvARB, glMultiTexCoord3dvARB, NULL, _gloffset_MultiTexCoord3dvARB),
+    NAME_FUNC_OFFSET(15185, glMultiTexCoord3fARB, glMultiTexCoord3fARB, NULL, _gloffset_MultiTexCoord3fARB),
+    NAME_FUNC_OFFSET(15203, glMultiTexCoord3fvARB, glMultiTexCoord3fvARB, NULL, _gloffset_MultiTexCoord3fvARB),
+    NAME_FUNC_OFFSET(15222, glMultiTexCoord3iARB, glMultiTexCoord3iARB, NULL, _gloffset_MultiTexCoord3iARB),
+    NAME_FUNC_OFFSET(15240, glMultiTexCoord3ivARB, glMultiTexCoord3ivARB, NULL, _gloffset_MultiTexCoord3ivARB),
+    NAME_FUNC_OFFSET(15259, glMultiTexCoord3sARB, glMultiTexCoord3sARB, NULL, _gloffset_MultiTexCoord3sARB),
+    NAME_FUNC_OFFSET(15277, glMultiTexCoord3svARB, glMultiTexCoord3svARB, NULL, _gloffset_MultiTexCoord3svARB),
+    NAME_FUNC_OFFSET(15296, glMultiTexCoord4dARB, glMultiTexCoord4dARB, NULL, _gloffset_MultiTexCoord4dARB),
+    NAME_FUNC_OFFSET(15314, glMultiTexCoord4dvARB, glMultiTexCoord4dvARB, NULL, _gloffset_MultiTexCoord4dvARB),
+    NAME_FUNC_OFFSET(15333, glMultiTexCoord4fARB, glMultiTexCoord4fARB, NULL, _gloffset_MultiTexCoord4fARB),
+    NAME_FUNC_OFFSET(15351, glMultiTexCoord4fvARB, glMultiTexCoord4fvARB, NULL, _gloffset_MultiTexCoord4fvARB),
+    NAME_FUNC_OFFSET(15370, glMultiTexCoord4iARB, glMultiTexCoord4iARB, NULL, _gloffset_MultiTexCoord4iARB),
+    NAME_FUNC_OFFSET(15388, glMultiTexCoord4ivARB, glMultiTexCoord4ivARB, NULL, _gloffset_MultiTexCoord4ivARB),
+    NAME_FUNC_OFFSET(15407, glMultiTexCoord4sARB, glMultiTexCoord4sARB, NULL, _gloffset_MultiTexCoord4sARB),
+    NAME_FUNC_OFFSET(15425, glMultiTexCoord4svARB, glMultiTexCoord4svARB, NULL, _gloffset_MultiTexCoord4svARB),
+    NAME_FUNC_OFFSET(15444, glStencilOpSeparate, glStencilOpSeparate, NULL, _gloffset_StencilOpSeparate),
+    NAME_FUNC_OFFSET(15467, glLoadTransposeMatrixdARB, glLoadTransposeMatrixdARB, NULL, _gloffset_LoadTransposeMatrixdARB),
+    NAME_FUNC_OFFSET(15490, glLoadTransposeMatrixfARB, glLoadTransposeMatrixfARB, NULL, _gloffset_LoadTransposeMatrixfARB),
+    NAME_FUNC_OFFSET(15513, glMultTransposeMatrixdARB, glMultTransposeMatrixdARB, NULL, _gloffset_MultTransposeMatrixdARB),
+    NAME_FUNC_OFFSET(15536, glMultTransposeMatrixfARB, glMultTransposeMatrixfARB, NULL, _gloffset_MultTransposeMatrixfARB),
+    NAME_FUNC_OFFSET(15559, glSampleCoverageARB, glSampleCoverageARB, NULL, _gloffset_SampleCoverageARB),
+    NAME_FUNC_OFFSET(15576, glCompressedTexImage1DARB, glCompressedTexImage1DARB, NULL, _gloffset_CompressedTexImage1DARB),
+    NAME_FUNC_OFFSET(15599, glCompressedTexImage2DARB, glCompressedTexImage2DARB, NULL, _gloffset_CompressedTexImage2DARB),
+    NAME_FUNC_OFFSET(15622, glCompressedTexImage3DARB, glCompressedTexImage3DARB, NULL, _gloffset_CompressedTexImage3DARB),
+    NAME_FUNC_OFFSET(15645, glCompressedTexSubImage1DARB, glCompressedTexSubImage1DARB, NULL, _gloffset_CompressedTexSubImage1DARB),
+    NAME_FUNC_OFFSET(15671, glCompressedTexSubImage2DARB, glCompressedTexSubImage2DARB, NULL, _gloffset_CompressedTexSubImage2DARB),
+    NAME_FUNC_OFFSET(15697, glCompressedTexSubImage3DARB, glCompressedTexSubImage3DARB, NULL, _gloffset_CompressedTexSubImage3DARB),
+    NAME_FUNC_OFFSET(15723, glGetCompressedTexImageARB, glGetCompressedTexImageARB, NULL, _gloffset_GetCompressedTexImageARB),
+    NAME_FUNC_OFFSET(15747, glDisableVertexAttribArrayARB, glDisableVertexAttribArrayARB, NULL, _gloffset_DisableVertexAttribArrayARB),
+    NAME_FUNC_OFFSET(15774, glEnableVertexAttribArrayARB, glEnableVertexAttribArrayARB, NULL, _gloffset_EnableVertexAttribArrayARB),
+    NAME_FUNC_OFFSET(15800, glGetVertexAttribdvARB, glGetVertexAttribdvARB, NULL, _gloffset_GetVertexAttribdvARB),
+    NAME_FUNC_OFFSET(15820, glGetVertexAttribfvARB, glGetVertexAttribfvARB, NULL, _gloffset_GetVertexAttribfvARB),
+    NAME_FUNC_OFFSET(15840, glGetVertexAttribivARB, glGetVertexAttribivARB, NULL, _gloffset_GetVertexAttribivARB),
+    NAME_FUNC_OFFSET(15860, glProgramEnvParameter4dARB, glProgramEnvParameter4dARB, NULL, _gloffset_ProgramEnvParameter4dARB),
+    NAME_FUNC_OFFSET(15883, glProgramEnvParameter4dvARB, glProgramEnvParameter4dvARB, NULL, _gloffset_ProgramEnvParameter4dvARB),
+    NAME_FUNC_OFFSET(15907, glProgramEnvParameter4fARB, glProgramEnvParameter4fARB, NULL, _gloffset_ProgramEnvParameter4fARB),
+    NAME_FUNC_OFFSET(15930, glProgramEnvParameter4fvARB, glProgramEnvParameter4fvARB, NULL, _gloffset_ProgramEnvParameter4fvARB),
+    NAME_FUNC_OFFSET(15954, glVertexAttrib1dARB, glVertexAttrib1dARB, NULL, _gloffset_VertexAttrib1dARB),
+    NAME_FUNC_OFFSET(15971, glVertexAttrib1dvARB, glVertexAttrib1dvARB, NULL, _gloffset_VertexAttrib1dvARB),
+    NAME_FUNC_OFFSET(15989, glVertexAttrib1fARB, glVertexAttrib1fARB, NULL, _gloffset_VertexAttrib1fARB),
+    NAME_FUNC_OFFSET(16006, glVertexAttrib1fvARB, glVertexAttrib1fvARB, NULL, _gloffset_VertexAttrib1fvARB),
+    NAME_FUNC_OFFSET(16024, glVertexAttrib1sARB, glVertexAttrib1sARB, NULL, _gloffset_VertexAttrib1sARB),
+    NAME_FUNC_OFFSET(16041, glVertexAttrib1svARB, glVertexAttrib1svARB, NULL, _gloffset_VertexAttrib1svARB),
+    NAME_FUNC_OFFSET(16059, glVertexAttrib2dARB, glVertexAttrib2dARB, NULL, _gloffset_VertexAttrib2dARB),
+    NAME_FUNC_OFFSET(16076, glVertexAttrib2dvARB, glVertexAttrib2dvARB, NULL, _gloffset_VertexAttrib2dvARB),
+    NAME_FUNC_OFFSET(16094, glVertexAttrib2fARB, glVertexAttrib2fARB, NULL, _gloffset_VertexAttrib2fARB),
+    NAME_FUNC_OFFSET(16111, glVertexAttrib2fvARB, glVertexAttrib2fvARB, NULL, _gloffset_VertexAttrib2fvARB),
+    NAME_FUNC_OFFSET(16129, glVertexAttrib2sARB, glVertexAttrib2sARB, NULL, _gloffset_VertexAttrib2sARB),
+    NAME_FUNC_OFFSET(16146, glVertexAttrib2svARB, glVertexAttrib2svARB, NULL, _gloffset_VertexAttrib2svARB),
+    NAME_FUNC_OFFSET(16164, glVertexAttrib3dARB, glVertexAttrib3dARB, NULL, _gloffset_VertexAttrib3dARB),
+    NAME_FUNC_OFFSET(16181, glVertexAttrib3dvARB, glVertexAttrib3dvARB, NULL, _gloffset_VertexAttrib3dvARB),
+    NAME_FUNC_OFFSET(16199, glVertexAttrib3fARB, glVertexAttrib3fARB, NULL, _gloffset_VertexAttrib3fARB),
+    NAME_FUNC_OFFSET(16216, glVertexAttrib3fvARB, glVertexAttrib3fvARB, NULL, _gloffset_VertexAttrib3fvARB),
+    NAME_FUNC_OFFSET(16234, glVertexAttrib3sARB, glVertexAttrib3sARB, NULL, _gloffset_VertexAttrib3sARB),
+    NAME_FUNC_OFFSET(16251, glVertexAttrib3svARB, glVertexAttrib3svARB, NULL, _gloffset_VertexAttrib3svARB),
+    NAME_FUNC_OFFSET(16269, glVertexAttrib4NbvARB, glVertexAttrib4NbvARB, NULL, _gloffset_VertexAttrib4NbvARB),
+    NAME_FUNC_OFFSET(16288, glVertexAttrib4NivARB, glVertexAttrib4NivARB, NULL, _gloffset_VertexAttrib4NivARB),
+    NAME_FUNC_OFFSET(16307, glVertexAttrib4NsvARB, glVertexAttrib4NsvARB, NULL, _gloffset_VertexAttrib4NsvARB),
+    NAME_FUNC_OFFSET(16326, glVertexAttrib4NubARB, glVertexAttrib4NubARB, NULL, _gloffset_VertexAttrib4NubARB),
+    NAME_FUNC_OFFSET(16345, glVertexAttrib4NubvARB, glVertexAttrib4NubvARB, NULL, _gloffset_VertexAttrib4NubvARB),
+    NAME_FUNC_OFFSET(16365, glVertexAttrib4NuivARB, glVertexAttrib4NuivARB, NULL, _gloffset_VertexAttrib4NuivARB),
+    NAME_FUNC_OFFSET(16385, glVertexAttrib4NusvARB, glVertexAttrib4NusvARB, NULL, _gloffset_VertexAttrib4NusvARB),
+    NAME_FUNC_OFFSET(16405, glVertexAttrib4bvARB, glVertexAttrib4bvARB, NULL, _gloffset_VertexAttrib4bvARB),
+    NAME_FUNC_OFFSET(16423, glVertexAttrib4dARB, glVertexAttrib4dARB, NULL, _gloffset_VertexAttrib4dARB),
+    NAME_FUNC_OFFSET(16440, glVertexAttrib4dvARB, glVertexAttrib4dvARB, NULL, _gloffset_VertexAttrib4dvARB),
+    NAME_FUNC_OFFSET(16458, glVertexAttrib4fARB, glVertexAttrib4fARB, NULL, _gloffset_VertexAttrib4fARB),
+    NAME_FUNC_OFFSET(16475, glVertexAttrib4fvARB, glVertexAttrib4fvARB, NULL, _gloffset_VertexAttrib4fvARB),
+    NAME_FUNC_OFFSET(16493, glVertexAttrib4ivARB, glVertexAttrib4ivARB, NULL, _gloffset_VertexAttrib4ivARB),
+    NAME_FUNC_OFFSET(16511, glVertexAttrib4sARB, glVertexAttrib4sARB, NULL, _gloffset_VertexAttrib4sARB),
+    NAME_FUNC_OFFSET(16528, glVertexAttrib4svARB, glVertexAttrib4svARB, NULL, _gloffset_VertexAttrib4svARB),
+    NAME_FUNC_OFFSET(16546, glVertexAttrib4ubvARB, glVertexAttrib4ubvARB, NULL, _gloffset_VertexAttrib4ubvARB),
+    NAME_FUNC_OFFSET(16565, glVertexAttrib4uivARB, glVertexAttrib4uivARB, NULL, _gloffset_VertexAttrib4uivARB),
+    NAME_FUNC_OFFSET(16584, glVertexAttrib4usvARB, glVertexAttrib4usvARB, NULL, _gloffset_VertexAttrib4usvARB),
+    NAME_FUNC_OFFSET(16603, glVertexAttribPointerARB, glVertexAttribPointerARB, NULL, _gloffset_VertexAttribPointerARB),
+    NAME_FUNC_OFFSET(16625, glBindBufferARB, glBindBufferARB, NULL, _gloffset_BindBufferARB),
+    NAME_FUNC_OFFSET(16638, glBufferDataARB, glBufferDataARB, NULL, _gloffset_BufferDataARB),
+    NAME_FUNC_OFFSET(16651, glBufferSubDataARB, glBufferSubDataARB, NULL, _gloffset_BufferSubDataARB),
+    NAME_FUNC_OFFSET(16667, glDeleteBuffersARB, glDeleteBuffersARB, NULL, _gloffset_DeleteBuffersARB),
+    NAME_FUNC_OFFSET(16683, glGenBuffersARB, glGenBuffersARB, NULL, _gloffset_GenBuffersARB),
+    NAME_FUNC_OFFSET(16696, glGetBufferParameterivARB, glGetBufferParameterivARB, NULL, _gloffset_GetBufferParameterivARB),
+    NAME_FUNC_OFFSET(16719, glGetBufferPointervARB, glGetBufferPointervARB, NULL, _gloffset_GetBufferPointervARB),
+    NAME_FUNC_OFFSET(16739, glGetBufferSubDataARB, glGetBufferSubDataARB, NULL, _gloffset_GetBufferSubDataARB),
+    NAME_FUNC_OFFSET(16758, glIsBufferARB, glIsBufferARB, NULL, _gloffset_IsBufferARB),
+    NAME_FUNC_OFFSET(16769, glMapBufferARB, glMapBufferARB, NULL, _gloffset_MapBufferARB),
+    NAME_FUNC_OFFSET(16781, glUnmapBufferARB, glUnmapBufferARB, NULL, _gloffset_UnmapBufferARB),
+    NAME_FUNC_OFFSET(16795, glBeginQueryARB, glBeginQueryARB, NULL, _gloffset_BeginQueryARB),
+    NAME_FUNC_OFFSET(16808, glDeleteQueriesARB, glDeleteQueriesARB, NULL, _gloffset_DeleteQueriesARB),
+    NAME_FUNC_OFFSET(16824, glEndQueryARB, glEndQueryARB, NULL, _gloffset_EndQueryARB),
+    NAME_FUNC_OFFSET(16835, glGenQueriesARB, glGenQueriesARB, NULL, _gloffset_GenQueriesARB),
+    NAME_FUNC_OFFSET(16848, glGetQueryObjectivARB, glGetQueryObjectivARB, NULL, _gloffset_GetQueryObjectivARB),
+    NAME_FUNC_OFFSET(16867, glGetQueryObjectuivARB, glGetQueryObjectuivARB, NULL, _gloffset_GetQueryObjectuivARB),
+    NAME_FUNC_OFFSET(16887, glGetQueryivARB, glGetQueryivARB, NULL, _gloffset_GetQueryivARB),
+    NAME_FUNC_OFFSET(16900, glIsQueryARB, glIsQueryARB, NULL, _gloffset_IsQueryARB),
+    NAME_FUNC_OFFSET(16910, glCompileShaderARB, glCompileShaderARB, NULL, _gloffset_CompileShaderARB),
+    NAME_FUNC_OFFSET(16926, glGetActiveUniformARB, glGetActiveUniformARB, NULL, _gloffset_GetActiveUniformARB),
+    NAME_FUNC_OFFSET(16945, glGetShaderSourceARB, glGetShaderSourceARB, NULL, _gloffset_GetShaderSourceARB),
+    NAME_FUNC_OFFSET(16963, glGetUniformLocationARB, glGetUniformLocationARB, NULL, _gloffset_GetUniformLocationARB),
+    NAME_FUNC_OFFSET(16984, glGetUniformfvARB, glGetUniformfvARB, NULL, _gloffset_GetUniformfvARB),
+    NAME_FUNC_OFFSET(16999, glGetUniformivARB, glGetUniformivARB, NULL, _gloffset_GetUniformivARB),
+    NAME_FUNC_OFFSET(17014, glLinkProgramARB, glLinkProgramARB, NULL, _gloffset_LinkProgramARB),
+    NAME_FUNC_OFFSET(17028, glShaderSourceARB, glShaderSourceARB, NULL, _gloffset_ShaderSourceARB),
+    NAME_FUNC_OFFSET(17043, glUniform1fARB, glUniform1fARB, NULL, _gloffset_Uniform1fARB),
+    NAME_FUNC_OFFSET(17055, glUniform1fvARB, glUniform1fvARB, NULL, _gloffset_Uniform1fvARB),
+    NAME_FUNC_OFFSET(17068, glUniform1iARB, glUniform1iARB, NULL, _gloffset_Uniform1iARB),
+    NAME_FUNC_OFFSET(17080, glUniform1ivARB, glUniform1ivARB, NULL, _gloffset_Uniform1ivARB),
+    NAME_FUNC_OFFSET(17093, glUniform2fARB, glUniform2fARB, NULL, _gloffset_Uniform2fARB),
+    NAME_FUNC_OFFSET(17105, glUniform2fvARB, glUniform2fvARB, NULL, _gloffset_Uniform2fvARB),
+    NAME_FUNC_OFFSET(17118, glUniform2iARB, glUniform2iARB, NULL, _gloffset_Uniform2iARB),
+    NAME_FUNC_OFFSET(17130, glUniform2ivARB, glUniform2ivARB, NULL, _gloffset_Uniform2ivARB),
+    NAME_FUNC_OFFSET(17143, glUniform3fARB, glUniform3fARB, NULL, _gloffset_Uniform3fARB),
+    NAME_FUNC_OFFSET(17155, glUniform3fvARB, glUniform3fvARB, NULL, _gloffset_Uniform3fvARB),
+    NAME_FUNC_OFFSET(17168, glUniform3iARB, glUniform3iARB, NULL, _gloffset_Uniform3iARB),
+    NAME_FUNC_OFFSET(17180, glUniform3ivARB, glUniform3ivARB, NULL, _gloffset_Uniform3ivARB),
+    NAME_FUNC_OFFSET(17193, glUniform4fARB, glUniform4fARB, NULL, _gloffset_Uniform4fARB),
+    NAME_FUNC_OFFSET(17205, glUniform4fvARB, glUniform4fvARB, NULL, _gloffset_Uniform4fvARB),
+    NAME_FUNC_OFFSET(17218, glUniform4iARB, glUniform4iARB, NULL, _gloffset_Uniform4iARB),
+    NAME_FUNC_OFFSET(17230, glUniform4ivARB, glUniform4ivARB, NULL, _gloffset_Uniform4ivARB),
+    NAME_FUNC_OFFSET(17243, glUniformMatrix2fvARB, glUniformMatrix2fvARB, NULL, _gloffset_UniformMatrix2fvARB),
+    NAME_FUNC_OFFSET(17262, glUniformMatrix3fvARB, glUniformMatrix3fvARB, NULL, _gloffset_UniformMatrix3fvARB),
+    NAME_FUNC_OFFSET(17281, glUniformMatrix4fvARB, glUniformMatrix4fvARB, NULL, _gloffset_UniformMatrix4fvARB),
+    NAME_FUNC_OFFSET(17300, glUseProgramObjectARB, glUseProgramObjectARB, NULL, _gloffset_UseProgramObjectARB),
+    NAME_FUNC_OFFSET(17313, glValidateProgramARB, glValidateProgramARB, NULL, _gloffset_ValidateProgramARB),
+    NAME_FUNC_OFFSET(17331, glBindAttribLocationARB, glBindAttribLocationARB, NULL, _gloffset_BindAttribLocationARB),
+    NAME_FUNC_OFFSET(17352, glGetActiveAttribARB, glGetActiveAttribARB, NULL, _gloffset_GetActiveAttribARB),
+    NAME_FUNC_OFFSET(17370, glGetAttribLocationARB, glGetAttribLocationARB, NULL, _gloffset_GetAttribLocationARB),
+    NAME_FUNC_OFFSET(17390, glDrawBuffersARB, glDrawBuffersARB, NULL, _gloffset_DrawBuffersARB),
+    NAME_FUNC_OFFSET(17404, glDrawBuffersARB, glDrawBuffersARB, NULL, _gloffset_DrawBuffersARB),
+    NAME_FUNC_OFFSET(17421, gl_dispatch_stub_568, gl_dispatch_stub_568, NULL, _gloffset_SampleMaskSGIS),
+    NAME_FUNC_OFFSET(17437, gl_dispatch_stub_569, gl_dispatch_stub_569, NULL, _gloffset_SamplePatternSGIS),
+    NAME_FUNC_OFFSET(17456, glPointParameterfEXT, glPointParameterfEXT, NULL, _gloffset_PointParameterfEXT),
+    NAME_FUNC_OFFSET(17474, glPointParameterfEXT, glPointParameterfEXT, NULL, _gloffset_PointParameterfEXT),
+    NAME_FUNC_OFFSET(17495, glPointParameterfEXT, glPointParameterfEXT, NULL, _gloffset_PointParameterfEXT),
+    NAME_FUNC_OFFSET(17517, glPointParameterfvEXT, glPointParameterfvEXT, NULL, _gloffset_PointParameterfvEXT),
+    NAME_FUNC_OFFSET(17536, glPointParameterfvEXT, glPointParameterfvEXT, NULL, _gloffset_PointParameterfvEXT),
+    NAME_FUNC_OFFSET(17558, glPointParameterfvEXT, glPointParameterfvEXT, NULL, _gloffset_PointParameterfvEXT),
+    NAME_FUNC_OFFSET(17581, glSecondaryColor3bEXT, glSecondaryColor3bEXT, NULL, _gloffset_SecondaryColor3bEXT),
+    NAME_FUNC_OFFSET(17600, glSecondaryColor3bvEXT, glSecondaryColor3bvEXT, NULL, _gloffset_SecondaryColor3bvEXT),
+    NAME_FUNC_OFFSET(17620, glSecondaryColor3dEXT, glSecondaryColor3dEXT, NULL, _gloffset_SecondaryColor3dEXT),
+    NAME_FUNC_OFFSET(17639, glSecondaryColor3dvEXT, glSecondaryColor3dvEXT, NULL, _gloffset_SecondaryColor3dvEXT),
+    NAME_FUNC_OFFSET(17659, glSecondaryColor3fEXT, glSecondaryColor3fEXT, NULL, _gloffset_SecondaryColor3fEXT),
+    NAME_FUNC_OFFSET(17678, glSecondaryColor3fvEXT, glSecondaryColor3fvEXT, NULL, _gloffset_SecondaryColor3fvEXT),
+    NAME_FUNC_OFFSET(17698, glSecondaryColor3iEXT, glSecondaryColor3iEXT, NULL, _gloffset_SecondaryColor3iEXT),
+    NAME_FUNC_OFFSET(17717, glSecondaryColor3ivEXT, glSecondaryColor3ivEXT, NULL, _gloffset_SecondaryColor3ivEXT),
+    NAME_FUNC_OFFSET(17737, glSecondaryColor3sEXT, glSecondaryColor3sEXT, NULL, _gloffset_SecondaryColor3sEXT),
+    NAME_FUNC_OFFSET(17756, glSecondaryColor3svEXT, glSecondaryColor3svEXT, NULL, _gloffset_SecondaryColor3svEXT),
+    NAME_FUNC_OFFSET(17776, glSecondaryColor3ubEXT, glSecondaryColor3ubEXT, NULL, _gloffset_SecondaryColor3ubEXT),
+    NAME_FUNC_OFFSET(17796, glSecondaryColor3ubvEXT, glSecondaryColor3ubvEXT, NULL, _gloffset_SecondaryColor3ubvEXT),
+    NAME_FUNC_OFFSET(17817, glSecondaryColor3uiEXT, glSecondaryColor3uiEXT, NULL, _gloffset_SecondaryColor3uiEXT),
+    NAME_FUNC_OFFSET(17837, glSecondaryColor3uivEXT, glSecondaryColor3uivEXT, NULL, _gloffset_SecondaryColor3uivEXT),
+    NAME_FUNC_OFFSET(17858, glSecondaryColor3usEXT, glSecondaryColor3usEXT, NULL, _gloffset_SecondaryColor3usEXT),
+    NAME_FUNC_OFFSET(17878, glSecondaryColor3usvEXT, glSecondaryColor3usvEXT, NULL, _gloffset_SecondaryColor3usvEXT),
+    NAME_FUNC_OFFSET(17899, glSecondaryColorPointerEXT, glSecondaryColorPointerEXT, NULL, _gloffset_SecondaryColorPointerEXT),
+    NAME_FUNC_OFFSET(17923, glMultiDrawArraysEXT, glMultiDrawArraysEXT, NULL, _gloffset_MultiDrawArraysEXT),
+    NAME_FUNC_OFFSET(17941, glMultiDrawElementsEXT, glMultiDrawElementsEXT, NULL, _gloffset_MultiDrawElementsEXT),
+    NAME_FUNC_OFFSET(17961, glFogCoordPointerEXT, glFogCoordPointerEXT, NULL, _gloffset_FogCoordPointerEXT),
+    NAME_FUNC_OFFSET(17979, glFogCoorddEXT, glFogCoorddEXT, NULL, _gloffset_FogCoorddEXT),
+    NAME_FUNC_OFFSET(17991, glFogCoorddvEXT, glFogCoorddvEXT, NULL, _gloffset_FogCoorddvEXT),
+    NAME_FUNC_OFFSET(18004, glFogCoordfEXT, glFogCoordfEXT, NULL, _gloffset_FogCoordfEXT),
+    NAME_FUNC_OFFSET(18016, glFogCoordfvEXT, glFogCoordfvEXT, NULL, _gloffset_FogCoordfvEXT),
+    NAME_FUNC_OFFSET(18029, glBlendFuncSeparateEXT, glBlendFuncSeparateEXT, NULL, _gloffset_BlendFuncSeparateEXT),
+    NAME_FUNC_OFFSET(18049, glBlendFuncSeparateEXT, glBlendFuncSeparateEXT, NULL, _gloffset_BlendFuncSeparateEXT),
+    NAME_FUNC_OFFSET(18073, glWindowPos2dMESA, glWindowPos2dMESA, NULL, _gloffset_WindowPos2dMESA),
+    NAME_FUNC_OFFSET(18087, glWindowPos2dMESA, glWindowPos2dMESA, NULL, _gloffset_WindowPos2dMESA),
+    NAME_FUNC_OFFSET(18104, glWindowPos2dvMESA, glWindowPos2dvMESA, NULL, _gloffset_WindowPos2dvMESA),
+    NAME_FUNC_OFFSET(18119, glWindowPos2dvMESA, glWindowPos2dvMESA, NULL, _gloffset_WindowPos2dvMESA),
+    NAME_FUNC_OFFSET(18137, glWindowPos2fMESA, glWindowPos2fMESA, NULL, _gloffset_WindowPos2fMESA),
+    NAME_FUNC_OFFSET(18151, glWindowPos2fMESA, glWindowPos2fMESA, NULL, _gloffset_WindowPos2fMESA),
+    NAME_FUNC_OFFSET(18168, glWindowPos2fvMESA, glWindowPos2fvMESA, NULL, _gloffset_WindowPos2fvMESA),
+    NAME_FUNC_OFFSET(18183, glWindowPos2fvMESA, glWindowPos2fvMESA, NULL, _gloffset_WindowPos2fvMESA),
+    NAME_FUNC_OFFSET(18201, glWindowPos2iMESA, glWindowPos2iMESA, NULL, _gloffset_WindowPos2iMESA),
+    NAME_FUNC_OFFSET(18215, glWindowPos2iMESA, glWindowPos2iMESA, NULL, _gloffset_WindowPos2iMESA),
+    NAME_FUNC_OFFSET(18232, glWindowPos2ivMESA, glWindowPos2ivMESA, NULL, _gloffset_WindowPos2ivMESA),
+    NAME_FUNC_OFFSET(18247, glWindowPos2ivMESA, glWindowPos2ivMESA, NULL, _gloffset_WindowPos2ivMESA),
+    NAME_FUNC_OFFSET(18265, glWindowPos2sMESA, glWindowPos2sMESA, NULL, _gloffset_WindowPos2sMESA),
+    NAME_FUNC_OFFSET(18279, glWindowPos2sMESA, glWindowPos2sMESA, NULL, _gloffset_WindowPos2sMESA),
+    NAME_FUNC_OFFSET(18296, glWindowPos2svMESA, glWindowPos2svMESA, NULL, _gloffset_WindowPos2svMESA),
+    NAME_FUNC_OFFSET(18311, glWindowPos2svMESA, glWindowPos2svMESA, NULL, _gloffset_WindowPos2svMESA),
+    NAME_FUNC_OFFSET(18329, glWindowPos3dMESA, glWindowPos3dMESA, NULL, _gloffset_WindowPos3dMESA),
+    NAME_FUNC_OFFSET(18343, glWindowPos3dMESA, glWindowPos3dMESA, NULL, _gloffset_WindowPos3dMESA),
+    NAME_FUNC_OFFSET(18360, glWindowPos3dvMESA, glWindowPos3dvMESA, NULL, _gloffset_WindowPos3dvMESA),
+    NAME_FUNC_OFFSET(18375, glWindowPos3dvMESA, glWindowPos3dvMESA, NULL, _gloffset_WindowPos3dvMESA),
+    NAME_FUNC_OFFSET(18393, glWindowPos3fMESA, glWindowPos3fMESA, NULL, _gloffset_WindowPos3fMESA),
+    NAME_FUNC_OFFSET(18407, glWindowPos3fMESA, glWindowPos3fMESA, NULL, _gloffset_WindowPos3fMESA),
+    NAME_FUNC_OFFSET(18424, glWindowPos3fvMESA, glWindowPos3fvMESA, NULL, _gloffset_WindowPos3fvMESA),
+    NAME_FUNC_OFFSET(18439, glWindowPos3fvMESA, glWindowPos3fvMESA, NULL, _gloffset_WindowPos3fvMESA),
+    NAME_FUNC_OFFSET(18457, glWindowPos3iMESA, glWindowPos3iMESA, NULL, _gloffset_WindowPos3iMESA),
+    NAME_FUNC_OFFSET(18471, glWindowPos3iMESA, glWindowPos3iMESA, NULL, _gloffset_WindowPos3iMESA),
+    NAME_FUNC_OFFSET(18488, glWindowPos3ivMESA, glWindowPos3ivMESA, NULL, _gloffset_WindowPos3ivMESA),
+    NAME_FUNC_OFFSET(18503, glWindowPos3ivMESA, glWindowPos3ivMESA, NULL, _gloffset_WindowPos3ivMESA),
+    NAME_FUNC_OFFSET(18521, glWindowPos3sMESA, glWindowPos3sMESA, NULL, _gloffset_WindowPos3sMESA),
+    NAME_FUNC_OFFSET(18535, glWindowPos3sMESA, glWindowPos3sMESA, NULL, _gloffset_WindowPos3sMESA),
+    NAME_FUNC_OFFSET(18552, glWindowPos3svMESA, glWindowPos3svMESA, NULL, _gloffset_WindowPos3svMESA),
+    NAME_FUNC_OFFSET(18567, glWindowPos3svMESA, glWindowPos3svMESA, NULL, _gloffset_WindowPos3svMESA),
+    NAME_FUNC_OFFSET(18585, glBindProgramNV, glBindProgramNV, NULL, _gloffset_BindProgramNV),
+    NAME_FUNC_OFFSET(18602, glDeleteProgramsNV, glDeleteProgramsNV, NULL, _gloffset_DeleteProgramsNV),
+    NAME_FUNC_OFFSET(18622, glGenProgramsNV, glGenProgramsNV, NULL, _gloffset_GenProgramsNV),
+    NAME_FUNC_OFFSET(18639, glGetVertexAttribPointervNV, glGetVertexAttribPointervNV, NULL, _gloffset_GetVertexAttribPointervNV),
+    NAME_FUNC_OFFSET(18665, glGetVertexAttribPointervNV, glGetVertexAttribPointervNV, NULL, _gloffset_GetVertexAttribPointervNV),
+    NAME_FUNC_OFFSET(18694, glIsProgramNV, glIsProgramNV, NULL, _gloffset_IsProgramNV),
+    NAME_FUNC_OFFSET(18709, glPointParameteriNV, glPointParameteriNV, NULL, _gloffset_PointParameteriNV),
+    NAME_FUNC_OFFSET(18727, glPointParameterivNV, glPointParameterivNV, NULL, _gloffset_PointParameterivNV),
+    NAME_FUNC_OFFSET(18746, gl_dispatch_stub_745, gl_dispatch_stub_745, NULL, _gloffset_BlendEquationSeparateEXT),
+    NAME_FUNC_OFFSET(18770, gl_dispatch_stub_745, gl_dispatch_stub_745, NULL, _gloffset_BlendEquationSeparateEXT),
+    NAME_FUNC_OFFSET(-1, NULL, NULL, NULL, 0)
+};
+
+#undef NAME_FUNC_OFFSET
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/osdep.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/osdep.h
@@ -0,0 +1,283 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _OSDEP_H_
+#define _OSDEP_H_ 1
+
+#define BOTIMEOUT 200 /* in milliseconds */
+#define BUFSIZE 4096
+#define BUFWATERMARK 8192
+
+#if defined(XDMCP) || defined(HASXDMAUTH)
+#include <X11/Xdmcp.h>
+#endif
+
+#ifdef _POSIX_SOURCE
+#include <limits.h>
+#else
+#define _POSIX_SOURCE
+#include <limits.h>
+#undef _POSIX_SOURCE
+#endif
+
+#ifndef OPEN_MAX
+#ifdef SVR4
+#define OPEN_MAX 256
+#else
+#include <sys/param.h>
+#ifndef OPEN_MAX
+#if defined(NOFILE) && !defined(NOFILES_MAX)
+#define OPEN_MAX NOFILE
+#else
+#if !defined(WIN32)
+#define OPEN_MAX NOFILES_MAX
+#else
+#define OPEN_MAX 256
+#endif
+#endif
+#endif
+#endif
+#endif
+
+#include <X11/Xpoll.h>
+
+/*
+ * MAXSOCKS is used only for initialising MaxClients when no other method
+ * like sysconf(_SC_OPEN_MAX) is not supported.
+ */
+
+#if OPEN_MAX <= 256
+#define MAXSOCKS (OPEN_MAX - 1)
+#else
+#define MAXSOCKS 256
+#endif
+
+/* MAXSELECT is the number of fds that select() can handle */
+#define MAXSELECT (sizeof(fd_set) * NBBY)
+
+#ifndef HAS_GETDTABLESIZE
+#if !defined(SVR4) && !defined(SYSV)
+#define HAS_GETDTABLESIZE
+#endif
+#endif
+
+#include <stddef.h>
+
+#if defined(XDMCP) || defined(HASXDMAUTH)
+typedef Bool (*ValidatorFunc)(ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
+typedef Bool (*GeneratorFunc)(ARRAY8Ptr Auth, ARRAY8Ptr Data, int packet_type);
+typedef Bool (*AddAuthorFunc)(unsigned name_length, const char *name,
+			      unsigned data_length, char *data);
+#endif
+
+typedef struct _connectionInput {
+    struct _connectionInput *next;
+    char *buffer;               /* contains current client input */
+    char *bufptr;               /* pointer to current start of data */
+    int  bufcnt;                /* count of bytes in buffer */
+    int lenLastReq;
+    int size;
+} ConnectionInput, *ConnectionInputPtr;
+
+typedef struct _connectionOutput {
+    struct _connectionOutput *next;
+    int size;
+    unsigned char *buf;
+    int count;
+} ConnectionOutput, *ConnectionOutputPtr;
+
+struct _osComm;
+
+#define AuthInitArgs void
+typedef void (*AuthInitFunc) (AuthInitArgs);
+
+#define AuthAddCArgs unsigned short data_length, const char *data, XID id
+typedef int (*AuthAddCFunc) (AuthAddCArgs);
+
+#define AuthCheckArgs unsigned short data_length, const char *data, ClientPtr client, char **reason
+typedef XID (*AuthCheckFunc) (AuthCheckArgs);
+
+#define AuthFromIDArgs XID id, unsigned short *data_lenp, char **datap
+typedef int (*AuthFromIDFunc) (AuthFromIDArgs);
+
+#define AuthGenCArgs unsigned data_length, const char *data, XID id, unsigned *data_length_return, char **data_return
+typedef XID (*AuthGenCFunc) (AuthGenCArgs);
+
+#define AuthRemCArgs unsigned short data_length, const char *data
+typedef int (*AuthRemCFunc) (AuthRemCArgs);
+
+#define AuthRstCArgs void
+typedef int (*AuthRstCFunc) (AuthRstCArgs);
+
+#define AuthToIDArgs unsigned short data_length, char *data
+typedef XID (*AuthToIDFunc) (AuthToIDArgs);
+
+typedef void (*OsCloseFunc)(ClientPtr);
+
+typedef int (*OsFlushFunc)(ClientPtr who, struct _osComm * oc, char* extraBuf, int extraCount);
+
+typedef struct _osComm {
+    int fd;
+    ConnectionInputPtr input;
+    ConnectionOutputPtr output;
+    XID	auth_id;		/* authorization id */
+    CARD32 conn_time;		/* timestamp if not established, else 0  */
+    struct _XtransConnInfo *trans_conn; /* transport connection object */
+} OsCommRec, *OsCommPtr;
+
+extern int FlushClient(
+    ClientPtr /*who*/,
+    OsCommPtr /*oc*/,
+    const void * /*extraBuf*/,
+    int /*extraCount*/
+);
+
+extern void FreeOsBuffers(
+    OsCommPtr /*oc*/
+);
+
+#include "dix.h"
+
+extern fd_set AllSockets;
+extern fd_set AllClients;
+extern fd_set LastSelectMask;
+extern fd_set WellKnownConnections;
+extern fd_set EnabledDevices;
+extern fd_set ClientsWithInput;
+extern fd_set ClientsWriteBlocked;
+extern fd_set OutputPending;
+extern fd_set IgnoredClientsWithInput;
+
+#ifndef WIN32
+extern int *ConnectionTranslation;
+#else
+extern int GetConnectionTranslation(int conn);
+extern void SetConnectionTranslation(int conn, int client);
+extern void ClearConnectionTranslation(void);
+#endif
+ 
+extern Bool NewOutputPending;
+extern Bool AnyClientsWriteBlocked;
+
+extern WorkQueuePtr workQueue;
+
+/* in WaitFor.c */
+#ifdef WIN32
+typedef long int fd_mask;
+#endif
+#define ffs mffs
+extern int mffs(fd_mask);
+
+/* in auth.c */
+extern void GenerateRandomData (int len, char *buf);
+
+/* in mitauth.c */
+extern XID  MitCheckCookie    (AuthCheckArgs);
+extern XID  MitGenerateCookie (AuthGenCArgs);
+extern XID  MitToID           (AuthToIDArgs);
+extern int  MitAddCookie      (AuthAddCArgs);
+extern int  MitFromID         (AuthFromIDArgs);
+extern int  MitRemoveCookie   (AuthRemCArgs);
+extern int  MitResetCookie    (AuthRstCArgs);
+
+/* in xdmauth.c */
+#ifdef HASXDMAUTH
+extern XID  XdmCheckCookie    (AuthCheckArgs);
+extern XID  XdmToID           (AuthToIDArgs);
+extern int  XdmAddCookie      (AuthAddCArgs);
+extern int  XdmFromID         (AuthFromIDArgs);
+extern int  XdmRemoveCookie   (AuthRemCArgs);
+extern int  XdmResetCookie    (AuthRstCArgs);
+#endif
+
+/* in rpcauth.c */
+#ifdef SECURE_RPC
+extern void SecureRPCInit     (AuthInitArgs);
+extern XID  SecureRPCCheck    (AuthCheckArgs);
+extern XID  SecureRPCToID     (AuthToIDArgs);
+extern int  SecureRPCAdd      (AuthAddCArgs);
+extern int  SecureRPCFromID   (AuthFromIDArgs);
+extern int  SecureRPCRemove   (AuthRemCArgs);
+extern int  SecureRPCReset    (AuthRstCArgs);
+#endif
+
+#ifdef XDMCP
+/* in xdmcp.c */
+extern void XdmcpUseMsg (void);
+extern int XdmcpOptions(int argc, char **argv, int i);
+extern void XdmcpRegisterConnection (
+    int	    type,
+    const char    *address,
+    int	    addrlen);
+extern void XdmcpRegisterAuthorizations (void);
+extern void XdmcpRegisterAuthorization (const char *name, int namelen);
+extern void XdmcpInit (void);
+extern void XdmcpReset (void);
+extern void XdmcpOpenDisplay(int sock);
+extern void XdmcpCloseDisplay(int sock);
+extern void XdmcpRegisterAuthentication (
+    const char    *name,
+    int	    namelen,
+    const char    *data,
+    int	    datalen,
+    ValidatorFunc Validator,
+    GeneratorFunc Generator,
+    AddAuthorFunc AddAuth);
+
+struct sockaddr_in;
+extern void XdmcpRegisterBroadcastAddress (const struct sockaddr_in *addr);
+#endif
+
+#ifdef HASXDMAUTH
+extern void XdmAuthenticationInit (const char *cookie, int cookie_length);
+#endif
+
+#endif /* _OSDEP_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compiler.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compiler.h
@@ -0,0 +1,1376 @@
+/*
+ * Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Thomas Roell not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Thomas Roell makes no representations
+ * about the suitability of this software for any purpose.  It is provided
+ * "as is" without express or implied warranty.
+ *
+ * THOMAS ROELL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL THOMAS ROELL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+/*
+ * Copyright (c) 1994-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _COMPILER_H
+
+# define _COMPILER_H
+
+#if defined(__SUNPRO_C)
+# define DO_PROTOTYPES
+#endif
+
+/* Map Sun compiler platform defines to gcc-style used in the code */
+#if defined(__amd64) && !defined(__amd64__)
+# define __amd64__
+#endif
+#if defined(__i386) && !defined(__i386__)
+# define __i386__
+#endif
+#if defined(__sparc) && !defined(__sparc__)
+# define __sparc__
+#endif
+#if defined(__sparcv9) && !defined(__sparc64__)
+# define __sparc64__
+#endif
+
+#ifndef _X_EXPORT
+# include <X11/Xfuncproto.h>
+#endif
+
+# include <pixman.h> /* for uint*_t types */
+
+/* Allow drivers to use the GCC-supported __inline__ and/or __inline. */
+# ifndef __inline__
+#  if defined(__GNUC__)
+    /* gcc has __inline__ */
+#  elif defined(__HIGHC__)
+#   define __inline__ _Inline
+#  else
+#   define __inline__ /**/
+#  endif
+# endif /* __inline__ */
+# ifndef __inline
+#  if defined(__GNUC__)
+    /* gcc has __inline */
+#  elif defined(__HIGHC__)
+#   define __inline _Inline
+#  else
+#   define __inline /**/
+#  endif
+# endif /* __inline */
+
+/* Support gcc's __FUNCTION__ for people using other compilers */
+#if !defined(__GNUC__) && !defined(__FUNCTION__)
+# define __FUNCTION__ __func__ /* C99 */
+#endif
+
+# if defined(NO_INLINE) || defined(DO_PROTOTYPES)
+
+#  if !defined(__arm__)
+#   if !defined(__sparc__) && !defined(__sparc) && !defined(__arm32__) \
+      && !(defined(__alpha__) && defined(linux)) \
+      && !(defined(__ia64__) && defined(linux)) \
+
+extern _X_EXPORT void outb(unsigned short, unsigned char);
+extern _X_EXPORT void outw(unsigned short, unsigned short);
+extern _X_EXPORT void outl(unsigned short, unsigned int);
+extern _X_EXPORT unsigned int inb(unsigned short);
+extern _X_EXPORT unsigned int inw(unsigned short);
+extern _X_EXPORT unsigned int inl(unsigned short);
+
+#   else /* __sparc__,  __arm32__, __alpha__*/
+
+extern _X_EXPORT void outb(unsigned long, unsigned char);
+extern _X_EXPORT void outw(unsigned long, unsigned short);
+extern _X_EXPORT void outl(unsigned long, unsigned int);
+extern _X_EXPORT unsigned int inb(unsigned long);
+extern _X_EXPORT unsigned int inw(unsigned long);
+extern _X_EXPORT unsigned int inl(unsigned long);
+
+#   endif /* __sparc__,  __arm32__, __alpha__ */
+#  endif /* __arm__ */
+
+#  if defined(__powerpc__) && !defined(__OpenBSD__)
+extern unsigned long ldq_u(unsigned long *);
+extern unsigned long ldl_u(unsigned int *);
+extern unsigned long ldw_u(unsigned short *);
+extern void stq_u(unsigned long, unsigned long *);
+extern void stl_u(unsigned long, unsigned int *);
+extern void stw_u(unsigned long, unsigned short *);
+extern void mem_barrier(void);
+extern void write_mem_barrier(void);
+extern void stl_brx(unsigned long, volatile unsigned char *, int);
+extern void stw_brx(unsigned short, volatile unsigned char *, int);
+extern unsigned long ldl_brx(volatile unsigned char *, int);
+extern unsigned short ldw_brx(volatile unsigned char *, int);
+#  endif /* __powerpc__ && !__OpenBSD */
+
+# endif /* NO_INLINE || DO_PROTOTYPES */
+
+# ifndef NO_INLINE
+#  ifdef __GNUC__
+#   ifdef __i386__
+
+#    ifdef __SSE__
+#     define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
+#    else
+#     define write_mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
+#    endif
+
+#    ifdef __SSE2__
+#     define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
+#    else
+#     define mem_barrier() __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory")
+#    endif
+
+#   elif defined __alpha__
+
+#    define mem_barrier() __asm__ __volatile__ ("mb" : : : "memory")
+#    define write_mem_barrier() __asm__ __volatile__ ("wmb" : : : "memory")
+
+#   elif defined __amd64__
+
+#    define mem_barrier() __asm__ __volatile__ ("mfence" : : : "memory")
+#    define write_mem_barrier() __asm__ __volatile__ ("sfence" : : : "memory")
+
+#   elif defined __ia64__
+
+#    ifndef __INTEL_COMPILER
+#     define mem_barrier()        __asm__ __volatile__ ("mf" : : : "memory")
+#     define write_mem_barrier()  __asm__ __volatile__ ("mf" : : : "memory")
+#    else
+#     include "ia64intrin.h"
+#     define mem_barrier() __mf()
+#     define write_mem_barrier() __mf()
+#    endif
+
+#   elif defined __mips__
+     /* Note: sync instruction requires MIPS II instruction set */
+#    define mem_barrier()		\
+	__asm__ __volatile__(		\
+		".set   push\n\t"	\
+		".set   noreorder\n\t"	\
+		".set   mips2\n\t"	\
+		"sync\n\t"		\
+		".set   pop"		\
+		: /* no output */	\
+		: /* no input */	\
+		: "memory")
+#    define write_mem_barrier() mem_barrier()
+
+#   elif defined __powerpc__
+
+#    if defined(linux) && defined(__powerpc64__)
+#     include <linux/version.h>
+#     if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 0)
+#      include <asm/memory.h>
+#     endif
+#    endif /* defined(linux) && defined(__powerpc64__) */
+
+#    ifndef eieio /* We deal with arch-specific eieio() routines above... */
+#     define eieio() __asm__ __volatile__ ("eieio" ::: "memory")
+#    endif /* eieio */
+#    define mem_barrier()	eieio()
+#    define write_mem_barrier()	eieio()
+
+#   elif defined __sparc__
+
+#    define barrier() __asm__ __volatile__ (".word 0x8143e00a" : : : "memory")
+#    define mem_barrier()         /* XXX: nop for now */
+#    define write_mem_barrier()   /* XXX: nop for now */
+#   endif
+#  endif /* __GNUC__ */
+# endif /* NO_INLINE */
+
+# ifndef mem_barrier
+#  define mem_barrier() /* NOP */
+# endif
+
+# ifndef write_mem_barrier
+#  define write_mem_barrier() /* NOP */
+# endif
+
+
+# ifndef NO_INLINE
+#  ifdef __GNUC__
+
+/* Define some packed structures to use with unaligned accesses */
+
+struct __una_u64 { uint64_t x __attribute__((packed)); };
+struct __una_u32 { uint32_t x __attribute__((packed)); };
+struct __una_u16 { uint16_t x __attribute__((packed)); };
+
+/* Elemental unaligned loads */
+
+static __inline__ uint64_t ldq_u(uint64_t *p)
+{
+	const struct __una_u64 *ptr = (const struct __una_u64 *) p;
+	return ptr->x;
+}
+
+static __inline__ uint32_t ldl_u(uint32_t *p)
+{
+	const struct __una_u32 *ptr = (const struct __una_u32 *) p;
+	return ptr->x;
+}
+
+static __inline__ uint16_t ldw_u(uint16_t *p)
+{
+	const struct __una_u16 *ptr = (const struct __una_u16 *) p;
+	return ptr->x;
+}
+
+/* Elemental unaligned stores */
+
+static __inline__ void stq_u(uint64_t val, uint64_t *p)
+{
+	struct __una_u64 *ptr = (struct __una_u64 *) p;
+	ptr->x = val;
+}
+
+static __inline__ void stl_u(uint32_t val, uint32_t *p)
+{
+	struct __una_u32 *ptr = (struct __una_u32 *) p;
+	ptr->x = val;
+}
+
+static __inline__ void stw_u(uint16_t val, uint16_t *p)
+{
+	struct __una_u16 *ptr = (struct __una_u16 *) p;
+	ptr->x = val;
+}
+#  else /* !__GNUC__ */
+
+#include <string.h> /* needed for memmove */
+
+static __inline__ uint64_t ldq_u(uint64_t *p)
+{
+	uint64_t ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+}
+
+static __inline__ uint32_t ldl_u(uint32_t *p)
+{
+	uint32_t ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+}
+
+static __inline__ uint16_t ldw_u(uint16_t *p)
+{
+	uint16_t ret;
+	memmove(&ret, p, sizeof(*p));
+	return ret;
+}
+
+static __inline__ void stq_u(uint64_t val, uint64_t *p)
+{
+	uint64_t tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+}
+
+static __inline__ void stl_u(uint32_t val, uint32_t *p)
+{
+	uint32_t tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+}
+
+static __inline__ void stw_u(uint16_t val, uint16_t *p)
+{
+	uint16_t tmp = val;
+	memmove(p, &tmp, sizeof(*p));
+}
+
+#  endif /* __GNUC__ */
+# endif /* NO_INLINE */
+
+# ifndef NO_INLINE
+#  ifdef __GNUC__
+#   if (defined(linux) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)) && (defined(__alpha__))
+
+#    ifdef linux
+/* for Linux on Alpha, we use the LIBC _inx/_outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern _X_EXPORT void _outb(unsigned char val, unsigned long port);
+extern _X_EXPORT void _outw(unsigned short val, unsigned long port);
+extern _X_EXPORT void _outl(unsigned int val, unsigned long port);
+extern _X_EXPORT unsigned int _inb(unsigned long port);
+extern _X_EXPORT unsigned int _inw(unsigned long port);
+extern _X_EXPORT unsigned int _inl(unsigned long port);
+
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+    _outb(val, port);
+}
+
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+    _outw(val, port);
+}
+
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+    _outl(val, port);
+}
+
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+  return _inb(port);
+}
+
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+  return _inw(port);
+}
+
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+  return _inl(port);
+}
+
+#    endif /* linux */
+
+#    if (defined(__FreeBSD__) || defined(__OpenBSD__)) \
+      && !defined(DO_PROTOTYPES)
+
+/* for FreeBSD and OpenBSD on Alpha, we use the libio (resp. libalpha) */
+/*  inx/outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+extern _X_EXPORT void outb(unsigned int port, unsigned char val);
+extern _X_EXPORT void outw(unsigned int port, unsigned short val);
+extern _X_EXPORT void outl(unsigned int port, unsigned int val);
+extern _X_EXPORT unsigned char inb(unsigned int port);
+extern _X_EXPORT unsigned short inw(unsigned int port);
+extern _X_EXPORT unsigned int inl(unsigned int port);
+
+#    endif /* (__FreeBSD__ || __OpenBSD__ ) && !DO_PROTOTYPES */
+
+
+#if defined(__NetBSD__)
+#include <machine/pio.h>
+#endif /* __NetBSD__ */
+
+#   elif defined(linux) && defined(__ia64__) 
+ 
+#    include <inttypes.h>
+
+#    include <sys/io.h>
+
+#    undef outb
+#    undef outw
+#    undef outl
+#    undef inb
+#    undef inw
+#    undef inl
+extern _X_EXPORT void outb(unsigned long port, unsigned char val);
+extern _X_EXPORT void outw(unsigned long port, unsigned short val);
+extern _X_EXPORT void outl(unsigned long port, unsigned int val);
+extern _X_EXPORT unsigned int inb(unsigned long port);
+extern _X_EXPORT unsigned int inw(unsigned long port);
+extern _X_EXPORT unsigned int inl(unsigned long port);
+ 
+#   elif (defined(linux) || defined(__FreeBSD__)) && defined(__amd64__)
+ 
+#    include <inttypes.h>
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
+}
+
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+   unsigned char ret;
+   __asm__ __volatile__("inb %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+   unsigned short ret;
+   __asm__ __volatile__("inw %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+   unsigned int ret;
+   __asm__ __volatile__("inl %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+#   elif (defined(linux) || defined(sun) || defined(__OpenBSD__) || defined(__FreeBSD__)) && defined(__sparc__)
+
+#     ifndef ASI_PL
+#      define ASI_PL 0x88
+#     endif
+
+static __inline__ void
+outb(unsigned long port, unsigned char val)
+{
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+outw(unsigned long port, unsigned short val)
+{
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+outl(unsigned long port, unsigned int val)
+{
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (port), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ unsigned int
+inb(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lduba [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lduha [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned long port)
+{
+	unsigned int ret;
+	__asm__ __volatile__("lda [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (port), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned char ret;
+
+	__asm__ __volatile__("lduba [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned short ret;
+
+	__asm__ __volatile__("lduh [%1], %0"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned short ret;
+
+	__asm__ __volatile__("lduha [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("ld [%1], %0"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("lda [%1] %2, %0"
+			     : "=r" (ret)
+			     : "r" (addr), "i" (ASI_PL));
+	return ret;
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+	       const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sth %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("st %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+	barrier();
+}
+
+static __inline__ void
+xf86WriteMmio8NB(__volatile__ void *base, const unsigned long offset,
+		 const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stba %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio16BeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sth %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+
+static __inline__ void
+xf86WriteMmio16LeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("stha %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+static __inline__ void
+xf86WriteMmio32BeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("st %0, [%1]"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+
+static __inline__ void
+xf86WriteMmio32LeNB(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sta %0, [%1] %2"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr), "i" (ASI_PL));
+}
+
+#   elif defined(__mips__) || (defined(__arm32__) && !defined(__linux__))
+#    ifdef __arm32__
+#     define PORT_SIZE long
+#    else
+#     define PORT_SIZE short
+#    endif
+
+_X_EXPORT unsigned int IOPortBase;  /* Memory mapped I/O port area */
+
+static __inline__ void
+outb(unsigned PORT_SIZE port, unsigned char val)
+{
+	*(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ void
+outw(unsigned PORT_SIZE port, unsigned short val)
+{
+	*(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ void
+outl(unsigned PORT_SIZE port, unsigned int val)
+{
+	*(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase) = val;
+}
+
+static __inline__ unsigned int
+inb(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned char*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+static __inline__ unsigned int
+inw(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned short*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+static __inline__ unsigned int
+inl(unsigned PORT_SIZE port)
+{
+	return *(volatile unsigned int*)(((unsigned PORT_SIZE)(port))+IOPortBase);
+}
+
+
+#    if defined(__mips__)
+#     ifdef linux	/* don't mess with other OSs */
+#       if X_BYTE_ORDER == X_BIG_ENDIAN
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+	unsigned int ret;
+
+	__asm__ __volatile__("lw %0, 0(%1)"
+			     : "=r" (ret)
+			     : "r" (addr));
+	return ret;
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+		  const unsigned int val)
+{
+	unsigned long addr = ((unsigned long)base) + offset;
+
+	__asm__ __volatile__("sw %0, 0(%1)"
+			     : /* No outputs */
+			     : "r" (val), "r" (addr));
+}
+#      endif
+#     endif /* !linux */
+#    endif /* __mips__ */
+
+#   elif (defined(linux) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__)) && defined(__powerpc__)
+
+#    ifndef MAP_FAILED
+#     define MAP_FAILED ((void *)-1)
+#    endif
+
+extern _X_EXPORT volatile unsigned char *ioBase;
+
+static __inline__ unsigned char
+xf86ReadMmio8(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned char val;
+        __asm__ __volatile__(
+                        "lbzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Be(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned short val;
+        __asm__ __volatile__(
+                        "lhzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned short
+xf86ReadMmio16Le(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned short val;
+        __asm__ __volatile__(
+                        "lhbrx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Be(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned int val;
+        __asm__ __volatile__(
+                        "lwzx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ unsigned int
+xf86ReadMmio32Le(__volatile__ void *base, const unsigned long offset)
+{
+        register unsigned int val;
+        __asm__ __volatile__(
+                        "lwbrx %0,%1,%2\n\t"
+                        "eieio"
+                        : "=r" (val)
+                        : "b" (base), "r" (offset),
+                        "m" (*((volatile unsigned char *)base+offset)));
+        return val;
+}
+
+static __inline__ void
+xf86WriteMmioNB8(__volatile__ void *base, const unsigned long offset,
+		 const unsigned char val)
+{
+        __asm__ __volatile__(
+                        "stbx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Le(__volatile__ void *base, const unsigned long offset,
+		    const unsigned short val)
+{
+        __asm__ __volatile__(
+                        "sthbrx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB16Be(__volatile__ void *base, const unsigned long offset,
+		    const unsigned short val)
+{
+        __asm__ __volatile__(
+                        "sthx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Le(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+        __asm__ __volatile__(
+                        "stwbrx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmioNB32Be(__volatile__ void *base, const unsigned long offset,
+		    const unsigned int val)
+{
+        __asm__ __volatile__(
+                        "stwx %1,%2,%3\n\t"
+                        : "=m" (*((volatile unsigned char *)base+offset))
+                        : "r" (val), "b" (base), "r" (offset));
+}
+
+static __inline__ void
+xf86WriteMmio8(__volatile__ void *base, const unsigned long offset,
+               const unsigned char val)
+{
+        xf86WriteMmioNB8(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+        xf86WriteMmioNB16Le(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio16Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned short val)
+{
+        xf86WriteMmioNB16Be(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Le(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+        xf86WriteMmioNB32Le(base, offset, val);
+        eieio();
+}
+
+static __inline__ void
+xf86WriteMmio32Be(__volatile__ void *base, const unsigned long offset,
+                  const unsigned int val)
+{
+        xf86WriteMmioNB32Be(base, offset, val);
+        eieio();
+}
+
+
+static __inline__ void
+outb(unsigned short port, unsigned char value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio8((void *)ioBase, port, value);
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio16Le((void *)ioBase, port, value);
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int value)
+{
+        if(ioBase == MAP_FAILED) return;
+        xf86WriteMmio32Le((void *)ioBase, port, value);
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio8((void *)ioBase, port);
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio16Le((void *)ioBase, port);
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+        if(ioBase == MAP_FAILED) return 0;
+        return xf86ReadMmio32Le((void *)ioBase, port);
+}
+
+#elif defined(__arm__) && defined(__linux__)
+
+/* for Linux on ARM, we use the LIBC inx/outx routines */
+/* note that the appropriate setup via "ioperm" needs to be done */
+/*  *before* any inx/outx is done. */
+
+#include <sys/io.h>
+
+static __inline__ void
+xf_outb(unsigned short port, unsigned char val)
+{
+    outb(val, port);
+}
+
+static __inline__ void
+xf_outw(unsigned short port, unsigned short val)
+{
+    outw(val, port);
+}
+
+static __inline__ void
+xf_outl(unsigned short port, unsigned int val)
+{
+    outl(val, port);
+}
+
+#define outb xf_outb
+#define outw xf_outw
+#define outl xf_outl
+
+#   else /* ix86 */
+
+#    if !defined(__SUNPRO_C)
+#    if !defined(FAKEIT) && !defined(__mc68000__) && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__s390__) && !defined(__m32r__)
+#     ifdef GCCUSESGAS
+
+/*
+ * If gcc uses gas rather than the native assembler, the syntax of these
+ * inlines has to be different.		DHD
+ */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+   __asm__ __volatile__("outb %0,%1" : :"a" (val), "d" (port));
+}
+
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+   __asm__ __volatile__("outw %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+   __asm__ __volatile__("outl %0,%1" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+   unsigned char ret;
+   __asm__ __volatile__("inb %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+   unsigned short ret;
+   __asm__ __volatile__("inw %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+   unsigned int ret;
+   __asm__ __volatile__("inl %1,%0" :
+       "=a" (ret) :
+       "d" (port));
+   return ret;
+}
+
+#     else	/* GCCUSESGAS */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+  __asm__ __volatile__("out%B0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+  __asm__ __volatile__("out%W0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+  __asm__ __volatile__("out%L0 (%1)" : :"a" (val), "d" (port));
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+  unsigned char ret;
+  __asm__ __volatile__("in%B0 (%1)" :
+		   "=a" (ret) :
+		   "d" (port));
+  return ret;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+  unsigned short ret;
+  __asm__ __volatile__("in%W0 (%1)" :
+		   "=a" (ret) :
+		   "d" (port));
+  return ret;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+  unsigned int ret;
+  __asm__ __volatile__("in%L0 (%1)" :
+                   "=a" (ret) :
+                   "d" (port));
+  return ret;
+}
+
+#     endif /* GCCUSESGAS */
+
+#    else /* !defined(FAKEIT) && !defined(__mc68000__)  && !defined(__arm__) && !defined(__sh__) && !defined(__hppa__) && !defined(__m32r__) */
+
+static __inline__ void
+outb(unsigned short port, unsigned char val)
+{
+}
+
+static __inline__ void
+outw(unsigned short port, unsigned short val)
+{
+}
+
+static __inline__ void
+outl(unsigned short port, unsigned int val)
+{
+}
+
+static __inline__ unsigned int
+inb(unsigned short port)
+{
+  return 0;
+}
+
+static __inline__ unsigned int
+inw(unsigned short port)
+{
+  return 0;
+}
+
+static __inline__ unsigned int
+inl(unsigned short port)
+{
+  return 0;
+}
+
+#    endif /* FAKEIT */
+#    endif /* __SUNPRO_C */
+
+#   endif /* ix86 */
+
+#  else /* !GNUC */
+#    if defined(__STDC__) && (__STDC__ == 1)
+#     ifndef asm
+#      define asm __asm
+#     endif
+#    endif
+#    ifndef SCO325
+#     if defined(__UNIXWARE__)
+#     /* avoid including <sys/types.h> for <sys/inline.h> on UnixWare */
+#      define ushort unsigned short
+#      define ushort_t unsigned short
+#      define ulong unsigned long
+#      define ulong_t unsigned long
+#      define uint_t unsigned int
+#      define uchar_t unsigned char
+#     endif /* __UNIXWARE__ */
+#     if !defined(__SUNPRO_C)
+#      include <sys/inline.h>
+#     endif
+#    else
+#     include "scoasm.h"
+#    endif
+#    if !defined(__HIGHC__) && !defined(__SUNPRO_C) || \
+	defined(__USLC__)
+#     pragma asm partial_optimization outl
+#     pragma asm partial_optimization outw
+#     pragma asm partial_optimization outb
+#     pragma asm partial_optimization inl
+#     pragma asm partial_optimization inw
+#     pragma asm partial_optimization inb
+#    endif
+#  endif /* __GNUC__ */
+
+# endif /* NO_INLINE */
+
+# ifdef __alpha__
+/* entry points for Mmio memory access routines */
+extern _X_EXPORT int (*xf86ReadMmio8)(void *, unsigned long);
+extern _X_EXPORT int (*xf86ReadMmio16)(void *, unsigned long);
+#  ifndef STANDALONE_MMIO
+extern _X_EXPORT int (*xf86ReadMmio32)(void *, unsigned long);
+#  else
+/* Some DRI 3D drivers need MMIO_IN32. */
+static __inline__ int
+xf86ReadMmio32(void *Base, unsigned long Offset)
+{
+	mem_barrier();
+	return *(volatile unsigned int*)((unsigned long)Base+(Offset));
+}
+#  endif
+extern _X_EXPORT void (*xf86WriteMmio8)(int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmio16)(int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmio32)(int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB8)(int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB16)(int, void *, unsigned long);
+extern _X_EXPORT void (*xf86WriteMmioNB32)(int, void *, unsigned long);
+extern _X_EXPORT void xf86SlowBCopyFromBus(unsigned char *, unsigned char *, int);
+extern _X_EXPORT void xf86SlowBCopyToBus(unsigned char *, unsigned char *, int);
+
+/* Some macros to hide the system dependencies for MMIO accesses */
+/* Changed to kill noise generated by gcc's -Wcast-align */
+#  define MMIO_IN8(base, offset) (*xf86ReadMmio8)(base, offset)
+#  define MMIO_IN16(base, offset) (*xf86ReadMmio16)(base, offset)
+#  ifndef STANDALONE_MMIO
+#   define MMIO_IN32(base, offset) (*xf86ReadMmio32)(base, offset)
+#  else
+#   define MMIO_IN32(base, offset) xf86ReadMmio32(base, offset)
+#  endif
+
+#  define MMIO_OUT32(base, offset, val) \
+    do { \
+	write_mem_barrier(); \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val); \
+    } while (0)
+#  define MMIO_ONB32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+
+#  define MMIO_OUT8(base, offset, val) \
+    (*xf86WriteMmio8)((CARD8)(val), base, offset)
+#  define MMIO_OUT16(base, offset, val) \
+    (*xf86WriteMmio16)((CARD16)(val), base, offset)
+#  define MMIO_ONB8(base, offset, val) \
+    (*xf86WriteMmioNB8)((CARD8)(val), base, offset)
+#  define MMIO_ONB16(base, offset, val) \
+    (*xf86WriteMmioNB16)((CARD16)(val), base, offset)
+#  define MMIO_MOVE32(base, offset, val) \
+    MMIO_OUT32(base, offset, val)
+
+# elif defined(__powerpc__)  
+ /* 
+  * we provide byteswapping and no byteswapping functions here
+  * with byteswapping as default, 
+  * drivers that don't need byteswapping should define PPC_MMIO_IS_BE 
+  */
+#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#  define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#  define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmioNB8(base, offset, (CARD8)(val))
+
+#  if defined(PPC_MMIO_IS_BE) /* No byteswapping */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+    xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+    xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+    xf86WriteMmioNB16Be(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+    xf86WriteMmioNB32Be(base, offset, (CARD32)(val))
+#  else /* byteswapping is the default */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmioNB16Le(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmioNB32Le(base, offset, (CARD32)(val))
+#  endif
+
+#  define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+# elif defined(__sparc__) || defined(sparc) || defined(__sparc)
+ /*
+  * Like powerpc, we provide byteswapping and no byteswapping functions
+  * here with byteswapping as default, drivers that don't need byteswapping
+  * should define SPARC_MMIO_IS_BE (perhaps create a generic macro so that we
+  * do not need to use PPC_MMIO_IS_BE and the sparc one in all the same places
+  * of drivers?).
+  */
+#  define MMIO_IN8(base, offset) xf86ReadMmio8(base, offset)
+#  define MMIO_OUT8(base, offset, val) \
+    xf86WriteMmio8(base, offset, (CARD8)(val))
+#  define MMIO_ONB8(base, offset, val) \
+    xf86WriteMmio8NB(base, offset, (CARD8)(val))
+
+#  if defined(SPARC_MMIO_IS_BE) /* No byteswapping */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Be(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Be(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Be(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Be(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16BeNB(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32BeNB(base, offset, (CARD32)(val))
+#  else /* byteswapping is the default */
+#   define MMIO_IN16(base, offset) xf86ReadMmio16Le(base, offset)
+#   define MMIO_IN32(base, offset) xf86ReadMmio32Le(base, offset)
+#   define MMIO_OUT16(base, offset, val) \
+     xf86WriteMmio16Le(base, offset, (CARD16)(val))
+#   define MMIO_OUT32(base, offset, val) \
+     xf86WriteMmio32Le(base, offset, (CARD32)(val))
+#   define MMIO_ONB16(base, offset, val) \
+     xf86WriteMmio16LeNB(base, offset, (CARD16)(val))
+#   define MMIO_ONB32(base, offset, val) \
+     xf86WriteMmio32LeNB(base, offset, (CARD32)(val))
+#  endif
+
+#  define MMIO_MOVE32(base, offset, val) \
+       xf86WriteMmio32Be(base, offset, (CARD32)(val))
+
+# else /* !__alpha__ && !__powerpc__ && !__sparc__ */
+
+#  define MMIO_IN8(base, offset) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset))
+#  define MMIO_IN16(base, offset) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset))
+#  define MMIO_IN32(base, offset) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset))
+#  define MMIO_OUT8(base, offset, val) \
+	*(volatile CARD8 *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_OUT16(base, offset, val) \
+	*(volatile CARD16 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_OUT32(base, offset, val) \
+	*(volatile CARD32 *)(void *)(((CARD8*)(base)) + (offset)) = (val)
+#  define MMIO_ONB8(base, offset, val) MMIO_OUT8(base, offset, val) 
+#  define MMIO_ONB16(base, offset, val) MMIO_OUT16(base, offset, val) 
+#  define MMIO_ONB32(base, offset, val) MMIO_OUT32(base, offset, val) 
+
+#  define MMIO_MOVE32(base, offset, val) MMIO_OUT32(base, offset, val)
+
+# endif /* __alpha__ */
+
+/*
+ * With Intel, the version in os-support/misc/SlowBcopy.s is used.
+ * This avoids port I/O during the copy (which causes problems with
+ * some hardware).
+ */
+# ifdef __alpha__
+#  define slowbcopy_tobus(src,dst,count) xf86SlowBCopyToBus(src,dst,count)
+#  define slowbcopy_frombus(src,dst,count) xf86SlowBCopyFromBus(src,dst,count)
+# else /* __alpha__ */
+#  define slowbcopy_tobus(src,dst,count) xf86SlowBcopy(src,dst,count)
+#  define slowbcopy_frombus(src,dst,count) xf86SlowBcopy(src,dst,count)
+# endif /* __alpha__ */
+
+#endif /* _COMPILER_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miline.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miline.h
@@ -0,0 +1,173 @@
+
+/*
+
+Copyright 1994, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+*/
+
+#ifndef MILINE_H
+
+#include "screenint.h"
+#include "privates.h"
+
+/*
+ * Public definitions used for configuring basic pixelization aspects
+ * of the sample implementation line-drawing routines provided in
+ * {mfb,mi,cfb*} at run-time.
+ */
+
+#define XDECREASING	4
+#define YDECREASING	2
+#define YMAJOR		1
+
+#define OCTANT1		(1 << (YDECREASING))
+#define OCTANT2		(1 << (YDECREASING|YMAJOR))
+#define OCTANT3		(1 << (XDECREASING|YDECREASING|YMAJOR))
+#define OCTANT4		(1 << (XDECREASING|YDECREASING))
+#define OCTANT5		(1 << (XDECREASING))
+#define OCTANT6		(1 << (XDECREASING|YMAJOR))
+#define OCTANT7		(1 << (YMAJOR))
+#define OCTANT8		(1 << (0))
+
+#define XMAJOROCTANTS		(OCTANT1 | OCTANT4 | OCTANT5 | OCTANT8)
+
+#define DEFAULTZEROLINEBIAS	(OCTANT2 | OCTANT3 | OCTANT4 | OCTANT5)
+
+/*
+ * Devices can configure the rendering of routines in mi, mfb, and cfb*
+ * by specifying a thin line bias to be applied to a particular screen
+ * using the following function.  The bias parameter is an OR'ing of
+ * the appropriate OCTANT constants defined above to indicate which
+ * octants to bias a line to prefer an axial step when the Bresenham
+ * error term is exactly zero.  The octants are mapped as follows:
+ *
+ *   \    |    /
+ *    \ 3 | 2 /
+ *     \  |  /
+ *    4 \ | / 1
+ *       \|/
+ *   -----------
+ *       /|\
+ *    5 / | \ 8
+ *     /  |  \
+ *    / 6 | 7 \
+ *   /    |    \
+ *
+ * For more information, see "Ambiguities in Incremental Line Rastering,"
+ * Jack E. Bresenham, IEEE CG&A, May 1987.
+ */
+
+extern _X_EXPORT void miSetZeroLineBias(
+    ScreenPtr /* pScreen */,
+    unsigned int /* bias */
+);
+
+/*
+ * Private definitions needed for drawing thin (zero width) lines
+ * Used by the mi, mfb, and all cfb* components.
+ */
+
+#define X_AXIS	0
+#define Y_AXIS	1
+
+#define OUT_LEFT  0x08
+#define OUT_RIGHT 0x04
+#define OUT_ABOVE 0x02
+#define OUT_BELOW 0x01
+
+#define OUTCODES(_result, _x, _y, _pbox) \
+    if	    ( (_x) <  (_pbox)->x1) (_result) |= OUT_LEFT; \
+    else if ( (_x) >= (_pbox)->x2) (_result) |= OUT_RIGHT; \
+    if	    ( (_y) <  (_pbox)->y1) (_result) |= OUT_ABOVE; \
+    else if ( (_y) >= (_pbox)->y2) (_result) |= OUT_BELOW;
+
+#define MIOUTCODES(outcode, x, y, xmin, ymin, xmax, ymax) \
+{\
+     if (x < xmin) outcode |= OUT_LEFT;\
+     if (x > xmax) outcode |= OUT_RIGHT;\
+     if (y < ymin) outcode |= OUT_ABOVE;\
+     if (y > ymax) outcode |= OUT_BELOW;\
+}
+  
+#define SWAPINT(i, j) \
+{  int _t = i;  i = j;  j = _t; }
+
+#define SWAPPT(i, j) \
+{  DDXPointRec _t; _t = i;  i = j; j = _t; }
+
+#define SWAPINT_PAIR(x1, y1, x2, y2)\
+{   int t = x1;  x1 = x2;  x2 = t;\
+        t = y1;  y1 = y2;  y2 = t;\
+}
+
+#define miGetZeroLineBias(_pScreen) ((unsigned long) (unsigned long*)\
+    dixLookupPrivate(&(_pScreen)->devPrivates, miZeroLineScreenKey))
+
+#define CalcLineDeltas(_x1,_y1,_x2,_y2,_adx,_ady,_sx,_sy,_SX,_SY,_octant) \
+    (_octant) = 0;				\
+    (_sx) = (_SX);				\
+    if (((_adx) = (_x2) - (_x1)) < 0) {		\
+	(_adx) = -(_adx);			\
+	(_sx = -(_sx));				\
+	(_octant) |= XDECREASING;		\
+    }						\
+    (_sy) = (_SY);				\
+    if (((_ady) = (_y2) - (_y1)) < 0) {		\
+	(_ady) = -(_ady);			\
+	(_sy = -(_sy));				\
+	(_octant) |= YDECREASING;		\
+    }
+
+#define SetYMajorOctant(_octant)	((_octant) |= YMAJOR)
+
+#define FIXUP_ERROR(_e, _octant, _bias) \
+    (_e) -= (((_bias) >> (_octant)) & 1)
+
+#define IsXMajorOctant(_octant)		(!((_octant) & YMAJOR))
+#define IsYMajorOctant(_octant)		((_octant) & YMAJOR)
+#define IsXDecreasingOctant(_octant)	((_octant) & XDECREASING)
+#define IsYDecreasingOctant(_octant)	((_octant) & YDECREASING)
+
+extern _X_EXPORT DevPrivateKeyRec miZeroLineScreenKeyRec;
+#define miZeroLineScreenKey (&miZeroLineScreenKeyRec)
+
+extern _X_EXPORT int miZeroClipLine(
+    int /*xmin*/,
+    int /*ymin*/,
+    int /*xmax*/,
+    int /*ymax*/,
+    int * /*new_x1*/,
+    int * /*new_y1*/,
+    int * /*new_x2*/,
+    int * /*new_y2*/,
+    unsigned int /*adx*/,
+    unsigned int /*ady*/,
+    int * /*pt1_clipped*/,
+    int * /*pt2_clipped*/,
+    int /*octant*/,
+    unsigned int /*bias*/,
+    int /*oc1*/,
+    int /*oc2*/
+);
+
+#endif /* MILINE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damage.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damage.h
@@ -0,0 +1,128 @@
+/*
+ * Copyright © 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGE_H_
+#define _DAMAGE_H_
+
+typedef struct _damage	*DamagePtr;
+
+typedef enum _damageReportLevel {
+    DamageReportRawRegion,
+    DamageReportDeltaRegion,
+    DamageReportBoundingBox,
+    DamageReportNonEmpty,
+    DamageReportNone
+} DamageReportLevel;
+
+typedef void (*DamageReportFunc) (DamagePtr pDamage, RegionPtr pRegion, void *closure);
+typedef void (*DamageDestroyFunc) (DamagePtr pDamage, void *closure);
+/* It's the responsibility of the driver to duplicate both regions. */
+/* At some point DamageRegionRendered() must be called. */
+typedef void (*DamageMarkerFunc) (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion, void *closure);
+
+typedef void (*DamageScreenCreateFunc) (DamagePtr);
+typedef void (*DamageScreenRegisterFunc) (DrawablePtr, DamagePtr);
+typedef void (*DamageScreenUnregisterFunc) (DrawablePtr, DamagePtr);
+typedef void (*DamageScreenDestroyFunc) (DamagePtr);
+
+typedef struct _damageScreenFuncs {
+    DamageScreenCreateFunc      Create;
+    DamageScreenRegisterFunc    Register;
+    DamageScreenUnregisterFunc  Unregister;
+    DamageScreenDestroyFunc     Destroy;
+} DamageScreenFuncsRec, *DamageScreenFuncsPtr;
+
+extern _X_EXPORT void miDamageCreate (DamagePtr);
+extern _X_EXPORT void miDamageRegister (DrawablePtr, DamagePtr);
+extern _X_EXPORT void miDamageUnregister (DrawablePtr, DamagePtr);
+extern _X_EXPORT void miDamageDestroy (DamagePtr);
+
+extern _X_EXPORT Bool
+DamageSetup (ScreenPtr pScreen);
+    
+extern _X_EXPORT DamagePtr
+DamageCreate (DamageReportFunc  damageReport,
+	      DamageDestroyFunc	damageDestroy,
+	      DamageReportLevel damageLevel,
+	      Bool		isInternal,
+	      ScreenPtr		pScreen,
+	      void *		closure);
+
+extern _X_EXPORT void
+DamageDrawInternal (ScreenPtr pScreen, Bool enable);
+
+extern _X_EXPORT void
+DamageRegister (DrawablePtr	pDrawable,
+		DamagePtr	pDamage);
+
+extern _X_EXPORT void
+DamageUnregister (DrawablePtr	pDrawable,
+		  DamagePtr	pDamage);
+
+extern _X_EXPORT void
+DamageDestroy (DamagePtr pDamage);
+
+extern _X_EXPORT Bool
+DamageSubtract (DamagePtr	    pDamage,
+		const RegionPtr	    pRegion);
+
+extern _X_EXPORT void
+DamageEmpty (DamagePtr pDamage);
+
+extern _X_EXPORT RegionPtr
+DamageRegion (DamagePtr		    pDamage);
+
+extern _X_EXPORT RegionPtr
+DamagePendingRegion (DamagePtr	    pDamage);
+
+/* In case of rendering, call this before the submitting the commands. */
+extern _X_EXPORT void
+DamageRegionAppend (DrawablePtr pDrawable, RegionPtr pRegion);
+
+/* Call this directly after the rendering operation has been submitted. */
+extern _X_EXPORT void
+DamageRegionProcessPending (DrawablePtr pDrawable);
+
+/* Call this some time after rendering is done, only relevant when a damageMarker is provided. */
+extern _X_EXPORT void
+DamageRegionRendered (DrawablePtr pDrawable, DamagePtr pDamage, RegionPtr pOldDamage, RegionPtr pRegion);
+
+/* Avoid using this call, it only exists for API compatibility. */
+extern _X_EXPORT void
+DamageDamageRegion (DrawablePtr	    pDrawable,
+		    const RegionPtr pRegion);
+
+extern _X_EXPORT void
+DamageSetReportAfterOp (DamagePtr pDamage, Bool reportAfter);
+
+extern _X_EXPORT void
+DamageSetPostRenderingFunctions(DamagePtr pDamage, DamageReportFunc damageReportPostRendering,
+				DamageMarkerFunc damageMarker);
+
+extern _X_EXPORT DamageScreenFuncsPtr
+DamageGetScreenFuncs (ScreenPtr);
+
+#endif /* _DAMAGE_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getvers.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getvers.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETVERS_H
+#define GETVERS_H 1
+
+int SProcXGetExtensionVersion(ClientPtr	/* client */
+    );
+
+int ProcXGetExtensionVersion(ClientPtr	/* client */
+    );
+
+void SRepXGetExtensionVersion(ClientPtr /* client */ ,
+			      int /* size */ ,
+			      xGetExtensionVersionReply *	/* rep */
+    );
+
+#endif /* GETVERS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dgaproc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dgaproc.h
@@ -0,0 +1,143 @@
+
+#ifndef __DGAPROC_H
+#define __DGAPROC_H
+
+#include <X11/Xproto.h>
+#include "pixmap.h"
+
+#define DGA_CONCURRENT_ACCESS	0x00000001
+#define DGA_FILL_RECT		0x00000002
+#define DGA_BLIT_RECT		0x00000004
+#define DGA_BLIT_RECT_TRANS	0x00000008
+#define DGA_PIXMAP_AVAILABLE	0x00000010
+
+#define DGA_INTERLACED		0x00010000
+#define DGA_DOUBLESCAN		0x00020000
+
+#define DGA_FLIP_IMMEDIATE	0x00000001
+#define DGA_FLIP_RETRACE	0x00000002
+
+#define DGA_COMPLETED		0x00000000
+#define DGA_PENDING		0x00000001
+
+#define DGA_NEED_ROOT		0x00000001
+
+typedef struct {
+   int num;		/* A unique identifier for the mode (num > 0) */
+   char *name;		/* name of mode given in the XF86Config */
+   int VSync_num;
+   int VSync_den;
+   int flags;		/* DGA_CONCURRENT_ACCESS, etc... */
+   int imageWidth;	/* linear accessible portion (pixels) */
+   int imageHeight;
+   int pixmapWidth;	/* Xlib accessible portion (pixels) */
+   int pixmapHeight;	/* both fields ignored if no concurrent access */
+   int bytesPerScanline; 
+   int byteOrder;	/* MSBFirst, LSBFirst */
+   int depth;		
+   int bitsPerPixel;
+   unsigned long red_mask;
+   unsigned long green_mask;
+   unsigned long blue_mask;
+   short visualClass;
+   int viewportWidth;
+   int viewportHeight;
+   int xViewportStep;	/* viewport position granularity */
+   int yViewportStep;
+   int maxViewportX;	/* max viewport origin */
+   int maxViewportY;
+   int viewportFlags;	/* types of page flipping possible */
+   int offset;
+   int reserved1;
+   int reserved2;
+} XDGAModeRec, *XDGAModePtr;
+
+/* DDX interface */
+
+extern _X_EXPORT int
+DGASetMode(
+   int Index,
+   int num,
+   XDGAModePtr mode,
+   PixmapPtr *pPix
+);
+
+extern _X_EXPORT void
+DGASetInputMode(
+   int Index,
+   Bool keyboard,
+   Bool mouse
+);
+
+extern _X_EXPORT void
+DGASelectInput(
+   int Index,
+   ClientPtr client,
+   long mask
+);
+
+extern _X_EXPORT Bool DGAAvailable(int Index);
+extern _X_EXPORT Bool DGAActive(int Index);
+extern _X_EXPORT void DGAShutdown(void);
+extern _X_EXPORT void DGAInstallCmap(ColormapPtr cmap);
+extern _X_EXPORT int DGAGetViewportStatus(int Index);
+extern _X_EXPORT int DGASync(int Index);
+
+extern _X_EXPORT int
+DGAFillRect(
+   int Index,
+   int x, int y, int w, int h,
+   unsigned long color
+);
+
+extern _X_EXPORT int
+DGABlitRect(
+   int Index,
+   int srcx, int srcy, 
+   int w, int h, 
+   int dstx, int dsty
+);
+
+extern _X_EXPORT int
+DGABlitTransRect(
+   int Index,
+   int srcx, int srcy, 
+   int w, int h, 
+   int dstx, int dsty,
+   unsigned long color
+);
+
+extern _X_EXPORT int
+DGASetViewport(
+   int Index,
+   int x, int y,
+   int mode
+); 
+
+extern _X_EXPORT int DGAGetModes(int Index);
+extern _X_EXPORT int DGAGetOldDGAMode(int Index);
+
+extern _X_EXPORT int DGAGetModeInfo(int Index, XDGAModePtr mode, int num);
+
+extern _X_EXPORT Bool DGAVTSwitch(void);
+extern _X_EXPORT Bool DGAStealButtonEvent(DeviceIntPtr dev, int Index, int button,
+                         int is_down);
+extern _X_EXPORT Bool DGAStealMotionEvent(DeviceIntPtr dev, int Index, int dx, int dy);
+extern _X_EXPORT Bool DGAStealKeyEvent(DeviceIntPtr dev, int Index, int key_code, int is_down);
+extern _X_EXPORT Bool DGAIsDgaEvent (xEvent *e);
+	    
+extern _X_EXPORT Bool DGAOpenFramebuffer(int Index, char **name, unsigned char **mem,
+			int *size, int *offset, int *flags);
+extern _X_EXPORT void DGACloseFramebuffer(int Index);
+extern _X_EXPORT Bool DGAChangePixmapMode(int Index, int *x, int *y, int mode);
+extern _X_EXPORT int DGACreateColormap(int Index, ClientPtr client, int id, int mode,
+			int alloc);
+
+extern _X_EXPORT unsigned char DGAReqCode;
+extern _X_EXPORT int DGAErrorBase;
+extern _X_EXPORT int DGAEventBase;
+extern _X_EXPORT int *XDGAEventBase;
+
+
+
+#endif /* __DGAPROC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxserver.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxserver.h
@@ -0,0 +1,317 @@
+#ifndef _GLX_server_h_
+#define _GLX_server_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#include "dmx.h"
+
+#include <misc.h>
+#include <dixstruct.h>
+#include <pixmapstr.h>
+#include <gcstruct.h>
+#include <extnsionst.h>
+#include <resource.h>
+#include <scrnintstr.h>
+
+
+/*
+** The X header misc.h defines these math functions.
+*/
+#undef abs
+#undef fabs
+
+#define GL_GLEXT_PROTOTYPES /* we want prototypes */
+#include <GL/gl.h>
+#include <GL/glxproto.h>
+#include <GL/glxint.h>
+
+#include "glxscreens.h"
+#include "glxdrawable.h"
+#include "glxcontext.h"
+#include "glxerror.h"
+
+
+#define GLX_SERVER_MAJOR_VERSION 1
+#define GLX_SERVER_MINOR_VERSION 3
+
+#ifndef True
+#define True 1
+#endif
+#ifndef False
+#define False 0
+#endif
+
+/*
+** GLX resources.
+typedef XID GLXContextID;
+typedef XID GLXPixmap;
+typedef XID GLXDrawable;
+typedef XID GLXWindow;
+typedef XID GLXPbuffer;
+
+typedef struct __GLXcontextRec *GLXContext;
+*/
+typedef struct __GLXclientStateRec __GLXclientState;
+
+extern __GLXscreenInfo *__glXActiveScreens;
+extern GLint __glXNumActiveScreens;
+
+/************************************************************************/
+
+/*
+** The last context used (from the server's persective) is cached.
+*/
+extern __GLXcontext *__glXLastContext;
+extern __GLXcontext *__glXForceCurrent(__GLXclientState*, GLXContextTag, int*);
+
+/*
+** Macros to set, unset, and retrieve the flag that says whether a context
+** has unflushed commands.
+*/
+#define __GLX_NOTE_UNFLUSHED_CMDS(glxc) glxc->hasUnflushedCommands = GL_TRUE
+#define __GLX_NOTE_FLUSHED_CMDS(glxc) glxc->hasUnflushedCommands = GL_FALSE
+#define __GLX_HAS_UNFLUSHED_CMDS(glxc) (glxc->hasUnflushedCommands)
+
+/************************************************************************/
+
+typedef struct {
+   int elem_size;  /* element size in bytes */
+   int nelems;     /* number of elements to swap */
+   void (*swapfunc)(GLbyte *pc);
+} __GLXRenderSwapInfo;
+
+/*
+** State kept per client.
+*/
+struct __GLXclientStateRec {
+    /*
+    ** Whether this structure is currently being used to support a client.
+    */
+    Bool inUse;
+
+    /*
+    ** Buffer for returned data.
+    */
+    GLbyte *returnBuf;
+    GLint returnBufSize;
+
+    /*
+    ** Keep a list of all the contexts that are current for this client's
+    ** threads.
+    */
+    __GLXcontext **currentContexts;
+    DrawablePtr *currentDrawables;
+    GLint numCurrentContexts;
+
+    /* Back pointer to X client record */
+    ClientPtr client;
+
+    int GLClientmajorVersion;
+    int GLClientminorVersion;
+    char *GLClientextensions;
+
+    GLXContextTag  *be_currentCTag;
+    Display **be_displays;
+
+    /*
+    ** Keep track of large rendering commands, which span multiple requests.
+    */
+    GLint largeCmdBytesSoFar;		/* bytes received so far	*/
+    GLint largeCmdBytesTotal;		/* total bytes expected		*/
+    GLint largeCmdRequestsSoFar;	/* requests received so far	*/
+    GLint largeCmdRequestsTotal;	/* total requests expected	*/
+    void (*largeCmdRequestsSwapProc)(GLbyte *); 
+    __GLXRenderSwapInfo  *largeCmdRequestsSwap_info;
+    GLbyte *largeCmdBuf;
+    GLint largeCmdBufSize;
+    GLint largeCmdMaxReqDataSize;
+
+};
+
+extern __GLXclientState *__glXClients[];
+
+/************************************************************************/
+
+/*
+** Dispatch tables.
+*/
+typedef void (*__GLXdispatchRenderProcPtr)(GLbyte *);
+typedef int (*__GLXdispatchSingleProcPtr)(__GLXclientState *, GLbyte *);
+typedef int (*__GLXdispatchVendorPrivProcPtr)(__GLXclientState *, GLbyte *);
+extern __GLXdispatchSingleProcPtr __glXSingleTable[];
+extern __GLXdispatchVendorPrivProcPtr __glXVendorPrivTable_EXT[];
+extern __GLXdispatchSingleProcPtr __glXSwapSingleTable[];
+extern __GLXdispatchVendorPrivProcPtr __glXSwapVendorPrivTable_EXT[];
+extern __GLXdispatchRenderProcPtr __glXSwapRenderTable[];
+
+extern __GLXRenderSwapInfo __glXSwapRenderTable_EXT[];
+
+/*
+ * Dispatch for GLX commands.
+ */
+typedef int (*__GLXprocPtr)(__GLXclientState *, char *pc);
+extern __GLXprocPtr __glXProcTable[];
+
+/*
+ * Tables for computing the size of each rendering command.
+ */
+typedef struct {
+    int bytes;
+    int (*varsize)(GLbyte *pc, Bool swap);
+} __GLXrenderSizeData;
+extern __GLXrenderSizeData __glXRenderSizeTable[];
+extern __GLXrenderSizeData __glXRenderSizeTable_EXT[];
+
+/************************************************************************/
+
+/*
+** X resources.
+*/
+extern RESTYPE __glXContextRes;
+extern RESTYPE __glXClientRes;
+extern RESTYPE __glXPixmapRes;
+extern RESTYPE __glXDrawableRes;
+extern RESTYPE __glXWindowRes;
+extern RESTYPE __glXPbufferRes;
+
+/************************************************************************/
+
+/*
+** Prototypes.
+*/
+
+
+extern char *__glXcombine_strings(const char *, const char *);
+
+extern void __glXDisp_DrawArrays(GLbyte*);
+extern void __glXDispSwap_DrawArrays(GLbyte*);
+
+
+/*
+** Routines for sending swapped replies.
+*/
+
+extern void __glXSwapMakeCurrentReply(ClientPtr client,  
+                                      xGLXMakeCurrentReadSGIReply *reply);
+
+extern void __glXSwapIsDirectReply(ClientPtr client,
+				   xGLXIsDirectReply *reply);
+extern void __glXSwapQueryVersionReply(ClientPtr client,
+				       xGLXQueryVersionReply *reply);
+extern void __glXSwapQueryContextInfoEXTReply(ClientPtr client,
+					      xGLXQueryContextInfoEXTReply *reply,
+					      int *buf);
+extern void glxSwapQueryExtensionsStringReply(ClientPtr client,
+				xGLXQueryExtensionsStringReply *reply, char *buf);
+extern void glxSwapQueryServerStringReply(ClientPtr client,
+				xGLXQueryServerStringReply *reply, char *buf);
+extern void __glXSwapQueryContextReply(ClientPtr client,
+                                xGLXQueryContextReply *reply, int *buf);
+extern void __glXSwapGetDrawableAttributesReply(ClientPtr client,
+                             xGLXGetDrawableAttributesReply *reply, int *buf);
+extern void __glXSwapQueryMaxSwapBarriersSGIXReply(ClientPtr client,
+				   xGLXQueryMaxSwapBarriersSGIXReply *reply);
+
+/*
+ * Routines for computing the size of variably-sized rendering commands.
+ */
+
+extern int __glXTypeSize(GLenum enm);
+extern int __glXImageSize(GLenum format, GLenum type, GLsizei w, GLsizei h,
+			  GLint rowLength, GLint skipRows, GLint alignment);
+extern int __glXImage3DSize(GLenum format, GLenum type,
+			    GLsizei w, GLsizei h, GLsizei d,
+			    GLint imageHeight, GLint rowLength,
+			    GLint skipImages, GLint skipRows,
+			    GLint alignment);
+
+extern int __glXCallListsReqSize(GLbyte *pc, Bool swap);
+extern int __glXBitmapReqSize(GLbyte *pc, Bool swap);
+extern int __glXFogfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXFogivReqSize(GLbyte *pc, Bool swap);
+extern int __glXLightfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXLightivReqSize(GLbyte *pc, Bool swap);
+extern int __glXLightModelfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXLightModelivReqSize(GLbyte *pc, Bool swap);
+extern int __glXMaterialfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXMaterialivReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexParameterfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexParameterivReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexImage1DReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexImage2DReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexEnvfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexEnvivReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexGendvReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexGenfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexGenivReqSize(GLbyte *pc, Bool swap);
+extern int __glXMap1dReqSize(GLbyte *pc, Bool swap);
+extern int __glXMap1fReqSize(GLbyte *pc, Bool swap);
+extern int __glXMap2dReqSize(GLbyte *pc, Bool swap);
+extern int __glXMap2fReqSize(GLbyte *pc, Bool swap);
+extern int __glXPixelMapfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXPixelMapuivReqSize(GLbyte *pc, Bool swap);
+extern int __glXPixelMapusvReqSize(GLbyte *pc, Bool swap);
+extern int __glXDrawPixelsReqSize(GLbyte *pc, Bool swap);
+extern int __glXDrawArraysSize(GLbyte *pc, Bool swap);
+extern int __glXPrioritizeTexturesReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexSubImage1DReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexSubImage2DReqSize(GLbyte *pc, Bool swap);
+extern int __glXTexImage3DReqSize(GLbyte *pc, Bool swap );
+extern int __glXTexSubImage3DReqSize(GLbyte *pc, Bool swap);
+extern int __glXConvolutionFilter1DReqSize(GLbyte *pc, Bool swap);
+extern int __glXConvolutionFilter2DReqSize(GLbyte *pc, Bool swap);
+extern int __glXConvolutionParameterivReqSize(GLbyte *pc, Bool swap);
+extern int __glXConvolutionParameterfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXSeparableFilter2DReqSize(GLbyte *pc, Bool swap);
+extern int __glXColorTableReqSize(GLbyte *pc, Bool swap);
+extern int __glXColorSubTableReqSize(GLbyte *pc, Bool swap);
+extern int __glXColorTableParameterfvReqSize(GLbyte *pc, Bool swap);
+extern int __glXColorTableParameterivReqSize(GLbyte *pc, Bool swap);
+
+/*
+ * Routines for computing the size of returned data.
+ */
+extern int __glXConvolutionParameterivSize(GLenum pname);
+extern int __glXConvolutionParameterfvSize(GLenum pname);
+extern int __glXColorTableParameterfvSize(GLenum pname);
+extern int __glXColorTableParameterivSize(GLenum pname);
+
+extern void __glXFreeGLXWindow(__glXWindow *pGlxWindow);
+extern void __glXFreeGLXPbuffer(__glXPbuffer *pGlxPbuffer);
+
+extern int __glXVersionMajor;
+extern int __glXVersionMinor;
+
+#define __GLX_IS_VERSION_SUPPORTED(major,minor) \
+         ( (__glXVersionMajor > (major)) || \
+           ((__glXVersionMajor == (major)) && (__glXVersionMinor >= (minor))) )
+
+#endif /* !__GLX_server_h__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvmodproc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvmodproc.h
@@ -0,0 +1,13 @@
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "xvmcext.h"
+
+extern DevPrivateKey (*XvGetScreenKeyProc)(void);
+extern unsigned long (*XvGetRTPortProc)(void);
+extern int (*XvScreenInitProc)(ScreenPtr);
+extern int (*XvMCScreenInitProc)(ScreenPtr, int, XvMCAdaptorPtr);
+
+extern void XvRegister(void);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86_OSlib.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86_OSlib.h
@@ -0,0 +1,454 @@
+/*
+ * Copyright 1990, 1991 by Thomas Roell, Dinkelscherben, Germany
+ * Copyright 1992 by David Dawes <dawes@XFree86.org>
+ * Copyright 1992 by Jim Tsillas <jtsilla@damon.ccs.northeastern.edu>
+ * Copyright 1992 by Rich Murphey <Rich@Rice.edu>
+ * Copyright 1992 by Robert Baron <Robert.Baron@ernst.mach.cs.cmu.edu>
+ * Copyright 1992 by Orest Zborowski <obz@eskimo.com>
+ * Copyright 1993 by Vrije Universiteit, The Netherlands
+ * Copyright 1993 by David Wexelblat <dwex@XFree86.org>
+ * Copyright 1994, 1996 by Holger Veit <Holger.Veit@gmd.de>
+ * Copyright 1997 by Takis Psarogiannakopoulos <takis@dpmms.cam.ac.uk>
+ * Copyright 1994-2003 by The XFree86 Project, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the names of the above listed copyright holders 
+ * not be used in advertising or publicity pertaining to distribution of 
+ * the software without specific, written prior permission.  The above listed
+ * copyright holders make no representations about the suitability of this 
+ * software for any purpose.  It is provided "as is" without express or 
+ * implied warranty.
+ *
+ * THE ABOVE LISTED COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD 
+ * TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY 
+ * AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDERS BE 
+ * LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 
+ * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER 
+ * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING 
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ */
+
+/*
+ * The ARM32 code here carries the following copyright:
+ *
+ * Copyright 1997
+ * Digital Equipment Corporation. All rights reserved.
+ * This software is furnished under license and may be used and copied only in 
+ * accordance with the following terms and conditions.  Subject to these
+ * conditions, you may download, copy, install, use, modify and distribute
+ * this software in source and/or binary form. No title or ownership is
+ * transferred hereby.
+ *
+ * 1) Any source code used, modified or distributed must reproduce and retain
+ *    this copyright notice and list of conditions as they appear in the
+ *    source file.
+ *
+ * 2) No right is granted to use any trade name, trademark, or logo of Digital 
+ *    Equipment Corporation. Neither the "Digital Equipment Corporation"
+ *    name nor any trademark or logo of Digital Equipment Corporation may be
+ *    used to endorse or promote products derived from this software without
+ *    the prior written permission of Digital Equipment Corporation.
+ *
+ * 3) This software is provided "AS-IS" and any express or implied warranties,
+ *    including but not limited to, any implied warranties of merchantability,
+ *    fitness for a particular purpose, or non-infringement are disclaimed.
+ *    In no event shall DIGITAL be liable for any damages whatsoever, and in
+ *    particular, DIGITAL shall not be liable for special, indirect,
+ *    consequential, or incidental damages or damages for lost profits, loss
+ *    of revenue or loss of use, whether such damages arise in contract, 
+ *    negligence, tort, under statute, in equity, at law or otherwise, even
+ *    if advised of the possibility of such damage. 
+ *
+ */
+
+/*
+ * This is private, and should not be included by any drivers.  Drivers
+ * may include xf86_OSproc.h to get prototypes for public interfaces.
+ */
+
+#ifndef _XF86_OSLIB_H
+#define _XF86_OSLIB_H
+
+#include <X11/Xos.h>
+#include <X11/Xfuncproto.h>
+
+#include <stdio.h>
+#include <ctype.h>
+#include <stddef.h>
+
+/**************************************************************************/
+/* SYSV386 (SVR3, SVR4), including Solaris                                */
+/**************************************************************************/
+#if (defined(SYSV) || defined(SVR4)) && \
+    (defined(sun) || defined(__i386__))
+# ifdef SCO325
+#  ifndef _SVID3
+#   define _SVID3
+#  endif
+#  ifndef _NO_STATIC
+#   define _NO_STATIC
+#  endif
+# endif
+# include <sys/ioctl.h>
+# include <signal.h>
+# include <termio.h>
+# include <sys/stat.h>
+# include <sys/types.h>
+# if defined(__SCO__) 
+# include <sys/param.h>
+# endif
+
+
+# include <errno.h>
+
+# if defined(_NEED_SYSI86)
+#  if !(defined (sun) && defined (SVR4))
+#    include <sys/immu.h>
+#    include <sys/region.h>
+#  endif
+#  include <sys/proc.h>
+#  include <sys/tss.h>
+#  include <sys/sysi86.h>
+#  if defined(SVR4) && !defined(sun)
+#   include <sys/seg.h>
+#  endif /* SVR4 && !sun */
+/* V86SC_IOPL was moved to <sys/sysi86.h> on Solaris 7 and later */
+#  if !defined(V86SC_IOPL)			/* Solaris 7 or later? */
+#   include <sys/v86.h>				/* Nope */
+#  endif
+#  if defined(sun) && (defined (__i386__) || defined(__i386) || defined(__x86))  && defined (SVR4)
+#    include <sys/psw.h>
+#  endif
+# endif /* _NEED_SYSI86 */
+
+# if defined(HAS_SVR3_MMAPDRV)
+#  include <sys/sysmacros.h>
+#  if !defined(_NEED_SYSI86)
+#   include <sys/immu.h>
+#   include <sys/region.h>
+#  endif
+#  include <sys/mmap.h>		/* MMAP driver header */
+# endif
+
+# if !defined(sun) || defined(HAVE_SYS_VT_H)
+#  define HAS_USL_VTS
+# endif
+# if !defined(sun)
+#  include <sys/emap.h>
+# endif
+# if defined(SCO325)
+#  include <sys/vtkd.h>
+#  include <sys/console.h>
+#  include <sys/scankbd.h>
+#  include <sys/vid.h>
+#  define LED_CAP CLKED
+#  define LED_NUM NLKED
+#  define LED_SCR SLKED
+# elif defined(HAS_USL_VTS)
+#  if !defined(sun)
+#   include <sys/at_ansi.h>
+#  endif
+#  include <sys/kd.h>
+#  include <sys/vt.h>
+# endif
+
+# if defined(sun)
+#  include <sys/fbio.h>
+#  include <sys/kbd.h> 
+#  include <sys/kbio.h>
+
+/* undefine symbols from <sys/kbd.h> we don't need that conflict with enum
+   definitions in parser/xf86tokens.h */
+#  undef STRING
+#  undef LEFTALT
+#  undef RIGHTALT
+
+#  define LED_CAP LED_CAPS_LOCK
+#  define LED_NUM LED_NUM_LOCK
+#  define LED_SCR LED_SCROLL_LOCK
+#  define LED_COMP LED_COMPOSE
+# endif /* sun */
+
+# if !defined(VT_ACKACQ)
+#  define VT_ACKACQ 2
+# endif /* !VT_ACKACQ */
+
+# if defined(__SCO__)
+#  include <sys/sysmacros.h>
+#  define POSIX_TTY
+# endif /* __SCO__ */
+
+# if defined(SVR4) || defined(SCO325)
+#  include <sys/mman.h>
+#  if !(defined(sun) && defined (SVR4))
+#    define DEV_MEM "/dev/pmem"
+#  endif
+#  ifdef SCO325
+#   undef DEV_MEM
+#   define DEV_MEM "/dev/mem"
+#  endif
+#  define CLEARDTR_SUPPORT
+#  define POSIX_TTY
+# endif /* SVR4 */
+
+
+# if defined(sun) && defined(HAS_USL_VTS)
+#  define USE_VT_SYSREQ
+# endif
+
+#endif /* (SYSV || SVR4) */
+
+/**************************************************************************/
+/* Linux or Glibc-based system                                            */
+/**************************************************************************/
+#if defined(__linux__) || defined(__GLIBC__)
+# include <sys/ioctl.h>
+# include <signal.h>
+# include <stdlib.h>
+# include <sys/types.h>
+# include <assert.h>
+
+# ifdef __linux__
+#  include <termio.h>
+# else /* __GLIBC__ */
+#  include <termios.h>
+# endif
+# ifdef __sparc__
+#  include <sys/param.h>
+# endif
+
+# include <errno.h>
+
+# include <sys/stat.h>
+
+# include <sys/mman.h>
+# ifdef __linux__
+#  define HAS_USL_VTS
+#  include <sys/kd.h>
+#  include <sys/vt.h>
+#  define LDGMAP GIO_SCRNMAP
+#  define LDSMAP PIO_SCRNMAP
+#  define LDNMAP LDSMAP
+#  define CLEARDTR_SUPPORT
+#  define USE_VT_SYSREQ
+# endif
+
+# define POSIX_TTY
+
+#endif /* __linux__ || __GLIBC__ */
+
+/**************************************************************************/
+/* 386BSD and derivatives,  BSD/386                                       */
+/**************************************************************************/
+
+#if defined(__386BSD__) && (defined(__FreeBSD__) || defined(__NetBSD__))
+# undef __386BSD__
+#endif
+
+#ifdef CSRG_BASED
+# include <sys/ioctl.h>
+# include <signal.h>
+
+# include <termios.h>
+# define termio termios
+# define POSIX_TTY
+
+# include <errno.h>
+
+# include <sys/types.h>
+# include <sys/mman.h>
+# include <sys/stat.h>
+
+# if defined(__bsdi__)
+#  include <sys/param.h>
+# if (_BSDI_VERSION < 199510)
+#  include <i386/isa/vgaioctl.h>
+# endif
+# endif /* __bsdi__ */
+
+#endif /* CSRG_BASED */
+
+/**************************************************************************/
+/* Kernel of *BSD                                                         */
+/**************************************************************************/
+#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || \
+ defined(__NetBSD__) || defined(__OpenBSD__) || defined(__bsdi__) || defined(__DragonFly__)
+
+# include <sys/param.h>
+# if defined(__FreeBSD_version) && !defined(__FreeBSD_kernel_version)
+#  define __FreeBSD_kernel_version __FreeBSD_version
+# endif
+
+# if !defined(LINKKIT)
+  /* Don't need this stuff for the Link Kit */
+#  if defined(__bsdi__)
+#   include <i386/isa/pcconsioctl.h>
+#   define CONSOLE_X_MODE_ON PCCONIOCRAW
+#   define CONSOLE_X_MODE_OFF PCCONIOCCOOK
+#   define CONSOLE_X_BELL PCCONIOCBEEP
+#  else /* __bsdi__ */
+#   if defined(__OpenBSD__)
+#     ifdef PCCONS_SUPPORT
+#       include <machine/pccons.h>
+#       undef CONSOLE_X_MODE_ON
+#       undef CONSOLE_X_MODE_OFF
+#       undef CONSOLE_X_BELL
+#     endif
+#   endif
+#   ifdef SYSCONS_SUPPORT
+#    define COMPAT_SYSCONS
+#    if defined(__NetBSD__) || defined(__OpenBSD__)
+#     include <machine/console.h>
+#    else
+#     if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#        if defined(__DragonFly__)  || (__FreeBSD_kernel_version >= 410000)
+#          include <sys/consio.h>
+#          include <sys/kbio.h>
+#        else
+#          include <machine/console.h>
+#        endif /* FreeBSD 4.1 RELEASE or lator */
+#     else
+#      include <sys/console.h>
+#     endif
+#    endif
+#   endif /* SYSCONS_SUPPORT */
+#   if defined(PCVT_SUPPORT)
+#    if !defined(SYSCONS_SUPPORT)
+      /* no syscons, so include pcvt specific header file */
+#     if defined(__FreeBSD__) || defined(__FreeBSD_kernel__)
+#      include <machine/pcvt_ioctl.h>
+#     else
+#      if defined(__NetBSD__) || defined(__OpenBSD__)
+#       if !defined(WSCONS_SUPPORT)
+#        include <machine/pcvt_ioctl.h>
+#       endif /* WSCONS_SUPPORT */
+#      else
+#       include <sys/pcvt_ioctl.h>
+#      endif /* __NetBSD__ */
+#     endif /* __FreeBSD_kernel__ || __OpenBSD__ */
+#    else /* pcvt and syscons: hard-code the ID magic */
+#     define VGAPCVTID _IOWR('V',113, struct pcvtid)
+      struct pcvtid {
+	char name[16];
+	int rmajor, rminor;
+      };
+#    endif /* PCVT_SUPPORT && SYSCONS_SUPPORT */
+#   endif /* PCVT_SUPPORT */
+#   ifdef WSCONS_SUPPORT
+#    include <dev/wscons/wsconsio.h>
+#    include <dev/wscons/wsdisplay_usl_io.h>
+#   endif /* WSCONS_SUPPORT */
+#   if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)
+#    if defined(__FreeBSD_kernel_version) && (__FreeBSD_kernel_version >= 500013)
+#     include <sys/mouse.h>
+#    else
+#     undef MOUSE_GETINFO
+#     include <machine/mouse.h>
+#    endif
+#   endif
+    /* Include these definitions in case ioctl_pc.h didn't get included */
+#   ifndef CONSOLE_X_MODE_ON
+#    define CONSOLE_X_MODE_ON _IO('t',121)
+#   endif
+#   ifndef CONSOLE_X_MODE_OFF
+#    define CONSOLE_X_MODE_OFF _IO('t',122)
+#   endif
+#   ifndef CONSOLE_X_BELL
+#    define CONSOLE_X_BELL _IOW('t',123,int[2])
+#   endif
+#   ifndef CONSOLE_X_TV_ON
+#    define CONSOLE_X_TV_ON _IOW('t',155,int)
+#    define XMODE_RGB   0
+#    define XMODE_NTSC  1
+#    define XMODE_PAL   2
+#    define XMODE_SECAM 3
+#   endif
+#   ifndef CONSOLE_X_TV_OFF
+#    define CONSOLE_X_TV_OFF _IO('t',156)
+#   endif
+#ifndef CONSOLE_GET_LINEAR_INFO
+#    define CONSOLE_GET_LINEAR_INFO         _IOR('t',157,struct map_info)
+#endif
+#ifndef CONSOLE_GET_IO_INFO 
+#    define CONSOLE_GET_IO_INFO             _IOR('t',158,struct map_info)
+#endif
+#ifndef CONSOLE_GET_MEM_INFO 
+#    define CONSOLE_GET_MEM_INFO            _IOR('t',159,struct map_info)
+#endif
+#  endif /* __bsdi__ */
+# endif /* !LINKKIT */
+
+#if defined(USE_I386_IOPL) || defined(USE_AMD64_IOPL)
+#include <machine/sysarch.h>
+#endif
+
+# define CLEARDTR_SUPPORT
+
+# if defined(SYSCONS_SUPPORT) || defined(PCVT_SUPPORT) || defined(WSCONS_SUPPORT)
+#  define USE_VT_SYSREQ
+# endif
+
+#endif
+/* __FreeBSD_kernel__ || __NetBSD__ || __OpenBSD__ || __bsdi__ */
+
+/**************************************************************************/
+/* IRIX                                                                   */
+/**************************************************************************/
+
+/**************************************************************************/
+/* Generic                                                                */
+/**************************************************************************/
+
+#include <sys/wait.h>	/* May need to adjust this for other OSs */
+
+/* 
+ * Hack originally for ISC 2.2 POSIX headers, but may apply elsewhere,
+ * and it's safe, so just do it.
+ */
+#if !defined(O_NDELAY) && defined(O_NONBLOCK)
+# define O_NDELAY O_NONBLOCK
+#endif /* !O_NDELAY && O_NONBLOCK */
+
+#if !defined(MAXHOSTNAMELEN)
+# define MAXHOSTNAMELEN 32
+#endif /* !MAXHOSTNAMELEN */
+
+#if defined(_POSIX_SOURCE)
+# include <limits.h>
+#else
+# define _POSIX_SOURCE
+# include <limits.h>
+# undef _POSIX_SOURCE
+#endif /* _POSIX_SOURCE */
+
+#if !defined(PATH_MAX)
+# if defined(MAXPATHLEN)
+#  define PATH_MAX MAXPATHLEN
+# else
+#  define PATH_MAX 1024
+# endif /* MAXPATHLEN */
+#endif /* !PATH_MAX */
+
+
+#ifndef DEV_MEM
+#define DEV_MEM "/dev/mem"
+#endif
+
+#ifndef VT_SYSREQ_DEFAULT
+#define VT_SYSREQ_DEFAULT FALSE
+#endif
+
+#define SYSCALL(call) while(((call) == -1) && (errno == EINTR))
+
+#define XF86_OS_PRIVS
+#include "xf86_OSproc.h"
+
+#ifndef NO_COMPILER_H
+#include "compiler.h"
+#endif
+
+#endif /* _XF86_OSLIB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxscrinit.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxscrinit.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2001-2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *   David H. Dawes <dawes@xfree86.org>
+ *
+ */
+
+/** \file
+ * Interface for screen initialization.  \see dmxscrinit.c */
+
+#ifndef DMXSCRINIT_H
+#define DMXSCRINIT_H
+
+#include "scrnintstr.h"
+
+extern Bool dmxScreenInit(int idx, ScreenPtr pScreen, int argc, char *argv[]);
+
+extern void dmxBEScreenInit(int idx, ScreenPtr pScreen);
+extern void dmxBECloseScreen(ScreenPtr pScreen);
+
+#endif /* DMXSCRINIT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86str.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86str.h
@@ -0,0 +1,918 @@
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains definitions of the public XFree86 data structures/types.
+ * Any data structures that video drivers need to access should go here.
+ */
+
+#ifndef _XF86STR_H
+#define _XF86STR_H
+
+#include "misc.h"
+#include "input.h"
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "colormapst.h"
+#include "xf86Module.h"
+#include "xf86Opt.h"
+#include "xf86Pci.h"
+
+#include <pciaccess.h>
+
+/**
+ * Integer type that is of the size of the addressable memory (machine size).
+ * On most platforms \c uintptr_t will suffice.  However, on some mixed
+ * 32-bit / 64-bit platforms, such as 32-bit binaries on 64-bit PowerPC, this
+ * must be 64-bits.
+ */
+#include <inttypes.h>
+#if defined(__powerpc__)
+typedef uint64_t memType;
+#else
+typedef uintptr_t memType;
+#endif
+
+
+/* Video mode flags */
+
+typedef enum {
+    V_PHSYNC	= 0x0001,
+    V_NHSYNC	= 0x0002,
+    V_PVSYNC	= 0x0004,
+    V_NVSYNC	= 0x0008,
+    V_INTERLACE	= 0x0010,
+    V_DBLSCAN	= 0x0020,
+    V_CSYNC	= 0x0040,
+    V_PCSYNC	= 0x0080,
+    V_NCSYNC	= 0x0100,
+    V_HSKEW	= 0x0200,	/* hskew provided */
+    V_BCAST	= 0x0400,
+    V_PIXMUX	= 0x1000,
+    V_DBLCLK	= 0x2000,
+    V_CLKDIV2	= 0x4000
+} ModeFlags;
+
+typedef enum {
+    INTERLACE_HALVE_V	= 0x0001	/* Halve V values for interlacing */
+} CrtcAdjustFlags;
+
+/* Flags passed to ChipValidMode() */
+typedef enum {
+    MODECHECK_INITIAL = 0,
+    MODECHECK_FINAL   = 1
+} ModeCheckFlags;
+
+/* These are possible return values for xf86CheckMode() and ValidMode() */
+typedef enum {
+    MODE_OK	= 0,	/* Mode OK */
+    MODE_HSYNC,		/* hsync out of range */
+    MODE_VSYNC,		/* vsync out of range */
+    MODE_H_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_V_ILLEGAL,	/* mode has illegal horizontal timings */
+    MODE_BAD_WIDTH,	/* requires an unsupported linepitch */
+    MODE_NOMODE,	/* no mode with a maching name */
+    MODE_NO_INTERLACE,	/* interlaced mode not supported */
+    MODE_NO_DBLESCAN,	/* doublescan mode not supported */
+    MODE_NO_VSCAN,	/* multiscan mode not supported */
+    MODE_MEM,		/* insufficient video memory */
+    MODE_VIRTUAL_X,	/* mode width too large for specified virtual size */
+    MODE_VIRTUAL_Y,	/* mode height too large for specified virtual size */
+    MODE_MEM_VIRT,	/* insufficient video memory given virtual size */
+    MODE_NOCLOCK,	/* no fixed clock available */
+    MODE_CLOCK_HIGH,	/* clock required is too high */
+    MODE_CLOCK_LOW,	/* clock required is too low */
+    MODE_CLOCK_RANGE,	/* clock/mode isn't in a ClockRange */
+    MODE_BAD_HVALUE,	/* horizontal timing was out of range */
+    MODE_BAD_VVALUE,	/* vertical timing was out of range */
+    MODE_BAD_VSCAN,	/* VScan value out of range */
+    MODE_HSYNC_NARROW,	/* horizontal sync too narrow */
+    MODE_HSYNC_WIDE,	/* horizontal sync too wide */
+    MODE_HBLANK_NARROW,	/* horizontal blanking too narrow */
+    MODE_HBLANK_WIDE,	/* horizontal blanking too wide */
+    MODE_VSYNC_NARROW,	/* vertical sync too narrow */
+    MODE_VSYNC_WIDE,	/* vertical sync too wide */
+    MODE_VBLANK_NARROW,	/* vertical blanking too narrow */
+    MODE_VBLANK_WIDE,	/* vertical blanking too wide */
+    MODE_PANEL,         /* exceeds panel dimensions */
+    MODE_INTERLACE_WIDTH, /* width too large for interlaced mode */
+    MODE_ONE_WIDTH,     /* only one width is supported */
+    MODE_ONE_HEIGHT,    /* only one height is supported */
+    MODE_ONE_SIZE,      /* only one resolution is supported */
+    MODE_NO_REDUCED,    /* monitor doesn't accept reduced blanking */
+    MODE_BANDWIDTH,	/* mode requires too much memory bandwidth */
+    MODE_BAD = -2,	/* unspecified reason */
+    MODE_ERROR	= -1	/* error condition */
+} ModeStatus;
+
+/*
+ * The mode sets are, from best to worst: USERDEF, DRIVER, and DEFAULT/BUILTIN.
+ * Preferred will bubble a mode to the top within a set.
+ */
+# define M_T_BUILTIN 0x01        /* built-in mode */
+# define M_T_CLOCK_C (0x02 | M_T_BUILTIN) /* built-in mode - configure clock */
+# define M_T_CRTC_C  (0x04 | M_T_BUILTIN) /* built-in mode - configure CRTC  */
+# define M_T_CLOCK_CRTC_C  (M_T_CLOCK_C | M_T_CRTC_C)
+                               /* built-in mode - configure CRTC and clock */
+# define M_T_PREFERRED 0x08	/* preferred mode within a set */
+# define M_T_DEFAULT 0x10	/* (VESA) default modes */
+# define M_T_USERDEF 0x20	/* One of the modes from the config file */
+# define M_T_DRIVER  0x40	/* Supplied by the driver (EDID, etc) */
+# define M_T_USERPREF 0x80	/* mode preferred by the user config */
+
+/* Video mode */
+typedef struct _DisplayModeRec {
+    struct _DisplayModeRec *	prev;
+    struct _DisplayModeRec *	next;
+    char *			name;		/* identifier for the mode */
+    ModeStatus			status;
+    int				type;
+
+    /* These are the values that the user sees/provides */
+    int				Clock;		/* pixel clock freq (kHz) */
+    int				HDisplay;	/* horizontal timing */
+    int				HSyncStart;
+    int				HSyncEnd;
+    int				HTotal;
+    int				HSkew;
+    int				VDisplay;	/* vertical timing */
+    int				VSyncStart;
+    int				VSyncEnd;
+    int				VTotal;
+    int				VScan;
+    int				Flags;
+
+  /* These are the values the hardware uses */
+    int				ClockIndex;
+    int				SynthClock;	/* Actual clock freq to
+					  	 * be programmed  (kHz) */
+    int				CrtcHDisplay;
+    int				CrtcHBlankStart;
+    int				CrtcHSyncStart;
+    int				CrtcHSyncEnd;
+    int				CrtcHBlankEnd;
+    int				CrtcHTotal;
+    int				CrtcHSkew;
+    int				CrtcVDisplay;
+    int				CrtcVBlankStart;
+    int				CrtcVSyncStart;
+    int				CrtcVSyncEnd;
+    int				CrtcVBlankEnd;
+    int				CrtcVTotal;
+    Bool			CrtcHAdjusted;
+    Bool			CrtcVAdjusted;
+    int				PrivSize;
+    INT32 *			Private;
+    int				PrivFlags;
+
+    float			HSync, VRefresh;
+} DisplayModeRec, *DisplayModePtr;
+
+/* The monitor description */
+
+#define MAX_HSYNC 8
+#define MAX_VREFRESH 8
+
+typedef struct { float hi, lo; } range;
+
+typedef struct { CARD32 red, green, blue; } rgb;
+
+typedef struct { float red, green, blue; } Gamma;
+
+/* The permitted gamma range is 1 / GAMMA_MAX <= g <= GAMMA_MAX */
+#define GAMMA_MAX	10.0
+#define GAMMA_MIN	(1.0 / GAMMA_MAX)
+#define GAMMA_ZERO	(GAMMA_MIN / 100.0)
+
+typedef struct {
+    char *		id;
+    char *		vendor;
+    char *		model;
+    int			nHsync;
+    range		hsync[MAX_HSYNC];
+    int			nVrefresh;
+    range		vrefresh[MAX_VREFRESH];
+    DisplayModePtr	Modes;		/* Start of the monitor's mode list */
+    DisplayModePtr	Last;		/* End of the monitor's mode list */
+    Gamma		gamma;		/* Gamma of the monitor */
+    int			widthmm;
+    int			heightmm;
+    pointer		options;
+    pointer		DDC;
+    Bool                reducedblanking; /* Allow CVT reduced blanking modes? */
+    int			maxPixClock;	 /* in kHz, like mode->Clock */
+} MonRec, *MonPtr;
+
+/* the list of clock ranges */
+typedef struct x_ClockRange {
+    struct x_ClockRange *next;
+    int			minClock;	/* (kHz) */
+    int			maxClock;	/* (kHz) */
+    int			clockIndex;	/* -1 for programmable clocks */
+    Bool		interlaceAllowed;
+    Bool		doubleScanAllowed;
+    int			ClockMulFactor;
+    int			ClockDivFactor;
+    int			PrivFlags;
+} ClockRange, *ClockRangePtr;
+
+/*
+ * The driverFunc. xorgDriverFuncOp specifies the action driver should
+ * perform. If requested option is not supported function should return
+ * FALSE. pointer can be used to pass arguments to the function or
+ * to return data to the caller.
+ */
+typedef struct _ScrnInfoRec *ScrnInfoPtr;
+
+/* do not change order */
+typedef enum {
+    RR_GET_INFO,
+    RR_SET_CONFIG,
+    RR_GET_MODE_MM,
+    GET_REQUIRED_HW_INTERFACES = 10
+} xorgDriverFuncOp;
+
+typedef Bool xorgDriverFuncProc		  (ScrnInfoPtr, xorgDriverFuncOp,
+					   pointer);
+
+/* RR_GET_INFO, RR_SET_CONFIG */
+typedef struct {
+    int rotation;
+    int rate;
+    int width;
+    int height;
+} xorgRRConfig;
+
+typedef union {
+    short RRRotations;
+    xorgRRConfig RRConfig;
+} xorgRRRotation, *xorgRRRotationPtr;
+
+/* RR_GET_MODE_MM */
+typedef struct {
+    DisplayModePtr mode;
+    int virtX;
+    int virtY;
+    int mmWidth;
+    int mmHeight;
+} xorgRRModeMM, *xorgRRModeMMPtr;
+
+/* GET_REQUIRED_HW_INTERFACES */
+#define HW_IO 1
+#define HW_MMIO 2
+#define HW_SKIP_CONSOLE 4
+#define NEED_IO_ENABLED(x) (x & HW_IO)
+
+typedef CARD32 xorgHWFlags;
+
+/*
+ * The driver list struct.  This contains the information required for each
+ * driver before a ScrnInfoRec has been allocated.
+ */
+struct _DriverRec;
+
+typedef struct {
+    int			driverVersion;
+    char *		driverName;
+    void		(*Identify)(int flags);
+    Bool		(*Probe)(struct _DriverRec *drv, int flags);
+    const OptionInfoRec * (*AvailableOptions)(int chipid, int bustype);
+    pointer		module;
+    int			refCount;
+} DriverRec1;
+
+struct _SymTabRec;
+struct _PciChipsets;
+
+typedef struct _DriverRec {
+    int			driverVersion;
+    char *		driverName;
+    void		(*Identify)(int flags);
+    Bool		(*Probe)(struct _DriverRec *drv, int flags);
+    const OptionInfoRec * (*AvailableOptions)(int chipid, int bustype);
+    pointer		module;
+    int			refCount;
+    xorgDriverFuncProc  *driverFunc;
+
+    const struct pci_id_match * supported_devices;
+    Bool (*PciProbe)( struct _DriverRec * drv, int entity_num,
+        struct pci_device * dev, intptr_t match_data );
+} DriverRec, *DriverPtr;
+
+/*
+ *  AddDriver flags
+ */
+#define HaveDriverFuncs 1
+
+/*
+ * These are the private bus types.  New types can be added here.  Types
+ * required for the public interface should be added to xf86str.h, with
+ * function prototypes added to xf86.h.
+ */
+
+/* Tolerate prior #include <linux/input.h> */
+#if defined(linux) && defined(_INPUT_H)
+#undef BUS_NONE
+#undef BUS_PCI
+#undef BUS_SBUS
+#undef BUS_last
+#endif
+
+typedef enum {
+    BUS_NONE,
+    BUS_PCI,
+    BUS_SBUS,
+    BUS_last    /* Keep last */
+} BusType;
+
+struct pci_device;
+
+typedef struct {
+    int		fbNum;
+} SbusBusId;
+
+typedef struct _bus {
+    BusType type;
+    union {
+	struct pci_device *pci;
+	SbusBusId sbus;
+    } id;
+} BusRec, *BusPtr;
+
+#define MAXCLOCKS   128
+typedef enum {
+    DAC_BPP8 = 0,
+    DAC_BPP16,
+    DAC_BPP24,
+    DAC_BPP32,
+    MAXDACSPEEDS
+} DacSpeedIndex;
+
+typedef struct {
+   char *			identifier;
+   char *			vendor;
+   char *			board;
+   char *			chipset;
+   char *			ramdac;
+   char *			driver;
+   struct _confscreenrec *	myScreenSection;
+   Bool				claimed;
+   int				dacSpeeds[MAXDACSPEEDS];
+   int				numclocks;
+   int				clock[MAXCLOCKS];
+   char *			clockchip;
+   char *			busID;
+   Bool				active;
+   Bool				inUse;
+   int				videoRam;
+   int				textClockFreq;
+   unsigned long		BiosBase;	/* Base address of video BIOS */
+   unsigned long		MemBase;	/* Frame buffer base address */
+   unsigned long		IOBase;
+   int				chipID;
+   int				chipRev;
+   pointer			options;
+   int                          irq;
+   int                          screen;         /* For multi-CRTC cards */
+} GDevRec, *GDevPtr;
+
+typedef struct {
+   char *			identifier;
+   char *			driver;
+   pointer		 	commonOptions;
+   pointer			extraOptions;
+   InputAttributes              *attrs;
+} IDevRec, *IDevPtr;
+
+typedef struct {
+    int			frameX0;
+    int			frameY0;
+    int			virtualX;
+    int			virtualY;
+    int			depth;
+    int			fbbpp;
+    rgb			weight;
+    rgb			blackColour;
+    rgb			whiteColour;
+    int			defaultVisual;
+    char **		modes;
+    pointer		options;
+} DispRec, *DispPtr;
+
+typedef struct _confxvportrec {
+    char *		identifier;
+    pointer		options;
+} confXvPortRec, *confXvPortPtr;
+
+typedef struct _confxvadaptrec {
+    char *		identifier;
+    int			numports;
+    confXvPortPtr	ports;
+    pointer		options;
+} confXvAdaptorRec, *confXvAdaptorPtr;
+
+typedef struct _confscreenrec {
+    char *		id;
+    int			screennum;
+    int			defaultdepth;
+    int			defaultbpp;
+    int			defaultfbbpp;
+    MonPtr		monitor;
+    GDevPtr		device;
+    int			numdisplays;
+    DispPtr		displays;
+    int			numxvadaptors;
+    confXvAdaptorPtr	xvadaptors;
+    pointer		options;
+} confScreenRec, *confScreenPtr;
+
+typedef enum {
+    PosObsolete = -1,
+    PosAbsolute = 0,
+    PosRightOf,
+    PosLeftOf,
+    PosAbove,
+    PosBelow,
+    PosRelative
+} PositionType;
+
+typedef struct _screenlayoutrec {
+    confScreenPtr	screen;
+    char *		topname;
+    confScreenPtr	top;
+    char *		bottomname;
+    confScreenPtr	bottom;
+    char *		leftname;
+    confScreenPtr	left;
+    char *		rightname;
+    confScreenPtr	right;
+    PositionType	where;
+    int			x;
+    int			y;
+    char *		refname;
+    confScreenPtr	refscreen;
+} screenLayoutRec, *screenLayoutPtr;
+
+typedef struct _serverlayoutrec {
+    char *		id;
+    screenLayoutPtr	screens;
+    GDevPtr		inactives;
+    IDevPtr*            inputs; /* NULL terminated */
+    pointer		options;
+} serverLayoutRec, *serverLayoutPtr;
+
+typedef struct _confdribufferrec {
+    int                 count;
+    int                 size;
+    enum {
+	XF86DRI_WC_HINT = 0x0001 /* Placeholder: not implemented */
+    }                   flags;
+} confDRIBufferRec, *confDRIBufferPtr;
+
+typedef struct _confdrirec {
+    int                 group;
+    int                 mode;
+    int                 bufs_count;
+    confDRIBufferRec    *bufs;
+} confDRIRec, *confDRIPtr;
+
+/* These values should be adjusted when new fields are added to ScrnInfoRec */
+#define NUM_RESERVED_INTS		16
+#define NUM_RESERVED_POINTERS		14
+#define NUM_RESERVED_FUNCS		11
+
+typedef pointer (*funcPointer)(void);
+
+/* flags for depth 24 pixmap options */
+typedef enum {
+    Pix24DontCare = 0,
+    Pix24Use24,
+    Pix24Use32
+} Pix24Flags;
+
+/* Power management events: so far we only support APM */
+
+typedef enum {
+    XF86_APM_UNKNOWN = -1,
+    XF86_APM_SYS_STANDBY,
+    XF86_APM_SYS_SUSPEND,
+    XF86_APM_CRITICAL_SUSPEND,
+    XF86_APM_USER_STANDBY,
+    XF86_APM_USER_SUSPEND,
+    XF86_APM_STANDBY_RESUME,
+    XF86_APM_NORMAL_RESUME,
+    XF86_APM_CRITICAL_RESUME,
+    XF86_APM_LOW_BATTERY,
+    XF86_APM_POWER_STATUS_CHANGE,
+    XF86_APM_UPDATE_TIME,
+    XF86_APM_CAPABILITY_CHANGED,
+    XF86_APM_STANDBY_FAILED,
+    XF86_APM_SUSPEND_FAILED
+} pmEvent;
+
+typedef enum {
+    PM_WAIT,
+    PM_CONTINUE,
+    PM_FAILED,
+    PM_NONE
+} pmWait;
+
+typedef struct _PciChipsets {
+    /**
+     * Key used to match this device with its name in an array of
+     * \c SymTabRec.
+     */
+    int numChipset;
+
+    /**
+     * This value is quirky.  Depending on the driver, it can take on one of
+     * three meanings.  In drivers that have exactly one vendor ID (e.g.,
+     * radeon, mga, i810) the low 16-bits are the device ID.
+     *
+     * In drivers that can have multiple vendor IDs (e.g., the glint driver
+     * can have either 3dlabs' ID or TI's ID, the i740 driver can have either
+     * Intel's ID or Real3D's ID, etc.) the low 16-bits are the device ID and
+     * the high 16-bits are the vendor ID.
+     *
+     * In drivers that don't have a specific vendor (e.g., vga) contains the
+     * device ID for either the generic VGA or generic 8514 devices.  This
+     * turns out to be the same as the subclass and programming interface
+     * value (e.g., the full 24-bit class for the VGA device is 0x030000 (or 
+     * 0x000101) and for 8514 is 0x030001).
+     */
+    int PCIid;
+
+/* dummy place holders for drivers to build against old/new servers */
+#define RES_UNDEFINED NULL
+#define RES_EXCLUSIVE_VGA NULL
+#define RES_SHARED_VGA NULL
+    void *dummy;
+} PciChipsets;
+
+
+/* Entity properties */
+typedef void (*EntityProc)(int entityIndex,pointer private);
+
+typedef struct _entityInfo {
+    int index;
+    BusRec location;
+    int chipset;
+    Bool active;
+    GDevPtr device;
+    DriverPtr driver;
+} EntityInfoRec, *EntityInfoPtr;
+
+/* server states */
+
+typedef enum {
+    SETUP,
+    OPERATING
+} xf86State;
+
+/* DGA */
+
+typedef struct {
+   int num;		/* A unique identifier for the mode (num > 0) */
+   DisplayModePtr mode;
+   int flags;		/* DGA_CONCURRENT_ACCESS, etc... */
+   int imageWidth;	/* linear accessible portion (pixels) */
+   int imageHeight;
+   int pixmapWidth;	/* Xlib accessible portion (pixels) */
+   int pixmapHeight;	/* both fields ignored if no concurrent access */
+   int bytesPerScanline;
+   int byteOrder;	/* MSBFirst, LSBFirst */
+   int depth;
+   int bitsPerPixel;
+   unsigned long red_mask;
+   unsigned long green_mask;
+   unsigned long blue_mask;
+   short visualClass;
+   int viewportWidth;
+   int viewportHeight;
+   int xViewportStep;	/* viewport position granularity */
+   int yViewportStep;
+   int maxViewportX;	/* max viewport origin */
+   int maxViewportY;
+   int viewportFlags;	/* types of page flipping possible */
+   int offset;		/* offset into physical memory */
+   unsigned char *address;	/* server's mapped framebuffer */
+   int reserved1;
+   int reserved2;
+} DGAModeRec, *DGAModePtr;
+
+typedef struct {
+   DGAModePtr mode;
+   PixmapPtr pPix;
+} DGADeviceRec, *DGADevicePtr;
+
+/*
+ * Flags for driver Probe() functions.
+ */
+#define PROBE_DEFAULT	  0x00
+#define PROBE_DETECT	  0x01
+#define PROBE_TRYHARD	  0x02
+
+/*
+ * Driver entry point types
+ */
+
+typedef Bool xf86ProbeProc                (DriverPtr, int);
+typedef Bool xf86PreInitProc              (ScrnInfoPtr, int);
+typedef Bool xf86ScreenInitProc           (int, ScreenPtr, int, char**);
+typedef Bool xf86SwitchModeProc           (int, DisplayModePtr, int);
+typedef void xf86AdjustFrameProc          (int, int, int, int);
+typedef Bool xf86EnterVTProc              (int, int);
+typedef void xf86LeaveVTProc              (int, int);
+typedef void xf86FreeScreenProc           (int, int);
+typedef ModeStatus xf86ValidModeProc      (int, DisplayModePtr, Bool, int);
+typedef void xf86EnableDisableFBAccessProc(int, Bool);
+typedef int  xf86SetDGAModeProc           (int, int, DGADevicePtr);
+typedef int  xf86ChangeGammaProc          (int, Gamma);
+typedef void xf86PointerMovedProc         (int, int, int);
+typedef Bool xf86PMEventProc              (int, pmEvent, Bool);
+typedef void xf86DPMSSetProc		  (ScrnInfoPtr, int, int);
+typedef void xf86LoadPaletteProc   (ScrnInfoPtr, int, int *, LOCO *, VisualPtr);
+typedef void xf86SetOverscanProc          (ScrnInfoPtr, int);
+
+
+/*
+ * ScrnInfoRec
+ *
+ * There is one of these for each screen, and it holds all the screen-specific
+ * information.
+ *
+ * Note: the size and layout must be kept the same across versions.  New
+ * fields are to be added in place of the "reserved*" fields.  No fields
+ * are to be dependent on compile-time defines.
+ */
+
+
+typedef struct _ScrnInfoRec {
+    int			driverVersion;
+    char *		driverName;		/* canonical name used in */
+						/* the config file */
+    ScreenPtr		pScreen;		/* Pointer to the ScreenRec */
+    int			scrnIndex;		/* Number of this screen */
+    Bool		configured;		/* Is this screen valid */
+    int			origIndex;		/* initial number assigned to
+						 * this screen before
+						 * finalising the number of
+						 * available screens */
+
+    /* Display-wide screenInfo values needed by this screen */
+    int			imageByteOrder;
+    int			bitmapScanlineUnit;
+    int			bitmapScanlinePad;
+    int			bitmapBitOrder;
+    int			numFormats;
+    PixmapFormatRec	formats[MAXFORMATS];
+    PixmapFormatRec	fbFormat;
+
+    int			bitsPerPixel;		/* fb bpp */
+    Pix24Flags		pixmap24;		/* pixmap pref for depth 24 */
+    int			depth;			/* depth of default visual */
+    MessageType		depthFrom;		/* set from config? */
+    MessageType		bitsPerPixelFrom;	/* set from config? */
+    rgb			weight;			/* r/g/b weights */
+    rgb			mask;			/* rgb masks */
+    rgb			offset;			/* rgb offsets */
+    int			rgbBits;		/* Number of bits in r/g/b */
+    Gamma		gamma;			/* Gamma of the monitor */
+    int			defaultVisual;		/* default visual class */
+    int			maxHValue;		/* max horizontal timing */
+    int			maxVValue;		/* max vertical timing value */
+    int			virtualX;		/* Virtual width */
+    int			virtualY; 		/* Virtual height */
+    int			xInc;			/* Horizontal timing increment */
+    MessageType		virtualFrom;		/* set from config? */
+    int			displayWidth;		/* memory pitch */
+    int			frameX0;		/* viewport position */
+    int			frameY0;
+    int			frameX1;
+    int			frameY1;
+    int			zoomLocked;		/* Disallow mode changes */
+    DisplayModePtr	modePool;		/* list of compatible modes */
+    DisplayModePtr	modes;			/* list of actual modes */
+    DisplayModePtr	currentMode;		/* current mode
+						 * This was previously
+						 * overloaded with the modes
+						 * field, which is a pointer
+						 * into a circular list */
+    confScreenPtr	confScreen;		/* Screen config info */
+    MonPtr		monitor;		/* Monitor information */
+    DispPtr		display;		/* Display information */
+    int *		entityList;		/* List of device entities */
+    int			numEntities;
+    int			widthmm;		/* physical display dimensions
+						 * in mm */
+    int			heightmm;
+    int			xDpi;			/* width DPI */
+    int			yDpi;			/* height DPI */
+    char *		name;			/* Name to prefix messages */
+    pointer		driverPrivate;		/* Driver private area */
+    DevUnion *		privates;		/* Other privates can hook in
+						 * here */
+    DriverPtr		drv;			/* xf86DriverList[] entry */
+    pointer		module;			/* Pointer to module head */
+    int			colorKey;
+    int			overlayFlags;
+
+    /* Some of these may be moved out of here into the driver private area */
+
+    char *		chipset;		/* chipset name */
+    char *		ramdac;			/* ramdac name */
+    char *		clockchip;		/* clock name */
+    Bool		progClock;		/* clock is programmable */
+    int			numClocks;		/* number of clocks */
+    int			clock[MAXCLOCKS];	/* list of clock frequencies */
+    int			videoRam;		/* amount of video ram (kb) */
+    unsigned long	biosBase;		/* Base address of video BIOS */
+    unsigned long	memPhysBase;		/* Physical address of FB */
+    unsigned long 	fbOffset;		/* Offset of FB in the above */
+    IOADDRESS    	domainIOBase;		/* Domain I/O base address */
+    int			memClk;			/* memory clock */
+    int			textClockFreq;		/* clock of text mode */
+    Bool		flipPixels;		/* swap default black/white */
+    pointer		options;
+
+    int			chipID;
+    int			chipRev;
+
+    /* Allow screens to be enabled/disabled individually */
+    Bool		vtSema;
+    DevUnion		pixmapPrivate;		/* saved devPrivate from pixmap */
+
+    /* hw cursor moves at SIGIO time */
+    Bool		silkenMouse;
+
+    /* Storage for clockRanges and adjustFlags for use with the VidMode ext */
+    ClockRangePtr	clockRanges;
+    int			adjustFlags;
+
+    /*
+     * These can be used when the minor ABI version is incremented.
+     * The NUM_* parameters must be reduced appropriately to keep the
+     * structure size and alignment unchanged.
+     */
+    int			reservedInt[NUM_RESERVED_INTS];
+
+    int *		entityInstanceList;
+    struct pci_device   *vgaDev;
+
+    pointer		reservedPtr[NUM_RESERVED_POINTERS];
+
+    /*
+     * Driver entry points.
+     *
+     */
+
+    xf86ProbeProc			*Probe;
+    xf86PreInitProc			*PreInit;
+    xf86ScreenInitProc			*ScreenInit;
+    xf86SwitchModeProc			*SwitchMode;
+    xf86AdjustFrameProc			*AdjustFrame;
+    xf86EnterVTProc			*EnterVT;
+    xf86LeaveVTProc			*LeaveVT;
+    xf86FreeScreenProc			*FreeScreen;
+    xf86ValidModeProc			*ValidMode;
+    xf86EnableDisableFBAccessProc	*EnableDisableFBAccess;
+    xf86SetDGAModeProc			*SetDGAMode;
+    xf86ChangeGammaProc			*ChangeGamma;
+    xf86PointerMovedProc		*PointerMoved;
+    xf86PMEventProc			*PMEvent;
+    xf86DPMSSetProc			*DPMSSet;
+    xf86LoadPaletteProc			*LoadPalette;
+    xf86SetOverscanProc			*SetOverscan;
+    xorgDriverFuncProc			*DriverFunc;
+
+    /*
+     * This can be used when the minor ABI version is incremented.
+     * The NUM_* parameter must be reduced appropriately to keep the
+     * structure size and alignment unchanged.
+     */
+    funcPointer		reservedFuncs[NUM_RESERVED_FUNCS];
+
+} ScrnInfoRec;
+
+
+typedef struct {
+   Bool (*OpenFramebuffer)(
+	ScrnInfoPtr pScrn,
+	char **name,
+	unsigned char **mem,
+	int *size,
+	int *offset,
+        int *extra
+   );
+   void	(*CloseFramebuffer)(ScrnInfoPtr pScrn);
+   Bool (*SetMode)(ScrnInfoPtr pScrn, DGAModePtr pMode);
+   void (*SetViewport)(ScrnInfoPtr pScrn, int x, int y, int flags);
+   int  (*GetViewport)(ScrnInfoPtr pScrn);
+   void (*Sync)(ScrnInfoPtr);
+   void (*FillRect)(
+	ScrnInfoPtr pScrn,
+	int x, int y, int w, int h,
+	unsigned long color
+   );
+   void (*BlitRect)(
+	ScrnInfoPtr pScrn,
+	int srcx, int srcy,
+	int w, int h,
+	int dstx, int dsty
+   );
+   void (*BlitTransRect)(
+	ScrnInfoPtr pScrn,
+	int srcx, int srcy,
+	int w, int h,
+	int dstx, int dsty,
+	unsigned long color
+   );
+} DGAFunctionRec, *DGAFunctionPtr;
+
+typedef struct _SymTabRec {
+    int			token;		/* id of the token */
+    const char *	name;		/* token name */
+} SymTabRec, *SymTabPtr;
+
+/* flags for xf86LookupMode */
+typedef enum {
+    LOOKUP_DEFAULT		= 0,	/* Use default mode lookup method */
+    LOOKUP_BEST_REFRESH,		/* Pick modes with best refresh */
+    LOOKUP_CLOSEST_CLOCK,		/* Pick modes with the closest clock */
+    LOOKUP_LIST_ORDER,			/* Pick first useful mode in list */
+    LOOKUP_CLKDIV2		= 0x0100, /* Allow half clocks */
+    LOOKUP_OPTIONAL_TOLERANCES	= 0x0200  /* Allow missing hsync/vrefresh */
+} LookupModeFlags;
+
+#define NoDepth24Support	0x00
+#define Support24bppFb		0x01	/* 24bpp framebuffer supported */
+#define Support32bppFb		0x02	/* 32bpp framebuffer supported */
+#define SupportConvert24to32	0x04	/* Can convert 24bpp pixmap to 32bpp */
+#define SupportConvert32to24	0x08	/* Can convert 32bpp pixmap to 24bpp */
+#define PreferConvert24to32	0x10	/* prefer 24bpp pixmap to 32bpp conv */
+#define PreferConvert32to24	0x20	/* prefer 32bpp pixmap to 24bpp conv */
+
+
+/* For DPMS */
+typedef void (*DPMSSetProcPtr)(ScrnInfoPtr, int, int);
+
+/* Input handler proc */
+typedef void (*InputHandlerProc)(int fd, pointer data);
+
+/* These are used by xf86GetClocks */
+#define CLK_REG_SAVE		-1
+#define CLK_REG_RESTORE		-2
+
+/*
+ * misc constants
+ */
+#define INTERLACE_REFRESH_WEIGHT	1.5
+#define SYNC_TOLERANCE		0.01	/* 1 percent */
+#define CLOCK_TOLERANCE		2000	/* Clock matching tolerance (2MHz) */
+
+
+#define OVERLAY_8_32_DUALFB	0x00000001
+#define OVERLAY_8_24_DUALFB	0x00000002
+#define OVERLAY_8_16_DUALFB	0x00000004
+#define OVERLAY_8_32_PLANAR	0x00000008
+
+/* Values of xf86Info.mouseFlags */
+#define MF_CLEAR_DTR       1
+#define MF_CLEAR_RTS       2
+
+/* Action Events */
+typedef enum {
+    ACTION_TERMINATE		= 0,	/* Terminate Server */
+    ACTION_NEXT_MODE		= 10,	/* Switch to next video mode */
+    ACTION_PREV_MODE,
+    ACTION_SWITCHSCREEN		= 100,	/* VT switch */
+    ACTION_SWITCHSCREEN_NEXT,
+    ACTION_SWITCHSCREEN_PREV,
+} ActionEvent;
+
+#endif /* _XF86STR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shadow.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/shadow.h
@@ -0,0 +1,181 @@
+/*
+ *
+ * Copyright © 2000 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _SHADOW_H_
+#define _SHADOW_H_
+
+#include "scrnintstr.h"
+
+#include "picturestr.h"
+
+#include "damage.h"
+#include "damagestr.h"
+typedef struct _shadowBuf   *shadowBufPtr;
+
+typedef void (*ShadowUpdateProc) (ScreenPtr pScreen,
+				  shadowBufPtr pBuf);
+
+#define SHADOW_WINDOW_RELOCATE 1
+#define SHADOW_WINDOW_READ 2
+#define SHADOW_WINDOW_WRITE 4
+
+typedef void *(*ShadowWindowProc) (ScreenPtr	pScreen,
+				   CARD32	row,
+				   CARD32	offset,
+				   int		mode,
+				   CARD32	*size,
+				   void		*closure);
+
+/* BC hack: do not move the damage member.  see shadow.c for explanation. */
+typedef struct _shadowBuf {
+    DamagePtr           pDamage;
+    ShadowUpdateProc	update;
+    ShadowWindowProc	window;
+    RegionRec		damage;
+    PixmapPtr		pPixmap;
+    void		*closure;
+    int			randr;
+
+    /* screen wrappers */
+    GetImageProcPtr     GetImage;
+    CloseScreenProcPtr  CloseScreen;
+} shadowBufRec;
+
+/* Match defines from randr extension */
+#define SHADOW_ROTATE_0	    1
+#define SHADOW_ROTATE_90    2
+#define SHADOW_ROTATE_180   4
+#define SHADOW_ROTATE_270   8
+#define SHADOW_ROTATE_ALL   (SHADOW_ROTATE_0|SHADOW_ROTATE_90|\
+			     SHADOW_ROTATE_180|SHADOW_ROTATE_270)
+#define SHADOW_REFLECT_X    16
+#define SHADOW_REFLECT_Y    32
+#define SHADOW_REFLECT_ALL  (SHADOW_REFLECT_X|SHADOW_REFLECT_Y)
+
+extern _X_EXPORT DevPrivateKey shadowScrPrivateKey;
+
+#define shadowGetBuf(pScr) ((shadowBufPtr) \
+    dixLookupPrivate(&(pScr)->devPrivates, shadowScrPrivateKey))
+#define shadowBuf(pScr)            shadowBufPtr pBuf = shadowGetBuf(pScr)
+#define shadowDamage(pBuf)  DamageRegion(pBuf->pDamage)    
+
+extern _X_EXPORT Bool
+shadowSetup (ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+shadowAdd (ScreenPtr	    pScreen,
+	   PixmapPtr	    pPixmap,
+	   ShadowUpdateProc update,
+	   ShadowWindowProc window,
+	   int		    randr,
+	   void		    *closure);
+
+extern _X_EXPORT void
+shadowRemove (ScreenPtr pScreen, PixmapPtr pPixmap);
+
+extern _X_EXPORT Bool
+shadowInit (ScreenPtr pScreen, ShadowUpdateProc update, ShadowWindowProc window);
+
+extern _X_EXPORT void *
+shadowAlloc (int width, int height, int bpp);
+
+extern _X_EXPORT void
+shadowUpdatePacked (ScreenPtr	    pScreen,
+		    shadowBufPtr    pBuf);
+
+extern _X_EXPORT void
+shadowUpdatePlanar4 (ScreenPtr	    pScreen,
+		     shadowBufPtr   pBuf);
+
+extern _X_EXPORT void
+shadowUpdatePlanar4x8 (ScreenPtr    pScreen,
+		       shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotatePacked (ScreenPtr    pScreen,
+			  shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate8_90 (ScreenPtr    pScreen,
+			shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16_90 (ScreenPtr    pScreen,
+			 shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16_90YX (ScreenPtr    pScreen,
+			   shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate32_90 (ScreenPtr    pScreen,
+			 shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate8_180 (ScreenPtr    pScreen,
+			 shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16_180 (ScreenPtr    pScreen,
+			  shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate32_180 (ScreenPtr    pScreen,
+			  shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate8_270 (ScreenPtr    pScreen,
+			 shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16_270 (ScreenPtr    pScreen,
+			  shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16_270YX (ScreenPtr    pScreen,
+			    shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate32_270 (ScreenPtr    pScreen,
+			  shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate8 (ScreenPtr    pScreen,
+		     shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate16 (ScreenPtr    pScreen,
+		      shadowBufPtr pBuf);
+
+extern _X_EXPORT void
+shadowUpdateRotate32 (ScreenPtr    pScreen,
+		      shadowBufPtr pBuf);
+
+typedef void (* shadowUpdateProc)(ScreenPtr, shadowBufPtr);
+
+extern _X_EXPORT shadowUpdateProc shadowUpdatePackedWeak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4Weak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdatePlanar4x8Weak(void);
+extern _X_EXPORT shadowUpdateProc shadowUpdateRotatePackedWeak(void);
+
+#endif /* _SHADOW_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbpriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbpriv.h
@@ -0,0 +1,265 @@
+/*
+ * copyed from from linux kernel 2.2.4
+ * removed internal stuff (#ifdef __KERNEL__)
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LINUX_FB_H
+#define _LINUX_FB_H
+
+#include <asm/types.h>
+
+/* Definitions of frame buffers						*/
+
+#define FB_MAJOR	29
+
+#define FB_MODES_SHIFT		5	/* 32 modes per framebuffer */
+#define FB_NUM_MINORS		256	/* 256 Minors               */
+#define FB_MAX			(FB_NUM_MINORS / (1 << FB_MODES_SHIFT))
+#define GET_FB_IDX(node)	(MINOR(node) >> FB_MODES_SHIFT)
+
+/* ioctls
+   0x46 is 'F'								*/
+#define FBIOGET_VSCREENINFO	0x4600
+#define FBIOPUT_VSCREENINFO	0x4601
+#define FBIOGET_FSCREENINFO	0x4602
+#define FBIOGETCMAP		0x4604
+#define FBIOPUTCMAP		0x4605
+#define FBIOPAN_DISPLAY		0x4606
+/* 0x4607-0x460B are defined below */
+/* #define FBIOGET_MONITORSPEC	0x460C */
+/* #define FBIOPUT_MONITORSPEC	0x460D */
+/* #define FBIOSWITCH_MONIBIT	0x460E */
+#define FBIOGET_CON2FBMAP	0x460F
+#define FBIOPUT_CON2FBMAP	0x4610
+#define FBIOBLANK		0x4611
+
+#define FB_TYPE_PACKED_PIXELS		0	/* Packed Pixels	*/
+#define FB_TYPE_PLANES			1	/* Non interleaved planes */
+#define FB_TYPE_INTERLEAVED_PLANES	2	/* Interleaved planes	*/
+#define FB_TYPE_TEXT			3	/* Text/attributes	*/
+
+#define FB_AUX_TEXT_MDA		0	/* Monochrome text */
+#define FB_AUX_TEXT_CGA		1	/* CGA/EGA/VGA Color text */
+#define FB_AUX_TEXT_S3_MMIO	2	/* S3 MMIO fasttext */
+#define FB_AUX_TEXT_MGA_STEP16	3	/* MGA Millenium I: text, attr, 14 reserved bytes */
+#define FB_AUX_TEXT_MGA_STEP8	4	/* other MGAs:      text, attr,  6 reserved bytes */
+
+#define FB_VISUAL_MONO01		0	/* Monochr. 1=Black 0=White */
+#define FB_VISUAL_MONO10		1	/* Monochr. 1=White 0=Black */
+#define FB_VISUAL_TRUECOLOR		2	/* True color	*/
+#define FB_VISUAL_PSEUDOCOLOR		3	/* Pseudo color (like atari) */
+#define FB_VISUAL_DIRECTCOLOR		4	/* Direct color */
+#define FB_VISUAL_STATIC_PSEUDOCOLOR	5	/* Pseudo color readonly */
+
+#define FB_ACCEL_NONE		0	/* no hardware accelerator	*/
+#define FB_ACCEL_ATARIBLITT	1	/* Atari Blitter		*/
+#define FB_ACCEL_AMIGABLITT	2	/* Amiga Blitter                */
+#define FB_ACCEL_S3_TRIO64	3	/* Cybervision64 (S3 Trio64)    */
+#define FB_ACCEL_NCR_77C32BLT	4	/* RetinaZ3 (NCR 77C32BLT)      */
+#define FB_ACCEL_S3_VIRGE	5	/* Cybervision64/3D (S3 ViRGE)	*/
+#define FB_ACCEL_ATI_MACH64GX	6	/* ATI Mach 64GX family		*/
+#define FB_ACCEL_DEC_TGA	7	/* DEC 21030 TGA		*/
+#define FB_ACCEL_ATI_MACH64CT	8	/* ATI Mach 64CT family		*/
+#define FB_ACCEL_ATI_MACH64VT	9	/* ATI Mach 64CT family VT class */
+#define FB_ACCEL_ATI_MACH64GT	10	/* ATI Mach 64CT family GT class */
+#define FB_ACCEL_SUN_CREATOR	11	/* Sun Creator/Creator3D	*/
+#define FB_ACCEL_SUN_CGSIX	12	/* Sun cg6			*/
+#define FB_ACCEL_SUN_LEO	13	/* Sun leo/zx			*/
+#define FB_ACCEL_IMS_TWINTURBO	14	/* IMS Twin Turbo		*/
+#define FB_ACCEL_3DLABS_PERMEDIA2 15	/* 3Dlabs Permedia 2		*/
+#define FB_ACCEL_MATROX_MGA2064W 16	/* Matrox MGA2064W (Millenium)	*/
+#define FB_ACCEL_MATROX_MGA1064SG 17	/* Matrox MGA1064SG (Mystique)	*/
+#define FB_ACCEL_MATROX_MGA2164W 18	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGA2164W_AGP 19	/* Matrox MGA2164W (Millenium II) */
+#define FB_ACCEL_MATROX_MGAG100	20	/* Matrox G100 (Productiva G100) */
+#define FB_ACCEL_MATROX_MGAG200	21	/* Matrox G200 (Myst, Mill, ...) */
+#define FB_ACCEL_SUN_CG14	22	/* Sun cgfourteen		 */
+#define FB_ACCEL_SUN_BWTWO	23	/* Sun bwtwo			 */
+#define FB_ACCEL_SUN_CGTHREE	24	/* Sun cgthree			 */
+#define FB_ACCEL_SUN_TCX	25	/* Sun tcx			 */
+#define FB_ACCEL_MATROX_MGAG400	26	/* Matrox G400			*/
+#define FB_ACCEL_NV3		27	/* nVidia RIVA 128              */
+#define FB_ACCEL_NV4		28	/* nVidia RIVA TNT		*/
+#define FB_ACCEL_NV5		29	/* nVidia RIVA TNT2		*/
+#define FB_ACCEL_CT_6555x	30	/* C&T 6555x			*/
+#define FB_ACCEL_3DFX_BANSHEE	31	/* 3Dfx Banshee			*/
+#define FB_ACCEL_ATI_RAGE128	32	/* ATI Rage128 family		*/
+
+struct fb_fix_screeninfo {
+	char id[16];			/* identification string eg "TT Builtin" */
+	char *smem_start;		/* Start of frame buffer mem */
+					/* (physical address) */
+	__u32 smem_len;			/* Length of frame buffer mem */
+	__u32 type;			/* see FB_TYPE_*		*/
+	__u32 type_aux;			/* Interleave for interleaved Planes */
+	__u32 visual;			/* see FB_VISUAL_*		*/ 
+	__u16 xpanstep;			/* zero if no hardware panning  */
+	__u16 ypanstep;			/* zero if no hardware panning  */
+	__u16 ywrapstep;		/* zero if no hardware ywrap    */
+	__u32 line_length;		/* length of a line in bytes    */
+	char *mmio_start;		/* Start of Memory Mapped I/O   */
+					/* (physical address) */
+	__u32 mmio_len;			/* Length of Memory Mapped I/O  */
+	__u32 accel;			/* Type of acceleration available */
+	__u16 reserved[3];		/* Reserved for future compatibility */
+};
+
+/* Interpretation of offset for color fields: All offsets are from the right,
+ * inside a "pixel" value, which is exactly 'bits_per_pixel' wide (means: you
+ * can use the offset as right argument to <<). A pixel afterwards is a bit
+ * stream and is written to video memory as that unmodified. This implies
+ * big-endian byte order if bits_per_pixel is greater than 8.
+ */
+struct fb_bitfield {
+	__u32 offset;			/* beginning of bitfield	*/
+	__u32 length;			/* length of bitfield		*/
+	__u32 msb_right;		/* != 0 : Most significant bit is */ 
+					/* right */ 
+};
+
+#define FB_NONSTD_HAM		1	/* Hold-And-Modify (HAM)        */
+
+#define FB_ACTIVATE_NOW		0	/* set values immediately (or vbl)*/
+#define FB_ACTIVATE_NXTOPEN	1	/* activate on next open	*/
+#define FB_ACTIVATE_TEST	2	/* don't set, round up impossible */
+#define FB_ACTIVATE_MASK       15
+					/* values			*/
+#define FB_ACTIVATE_VBL	       16	/* activate values on next vbl  */
+#define FB_CHANGE_CMAP_VBL     32	/* change colormap on vbl	*/
+#define FB_ACTIVATE_ALL	       64	/* change all VCs on this fb	*/
+
+#define FB_ACCELF_TEXT		1	/* text mode acceleration */
+
+#define FB_SYNC_HOR_HIGH_ACT	1	/* horizontal sync high active	*/
+#define FB_SYNC_VERT_HIGH_ACT	2	/* vertical sync high active	*/
+#define FB_SYNC_EXT		4	/* external sync		*/
+#define FB_SYNC_COMP_HIGH_ACT	8	/* composite sync high active   */
+#define FB_SYNC_BROADCAST	16	/* broadcast video timings      */
+					/* vtotal = 144d/288n/576i => PAL  */
+					/* vtotal = 121d/242n/484i => NTSC */
+#define FB_SYNC_ON_GREEN	32	/* sync on green */
+
+#define FB_VMODE_NONINTERLACED  0	/* non interlaced */
+#define FB_VMODE_INTERLACED	1	/* interlaced	*/
+#define FB_VMODE_DOUBLE		2	/* double scan */
+#define FB_VMODE_MASK		255
+
+#define FB_VMODE_YWRAP		256	/* ywrap instead of panning     */
+#define FB_VMODE_SMOOTH_XPAN	512	/* smooth xpan possible (internally used) */
+#define FB_VMODE_CONUPDATE	512	/* don't update x/yoffset	*/
+
+struct fb_var_screeninfo {
+	__u32 xres;			/* visible resolution		*/
+	__u32 yres;
+	__u32 xres_virtual;		/* virtual resolution		*/
+	__u32 yres_virtual;
+	__u32 xoffset;			/* offset from virtual to visible */
+	__u32 yoffset;			/* resolution			*/
+
+	__u32 bits_per_pixel;		/* guess what			*/
+	__u32 grayscale;		/* != 0 Graylevels instead of colors */
+
+	struct fb_bitfield red;		/* bitfield in fb mem if true color, */
+	struct fb_bitfield green;	/* else only length is significant */
+	struct fb_bitfield blue;
+	struct fb_bitfield transp;	/* transparency			*/	
+
+	__u32 nonstd;			/* != 0 Non standard pixel format */
+
+	__u32 activate;			/* see FB_ACTIVATE_*		*/
+
+	__u32 height;			/* height of picture in mm    */
+	__u32 width;			/* width of picture in mm     */
+
+	__u32 accel_flags;		/* acceleration flags (hints)	*/
+
+	/* Timing: All values in pixclocks, except pixclock (of course) */
+	__u32 pixclock;			/* pixel clock in ps (pico seconds) */
+	__u32 left_margin;		/* time from sync to picture	*/
+	__u32 right_margin;		/* time from picture to sync	*/
+	__u32 upper_margin;		/* time from sync to picture	*/
+	__u32 lower_margin;
+	__u32 hsync_len;		/* length of horizontal sync	*/
+	__u32 vsync_len;		/* length of vertical sync	*/
+	__u32 sync;			/* see FB_SYNC_*		*/
+	__u32 vmode;			/* see FB_VMODE_*		*/
+	__u32 reserved[6];		/* Reserved for future compatibility */
+};
+
+struct fb_cmap {
+	__u32 start;			/* First entry	*/
+	__u32 len;			/* Number of entries */
+	__u16 *red;			/* Red values	*/
+	__u16 *green;
+	__u16 *blue;
+	__u16 *transp;			/* transparency, can be NULL */
+};
+
+struct fb_con2fbmap {
+	__u32 console;
+	__u32 framebuffer;
+};
+
+struct fb_monspecs {
+	__u32 hfmin;			/* hfreq lower limit (Hz) */
+	__u32 hfmax; 			/* hfreq upper limit (Hz) */
+	__u16 vfmin;			/* vfreq lower limit (Hz) */
+	__u16 vfmax;			/* vfreq upper limit (Hz) */
+	unsigned dpms : 1;		/* supports DPMS */
+};
+
+#if 1
+
+#define FBCMD_GET_CURRENTPAR	0xDEAD0005
+#define FBCMD_SET_CURRENTPAR	0xDEAD8005
+
+#endif
+
+
+#if 1 /* Preliminary */
+
+   /*
+    *    Hardware Cursor
+    */
+
+#define FBIOGET_FCURSORINFO     0x4607
+#define FBIOGET_VCURSORINFO     0x4608
+#define FBIOPUT_VCURSORINFO     0x4609
+#define FBIOGET_CURSORSTATE     0x460A
+#define FBIOPUT_CURSORSTATE     0x460B
+
+
+struct fb_fix_cursorinfo {
+	__u16 crsr_width;		/* width and height of the cursor in */
+	__u16 crsr_height;		/* pixels (zero if no cursor)	*/
+	__u16 crsr_xsize;		/* cursor size in display pixels */
+	__u16 crsr_ysize;
+	__u16 crsr_color1;		/* colormap entry for cursor color1 */
+	__u16 crsr_color2;		/* colormap entry for cursor color2 */
+};
+
+struct fb_var_cursorinfo {
+	__u16 width;
+	__u16 height;
+	__u16 xspot;
+	__u16 yspot;
+	__u8 data[1];			/* field with [height][width]        */
+};
+
+struct fb_cursorstate {
+	__s16 xoffset;
+	__s16 yoffset;
+	__u16 mode;
+};
+
+#define FB_CURSOR_OFF		0
+#define FB_CURSOR_ON		1
+#define FB_CURSOR_FLASH		2
+
+#endif /* Preliminary */
+
+#endif /* _LINUX_FB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86dgaext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86dgaext.h
@@ -0,0 +1,10 @@
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _XF86DGAEXT_H_
+#define _XF86DGAEXT_H_
+
+extern DISPATCH_PROC(ProcXF86DGADispatch);
+
+#endif /* _XF86DGAEXT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xvmc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86xvmc.h
@@ -0,0 +1,166 @@
+
+/*
+ * Copyright (c) 2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86XVMC_H
+#define _XF86XVMC_H
+
+#include "xvmcext.h"
+#include "xf86xv.h"
+
+typedef struct {
+  int num_xvimages;
+  int *xvimage_ids;  /* reference the subpictures in the XF86MCAdaptorRec */
+} XF86MCImageIDList; 
+
+typedef struct {
+  int surface_type_id;  /* Driver generated.  Must be unique on the port */
+  int chroma_format;
+  int color_description;  /* no longer used */
+  unsigned short max_width;       
+  unsigned short max_height;   
+  unsigned short subpicture_max_width;
+  unsigned short subpicture_max_height;
+  int mc_type;         
+  int flags;
+  XF86MCImageIDList *compatible_subpictures; /* can be null, if none */
+} XF86MCSurfaceInfoRec, *XF86MCSurfaceInfoPtr;
+
+
+/*
+   xf86XvMCCreateContextProc 
+
+   DIX will fill everything out in the context except the driver_priv.
+   The port_priv holds the private data specified for the port when
+   Xv was initialized by the driver.
+   The driver may store whatever it wants in driver_priv and edit
+   the width, height and flags.  If the driver wants to return something
+   to the client it can allocate space in priv and specify the number
+   of 32 bit words in num_priv.  This must be dynamically allocated
+   space because DIX will free it after it passes it to the client.
+*/
+   
+
+typedef int (*xf86XvMCCreateContextProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCContextPtr context,
+  int *num_priv,
+  CARD32 **priv 
+);
+
+typedef void (*xf86XvMCDestroyContextProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCContextPtr context
+);
+
+/*
+   xf86XvMCCreateSurfaceProc 
+
+   DIX will fill everything out in the surface except the driver_priv.
+   The driver may store whatever it wants in driver_priv.  The driver
+   may pass data back to the client in the same manner as the
+   xf86XvMCCreateContextProc.
+*/
+
+
+typedef int (*xf86XvMCCreateSurfaceProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCSurfacePtr surface,
+  int *num_priv,
+  CARD32 **priv
+);
+
+typedef void (*xf86XvMCDestroySurfaceProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCSurfacePtr surface
+);
+
+/*
+   xf86XvMCCreateSubpictureProc 
+
+   DIX will fill everything out in the subpicture except the driver_priv,
+   num_palette_entries, entry_bytes and component_order.  The driver may
+   store whatever it wants in driver_priv and edit the width and height.
+   If it is a paletted subpicture the driver needs to fill out the
+   num_palette_entries, entry_bytes and component_order.  These are
+   not communicated to the client until the time the surface is
+   created.
+
+   The driver may pass data back to the client in the same manner as the
+   xf86XvMCCreateContextProc.
+*/
+
+
+typedef int (*xf86XvMCCreateSubpictureProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCSubpicturePtr subpicture,
+  int *num_priv,
+  CARD32 **priv
+);
+
+typedef void (*xf86XvMCDestroySubpictureProcPtr) (
+  ScrnInfoPtr pScrn,
+  XvMCSubpicturePtr subpicture
+);
+
+
+typedef struct {
+  char *name;
+  int num_surfaces;
+  XF86MCSurfaceInfoPtr *surfaces;
+  int num_subpictures;
+  XF86ImagePtr *subpictures;
+  xf86XvMCCreateContextProcPtr 		CreateContext; 
+  xf86XvMCDestroyContextProcPtr		DestroyContext; 
+  xf86XvMCCreateSurfaceProcPtr 		CreateSurface; 
+  xf86XvMCDestroySurfaceProcPtr		DestroySurface; 
+  xf86XvMCCreateSubpictureProcPtr	CreateSubpicture; 
+  xf86XvMCDestroySubpictureProcPtr	DestroySubpicture; 
+} XF86MCAdaptorRec, *XF86MCAdaptorPtr;
+
+/* 
+   xf86XvMCScreenInit 
+
+   Unlike Xv, the adaptor data is not copied from this structure.
+   This structure's data is used so it must stick around for the
+   life of the server.  Note that it's an array of pointers not
+   an array of structures.
+*/
+
+extern _X_EXPORT Bool xf86XvMCScreenInit(
+  ScreenPtr pScreen, 
+  int num_adaptors,
+  XF86MCAdaptorPtr *adaptors
+);
+
+extern _X_EXPORT XF86MCAdaptorPtr xf86XvMCCreateAdaptorRec (void);
+extern _X_EXPORT void xf86XvMCDestroyAdaptorRec(XF86MCAdaptorPtr adaptor);
+
+typedef int (*XvMCScreenInitProcPtr)(ScreenPtr, int, XvMCAdaptorPtr);
+extern _X_EXPORT XvMCScreenInitProcPtr XvMCScreenInitProc;
+
+#endif /* _XF86XVMC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ptrveloc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ptrveloc.h
@@ -0,0 +1,140 @@
+/*
+ *
+ * Copyright © 2006-2009 Simon Thum             simon dot thum at gmx dot de
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef POINTERVELOCITY_H
+#define POINTERVELOCITY_H
+
+#include <input.h> /* DeviceIntPtr */
+
+/* constants for acceleration profiles */
+
+#define AccelProfileNone -1
+#define AccelProfileClassic  0
+#define AccelProfileDeviceSpecific 1
+#define AccelProfilePolynomial 2
+#define AccelProfileSmoothLinear 3
+#define AccelProfileSimple 4
+#define AccelProfilePower 5
+#define AccelProfileLinear 6
+#define AccelProfileSmoothLimited 7
+#define AccelProfileLAST AccelProfileSmoothLimited
+
+/* fwd */
+struct _DeviceVelocityRec;
+
+/**
+ * profile
+ * returns actual acceleration depending on velocity, acceleration control,...
+ */
+typedef float (*PointerAccelerationProfileFunc)
+              (DeviceIntPtr dev, struct _DeviceVelocityRec* vel,
+               float velocity, float threshold, float accelCoeff);
+
+/**
+ * a motion history, with just enough information to
+ * calc mean velocity and decide which motion was along
+ * a more or less straight line
+ */
+typedef struct _MotionTracker {
+    int dx, dy;     /* accumulated delta for each axis */
+    int time;         /* time of creation */
+    int dir;        /* initial direction bitfield */
+} MotionTracker, *MotionTrackerPtr;
+
+/* number of properties for predictable acceleration */
+#define NPROPS_PREDICTABLE_ACCEL 4
+
+/**
+ * Contains all data needed to implement mouse ballistics
+ */
+typedef struct _DeviceVelocityRec {
+    MotionTrackerPtr tracker;
+    int num_tracker;
+    int cur_tracker;        /* current index */
+    float   velocity;       /* velocity as guessed by algorithm */
+    float   last_velocity;  /* previous velocity estimate */
+    int     last_dx;      /* last time-difference */
+    int     last_dy ;     /* phase of last/current estimate */
+    float   corr_mul;       /* config: multiply this into velocity */
+    float   const_acceleration;  /* config: (recipr.) const deceleration */
+    float   min_acceleration;    /* config: minimum acceleration */
+    short   reset_time;     /* config: reset non-visible state after # ms */
+    short   use_softening;  /* config: use softening of mouse values */
+    float   max_rel_diff;   /* config: max. relative difference */
+    float   max_diff;       /* config: max. difference */
+    int     initial_range;  /* config: max. offset used as initial velocity */
+    Bool    average_accel;  /* config: average acceleration over velocity */
+    PointerAccelerationProfileFunc Profile;
+    PointerAccelerationProfileFunc deviceSpecificProfile;
+    void*   profile_private;/* extended data, see  SetAccelerationProfile() */
+    struct {   /* to be able to query this information */
+        int     profile_number;
+    } statistics;
+    long    prop_handlers[NPROPS_PREDICTABLE_ACCEL];
+} DeviceVelocityRec, *DeviceVelocityPtr;
+
+extern _X_EXPORT void
+InitVelocityData(DeviceVelocityPtr vel);
+
+extern _X_EXPORT void
+InitTrackers(DeviceVelocityPtr vel, int ntracker);
+
+extern _X_EXPORT short
+ProcessVelocityData2D(DeviceVelocityPtr vel, int dx, int dy, int time);
+
+extern _X_EXPORT float
+BasicComputeAcceleration(DeviceIntPtr dev, DeviceVelocityPtr vel,
+    float velocity, float threshold, float acc);
+
+extern _X_EXPORT void
+FreeVelocityData(DeviceVelocityPtr vel);
+
+extern _X_INTERNAL BOOL
+InitializePredictableAccelerationProperties(DeviceIntPtr dev);
+
+extern _X_INTERNAL BOOL
+DeletePredictableAccelerationProperties(DeviceIntPtr dev);
+
+extern _X_EXPORT int
+SetAccelerationProfile(DeviceVelocityPtr vel, int profile_num);
+
+extern _X_EXPORT DeviceVelocityPtr
+GetDevicePredictableAccelData(DeviceIntPtr dev);
+
+extern _X_EXPORT void
+SetDeviceSpecificAccelerationProfile(DeviceVelocityPtr vel,
+                                     PointerAccelerationProfileFunc profile);
+
+extern _X_INTERNAL void
+AccelerationDefaultCleanup(DeviceIntPtr dev);
+
+extern _X_INTERNAL void
+acceleratePointerPredictable(DeviceIntPtr dev, int first_valuator,
+                             int num_valuators, int *valuators, int evtime);
+
+extern _X_INTERNAL void
+acceleratePointerLightweight(DeviceIntPtr dev, int first_valuator,
+                             int num_valuators, int *valuators, int ignored);
+
+#endif  /* POINTERVELOCITY_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/pixmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/pixmap.h
@@ -0,0 +1,121 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PIXMAP_H
+#define PIXMAP_H
+
+#include "misc.h"
+#include "screenint.h"
+
+/* types for Drawable */
+#define DRAWABLE_WINDOW 0
+#define DRAWABLE_PIXMAP 1
+#define UNDRAWABLE_WINDOW 2
+#define DRAWABLE_BUFFER 3
+
+/* corresponding type masks for dixLookupDrawable() */
+#define M_DRAWABLE_WINDOW	(1<<0)
+#define M_DRAWABLE_PIXMAP	(1<<1)
+#define M_UNDRAWABLE_WINDOW	(1<<2)
+#define M_DRAWABLE_BUFFER	(1<<3)
+#define M_ANY			(-1)
+#define M_WINDOW	(M_DRAWABLE_WINDOW|M_UNDRAWABLE_WINDOW)
+#define M_DRAWABLE	(M_DRAWABLE_WINDOW|M_DRAWABLE_PIXMAP|M_DRAWABLE_BUFFER)
+#define M_UNDRAWABLE	(M_UNDRAWABLE_WINDOW)
+
+/* flags to PaintWindow() */
+#define PW_BACKGROUND 0
+#define PW_BORDER 1
+
+#define NullPixmap ((PixmapPtr)0)
+
+typedef struct _Drawable *DrawablePtr;	
+typedef struct _Pixmap *PixmapPtr;
+
+typedef union _PixUnion {
+    PixmapPtr		pixmap;
+    unsigned long	pixel;
+} PixUnion;
+
+#define SamePixUnion(a,b,isPixel)\
+    ((isPixel) ? (a).pixel == (b).pixel : (a).pixmap == (b).pixmap)
+
+#define EqualPixUnion(as, a, bs, b)				\
+    ((as) == (bs) && (SamePixUnion (a, b, as)))
+
+#define OnScreenDrawable(type) \
+	((type == DRAWABLE_WINDOW) || (type == DRAWABLE_BUFFER))
+
+#define WindowDrawable(type) \
+	((type == DRAWABLE_WINDOW) || (type == UNDRAWABLE_WINDOW))
+
+extern _X_EXPORT PixmapPtr GetScratchPixmapHeader(
+    ScreenPtr /*pScreen*/,
+    int /*width*/,
+    int /*height*/,
+    int /*depth*/,
+    int /*bitsPerPixel*/,
+    int /*devKind*/,
+    pointer /*pPixData*/);
+
+extern _X_EXPORT void FreeScratchPixmapHeader(
+    PixmapPtr /*pPixmap*/);
+
+extern _X_EXPORT Bool CreateScratchPixmapsForScreen(
+    int /*scrnum*/);
+
+extern _X_EXPORT void FreeScratchPixmapsForScreen(
+    int /*scrnum*/);
+
+extern _X_EXPORT PixmapPtr AllocatePixmap(
+    ScreenPtr /*pScreen*/,
+    int /*pixDataSize*/);
+
+extern _X_EXPORT void FreePixmap(
+    PixmapPtr /*pPixmap*/);
+
+#endif /* PIXMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dispatch.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dispatch.h
@@ -0,0 +1,146 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+/*
+ * This prototypes the dispatch.c module (except for functions declared in
+ * global headers), plus related dispatch procedures from devices.c, events.c,
+ * extension.c, property.c. 
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef DISPATCH_H
+#define DISPATCH_H 1
+
+DISPATCH_PROC(InitClientPrivates);
+DISPATCH_PROC(ProcAllocColor);
+DISPATCH_PROC(ProcAllocColorCells);
+DISPATCH_PROC(ProcAllocColorPlanes);
+DISPATCH_PROC(ProcAllocNamedColor);
+DISPATCH_PROC(ProcBell);
+DISPATCH_PROC(ProcChangeAccessControl);
+DISPATCH_PROC(ProcChangeCloseDownMode);
+DISPATCH_PROC(ProcChangeGC);
+DISPATCH_PROC(ProcChangeHosts);
+DISPATCH_PROC(ProcChangeKeyboardControl);
+DISPATCH_PROC(ProcChangeKeyboardMapping);
+DISPATCH_PROC(ProcChangePointerControl);
+DISPATCH_PROC(ProcChangeProperty);
+DISPATCH_PROC(ProcChangeSaveSet);
+DISPATCH_PROC(ProcChangeWindowAttributes);
+DISPATCH_PROC(ProcCirculateWindow);
+DISPATCH_PROC(ProcClearToBackground);
+DISPATCH_PROC(ProcCloseFont);
+DISPATCH_PROC(ProcConfigureWindow);
+DISPATCH_PROC(ProcConvertSelection);
+DISPATCH_PROC(ProcCopyArea);
+DISPATCH_PROC(ProcCopyColormapAndFree);
+DISPATCH_PROC(ProcCopyGC);
+DISPATCH_PROC(ProcCopyPlane);
+DISPATCH_PROC(ProcCreateColormap);
+DISPATCH_PROC(ProcCreateCursor);
+DISPATCH_PROC(ProcCreateGC);
+DISPATCH_PROC(ProcCreateGlyphCursor);
+DISPATCH_PROC(ProcCreatePixmap);
+DISPATCH_PROC(ProcCreateWindow);
+DISPATCH_PROC(ProcDeleteProperty);
+DISPATCH_PROC(ProcDestroySubwindows);
+DISPATCH_PROC(ProcDestroyWindow);
+DISPATCH_PROC(ProcEstablishConnection);
+DISPATCH_PROC(ProcFillPoly);
+DISPATCH_PROC(ProcForceScreenSaver);
+DISPATCH_PROC(ProcFreeColormap);
+DISPATCH_PROC(ProcFreeColors);
+DISPATCH_PROC(ProcFreeCursor);
+DISPATCH_PROC(ProcFreeGC);
+DISPATCH_PROC(ProcFreePixmap);
+DISPATCH_PROC(ProcGetAtomName);
+DISPATCH_PROC(ProcGetFontPath);
+DISPATCH_PROC(ProcGetGeometry);
+DISPATCH_PROC(ProcGetImage);
+DISPATCH_PROC(ProcGetKeyboardControl);
+DISPATCH_PROC(ProcGetKeyboardMapping);
+DISPATCH_PROC(ProcGetModifierMapping);
+DISPATCH_PROC(ProcGetMotionEvents);
+DISPATCH_PROC(ProcGetPointerControl);
+DISPATCH_PROC(ProcGetPointerMapping);
+DISPATCH_PROC(ProcGetProperty);
+DISPATCH_PROC(ProcGetScreenSaver);
+DISPATCH_PROC(ProcGetSelectionOwner);
+DISPATCH_PROC(ProcGetWindowAttributes);
+DISPATCH_PROC(ProcGrabServer);
+DISPATCH_PROC(ProcImageText16);
+DISPATCH_PROC(ProcImageText8);
+DISPATCH_PROC(ProcInitialConnection);
+DISPATCH_PROC(ProcInstallColormap);
+DISPATCH_PROC(ProcInternAtom);
+DISPATCH_PROC(ProcKillClient);
+DISPATCH_PROC(ProcListExtensions);
+DISPATCH_PROC(ProcListFonts);
+DISPATCH_PROC(ProcListFontsWithInfo);
+DISPATCH_PROC(ProcListHosts);
+DISPATCH_PROC(ProcListInstalledColormaps);
+DISPATCH_PROC(ProcListProperties);
+DISPATCH_PROC(ProcLookupColor);
+DISPATCH_PROC(ProcMapSubwindows);
+DISPATCH_PROC(ProcMapWindow);
+DISPATCH_PROC(ProcNoOperation);
+DISPATCH_PROC(ProcOpenFont);
+DISPATCH_PROC(ProcPolyArc);
+DISPATCH_PROC(ProcPolyFillArc);
+DISPATCH_PROC(ProcPolyFillRectangle);
+DISPATCH_PROC(ProcPolyLine);
+DISPATCH_PROC(ProcPolyPoint);
+DISPATCH_PROC(ProcPolyRectangle);
+DISPATCH_PROC(ProcPolySegment);
+DISPATCH_PROC(ProcPolyText);
+DISPATCH_PROC(ProcPutImage);
+DISPATCH_PROC(ProcQueryBestSize);
+DISPATCH_PROC(ProcQueryColors);
+DISPATCH_PROC(ProcQueryExtension);
+DISPATCH_PROC(ProcQueryFont);
+DISPATCH_PROC(ProcQueryKeymap);
+DISPATCH_PROC(ProcQueryTextExtents);
+DISPATCH_PROC(ProcQueryTree);
+DISPATCH_PROC(ProcReparentWindow);
+DISPATCH_PROC(ProcRotateProperties);
+DISPATCH_PROC(ProcSetClipRectangles);
+DISPATCH_PROC(ProcSetDashes);
+DISPATCH_PROC(ProcSetFontPath);
+DISPATCH_PROC(ProcSetModifierMapping);
+DISPATCH_PROC(ProcSetPointerMapping);
+DISPATCH_PROC(ProcSetScreenSaver);
+DISPATCH_PROC(ProcSetSelectionOwner);
+DISPATCH_PROC(ProcStoreColors);
+DISPATCH_PROC(ProcStoreNamedColor);
+DISPATCH_PROC(ProcTranslateCoords);
+DISPATCH_PROC(ProcUngrabServer);
+DISPATCH_PROC(ProcUninstallColormap);
+DISPATCH_PROC(ProcUnmapSubwindows);
+DISPATCH_PROC(ProcUnmapWindow);
+
+#endif /* DISPATCH_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extension_string.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extension_string.h
@@ -0,0 +1,64 @@
+/*
+ * (C) Copyright IBM Corporation 2002-2006
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * the Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
+ * USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file extension_string.h
+ * Routines to manage the GLX extension string and GLX version for AIGLX
+ * drivers.  This code is loosely based on src/glx/x11/glxextensions.c from
+ * Mesa.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#ifndef GLX_EXTENSION_STRING_H
+#define GLX_EXTENSION_STRING_H
+
+enum {
+/*   GLX_ARB_get_proc_address is implemented on the client. */
+   ARB_multisample_bit = 0,
+   EXT_import_context_bit,
+   EXT_texture_from_pixmap_bit,
+   EXT_visual_info_bit,
+   EXT_visual_rating_bit,
+   MESA_copy_sub_buffer_bit,
+   OML_swap_method_bit,
+   SGI_make_current_read_bit,
+   SGI_swap_control_bit,
+   SGI_video_sync_bit,
+   SGIS_multisample_bit,
+   SGIX_fbconfig_bit,
+   SGIX_pbuffer_bit,
+   SGIX_visual_select_group_bit,
+   INTEL_swap_event_bit,
+   __NUM_GLX_EXTS,
+};
+
+#define __GLX_EXT_BYTES ((__NUM_GLX_EXTS + 7) / 8)
+
+extern int __glXGetExtensionString(const unsigned char *enable_bits,
+    char *buffer);
+extern void __glXEnableExtension(unsigned char *enable_bits, const char *ext);
+extern void __glXInitExtensionEnableBits(unsigned char *enable_bits);
+
+#endif /* GLX_EXTENSION_STRING_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86sbusBus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86sbusBus.h
@@ -0,0 +1,100 @@
+/*
+ * SBUS bus-specific declarations
+ *
+ * Copyright (C) 2000 Jakub Jelinek (jakub@redhat.com)
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * JAKUB JELINEK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _XF86_SBUSBUS_H
+#define _XF86_SBUSBUS_H
+
+#include "xf86str.h"
+
+#define SBUS_DEVICE_BW2		0x0001
+#define SBUS_DEVICE_CG2		0x0002
+#define SBUS_DEVICE_CG3		0x0003
+#define SBUS_DEVICE_CG4		0x0004
+#define SBUS_DEVICE_CG6		0x0005
+#define SBUS_DEVICE_CG8		0x0006
+#define SBUS_DEVICE_CG12	0x0007
+#define SBUS_DEVICE_CG14	0x0008
+#define SBUS_DEVICE_LEO		0x0009
+#define SBUS_DEVICE_TCX		0x000a
+#define SBUS_DEVICE_FFB		0x000b
+#define SBUS_DEVICE_GT		0x000c
+#define SBUS_DEVICE_MGX		0x000d
+
+typedef struct sbus_prom_node {
+    int			node;
+    /* Because of misdesigned openpromio */
+    int			cookie[2];
+} sbusPromNode, *sbusPromNodePtr;
+
+typedef struct sbus_device {
+    int			devId;
+    int			fbNum;
+    int			fd;
+    int			width, height;
+    sbusPromNode	node;
+    char		*descr;
+    char		*device;
+} sbusDevice, *sbusDevicePtr;
+
+struct sbus_devtable {
+    int devId;
+    int fbType;
+    char *promName;
+    char *driverName;
+    char *descr;
+};
+
+extern _X_EXPORT void xf86SbusProbe(void);
+extern _X_EXPORT sbusDevicePtr *xf86SbusInfo;
+extern _X_EXPORT struct sbus_devtable sbusDeviceTable[];
+
+extern _X_EXPORT int xf86MatchSbusInstances(const char *driverName, int sbusDevId,
+			   GDevPtr *devList, int numDevs, DriverPtr drvp,
+			   int **foundEntities);
+extern _X_EXPORT sbusDevicePtr xf86GetSbusInfoForEntity(int entityIndex);
+extern _X_EXPORT int xf86GetEntityForSbusInfo(sbusDevicePtr psdp);
+extern _X_EXPORT void xf86SbusUseBuiltinMode(ScrnInfoPtr pScrn, sbusDevicePtr psdp);
+extern _X_EXPORT pointer xf86MapSbusMem(sbusDevicePtr psdp, unsigned long offset,
+		       unsigned long size);
+extern _X_EXPORT void xf86UnmapSbusMem(sbusDevicePtr psdp, pointer addr, unsigned long size);
+extern _X_EXPORT void xf86SbusHideOsHwCursor(sbusDevicePtr psdp);
+extern _X_EXPORT void xf86SbusSetOsHwCursorCmap(sbusDevicePtr psdp, int bg, int fg);
+extern _X_EXPORT Bool xf86SbusHandleColormaps(ScreenPtr pScreen, sbusDevicePtr psdp);
+
+extern _X_EXPORT int promRootNode;
+
+extern _X_EXPORT int promGetSibling(int node);
+extern _X_EXPORT int promGetChild(int node);
+extern _X_EXPORT char * promGetProperty(const char *prop, int *lenp);
+extern _X_EXPORT int promGetBool(const char *prop);
+
+extern _X_EXPORT int sparcPromInit(void);
+extern _X_EXPORT void sparcPromClose(void);
+extern _X_EXPORT char * sparcPromGetProperty(sbusPromNodePtr pnode, const char *prop, int *lenp);
+extern _X_EXPORT int sparcPromGetBool(sbusPromNodePtr pnode, const char *prop);
+extern _X_EXPORT void sparcPromAssignNodes(void);
+extern _X_EXPORT char * sparcPromNode2Pathname(sbusPromNodePtr pnode);
+extern _X_EXPORT int sparcPromPathname2Node(const char *pathName);
+extern _X_EXPORT char *sparcDriverName(void);
+
+#endif /* _XF86_SBUSBUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipointer.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipointer.h
@@ -0,0 +1,153 @@
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+#ifndef MIPOINTER_H
+#define MIPOINTER_H
+
+#include "cursor.h"
+#include "input.h"
+#include "privates.h"
+
+typedef struct _miPointerSpriteFuncRec {
+    Bool	(*RealizeCursor)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */,
+                    CursorPtr /* pCurs */
+                    );
+    Bool	(*UnrealizeCursor)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */,
+                    CursorPtr /* pCurs */
+                    );
+    void	(*SetCursor)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */,
+                    CursorPtr /* pCurs */,
+                    int  /* x */,
+                    int  /* y */
+                    );
+    void	(*MoveCursor)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */,
+                    int  /* x */,
+                    int  /* y */
+                    );
+    Bool        (*DeviceCursorInitialize)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */
+                    );
+    void        (*DeviceCursorCleanup)(
+                    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */
+                    );
+} miPointerSpriteFuncRec, *miPointerSpriteFuncPtr;
+
+typedef struct _miPointerScreenFuncRec {
+    Bool	(*CursorOffScreen)(
+                    ScreenPtr* /* ppScr */,
+                    int*  /* px */,
+                    int*  /* py */
+                    );
+    void	(*CrossScreen)(
+                    ScreenPtr /* pScr */,
+                    int  /* entering */
+                    );
+    void	(*WarpCursor)(
+                    DeviceIntPtr /*pDev*/, 
+                    ScreenPtr /* pScr */,
+                    int  /* x */,
+                    int  /* y */
+                    );
+    void	(*EnqueueEvent)(
+                    DeviceIntPtr /* pDev */,
+                    InternalEvent* /* event */
+                    );
+    void	(*NewEventScreen)(
+		    DeviceIntPtr /* pDev */,
+                    ScreenPtr /* pScr */,
+		    Bool /* fromDIX */
+                    );
+} miPointerScreenFuncRec, *miPointerScreenFuncPtr;
+
+extern _X_EXPORT Bool miDCInitialize(
+    ScreenPtr /*pScreen*/,
+    miPointerScreenFuncPtr /*screenFuncs*/
+);
+
+extern _X_EXPORT Bool miPointerInitialize(
+    ScreenPtr /*pScreen*/,
+    miPointerSpriteFuncPtr /*spriteFuncs*/,
+    miPointerScreenFuncPtr /*screenFuncs*/,
+    Bool /*waitForUpdate*/
+);
+
+extern _X_EXPORT void miPointerWarpCursor(
+    DeviceIntPtr /*pDev*/,
+    ScreenPtr /*pScreen*/,
+    int /*x*/,
+    int /*y*/
+);
+
+/* Deprecated in favour of miPointerGetScreen. */
+extern _X_EXPORT ScreenPtr miPointerCurrentScreen(
+    void
+) _X_DEPRECATED;
+
+extern _X_EXPORT ScreenPtr miPointerGetScreen(
+    DeviceIntPtr pDev);
+extern _X_EXPORT void miPointerSetScreen(
+    DeviceIntPtr pDev,
+    int screen_num,
+    int x,
+    int y);
+
+/* Returns the current cursor position. */
+extern _X_EXPORT void miPointerGetPosition(
+    DeviceIntPtr pDev,
+    int *x,
+    int *y);
+
+/* Moves the cursor to the specified position.  May clip the co-ordinates:
+ * x and y are modified in-place. */
+extern _X_EXPORT void miPointerSetPosition(
+    DeviceIntPtr pDev,
+    int *x,
+    int *y);
+
+extern _X_EXPORT void miPointerUpdateSprite(
+    DeviceIntPtr pDev);
+
+/* Sets whether the sprite should be updated immediately on pointer moves */
+extern _X_EXPORT Bool miPointerSetWaitForUpdate(
+    ScreenPtr pScreen,
+    Bool wait);
+
+extern _X_EXPORT DevPrivateKeyRec miPointerPrivKeyRec;
+#define miPointerPrivKey (&miPointerPrivKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec miPointerScreenKeyRec;
+#define miPointerScreenKey (&miPointerScreenKeyRec)
+
+#endif /* MIPOINTER_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/loader.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/loader.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright 1995-1998 by Metro Link, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Metro Link, Inc. not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Metro Link, Inc. makes no
+ * representations about the suitability of this software for any purpose.
+ *  It is provided "as is" without express or implied warranty.
+ *
+ * METRO LINK, INC. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL METRO LINK, INC. BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _LOADER_H
+#define _LOADER_H
+
+#include <X11/Xosdefs.h>
+#include <X11/Xfuncproto.h>
+#include <X11/Xmd.h>
+
+/* LoadModule proc flags; LD_FLAG_GLOBAL adds symbols to global
+ * namespace, default is to keep symbols local to module. */
+#define LD_FLAG_GLOBAL 1
+
+typedef struct _loader *loaderPtr;
+
+/* Each module loaded has a loaderRec */
+typedef struct _loader {
+    int handle;			/* Unique id used to remove symbols from
+				 * this module when it is unloaded */
+    int module;			/* Unique id to identify compilation units */
+    char *name;
+    char *cname;
+    void *private;		/* format specific data */
+    loaderPtr next;
+} loaderRec;
+
+/* Compiled-in version information */
+typedef struct {
+    int xf86Version;
+    int ansicVersion;
+    int videodrvVersion;
+    int xinputVersion;
+    int extensionVersion;
+    int fontVersion;
+} ModuleVersions;
+extern const ModuleVersions LoaderVersionInfo;
+
+extern unsigned long LoaderOptions;
+
+/* Internal Functions */
+void LoaderDuplicateSymbol(const char *, const int);
+char *_LoaderModuleToName(int);
+int LoaderOpen(const char *, const char *, int, int *, int *, int *, int);
+int LoaderHandleOpen(int);
+
+/* object to name lookup routines */
+char *_LoaderHandleToName(int handle);
+char *_LoaderHandleToCanonicalName(int handle);
+
+/* Loader backends. */
+#include "dlloader.h"
+
+#endif /* _LOADER_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/geint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/geint.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _GEINT_H_
+#define _GEINT_H_
+
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "os.h"
+#include "dixstruct.h"
+#include "extnsionst.h"
+#include <X11/extensions/geproto.h>
+
+extern _X_EXPORT DevPrivateKeyRec GEClientPrivateKeyRec;
+#define GEClientPrivateKey (&GEClientPrivateKeyRec)
+
+typedef struct _GEClientInfo {
+    CARD32  major_version;
+    CARD32  minor_version;
+} GEClientInfoRec, *GEClientInfoPtr;
+
+#define GEGetClient(pClient)    ((GEClientInfoPtr)(dixLookupPrivate(&((pClient)->devPrivates), GEClientPrivateKey)))
+
+extern _X_EXPORT int (*ProcGEVector[/*GENumRequests*/])(ClientPtr);
+extern _X_EXPORT int (*SProcGEVector[/*GENumRequests*/])(ClientPtr);
+
+#endif /* _GEINT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_asm.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_asm.h
@@ -0,0 +1,970 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		Watcom C++ 10.6 or later
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Inline assembler versions of the primitive operand
+*				functions for faster performance. At the moment this is
+*				x86 inline assembler, but these functions could be replaced
+*				with native inline assembler for each supported processor
+*				platform.
+*
+****************************************************************************/
+
+#ifndef	__X86EMU_PRIM_ASM_H
+#define	__X86EMU_PRIM_ASM_H
+
+#ifdef	__WATCOMC__
+
+#ifndef	VALIDATE
+#define	__HAVE_INLINE_ASSEMBLER__
+#endif
+
+u32		get_flags_asm(void);
+#pragma aux get_flags_asm =			\
+	"pushf"                         \
+	"pop	eax"                  	\
+	value [eax]                     \
+	modify exact [eax];
+
+u16     aaa_word_asm(u32 *flags,u16 d);
+#pragma aux aaa_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aaa"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16     aas_word_asm(u32 *flags,u16 d);
+#pragma aux aas_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aas"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16     aad_word_asm(u32 *flags,u16 d);
+#pragma aux aad_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aad"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u16     aam_word_asm(u32 *flags,u8 d);
+#pragma aux aam_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"aam"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] 				\
+	value [ax]                      \
+	modify exact [ax];
+
+u8      adc_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux adc_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     adc_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux adc_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     adc_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux adc_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"adc	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      add_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux add_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     add_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux add_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     add_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux add_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"add	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      and_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux and_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     and_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux and_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     and_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux and_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"and	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      cmp_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux cmp_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     cmp_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux cmp_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     cmp_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux cmp_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"cmp	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      daa_byte_asm(u32 *flags,u8 d);
+#pragma aux daa_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"daa"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u8      das_byte_asm(u32 *flags,u8 d);
+#pragma aux das_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"das"                  			\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u8      dec_byte_asm(u32 *flags,u8 d);
+#pragma aux dec_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16     dec_word_asm(u32 *flags,u16 d);
+#pragma aux dec_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32     dec_long_asm(u32 *flags,u32 d);
+#pragma aux dec_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"dec	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8      inc_byte_asm(u32 *flags,u8 d);
+#pragma aux inc_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16     inc_word_asm(u32 *flags,u16 d);
+#pragma aux inc_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32     inc_long_asm(u32 *flags,u32 d);
+#pragma aux inc_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"inc	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8      or_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux or_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	al,bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     or_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux or_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	ax,bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     or_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux or_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"or	eax,ebx"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      neg_byte_asm(u32 *flags,u8 d);
+#pragma aux neg_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16     neg_word_asm(u32 *flags,u16 d);
+#pragma aux neg_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32     neg_long_asm(u32 *flags,u32 d);
+#pragma aux neg_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"neg	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8      not_byte_asm(u32 *flags,u8 d);
+#pragma aux not_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	al"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al]            		\
+	value [al]                      \
+	modify exact [al];
+
+u16     not_word_asm(u32 *flags,u16 d);
+#pragma aux not_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	ax"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax]            		\
+	value [ax]                      \
+	modify exact [ax];
+
+u32     not_long_asm(u32 *flags,u32 d);
+#pragma aux not_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"not	eax"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax]          		\
+	value [eax]                     \
+	modify exact [eax];
+
+u8      rcl_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux rcl_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     rcl_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux rcl_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     rcl_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux rcl_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcl	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      rcr_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux rcr_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     rcr_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux rcr_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     rcr_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux rcr_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rcr	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      rol_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux rol_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     rol_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux rol_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     rol_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux rol_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"rol	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      ror_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux ror_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     ror_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux ror_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     ror_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux ror_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"ror	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      shl_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux shl_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     shl_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux shl_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     shl_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux shl_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shl	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      shr_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux shr_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     shr_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux shr_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     shr_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux shr_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shr	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u8      sar_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux sar_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	al,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [cl]            \
+	value [al]                      \
+	modify exact [al cl];
+
+u16     sar_word_asm(u32 *flags,u16 d, u8 s);
+#pragma aux sar_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	ax,cl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [cl]            \
+	value [ax]                      \
+	modify exact [ax cl];
+
+u32     sar_long_asm(u32 *flags,u32 d, u8 s);
+#pragma aux sar_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sar	eax,cl"                	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [cl]          	\
+	value [eax]                     \
+	modify exact [eax cl];
+
+u16		shld_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
+#pragma aux shld_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shld	ax,dx,cl"               \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [dx] [cl]       \
+	value [ax]                      \
+	modify exact [ax dx cl];
+
+u32     shld_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
+#pragma aux shld_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shld	eax,edx,cl"             \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [edx] [cl]     \
+	value [eax]                     \
+	modify exact [eax edx cl];
+
+u16		shrd_word_asm(u32 *flags,u16 d, u16 fill, u8 s);
+#pragma aux shrd_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shrd	ax,dx,cl"               \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [dx] [cl]       \
+	value [ax]                      \
+	modify exact [ax dx cl];
+
+u32     shrd_long_asm(u32 *flags,u32 d, u32 fill, u8 s);
+#pragma aux shrd_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"shrd	eax,edx,cl"             \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [edx] [cl]     \
+	value [eax]                     \
+	modify exact [eax edx cl];
+
+u8      sbb_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux sbb_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     sbb_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux sbb_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     sbb_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux sbb_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sbb	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+u8      sub_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux sub_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     sub_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux sub_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     sub_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux sub_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"sub	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+void	test_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux test_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	modify exact [al bl];
+
+void	test_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux test_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	modify exact [ax bx];
+
+void	test_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux test_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"test	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	modify exact [eax ebx];
+
+u8      xor_byte_asm(u32 *flags,u8 d, u8 s);
+#pragma aux xor_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	al,bl"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [al] [bl]            \
+	value [al]                      \
+	modify exact [al bl];
+
+u16     xor_word_asm(u32 *flags,u16 d, u16 s);
+#pragma aux xor_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	ax,bx"                  \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [ax] [bx]            \
+	value [ax]                      \
+	modify exact [ax bx];
+
+u32     xor_long_asm(u32 *flags,u32 d, u32 s);
+#pragma aux xor_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"xor	eax,ebx"                \
+	"pushf"                         \
+	"pop	[edi]"            		\
+	parm [edi] [eax] [ebx]          \
+	value [eax]                     \
+	modify exact [eax ebx];
+
+void    imul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
+#pragma aux imul_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	parm [edi] [esi] [al] [bl]      \
+	modify exact [esi ax bl];
+
+void    imul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
+#pragma aux imul_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [bx]\
+	modify exact [esi edi ax bx dx];
+
+void    imul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
+#pragma aux imul_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"imul	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [ebx] \
+	modify exact [esi edi eax ebx edx];
+
+void    mul_byte_asm(u32 *flags,u16 *ax,u8 d,u8 s);
+#pragma aux mul_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	parm [edi] [esi] [al] [bl]      \
+	modify exact [esi ax bl];
+
+void    mul_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 d,u16 s);
+#pragma aux mul_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [bx]\
+	modify exact [esi edi ax bx dx];
+
+void    mul_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 d,u32 s);
+#pragma aux mul_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"mul	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [ebx] \
+	modify exact [esi edi eax ebx edx];
+
+void	idiv_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
+#pragma aux idiv_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],al"				\
+	"mov	[ecx],ah"				\
+	parm [edi] [esi] [ecx] [ax] [bl]\
+	modify exact [esi edi ax bl];
+
+void	idiv_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
+#pragma aux idiv_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
+	modify exact [esi edi ax dx bx];
+
+void	idiv_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
+#pragma aux idiv_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"idiv	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [edx] [ebx]\
+	modify exact [esi edi eax edx ebx];
+
+void	div_byte_asm(u32 *flags,u8 *al,u8 *ah,u16 d,u8 s);
+#pragma aux div_byte_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	bl"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],al"				\
+	"mov	[ecx],ah"				\
+	parm [edi] [esi] [ecx] [ax] [bl]\
+	modify exact [esi edi ax bl];
+
+void	div_word_asm(u32 *flags,u16 *ax,u16 *dx,u16 dlo,u16 dhi,u16 s);
+#pragma aux div_word_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	bx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],ax"				\
+	"mov	[ecx],dx"				\
+	parm [edi] [esi] [ecx] [ax] [dx] [bx]\
+	modify exact [esi edi ax dx bx];
+
+void	div_long_asm(u32 *flags,u32 *eax,u32 *edx,u32 dlo,u32 dhi,u32 s);
+#pragma aux div_long_asm =			\
+	"push	[edi]"            		\
+	"popf"                         	\
+	"div	ebx"                  	\
+	"pushf"                         \
+	"pop	[edi]"            		\
+	"mov	[esi],eax"				\
+	"mov	[ecx],edx"				\
+	parm [edi] [esi] [ecx] [eax] [edx] [ebx]\
+	modify exact [esi edi eax edx ebx];
+
+#endif
+
+#endif /* __X86EMU_PRIM_ASM_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbbits.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fbbits.h
@@ -0,0 +1,971 @@
+/*
+ * Copyright © 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/*
+ * This file defines functions for drawing some primitives using
+ * underlying datatypes instead of masks
+ */
+
+#define isClipped(c,ul,lr)  (((c) | ((c) - (ul)) | ((lr) - (c))) & 0x80008000)
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifdef BITSMUL
+#define MUL BITSMUL
+#else
+#define MUL 1
+#endif
+
+#ifdef BITSSTORE
+#define STORE(b,x)  BITSSTORE(b,x)
+#else
+#define STORE(b,x)  WRITE((b), (x))
+#endif
+
+#ifdef BITSRROP
+#define RROP(b,a,x)	BITSRROP(b,a,x)
+#else
+#define RROP(b,a,x)	WRITE((b), FbDoRRop (READ(b), (a), (x)))
+#endif
+
+#ifdef BITSUNIT
+#define UNIT BITSUNIT
+#define USE_SOLID
+#else
+#define UNIT BITS
+#endif
+
+/*
+ * Define the following before including this file:
+ *
+ *  BRESSOLID	name of function for drawing a solid segment
+ *  BRESDASH	name of function for drawing a dashed segment
+ *  DOTS	name of function for drawing dots
+ *  ARC		name of function for drawing a solid arc
+ *  BITS	type of underlying unit
+ */
+
+#ifdef BRESSOLID
+void
+BRESSOLID (DrawablePtr	pDrawable,
+	   GCPtr	pGC,
+	   int		dashOffset,
+	   int		signdx,
+	   int		signdy,
+	   int		axis,
+	   int		x1,
+	   int		y1,
+	   int		e,
+	   int		e1,
+	   int		e3,
+	   int		len)
+{
+    FbBits	*dst;
+    FbStride	dstStride;
+    int		dstBpp;
+    int		dstXoff, dstYoff;
+    FbGCPrivPtr	pPriv = fbGetGCPrivate (pGC);
+    UNIT	*bits;
+    FbStride	bitsStride;
+    FbStride	majorStep, minorStep;
+    BITS	xor = (BITS) pPriv->xor;
+    
+    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bits = ((UNIT *) (dst + ((y1 + dstYoff) * dstStride))) + (x1 + dstXoff) * MUL;
+    bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    if (signdy < 0)
+	bitsStride = -bitsStride;
+    if (axis == X_AXIS)
+    {
+	majorStep = signdx * MUL;
+	minorStep = bitsStride;
+    }
+    else
+    {
+	majorStep = bitsStride;
+	minorStep = signdx * MUL;
+    }
+    while (len--)
+    {
+	STORE(bits,xor);
+	bits += majorStep;
+	e += e1;
+	if (e >= 0)
+	{
+	    bits += minorStep;
+	    e += e3;
+	}
+    }
+
+    fbFinishAccess (pDrawable);
+}
+#endif
+
+#ifdef BRESDASH
+void
+BRESDASH (DrawablePtr	pDrawable,
+	  GCPtr		pGC,
+	  int		dashOffset,
+	  int		signdx,
+	  int		signdy,
+	  int		axis,
+	  int		x1,
+	  int		y1,
+	  int		e,
+	  int		e1,
+	  int		e3,
+	  int		len)
+{
+    FbBits	*dst;
+    FbStride	dstStride;
+    int		dstBpp;
+    int		dstXoff, dstYoff;
+    FbGCPrivPtr	pPriv = fbGetGCPrivate (pGC);
+    UNIT	*bits;
+    FbStride	bitsStride;
+    FbStride	majorStep, minorStep;
+    BITS	xorfg, xorbg;
+    FbDashDeclare;
+    int		dashlen;
+    Bool	even;
+    Bool	doOdd;
+    
+    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    doOdd = pGC->lineStyle == LineDoubleDash;
+    xorfg = (BITS) pPriv->xor;
+    xorbg = (BITS) pPriv->bgxor;
+    
+    FbDashInit (pGC, pPriv, dashOffset, dashlen, even);
+    
+    bits = ((UNIT *) (dst + ((y1 + dstYoff) * dstStride))) + (x1 + dstXoff) * MUL;
+    bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    if (signdy < 0)
+	bitsStride = -bitsStride;
+    if (axis == X_AXIS)
+    {
+	majorStep = signdx * MUL;
+	minorStep = bitsStride;
+    }
+    else
+    {
+	majorStep = bitsStride;
+	minorStep = signdx * MUL;
+    }
+    if (dashlen >= len)
+	dashlen = len;
+    if (doOdd)
+    {
+	if (!even)
+	    goto doubleOdd;
+	for (;;)
+	{
+	    len -= dashlen;
+	    while (dashlen--)
+	    {
+		STORE(bits,xorfg);
+		bits += majorStep;
+		if ((e += e1) >= 0)
+		{
+		    e += e3;
+		    bits += minorStep;
+		}
+	    }
+	    if (!len)
+		break;
+	    
+	    FbDashNextEven(dashlen);
+	    
+	    if (dashlen >= len)
+		dashlen = len;
+doubleOdd:
+	    len -= dashlen;
+	    while (dashlen--)
+	    {
+		STORE(bits,xorbg);
+		bits += majorStep;
+		if ((e += e1) >= 0)
+		{
+		    e += e3;
+		    bits += minorStep;
+		}
+	    }
+	    if (!len)
+		break;
+	    
+	    FbDashNextOdd(dashlen);
+	    
+	    if (dashlen >= len)
+		dashlen = len;
+	}
+    }
+    else
+    {
+	if (!even)
+	    goto onOffOdd;
+	for (;;)
+	{
+	    len -= dashlen;
+	    while (dashlen--)
+	    {
+		STORE(bits,xorfg);
+		bits += majorStep;
+		if ((e += e1) >= 0)
+		{
+		    e += e3;
+		    bits += minorStep;
+		}
+	    }
+	    if (!len)
+		break;
+
+	    FbDashNextEven (dashlen);
+	    
+	    if (dashlen >= len)
+		dashlen = len;
+onOffOdd:
+	    len -= dashlen;
+	    while (dashlen--)
+	    {
+		bits += majorStep;
+		if ((e += e1) >= 0)
+		{
+		    e += e3;
+		    bits += minorStep;
+		}
+	    }
+	    if (!len)
+		break;
+	    
+	    FbDashNextOdd (dashlen);
+	    
+	    if (dashlen >= len)
+		dashlen = len;
+	}
+    }
+
+    fbFinishAccess (pDrawable);
+}
+#endif
+
+#ifdef DOTS
+void
+DOTS (FbBits	    *dst,
+      FbStride	    dstStride,
+      int	    dstBpp,
+      BoxPtr	    pBox,
+      xPoint	    *ptsOrig,
+      int	    npt,
+      int	    xorg,
+      int	    yorg,
+      int	    xoff,
+      int	    yoff,
+      FbBits	    and,
+      FbBits	    xor)
+{
+    INT32    	*pts = (INT32 *) ptsOrig;
+    UNIT	*bits = (UNIT *) dst;
+    UNIT	*point;
+    BITS	bxor = (BITS) xor;
+    BITS	band = (BITS) and;
+    FbStride	bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    INT32    	ul, lr;
+    INT32    	pt;
+
+    ul = coordToInt(pBox->x1 - xorg,     pBox->y1 - yorg);
+    lr = coordToInt(pBox->x2 - xorg - 1, pBox->y2 - yorg - 1);
+
+    bits += bitsStride * (yorg + yoff) + (xorg + xoff) * MUL;
+    
+    if (and == 0)
+    {
+	while (npt--)
+	{
+	    pt = *pts++;
+	    if (!isClipped(pt,ul,lr))
+	    {
+		point = bits + intToY(pt) * bitsStride + intToX(pt) * MUL;
+		STORE(point,bxor);
+	    }
+	}
+    }
+    else
+    {
+	while (npt--)
+	{
+	    pt = *pts++;
+	    if (!isClipped(pt,ul,lr))
+	    {
+		point = bits + intToY(pt) * bitsStride + intToX(pt) * MUL;
+		RROP(point,band,bxor);
+	    }
+	}
+    }
+}
+#endif
+
+#ifdef ARC
+
+#define ARCCOPY(d)  STORE(d,xorBits)
+#define ARCRROP(d)  RROP(d,andBits,xorBits)
+
+void
+ARC (FbBits	*dst,
+     FbStride	dstStride,
+     int	dstBpp,
+     xArc	*arc,
+     int	drawX,
+     int	drawY,
+     FbBits	and,
+     FbBits	xor)
+{
+    UNIT	    *bits;
+    FbStride	    bitsStride;
+    miZeroArcRec    info;
+    Bool	    do360;
+    int		    x;
+    UNIT	    *yorgp, *yorgop;
+    BITS	    andBits, xorBits;
+    int		    yoffset, dyoffset;
+    int		    y, a, b, d, mask;
+    int		    k1, k3, dx, dy;
+    
+    bits = (UNIT *) dst;
+    bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    andBits = (BITS) and;
+    xorBits = (BITS) xor;
+    do360 = miZeroArcSetup(arc, &info, TRUE);
+    yorgp = bits + ((info.yorg + drawY) * bitsStride);
+    yorgop = bits + ((info.yorgo + drawY) * bitsStride);
+    info.xorg = (info.xorg + drawX) * MUL;
+    info.xorgo = (info.xorgo + drawX) * MUL;
+    MIARCSETUP();
+    yoffset = y ? bitsStride : 0;
+    dyoffset = 0;
+    mask = info.initialMask;
+    
+    if (!(arc->width & 1))
+    {
+	if (andBits == 0)
+	{
+	    if (mask & 2)
+		ARCCOPY(yorgp + info.xorgo);
+	    if (mask & 8)
+		ARCCOPY(yorgop + info.xorgo);
+	}
+	else
+	{
+	    if (mask & 2)
+		ARCRROP(yorgp + info.xorgo);
+	    if (mask & 8)
+		ARCRROP(yorgop + info.xorgo);
+	}
+    }
+    if (!info.end.x || !info.end.y)
+    {
+	mask = info.end.mask;
+	info.end = info.altend;
+    }
+    if (do360 && (arc->width == arc->height) && !(arc->width & 1))
+    {
+	int xoffset = bitsStride;
+	UNIT *yorghb = yorgp + (info.h * bitsStride) + info.xorg;
+	UNIT *yorgohb = yorghb - info.h * MUL;
+
+	yorgp += info.xorg;
+	yorgop += info.xorg;
+	yorghb += info.h * MUL;
+	while (1)
+	{
+	    if (andBits == 0)
+	    {
+		ARCCOPY(yorgp + yoffset + x * MUL);
+		ARCCOPY(yorgp + yoffset - x * MUL);
+		ARCCOPY(yorgop - yoffset - x * MUL);
+		ARCCOPY(yorgop - yoffset + x * MUL);
+	    }
+	    else
+	    {
+		ARCRROP(yorgp + yoffset + x * MUL);
+		ARCRROP(yorgp + yoffset - x * MUL);
+		ARCRROP(yorgop - yoffset - x * MUL);
+		ARCRROP(yorgop - yoffset + x * MUL);
+	    }
+	    if (a < 0)
+		break;
+	    if (andBits == 0)
+	    {
+		ARCCOPY(yorghb - xoffset - y * MUL);
+		ARCCOPY(yorgohb - xoffset + y * MUL);
+		ARCCOPY(yorgohb + xoffset + y * MUL);
+		ARCCOPY(yorghb + xoffset - y * MUL);
+	    }
+	    else
+	    {
+		ARCRROP(yorghb - xoffset - y * MUL);
+		ARCRROP(yorgohb - xoffset + y * MUL);
+		ARCRROP(yorgohb + xoffset + y * MUL);
+		ARCRROP(yorghb + xoffset - y * MUL);
+	    }
+	    xoffset += bitsStride;
+	    MIARCCIRCLESTEP(yoffset += bitsStride;);
+	}
+	yorgp -= info.xorg;
+	yorgop -= info.xorg;
+	x = info.w;
+	yoffset = info.h * bitsStride;
+    }
+    else if (do360)
+    {
+	while (y < info.h || x < info.w)
+	{
+	    MIARCOCTANTSHIFT(dyoffset = bitsStride;);
+	    if (andBits == 0)
+	    {
+		ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+		ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+		ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+		ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+	    }
+	    else
+	    {
+		ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+		ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+		ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+		ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+	    }
+	    MIARCSTEP(yoffset += dyoffset;, yoffset += bitsStride;);
+	}
+    }
+    else
+    {
+	while (y < info.h || x < info.w)
+	{
+	    MIARCOCTANTSHIFT(dyoffset = bitsStride;);
+	    if ((x == info.start.x) || (y == info.start.y))
+	    {
+		mask = info.start.mask;
+		info.start = info.altstart;
+	    }
+	    if (andBits == 0)
+	    {
+		if (mask & 1)
+		    ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+		if (mask & 2)
+		    ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+		if (mask & 4)
+		    ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+		if (mask & 8)
+		    ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+	    }
+	    else
+	    {
+		if (mask & 1)
+		    ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+		if (mask & 2)
+		    ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+		if (mask & 4)
+		    ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+		if (mask & 8)
+		    ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+	    }
+	    if ((x == info.end.x) || (y == info.end.y))
+	    {
+		mask = info.end.mask;
+		info.end = info.altend;
+	    }
+	    MIARCSTEP(yoffset += dyoffset;, yoffset += bitsStride;);
+	}
+    }
+    if ((x == info.start.x) || (y == info.start.y))
+	mask = info.start.mask;
+    if (andBits == 0)
+    {
+	if (mask & 1)
+	    ARCCOPY(yorgp + yoffset + info.xorg + x * MUL);
+	if (mask & 4)
+	    ARCCOPY(yorgop - yoffset + info.xorgo - x * MUL);
+	if (arc->height & 1)
+	{
+	    if (mask & 2)
+		ARCCOPY(yorgp + yoffset + info.xorgo - x * MUL);
+	    if (mask & 8)
+		ARCCOPY(yorgop - yoffset + info.xorg + x * MUL);
+	}
+    }
+    else
+    {
+	if (mask & 1)
+	    ARCRROP(yorgp + yoffset + info.xorg + x * MUL);
+	if (mask & 4)
+	    ARCRROP(yorgop - yoffset + info.xorgo - x * MUL);
+	if (arc->height & 1)
+	{
+	    if (mask & 2)
+		ARCRROP(yorgp + yoffset + info.xorgo - x * MUL);
+	    if (mask & 8)
+		ARCRROP(yorgop - yoffset + info.xorg + x * MUL);
+	}
+    }
+}
+#undef ARCCOPY
+#undef ARCRROP
+#endif
+
+#ifdef GLYPH
+#if BITMAP_BIT_ORDER == LSBFirst
+# define WRITE_ADDR1(n)	    (n)
+# define WRITE_ADDR2(n)	    (n)
+# define WRITE_ADDR4(n)	    (n)
+#else
+# define WRITE_ADDR1(n)	    ((n) ^ 3)
+# define WRITE_ADDR2(n)	    ((n) ^ 2)
+# define WRITE_ADDR4(n)	    ((n))
+#endif
+
+#define WRITE1(d,n,fg)	    WRITE(d + WRITE_ADDR1(n), (BITS) (fg))
+
+#ifdef BITS2
+# define WRITE2(d,n,fg)	    WRITE((BITS2 *) &((d)[WRITE_ADDR2(n)]), (BITS2) (fg))
+#else
+# define WRITE2(d,n,fg)	    (WRITE1(d,n,fg), WRITE1(d,(n)+1,fg))
+#endif
+
+#ifdef BITS4
+# define WRITE4(d,n,fg)	    WRITE((BITS4 *) &((d)[WRITE_ADDR4(n)]), (BITS4) (fg))
+#else
+# define WRITE4(d,n,fg)	    (WRITE2(d,n,fg), WRITE2(d,(n)+2,fg))
+#endif
+
+void
+GLYPH (FbBits	*dstBits,
+   FbStride	dstStride,
+   int	dstBpp,
+   FbStip	*stipple,
+   FbBits	fg,
+   int	x,
+   int	height)
+{
+    int	    lshift;
+    FbStip  bits;
+    BITS    *dstLine;
+    BITS    *dst;
+    int	    n;
+    int	    shift;
+
+    dstLine = (BITS *) dstBits;
+    dstLine += x & ~3;
+    dstStride *= (sizeof (FbBits) / sizeof (BITS));
+    shift = x & 3;
+    lshift = 4 - shift;
+    while (height--)
+    {
+	bits = *stipple++;
+	dst = (BITS *) dstLine;
+	n = lshift;
+	while (bits)
+	{
+	    switch (FbStipMoveLsb (FbLeftStipBits (bits, n), 4, n)) {
+	    case 0:
+		break;
+	    case 1:
+		WRITE1(dst,0,fg);
+		break;
+	    case 2:
+		WRITE1(dst,1,fg);
+		break;
+	    case 3:
+		WRITE2(dst,0,fg);
+		break;
+	    case 4:
+		WRITE1(dst,2,fg);
+		break;
+	    case 5:
+		WRITE1(dst,0,fg);
+		WRITE1(dst,2,fg);
+		break;
+	    case 6:
+		WRITE1(dst,1,fg);
+		WRITE1(dst,2,fg);
+		break;
+	    case 7:
+		WRITE2(dst,0,fg);
+		WRITE1(dst,2,fg);
+		break;
+	    case 8:
+		WRITE1(dst,3,fg);
+		break;
+	    case 9:
+		WRITE1(dst,0,fg);
+		WRITE1(dst,3,fg);
+		break;
+	    case 10:
+		WRITE1(dst,1,fg);
+		WRITE1(dst,3,fg);
+		break;
+	    case 11:
+		WRITE2(dst,0,fg);
+		WRITE1(dst,3,fg);
+		break;
+	    case 12:
+		WRITE2(dst,2,fg);
+		break;
+	    case 13:
+		WRITE1(dst,0,fg);
+		WRITE2(dst,2,fg);
+		break;
+	    case 14:
+		WRITE1(dst,1,fg);
+		WRITE2(dst,2,fg);
+		break;
+	    case 15:
+		WRITE4(dst,0,fg);
+		break;
+	    }
+	    bits = FbStipLeft (bits, n);
+	    n = 4;
+	    dst += 4;
+	}
+	dstLine += dstStride;
+    }
+}
+#undef WRITE_ADDR1
+#undef WRITE_ADDR2
+#undef WRITE_ADDR4
+#undef WRITE1
+#undef WRITE2
+#undef WRITE4
+
+#endif
+
+#ifdef POLYLINE
+void
+POLYLINE (DrawablePtr	pDrawable,
+	  GCPtr		pGC,
+	  int		mode,
+	  int		npt,
+	  DDXPointPtr	ptsOrig)
+{
+    INT32	    *pts = (INT32 *) ptsOrig;
+    int		    xoff = pDrawable->x;
+    int		    yoff = pDrawable->y;
+    unsigned int    bias = miGetZeroLineBias(pDrawable->pScreen);
+    BoxPtr	    pBox = RegionExtents(fbGetCompositeClip (pGC));
+    
+    FbBits	    *dst;
+    int		    dstStride;
+    int		    dstBpp;
+    int		    dstXoff, dstYoff;
+    
+    UNIT	    *bits, *bitsBase;
+    FbStride	    bitsStride;
+    BITS	    xor = fbGetGCPrivate(pGC)->xor;
+    BITS	    and = fbGetGCPrivate(pGC)->and;
+    int		    dashoffset = 0;
+    
+    INT32	    ul, lr;
+    INT32	    pt1, pt2;
+
+    int		    e, e1, e3, len;
+    int		    stepmajor, stepminor;
+    int		    octant;
+
+    if (mode == CoordModePrevious)
+	fbFixCoordModePrevious (npt, ptsOrig);
+    
+    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    bitsBase = ((UNIT *) dst) + (yoff + dstYoff) * bitsStride + (xoff + dstXoff) * MUL;
+    ul = coordToInt(pBox->x1 - xoff,     pBox->y1 - yoff);
+    lr = coordToInt(pBox->x2 - xoff - 1, pBox->y2 - yoff - 1);
+
+    pt1 = *pts++;
+    npt--;
+    pt2 = *pts++;
+    npt--;
+    for (;;)
+    {
+	if (isClipped (pt1, ul, lr) | isClipped (pt2, ul, lr))
+	{
+	    fbSegment (pDrawable, pGC, 
+		       intToX(pt1) + xoff, intToY(pt1) + yoff,
+		       intToX(pt2) + xoff, intToY(pt2) + yoff,
+		       npt == 0 && pGC->capStyle != CapNotLast,
+		       &dashoffset);
+	    if (!npt) {
+		fbFinishAccess (pDrawable);
+		return;
+	    }
+	    pt1 = pt2;
+	    pt2 = *pts++;
+	    npt--;
+	}
+	else
+	{
+	    bits = bitsBase + intToY(pt1) * bitsStride + intToX(pt1) * MUL;
+	    for (;;)
+	    {
+		CalcLineDeltas (intToX(pt1), intToY(pt1),
+				intToX(pt2), intToY(pt2),
+				len, e1, stepmajor, stepminor, 1, bitsStride,
+				octant);
+		stepmajor *= MUL;
+		if (len < e1)
+		{
+		    e3 = len;
+		    len = e1;
+		    e1 = e3;
+
+		    e3 = stepminor;
+		    stepminor = stepmajor;
+		    stepmajor = e3;
+		    SetYMajorOctant(octant);
+		}
+		e = -len;
+		e1 <<= 1;
+		e3 = e << 1;
+		FIXUP_ERROR (e, octant, bias);
+		if (and == 0)
+		{
+		    while (len--)
+		    {
+			STORE(bits,xor);
+			bits += stepmajor;
+			e += e1;
+			if (e >= 0)
+			{
+			    bits += stepminor;
+			    e += e3;
+			}
+		    }
+		}
+		else
+		{
+		    while (len--)
+		    {
+			RROP(bits,and,xor);
+			bits += stepmajor;
+			e += e1;
+			if (e >= 0)
+			{
+			    bits += stepminor;
+			    e += e3;
+			}
+		    }
+		}
+		if (!npt)
+		{
+		    if (pGC->capStyle != CapNotLast && 
+			pt2 != *((INT32 *) ptsOrig))
+		    {
+			RROP(bits,and,xor);
+		    }
+		    fbFinishAccess (pDrawable);
+		    return;
+		}
+		pt1 = pt2;
+		pt2 = *pts++;
+		--npt;
+		if (isClipped (pt2, ul, lr))
+		    break;
+    	    }
+	}
+    }
+
+    fbFinishAccess (pDrawable);
+}
+#endif
+
+#ifdef POLYSEGMENT
+void
+POLYSEGMENT (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    nseg,
+	     xSegment	    *pseg)
+{
+    INT32	    *pts = (INT32 *) pseg;
+    int		    xoff = pDrawable->x;
+    int		    yoff = pDrawable->y;
+    unsigned int    bias = miGetZeroLineBias(pDrawable->pScreen);
+    BoxPtr	    pBox = RegionExtents(fbGetCompositeClip (pGC));
+    
+    FbBits	    *dst;
+    int		    dstStride;
+    int		    dstBpp;
+    int		    dstXoff, dstYoff;
+    
+    UNIT	    *bits, *bitsBase;
+    FbStride	    bitsStride;
+    FbBits	    xorBits = fbGetGCPrivate(pGC)->xor;
+    FbBits	    andBits = fbGetGCPrivate(pGC)->and;
+    BITS	    xor = xorBits;
+    BITS	    and = andBits;
+    int		    dashoffset = 0;
+    
+    INT32	    ul, lr;
+    INT32	    pt1, pt2;
+
+    int		    e, e1, e3, len;
+    int		    stepmajor, stepminor;
+    int		    octant;
+    Bool	    capNotLast;
+
+    fbGetDrawable (pDrawable, dst, dstStride, dstBpp, dstXoff, dstYoff);
+    bitsStride = dstStride * (sizeof (FbBits) / sizeof (UNIT));
+    bitsBase = ((UNIT *) dst) + (yoff + dstYoff) * bitsStride + (xoff + dstXoff) * MUL;
+    ul = coordToInt(pBox->x1 - xoff,     pBox->y1 - yoff);
+    lr = coordToInt(pBox->x2 - xoff - 1, pBox->y2 - yoff - 1);
+
+    capNotLast = pGC->capStyle == CapNotLast;
+    
+    while (nseg--)
+    {
+	pt1 = *pts++;
+	pt2 = *pts++;
+	if (isClipped (pt1, ul, lr) | isClipped (pt2, ul, lr))
+	{
+	    fbSegment (pDrawable, pGC, 
+		       intToX(pt1) + xoff, intToY(pt1) + yoff,
+		       intToX(pt2) + xoff, intToY(pt2) + yoff,
+		       !capNotLast, &dashoffset);
+	}
+	else
+	{
+	    CalcLineDeltas (intToX(pt1), intToY(pt1),
+			    intToX(pt2), intToY(pt2),
+			    len, e1, stepmajor, stepminor, 1, bitsStride,
+			    octant);
+	    if (e1 == 0 && len > 3
+#if MUL != 1
+		&& FbCheck24Pix(and) && FbCheck24Pix(xor)
+#endif
+		)
+	    {
+		int	x1, x2;
+		FbBits	*dstLine;
+		int	dstX, width;
+		FbBits	startmask, endmask;
+		int	nmiddle;
+		
+		if (stepmajor < 0)
+		{
+		    x1 = intToX(pt2);
+		    x2 = intToX(pt1) + 1;
+		    if (capNotLast)
+			x1++;
+		}
+		else
+		{
+		    x1 = intToX(pt1);
+		    x2 = intToX(pt2);
+		    if (!capNotLast)
+			x2++;
+		}
+		dstX = (x1 + xoff + dstXoff) * (sizeof (UNIT) * 8 * MUL);
+		width = (x2 - x1) * (sizeof (UNIT) * 8 * MUL);
+		
+		dstLine = dst + (intToY(pt1) + yoff + dstYoff) * dstStride;
+		dstLine += dstX >> FB_SHIFT;
+		dstX &= FB_MASK;
+		FbMaskBits (dstX, width, startmask, nmiddle, endmask);
+		if (startmask)
+		{
+		    WRITE(dstLine, FbDoMaskRRop (READ(dstLine), andBits, xorBits, startmask));
+		    dstLine++;
+		}
+		if (!andBits)
+		    while (nmiddle--)
+			WRITE(dstLine++, xorBits);
+		else
+		    while (nmiddle--)
+		    {
+			WRITE(dstLine, FbDoRRop (READ(dstLine), andBits, xorBits));
+			dstLine++;
+		    }
+		if (endmask)
+		    WRITE(dstLine, FbDoMaskRRop (READ(dstLine), andBits, xorBits, endmask));
+	    }
+	    else
+	    {
+		stepmajor *= MUL;
+		bits = bitsBase + intToY(pt1) * bitsStride + intToX(pt1) * MUL;
+		if (len < e1)
+		{
+		    e3 = len;
+		    len = e1;
+		    e1 = e3;
+    
+		    e3 = stepminor;
+		    stepminor = stepmajor;
+		    stepmajor = e3;
+		    SetYMajorOctant(octant);
+		}
+		e = -len;
+		e1 <<= 1;
+		e3 = e << 1;
+		FIXUP_ERROR (e, octant, bias);
+		if (!capNotLast)
+		    len++;
+		if (and == 0)
+		{
+		    while (len--)
+		    {
+			STORE(bits,xor);
+			bits += stepmajor;
+			e += e1;
+			if (e >= 0)
+			{
+			    bits += stepminor;
+			    e += e3;
+			}
+		    }
+		}
+		else
+		{
+		    while (len--)
+		    {
+			RROP(bits,and,xor);
+			bits += stepmajor;
+			e += e1;
+			if (e >= 0)
+			{
+			    bits += stepminor;
+			    e += e3;
+			}
+		    }
+		}
+	    }
+	}
+    }
+
+    fbFinishAccess (pDrawable);
+}
+#endif
+
+#undef MUL
+#undef STORE
+#undef RROP
+#undef UNIT
+#undef USE_SOLID
+
+#undef isClipped
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/selectev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/selectev.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SELECTEV_H
+#define SELECTEV_H 1
+
+int SProcXSelectExtensionEvent(ClientPtr	/* client */
+    );
+
+int ProcXSelectExtensionEvent(ClientPtr	/* client */
+    );
+
+#endif /* SELECTEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxext.h
@@ -0,0 +1,92 @@
+#ifndef _glxext_h_
+#define _glxext_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+/*
+ * Added by VA Linux for XFree86 4.0.x
+ */
+typedef struct {
+    int type;
+    void (*resetExtension)(void);
+    Bool (*initVisuals)(
+        VisualPtr *       visualp,
+        DepthPtr *        depthp,
+        int *             nvisualp,
+        int *             ndepthp,
+        int *             rootDepthp,
+        VisualID *        defaultVisp,
+        unsigned long     sizes,
+        int               bitsPerRGB
+        );
+    void (*setVisualConfigs)(
+        int                nconfigs,
+        __GLXvisualConfig *configs,
+        void              **privates
+        );
+} __GLXextensionInfo;
+
+extern GLboolean __glXFreeContext(__GLXcontext *glxc);
+extern void __glXFlushContextCache(void);
+
+extern void __glXFreeGLXWindow(__glXWindow *pGlxWindow);
+extern void __glXFreeGLXPixmap( __GLXpixmap *pGlxPixmap );
+
+extern void __glXNoSuchRenderOpcode(GLbyte*);
+extern int __glXNoSuchSingleOpcode(__GLXclientState*, GLbyte*);
+extern void __glXErrorCallBack(GLenum code);
+extern void __glXClearErrorOccured(void);
+extern GLboolean __glXErrorOccured(void);
+extern void __glXResetLargeCommandStatus(__GLXclientState*);
+
+extern int __glXQueryContextInfoEXT(__GLXclientState *cl, GLbyte *pc);
+extern int __glXSwapQueryContextInfoEXT(__GLXclientState *cl, char *pc);
+
+extern void GlxExtensionInit(void);
+
+extern Bool __glXCoreType(void);
+
+extern int GlxInitVisuals(
+#if NeedFunctionPrototypes
+    VisualPtr *       visualp,
+    DepthPtr *        depthp,
+    int *             nvisualp,
+    int *             ndepthp,
+    int *             rootDepthp,
+    VisualID *        defaultVisp,
+    unsigned long     sizes,
+    int               bitsPerRGB,
+    int               preferredVis
+#endif
+);
+
+#endif /* _glxext_h_ */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vidmodeproc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/vidmodeproc.h
@@ -0,0 +1,77 @@
+
+/* Prototypes for DGA functions that the DDX must provide */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _VIDMODEPROC_H_
+#define _VIDMODEPROC_H_
+
+
+typedef enum {
+    VIDMODE_H_DISPLAY,
+    VIDMODE_H_SYNCSTART,
+    VIDMODE_H_SYNCEND,
+    VIDMODE_H_TOTAL,
+    VIDMODE_H_SKEW,
+    VIDMODE_V_DISPLAY,
+    VIDMODE_V_SYNCSTART,
+    VIDMODE_V_SYNCEND,
+    VIDMODE_V_TOTAL,
+    VIDMODE_FLAGS,
+    VIDMODE_CLOCK
+} VidModeSelectMode;
+
+typedef enum {
+    VIDMODE_MON_VENDOR,
+    VIDMODE_MON_MODEL,
+    VIDMODE_MON_NHSYNC,
+    VIDMODE_MON_NVREFRESH,
+    VIDMODE_MON_HSYNC_LO,
+    VIDMODE_MON_HSYNC_HI,
+    VIDMODE_MON_VREFRESH_LO,
+    VIDMODE_MON_VREFRESH_HI
+} VidModeSelectMonitor;
+
+typedef union {
+  pointer ptr;
+  int i;
+  float f;
+} vidMonitorValue;
+
+extern _X_EXPORT void XFree86VidModeExtensionInit(void);
+
+extern _X_EXPORT Bool VidModeAvailable(int scrnIndex);
+extern _X_EXPORT Bool VidModeGetCurrentModeline(int scrnIndex, pointer *mode, int *dotClock);
+extern _X_EXPORT Bool VidModeGetFirstModeline(int scrnIndex, pointer *mode, int *dotClock);
+extern _X_EXPORT Bool VidModeGetNextModeline(int scrnIndex, pointer *mode, int *dotClock);
+extern _X_EXPORT Bool VidModeDeleteModeline(int scrnIndex, pointer mode);
+extern _X_EXPORT Bool VidModeZoomViewport(int scrnIndex, int zoom);
+extern _X_EXPORT Bool VidModeGetViewPort(int scrnIndex, int *x, int *y);
+extern _X_EXPORT Bool VidModeSetViewPort(int scrnIndex, int x, int y);
+extern _X_EXPORT Bool VidModeSwitchMode(int scrnIndex, pointer mode);
+extern _X_EXPORT Bool VidModeLockZoom(int scrnIndex, Bool lock);
+extern _X_EXPORT Bool VidModeGetMonitor(int scrnIndex, pointer *monitor);
+extern _X_EXPORT int VidModeGetNumOfClocks(int scrnIndex, Bool *progClock);
+extern _X_EXPORT Bool VidModeGetClocks(int scrnIndex, int *Clocks);
+extern _X_EXPORT ModeStatus VidModeCheckModeForMonitor(int scrnIndex, pointer mode);
+extern _X_EXPORT ModeStatus VidModeCheckModeForDriver(int scrnIndex, pointer mode);
+extern _X_EXPORT void VidModeSetCrtcForMode(int scrnIndex, pointer mode);
+extern _X_EXPORT Bool VidModeAddModeline(int scrnIndex, pointer mode);
+extern _X_EXPORT int VidModeGetDotClock(int scrnIndex, int Clock);
+extern _X_EXPORT int VidModeGetNumOfModes(int scrnIndex);
+extern _X_EXPORT Bool VidModeSetGamma(int scrnIndex, float red, float green, float blue);
+extern _X_EXPORT Bool VidModeGetGamma(int scrnIndex, float *red, float *green, float *blue);
+extern _X_EXPORT pointer VidModeCreateMode(void);
+extern _X_EXPORT void VidModeCopyMode(pointer modefrom, pointer modeto);
+extern _X_EXPORT int VidModeGetModeValue(pointer mode, int valtyp);
+extern _X_EXPORT void VidModeSetModeValue(pointer mode, int valtyp, int val);
+extern _X_EXPORT vidMonitorValue VidModeGetMonitorValue(pointer monitor, int valtyp, int indx);
+extern _X_EXPORT Bool VidModeSetGammaRamp(int, int, CARD16 *, CARD16 *, CARD16 *);
+extern _X_EXPORT Bool VidModeGetGammaRamp(int, int, CARD16 *, CARD16 *, CARD16 *);
+extern _X_EXPORT int VidModeGetGammaRampSize(int scrnIndex);
+
+#endif
+
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdevb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdevb.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEVB_H
+#define GRABDEVB_H 1
+
+int SProcXGrabDeviceButton(ClientPtr	/* client */
+    );
+
+int ProcXGrabDeviceButton(ClientPtr	/* client */
+    );
+
+#endif /* GRABDEVB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxvisual.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxvisual.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for visual support.  \see dmxvisual.c */
+
+#ifndef DMXVISUAL_H
+#define DMXVISUAL_H
+
+#include "scrnintstr.h"
+
+extern Visual   *dmxLookupVisual(ScreenPtr pScreen, VisualPtr pVisual);
+extern Visual   *dmxLookupVisualFromID(ScreenPtr pScreen, VisualID vid);
+extern Colormap  dmxColormapFromDefaultVisual(ScreenPtr pScreen,
+					      Visual *visual);
+
+#endif /* DMXVISUAL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/os.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/os.h
@@ -0,0 +1,557 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+
+#ifndef OS_H
+#define OS_H
+
+#include "misc.h"
+#include <stdarg.h>
+
+#define SCREEN_SAVER_ON   0
+#define SCREEN_SAVER_OFF  1
+#define SCREEN_SAVER_FORCER 2
+#define SCREEN_SAVER_CYCLE  3
+
+#ifndef MAX_REQUEST_SIZE
+#define MAX_REQUEST_SIZE 65535
+#endif
+#ifndef MAX_BIG_REQUEST_SIZE
+#define MAX_BIG_REQUEST_SIZE 4194303
+#endif
+
+typedef struct _FontPathRec *FontPathPtr;
+typedef struct _NewClientRec *NewClientPtr;
+
+#ifndef xalloc
+#define xnfalloc(size) XNFalloc((unsigned long)(size))
+#define xnfcalloc(_num, _size) XNFcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xnfrealloc(ptr, size) XNFrealloc((pointer)(ptr), (unsigned long)(size))
+
+#define xalloc(size) Xalloc((unsigned long)(size))
+#define xcalloc(_num, _size) Xcalloc((unsigned long)(_num)*(unsigned long)(_size))
+#define xrealloc(ptr, size) Xrealloc((pointer)(ptr), (unsigned long)(size))
+#define xfree(ptr) Xfree((pointer)(ptr))
+#define xstrdup(s) Xstrdup(s)
+#define xnfstrdup(s) XNFstrdup(s)
+#endif
+
+#include <stdio.h>
+#include <stdarg.h>
+
+#ifdef DDXBEFORERESET
+extern void ddxBeforeReset (void);
+#endif
+
+#ifdef DDXOSVERRORF
+extern _X_EXPORT void (*OsVendorVErrorFProc)(const char *, va_list args);
+#endif
+
+extern _X_EXPORT int WaitForSomething(
+    int* /*pClientsReady*/
+);
+
+extern _X_EXPORT int ReadRequestFromClient(ClientPtr /*client*/);
+
+extern _X_EXPORT Bool InsertFakeRequest(
+    ClientPtr /*client*/, 
+    char* /*data*/, 
+    int /*count*/);
+
+extern _X_EXPORT void ResetCurrentRequest(ClientPtr /*client*/);
+
+extern _X_EXPORT void FlushAllOutput(void);
+
+extern _X_EXPORT void FlushIfCriticalOutputPending(void);
+
+extern _X_EXPORT void SetCriticalOutputPending(void);
+
+extern _X_EXPORT int WriteToClient(ClientPtr /*who*/, int /*count*/, const void* /*buf*/);
+
+extern _X_EXPORT void ResetOsBuffers(void);
+
+extern _X_EXPORT void InitConnectionLimits(void);
+
+extern _X_EXPORT void NotifyParentProcess(void);
+
+extern _X_EXPORT void CreateWellKnownSockets(void);
+
+extern _X_EXPORT void ResetWellKnownSockets(void);
+
+extern _X_EXPORT void CloseWellKnownConnections(void);
+
+extern _X_EXPORT XID AuthorizationIDOfClient(ClientPtr /*client*/);
+
+extern _X_EXPORT char *ClientAuthorized(
+    ClientPtr /*client*/,
+    unsigned int /*proto_n*/,
+    char* /*auth_proto*/,
+    unsigned int /*string_n*/,
+    char* /*auth_string*/);
+
+extern _X_EXPORT Bool EstablishNewConnections(
+    ClientPtr /*clientUnused*/,
+    pointer /*closure*/);
+
+extern _X_EXPORT void CheckConnections(void);
+
+extern _X_EXPORT void CloseDownConnection(ClientPtr /*client*/);
+
+extern _X_EXPORT void AddGeneralSocket(int /*fd*/);
+
+extern _X_EXPORT void RemoveGeneralSocket(int /*fd*/);
+
+extern _X_EXPORT void AddEnabledDevice(int /*fd*/);
+
+extern _X_EXPORT void RemoveEnabledDevice(int /*fd*/);
+
+extern _X_EXPORT int OnlyListenToOneClient(ClientPtr /*client*/);
+
+extern _X_EXPORT void ListenToAllClients(void);
+
+extern _X_EXPORT void IgnoreClient(ClientPtr /*client*/);
+
+extern _X_EXPORT void AttendClient(ClientPtr /*client*/);
+
+extern _X_EXPORT void MakeClientGrabImpervious(ClientPtr /*client*/);
+
+extern _X_EXPORT void MakeClientGrabPervious(ClientPtr /*client*/);
+
+#ifdef XQUARTZ
+extern void ListenOnOpenFD(int /* fd */, int /* noxauth */);
+#endif
+
+extern _X_EXPORT CARD32 GetTimeInMillis(void);
+
+extern _X_EXPORT void AdjustWaitForDelay(
+    pointer /*waitTime*/,
+    unsigned long /*newdelay*/);
+
+typedef	struct _OsTimerRec *OsTimerPtr;
+
+typedef CARD32 (*OsTimerCallback)(
+    OsTimerPtr /* timer */,
+    CARD32 /* time */,
+    pointer /* arg */);
+
+extern _X_EXPORT void TimerInit(void);
+
+extern _X_EXPORT Bool TimerForce(OsTimerPtr /* timer */);
+
+#define TimerAbsolute (1<<0)
+#define TimerForceOld (1<<1)
+
+extern _X_EXPORT OsTimerPtr TimerSet(
+    OsTimerPtr /* timer */,
+    int /* flags */,
+    CARD32 /* millis */,
+    OsTimerCallback /* func */,
+    pointer /* arg */);
+
+extern _X_EXPORT void TimerCheck(void);
+extern _X_EXPORT void TimerCancel(OsTimerPtr /* pTimer */);
+extern _X_EXPORT void TimerFree(OsTimerPtr /* pTimer */);
+
+extern _X_EXPORT void SetScreenSaverTimer(void);
+extern _X_EXPORT void FreeScreenSaverTimer(void);
+
+extern _X_EXPORT void AutoResetServer(int /*sig*/);
+
+extern _X_EXPORT void GiveUp(int /*sig*/);
+
+extern _X_EXPORT void UseMsg(void);
+
+extern _X_EXPORT void ProcessCommandLine(int /*argc*/, char* /*argv*/[]);
+
+extern _X_EXPORT int set_font_authorizations(
+    char ** /* authorizations */, 
+    int * /*authlen */, 
+    pointer /* client */);
+
+#ifndef _HAVE_XALLOC_DECLS
+#define _HAVE_XALLOC_DECLS
+
+/*
+ * Use malloc(3) instead.
+ */
+extern _X_EXPORT void *Xalloc(unsigned long /*amount*/) _X_DEPRECATED;
+/*
+ * Use calloc(3) instead
+ */
+extern _X_EXPORT void *Xcalloc(unsigned long /*amount*/) _X_DEPRECATED;
+/*
+ * Use realloc(3) instead
+ */
+extern _X_EXPORT void *Xrealloc(void * /*ptr*/, unsigned long /*amount*/)
+    _X_DEPRECATED;
+/*
+ * Use free(3) instead
+ */
+extern _X_EXPORT void Xfree(void * /*ptr*/) _X_DEPRECATED;
+
+#endif
+
+/*
+ * This function malloc(3)s buffer, terminating the server if there is not
+ * enough memory.
+ */
+extern _X_EXPORT void *XNFalloc(unsigned long /*amount*/);
+/*
+ * This function calloc(3)s buffer, terminating the server if there is not
+ * enough memory.
+ */
+extern _X_EXPORT void *XNFcalloc(unsigned long /*amount*/);
+/*
+ * This function realloc(3)s passed buffer, terminating the server if there is
+ * not enough memory.
+ */
+extern _X_EXPORT void *XNFrealloc(void * /*ptr*/, unsigned long /*amount*/);
+
+/*
+ * This function strdup(3)s passed string. The only difference from the library
+ * function that it is safe to pass NULL, as NULL will be returned.
+ */
+extern _X_EXPORT char *Xstrdup(const char *s);
+
+/*
+ * This function strdup(3)s passed string, terminating the server if there is
+ * not enough memory. If NULL is passed to this function, NULL is returned.
+ */
+extern _X_EXPORT char *XNFstrdup(const char *s);
+
+extern _X_EXPORT char *Xprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);
+extern _X_EXPORT char *Xvprintf(const char *fmt, va_list va);
+extern _X_EXPORT char *XNFprintf(const char *fmt, ...) _X_ATTRIBUTE_PRINTF(1,2);
+extern _X_EXPORT char *XNFvprintf(const char *fmt, va_list va);
+
+typedef void (*OsSigHandlerPtr)(int /* sig */);
+typedef int (*OsSigWrapperPtr)(int /* sig */);
+
+extern _X_EXPORT OsSigHandlerPtr OsSignal(int /* sig */, OsSigHandlerPtr /* handler */);
+extern _X_EXPORT OsSigWrapperPtr OsRegisterSigWrapper(OsSigWrapperPtr newWrap);
+
+extern _X_EXPORT int auditTrailLevel;
+
+extern _X_EXPORT void LockServer(void);
+extern _X_EXPORT void UnlockServer(void);
+
+extern _X_EXPORT int OsLookupColor(
+    int	/*screen*/,
+    char * /*name*/,
+    unsigned /*len*/,
+    unsigned short * /*pred*/,
+    unsigned short * /*pgreen*/,
+    unsigned short * /*pblue*/);
+
+extern _X_EXPORT void OsInit(void);
+
+extern _X_EXPORT void OsCleanup(Bool);
+
+extern _X_EXPORT void OsVendorFatalError(void);
+
+extern _X_EXPORT void OsVendorInit(void);
+
+extern _X_EXPORT void OsBlockSignals (void);
+
+extern _X_EXPORT void OsReleaseSignals (void);
+
+extern _X_EXPORT void OsAbort (void) _X_NORETURN;
+
+#if !defined(WIN32)
+extern _X_EXPORT int System(char *);
+extern _X_EXPORT pointer Popen(char *, char *);
+extern _X_EXPORT int Pclose(pointer);
+extern _X_EXPORT pointer Fopen(char *, char *);
+extern _X_EXPORT int Fclose(pointer);
+#else
+#define System(a) system(a)
+#define Popen(a,b) popen(a,b)
+#define Pclose(a) pclose(a)
+#define Fopen(a,b) fopen(a,b)
+#define Fclose(a) fclose(a)
+#endif
+
+extern _X_EXPORT void CheckUserParameters(int argc, char **argv, char **envp);
+extern _X_EXPORT void CheckUserAuthorization(void);
+
+extern _X_EXPORT int AddHost(
+    ClientPtr	/*client*/,
+    int         /*family*/,
+    unsigned    /*length*/,
+    const void */*pAddr*/);
+
+extern _X_EXPORT Bool ForEachHostInFamily (
+    int	    /*family*/,
+    Bool    (* /*func*/ )(
+            unsigned char * /* addr */,
+            short           /* len */,
+            pointer         /* closure */),
+    pointer /*closure*/);
+
+extern _X_EXPORT int RemoveHost(
+    ClientPtr	/*client*/,
+    int         /*family*/,
+    unsigned    /*length*/,
+    pointer     /*pAddr*/);
+
+extern _X_EXPORT int GetHosts(
+    pointer * /*data*/,
+    int	    * /*pnHosts*/,
+    int	    * /*pLen*/,
+    BOOL    * /*pEnabled*/);
+
+typedef struct sockaddr * sockaddrPtr;
+
+extern _X_EXPORT int InvalidHost(sockaddrPtr /*saddr*/, int /*len*/, ClientPtr client);
+
+extern _X_EXPORT int LocalClient(ClientPtr /* client */);
+
+extern _X_EXPORT int LocalClientCred(ClientPtr, int *, int *);
+
+#define LCC_UID_SET	(1 << 0)
+#define LCC_GID_SET	(1 << 1)
+#define LCC_PID_SET	(1 << 2)
+#define LCC_ZID_SET	(1 << 3)
+
+typedef struct {
+    int fieldsSet;	/* Bit mask of fields set */
+    int	euid;		/* Effective uid */
+    int egid;		/* Primary effective group id */
+    int nSuppGids;	/* Number of supplementary group ids */
+    int *pSuppGids;	/* Array of supplementary group ids */
+    int pid;		/* Process id */
+    int zoneid;		/* Only set on Solaris 10 & later */
+} LocalClientCredRec;
+
+extern _X_EXPORT int GetLocalClientCreds(ClientPtr, LocalClientCredRec **);
+extern _X_EXPORT void FreeLocalClientCreds(LocalClientCredRec *);
+
+extern _X_EXPORT int ChangeAccessControl(ClientPtr /*client*/, int /*fEnabled*/);
+
+extern _X_EXPORT int GetAccessControl(void);
+
+
+extern _X_EXPORT void AddLocalHosts(void);
+
+extern _X_EXPORT void ResetHosts(char *display);
+
+extern _X_EXPORT void EnableLocalHost(void);
+
+extern _X_EXPORT void DisableLocalHost(void);
+
+extern _X_EXPORT void AccessUsingXdmcp(void);
+
+extern _X_EXPORT void DefineSelf(int /*fd*/);
+
+#if XDMCP
+extern _X_EXPORT void AugmentSelf(pointer /*from*/, int /*len*/);
+
+extern _X_EXPORT void RegisterAuthorizations(void);
+#endif
+
+extern _X_EXPORT void InitAuthorization(char * /*filename*/);
+
+/* extern int LoadAuthorization(void); */
+
+extern _X_EXPORT int AuthorizationFromID (
+	XID 		id,
+	unsigned short	*name_lenp,
+	char		**namep,
+	unsigned short	*data_lenp,
+	char		**datap);
+
+extern _X_EXPORT XID CheckAuthorization(
+    unsigned int /*namelength*/,
+    const char * /*name*/,
+    unsigned int /*datalength*/,
+    const char * /*data*/,
+    ClientPtr /*client*/,
+    char ** /*reason*/
+);
+
+extern _X_EXPORT void ResetAuthorization(void);
+
+extern _X_EXPORT int RemoveAuthorization (
+    unsigned short	name_length,
+    const char		*name,
+    unsigned short	data_length,
+    const char		*data);
+
+extern _X_EXPORT int AddAuthorization(
+    unsigned int	/*name_length*/,
+    const char *	/*name*/,
+    unsigned int	/*data_length*/,
+    char *		/*data*/);
+
+#ifdef XCSECURITY
+extern _X_EXPORT XID GenerateAuthorization(
+    unsigned int   /* name_length */,
+    const char	*  /* name */,
+    unsigned int   /* data_length */,
+    const char	*  /* data */,
+    unsigned int * /* data_length_return */,
+    char	** /* data_return */);
+#endif
+
+extern _X_EXPORT int ddxProcessArgument(int /*argc*/, char * /*argv*/ [], int /*i*/);
+
+extern _X_EXPORT void ddxUseMsg(void);
+
+/* int ReqLen(xReq *req, ClientPtr client)
+ * Given a pointer to a *complete* request, return its length in bytes.
+ * Note that if the request is a big request (as defined in the Big
+ * Requests extension), the macro lies by returning 4 less than the
+ * length that it actually occupies in the request buffer.  This is so you
+ * can blindly compare the length with the various sz_<request> constants
+ * in Xproto.h without having to know/care about big requests.
+ */
+#define ReqLen(_pxReq, _client) \
+ ((_pxReq->length ? \
+     (_client->swapped ? lswaps(_pxReq->length) : _pxReq->length) \
+  : ((_client->swapped ? \
+	lswapl(((CARD32*)_pxReq)[1]) : ((CARD32*)_pxReq)[1])-1) \
+  ) << 2)
+
+/* otherReqTypePtr CastxReq(xReq *req, otherReqTypePtr)
+ * Cast the given request to one of type otherReqTypePtr to access
+ * fields beyond the length field.
+ */
+#define CastxReq(_pxReq, otherReqTypePtr) \
+    (_pxReq->length ? (otherReqTypePtr)_pxReq \
+		    : (otherReqTypePtr)(((CARD32*)_pxReq)+1))
+
+/* stuff for ReplyCallback */
+extern _X_EXPORT CallbackListPtr ReplyCallback;
+typedef struct {
+    ClientPtr client;
+    const void *replyData;
+    unsigned long dataLenBytes;
+    unsigned long bytesRemaining;
+    Bool startOfReply;
+} ReplyInfoRec;
+
+/* stuff for FlushCallback */
+extern _X_EXPORT CallbackListPtr FlushCallback;
+
+extern _X_EXPORT void AbortDDX(void);
+extern _X_EXPORT void ddxGiveUp(void);
+extern _X_EXPORT int TimeSinceLastInputEvent(void);
+
+/* strcasecmp.c */
+#if NEED_STRCASECMP
+#define strcasecmp xstrcasecmp
+extern _X_EXPORT int xstrcasecmp(const char *s1, const char *s2);
+#endif
+
+#if NEED_STRNCASECMP
+#define strncasecmp xstrncasecmp
+extern _X_EXPORT int xstrncasecmp(const char *s1, const char *s2, size_t n);
+#endif
+
+#if NEED_STRCASESTR
+#define strcasestr xstrcasestr
+extern _X_EXPORT char *xstrcasestr(const char *s, const char *find);
+#endif
+
+#ifndef HAS_STRLCPY
+extern _X_EXPORT size_t strlcpy(char *dst, const char *src, size_t siz);
+extern _X_EXPORT size_t strlcat(char *dst, const char *src, size_t siz);
+#endif
+
+/* Logging. */
+typedef enum _LogParameter {
+    XLOG_FLUSH,
+    XLOG_SYNC,
+    XLOG_VERBOSITY,
+    XLOG_FILE_VERBOSITY
+} LogParameter;
+
+/* Flags for log messages. */
+typedef enum {
+    X_PROBED,			/* Value was probed */
+    X_CONFIG,			/* Value was given in the config file */
+    X_DEFAULT,			/* Value is a default */
+    X_CMDLINE,			/* Value was given on the command line */
+    X_NOTICE,			/* Notice */
+    X_ERROR,			/* Error message */
+    X_WARNING,			/* Warning message */
+    X_INFO,			/* Informational message */
+    X_NONE,			/* No prefix */
+    X_NOT_IMPLEMENTED,		/* Not implemented */
+    X_UNKNOWN = -1		/* unknown -- this must always be last */
+} MessageType;
+
+extern _X_EXPORT const char *LogInit(const char *fname, const char *backup);
+extern _X_EXPORT void LogClose(void);
+extern _X_EXPORT Bool LogSetParameter(LogParameter param, int value);
+extern _X_EXPORT void LogVWrite(int verb, const char *f, va_list args);
+extern _X_EXPORT void LogWrite(int verb, const char *f, ...) _X_ATTRIBUTE_PRINTF(2,3);
+extern _X_EXPORT void LogVMessageVerb(MessageType type, int verb, const char *format,
+			    va_list args);
+extern _X_EXPORT void LogMessageVerb(MessageType type, int verb, const char *format,
+			   ...) _X_ATTRIBUTE_PRINTF(3,4);
+extern _X_EXPORT void LogMessage(MessageType type, const char *format, ...)
+			_X_ATTRIBUTE_PRINTF(2,3);
+extern _X_EXPORT void FreeAuditTimer(void);
+extern _X_EXPORT void AuditF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);
+extern _X_EXPORT void VAuditF(const char *f, va_list args);
+extern _X_EXPORT void FatalError(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2) _X_NORETURN;
+
+#ifdef DEBUG
+#define DebugF ErrorF
+#else
+#define DebugF(...) /* */
+#endif
+
+extern _X_EXPORT void VErrorF(const char *f, va_list args);
+extern _X_EXPORT void ErrorF(const char *f, ...) _X_ATTRIBUTE_PRINTF(1,2);
+extern _X_EXPORT void Error(char *str);
+extern _X_EXPORT void LogPrintMarkers(void);
+
+extern _X_EXPORT void xorg_backtrace(void);
+
+#endif /* OS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxgcops.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxgcops.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright 2001,2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for gcops support.  \see dmxgcops.c */
+
+#ifndef DMXGCOPS_H
+#define DMXGCOPS_H
+
+extern void dmxFillSpans(DrawablePtr pDrawable, GCPtr pGC,
+			 int nInit, DDXPointPtr pptInit, int *pwidthInit,
+			 int fSorted);
+extern void dmxSetSpans(DrawablePtr pDrawable, GCPtr pGC,
+			char *psrc, DDXPointPtr ppt, int *pwidth, int nspans,
+			int fSorted);
+extern void dmxPutImage(DrawablePtr pDrawable, GCPtr pGC,
+			int depth, int x, int y, int w, int h,
+			int leftPad, int format, char *pBits);
+extern RegionPtr dmxCopyArea(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+			     int srcx, int srcy, int w, int h,
+			     int dstx, int dsty);
+extern RegionPtr dmxCopyPlane(DrawablePtr pSrc, DrawablePtr pDst, GCPtr pGC,
+			      int srcx, int srcy, int width, int height,
+			      int dstx, int dsty, unsigned long bitPlane);
+extern void dmxPolyPoint(DrawablePtr pDrawable, GCPtr pGC,
+			 int mode, int npt, DDXPointPtr pptInit);
+extern void dmxPolylines(DrawablePtr pDrawable, GCPtr pGC,
+			 int mode, int npt, DDXPointPtr pptInit);
+extern void dmxPolySegment(DrawablePtr pDrawable, GCPtr pGC,
+			   int nseg, xSegment *pSegs);
+extern void dmxPolyRectangle(DrawablePtr pDrawable, GCPtr pGC,
+			     int nrects, xRectangle *pRects);
+extern void dmxPolyArc(DrawablePtr pDrawable, GCPtr pGC,
+		       int narcs, xArc *parcs);
+extern void dmxFillPolygon(DrawablePtr pDrawable, GCPtr pGC,
+			   int shape, int mode, int count, DDXPointPtr pPts);
+extern void dmxPolyFillRect(DrawablePtr pDrawable, GCPtr pGC,
+			    int nrectFill, xRectangle *prectInit);
+extern void dmxPolyFillArc(DrawablePtr pDrawable, GCPtr pGC,
+			   int narcs, xArc *parcs);
+extern int dmxPolyText8(DrawablePtr pDrawable, GCPtr pGC,
+			int x, int y, int count, char *chars);
+extern int dmxPolyText16(DrawablePtr pDrawable, GCPtr pGC,
+			 int x, int y, int count, unsigned short *chars);
+extern void dmxImageText8(DrawablePtr pDrawable, GCPtr pGC,
+			  int x, int y, int count, char *chars);
+extern void dmxImageText16(DrawablePtr pDrawable, GCPtr pGC,
+			   int x, int y, int count, unsigned short *chars);
+extern void dmxImageGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+			     int x, int y, unsigned int nglyph,
+			     CharInfoPtr *ppci, pointer pglyphBase);
+extern void dmxPolyGlyphBlt(DrawablePtr pDrawable, GCPtr pGC,
+			    int x, int y, unsigned int nglyph,
+			    CharInfoPtr *ppci, pointer pglyphBase);
+extern void dmxPushPixels(GCPtr pGC, PixmapPtr pBitMap, DrawablePtr pDst,
+			  int w, int h, int x, int y);
+
+extern void dmxGetImage(DrawablePtr pDrawable, int sx, int sy, int w, int h,
+			unsigned int format, unsigned long planeMask,
+			char *pdstLine);
+extern void dmxGetSpans(DrawablePtr pDrawable, int wMax,
+			DDXPointPtr ppt, int *pwidth, int nspans,
+			char *pdstStart);
+
+#endif /* DMXGCOPS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipict.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mipict.h
@@ -0,0 +1,215 @@
+/*
+ *
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _MIPICT_H_
+#define _MIPICT_H_
+
+#include "picturestr.h"
+
+#define MI_MAX_INDEXED	256 /* XXX depth must be <= 8 */
+
+#if MI_MAX_INDEXED <= 256
+typedef CARD8 miIndexType;
+#endif
+
+typedef struct _miIndexed {
+    Bool	color;
+    CARD32	rgba[MI_MAX_INDEXED];
+    miIndexType	ent[32768];
+} miIndexedRec, *miIndexedPtr;
+
+#define miCvtR8G8B8to15(s) ((((s) >> 3) & 0x001f) | \
+			     (((s) >> 6) & 0x03e0) | \
+			     (((s) >> 9) & 0x7c00))
+#define miIndexToEnt15(mif,rgb15) ((mif)->ent[rgb15])
+#define miIndexToEnt24(mif,rgb24) miIndexToEnt15(mif,miCvtR8G8B8to15(rgb24))
+
+#define miIndexToEntY24(mif,rgb24) ((mif)->ent[CvtR8G8B8toY15(rgb24)])
+
+extern _X_EXPORT int
+miCreatePicture (PicturePtr pPicture);
+
+extern _X_EXPORT void
+miDestroyPicture (PicturePtr pPicture);
+
+extern _X_EXPORT void
+miDestroyPictureClip (PicturePtr pPicture);
+
+extern _X_EXPORT int
+miChangePictureClip (PicturePtr    pPicture,
+		     int	   type,
+		     pointer	   value,
+		     int	   n);
+
+extern _X_EXPORT void
+miChangePicture (PicturePtr pPicture,
+		 Mask       mask);
+
+extern _X_EXPORT void
+miValidatePicture (PicturePtr pPicture,
+		   Mask       mask);
+
+extern _X_EXPORT int
+miChangePictureTransform (PicturePtr	pPicture,
+			  PictTransform *transform);
+
+extern _X_EXPORT int
+miChangePictureFilter (PicturePtr pPicture,
+		       int	  filter,
+		       xFixed     *params,
+		       int	  nparams);
+
+extern _X_EXPORT void
+miCompositeSourceValidate (PicturePtr	pPicture,
+			   INT16	x,
+			   INT16	y,
+			   CARD16	width,
+			   CARD16	height);
+extern _X_EXPORT Bool
+miComputeCompositeRegion (RegionPtr	pRegion,
+			  PicturePtr	pSrc,
+			  PicturePtr	pMask,
+			  PicturePtr	pDst,
+			  INT16		xSrc,
+			  INT16		ySrc,
+			  INT16		xMask,
+			  INT16		yMask,
+			  INT16		xDst,
+			  INT16		yDst,
+			  CARD16	width,
+			  CARD16	height);
+
+extern _X_EXPORT Bool
+miPictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats);
+
+extern _X_EXPORT Bool
+miRealizeGlyph (ScreenPtr pScreen,
+		GlyphPtr  glyph);
+
+extern _X_EXPORT void
+miUnrealizeGlyph (ScreenPtr pScreen,
+		  GlyphPtr  glyph);
+
+extern _X_EXPORT void
+miGlyphs (CARD8		op,
+	  PicturePtr	pSrc,
+	  PicturePtr	pDst,
+	  PictFormatPtr	maskFormat,
+	  INT16		xSrc,
+	  INT16		ySrc,
+	  int		nlist,
+	  GlyphListPtr	list,
+	  GlyphPtr	*glyphs);
+
+extern _X_EXPORT void
+miRenderColorToPixel (PictFormatPtr pPict,
+		      xRenderColor  *color,
+		      CARD32	    *pixel);
+
+extern _X_EXPORT void
+miRenderPixelToColor (PictFormatPtr pPict,
+		      CARD32	    pixel,
+		      xRenderColor  *color);
+
+extern _X_EXPORT Bool
+miIsSolidAlpha (PicturePtr pSrc);
+
+extern _X_EXPORT void
+miCompositeRects (CARD8		op,
+		  PicturePtr	pDst,
+		  xRenderColor  *color,
+		  int		nRect,
+		  xRectangle    *rects);
+
+extern _X_EXPORT void
+miTrapezoidBounds (int ntrap, xTrapezoid *traps, BoxPtr box);
+
+extern _X_EXPORT void
+miTrapezoids (CARD8	    op,
+	      PicturePtr    pSrc,
+	      PicturePtr    pDst,
+	      PictFormatPtr maskFormat,
+	      INT16	    xSrc,
+	      INT16	    ySrc,
+	      int	    ntrap,
+	      xTrapezoid    *traps);
+
+extern _X_EXPORT void
+miPointFixedBounds (int npoint, xPointFixed *points, BoxPtr bounds);
+    
+extern _X_EXPORT void
+miTriangleBounds (int ntri, xTriangle *tris, BoxPtr bounds);
+
+extern _X_EXPORT void
+miTriangles (CARD8	    op,
+	     PicturePtr	    pSrc,
+	     PicturePtr	    pDst,
+	     PictFormatPtr  maskFormat,
+	     INT16	    xSrc,
+	     INT16	    ySrc,
+	     int	    ntri,
+	     xTriangle	    *tris);
+
+extern _X_EXPORT void
+miTriStrip (CARD8	    op,
+	    PicturePtr	    pSrc,
+	    PicturePtr	    pDst,
+	    PictFormatPtr   maskFormat,
+	    INT16	    xSrc,
+	    INT16	    ySrc,
+	    int		    npoint,
+	    xPointFixed	    *points);
+
+extern _X_EXPORT void
+miTriFan (CARD8		op,
+	  PicturePtr	pSrc,
+	  PicturePtr	pDst,
+	  PictFormatPtr maskFormat,
+	  INT16		xSrc,
+	  INT16		ySrc,
+	  int		npoint,
+	  xPointFixed	*points);
+
+extern _X_EXPORT PicturePtr
+miCreateAlphaPicture (ScreenPtr	    pScreen, 
+		      PicturePtr    pDst,
+		      PictFormatPtr pPictFormat,
+		      CARD16	    width,
+		      CARD16	    height);
+
+extern _X_EXPORT Bool
+miInitIndexed (ScreenPtr	pScreen,
+	       PictFormatPtr	pFormat);
+
+extern _X_EXPORT void
+miCloseIndexed (ScreenPtr	pScreen,
+		PictFormatPtr	pFormat);
+
+extern _X_EXPORT void
+miUpdateIndexed (ScreenPtr	pScreen,
+		 PictFormatPtr	pFormat,
+		 int		ndef,
+		 xColorItem	*pdef);
+
+#endif /* _MIPICT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapioffsets.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapioffsets.h
@@ -0,0 +1,1174 @@
+/* DO NOT EDIT - This file generated automatically by gl_offsets.py (from Mesa) script */
+
+/*
+ * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL, IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _GLAPI_OFFSETS_H_ )
+#  define _GLAPI_OFFSETS_H_
+
+#define _gloffset_NewList 0
+#define _gloffset_EndList 1
+#define _gloffset_CallList 2
+#define _gloffset_CallLists 3
+#define _gloffset_DeleteLists 4
+#define _gloffset_GenLists 5
+#define _gloffset_ListBase 6
+#define _gloffset_Begin 7
+#define _gloffset_Bitmap 8
+#define _gloffset_Color3b 9
+#define _gloffset_Color3bv 10
+#define _gloffset_Color3d 11
+#define _gloffset_Color3dv 12
+#define _gloffset_Color3f 13
+#define _gloffset_Color3fv 14
+#define _gloffset_Color3i 15
+#define _gloffset_Color3iv 16
+#define _gloffset_Color3s 17
+#define _gloffset_Color3sv 18
+#define _gloffset_Color3ub 19
+#define _gloffset_Color3ubv 20
+#define _gloffset_Color3ui 21
+#define _gloffset_Color3uiv 22
+#define _gloffset_Color3us 23
+#define _gloffset_Color3usv 24
+#define _gloffset_Color4b 25
+#define _gloffset_Color4bv 26
+#define _gloffset_Color4d 27
+#define _gloffset_Color4dv 28
+#define _gloffset_Color4f 29
+#define _gloffset_Color4fv 30
+#define _gloffset_Color4i 31
+#define _gloffset_Color4iv 32
+#define _gloffset_Color4s 33
+#define _gloffset_Color4sv 34
+#define _gloffset_Color4ub 35
+#define _gloffset_Color4ubv 36
+#define _gloffset_Color4ui 37
+#define _gloffset_Color4uiv 38
+#define _gloffset_Color4us 39
+#define _gloffset_Color4usv 40
+#define _gloffset_EdgeFlag 41
+#define _gloffset_EdgeFlagv 42
+#define _gloffset_End 43
+#define _gloffset_Indexd 44
+#define _gloffset_Indexdv 45
+#define _gloffset_Indexf 46
+#define _gloffset_Indexfv 47
+#define _gloffset_Indexi 48
+#define _gloffset_Indexiv 49
+#define _gloffset_Indexs 50
+#define _gloffset_Indexsv 51
+#define _gloffset_Normal3b 52
+#define _gloffset_Normal3bv 53
+#define _gloffset_Normal3d 54
+#define _gloffset_Normal3dv 55
+#define _gloffset_Normal3f 56
+#define _gloffset_Normal3fv 57
+#define _gloffset_Normal3i 58
+#define _gloffset_Normal3iv 59
+#define _gloffset_Normal3s 60
+#define _gloffset_Normal3sv 61
+#define _gloffset_RasterPos2d 62
+#define _gloffset_RasterPos2dv 63
+#define _gloffset_RasterPos2f 64
+#define _gloffset_RasterPos2fv 65
+#define _gloffset_RasterPos2i 66
+#define _gloffset_RasterPos2iv 67
+#define _gloffset_RasterPos2s 68
+#define _gloffset_RasterPos2sv 69
+#define _gloffset_RasterPos3d 70
+#define _gloffset_RasterPos3dv 71
+#define _gloffset_RasterPos3f 72
+#define _gloffset_RasterPos3fv 73
+#define _gloffset_RasterPos3i 74
+#define _gloffset_RasterPos3iv 75
+#define _gloffset_RasterPos3s 76
+#define _gloffset_RasterPos3sv 77
+#define _gloffset_RasterPos4d 78
+#define _gloffset_RasterPos4dv 79
+#define _gloffset_RasterPos4f 80
+#define _gloffset_RasterPos4fv 81
+#define _gloffset_RasterPos4i 82
+#define _gloffset_RasterPos4iv 83
+#define _gloffset_RasterPos4s 84
+#define _gloffset_RasterPos4sv 85
+#define _gloffset_Rectd 86
+#define _gloffset_Rectdv 87
+#define _gloffset_Rectf 88
+#define _gloffset_Rectfv 89
+#define _gloffset_Recti 90
+#define _gloffset_Rectiv 91
+#define _gloffset_Rects 92
+#define _gloffset_Rectsv 93
+#define _gloffset_TexCoord1d 94
+#define _gloffset_TexCoord1dv 95
+#define _gloffset_TexCoord1f 96
+#define _gloffset_TexCoord1fv 97
+#define _gloffset_TexCoord1i 98
+#define _gloffset_TexCoord1iv 99
+#define _gloffset_TexCoord1s 100
+#define _gloffset_TexCoord1sv 101
+#define _gloffset_TexCoord2d 102
+#define _gloffset_TexCoord2dv 103
+#define _gloffset_TexCoord2f 104
+#define _gloffset_TexCoord2fv 105
+#define _gloffset_TexCoord2i 106
+#define _gloffset_TexCoord2iv 107
+#define _gloffset_TexCoord2s 108
+#define _gloffset_TexCoord2sv 109
+#define _gloffset_TexCoord3d 110
+#define _gloffset_TexCoord3dv 111
+#define _gloffset_TexCoord3f 112
+#define _gloffset_TexCoord3fv 113
+#define _gloffset_TexCoord3i 114
+#define _gloffset_TexCoord3iv 115
+#define _gloffset_TexCoord3s 116
+#define _gloffset_TexCoord3sv 117
+#define _gloffset_TexCoord4d 118
+#define _gloffset_TexCoord4dv 119
+#define _gloffset_TexCoord4f 120
+#define _gloffset_TexCoord4fv 121
+#define _gloffset_TexCoord4i 122
+#define _gloffset_TexCoord4iv 123
+#define _gloffset_TexCoord4s 124
+#define _gloffset_TexCoord4sv 125
+#define _gloffset_Vertex2d 126
+#define _gloffset_Vertex2dv 127
+#define _gloffset_Vertex2f 128
+#define _gloffset_Vertex2fv 129
+#define _gloffset_Vertex2i 130
+#define _gloffset_Vertex2iv 131
+#define _gloffset_Vertex2s 132
+#define _gloffset_Vertex2sv 133
+#define _gloffset_Vertex3d 134
+#define _gloffset_Vertex3dv 135
+#define _gloffset_Vertex3f 136
+#define _gloffset_Vertex3fv 137
+#define _gloffset_Vertex3i 138
+#define _gloffset_Vertex3iv 139
+#define _gloffset_Vertex3s 140
+#define _gloffset_Vertex3sv 141
+#define _gloffset_Vertex4d 142
+#define _gloffset_Vertex4dv 143
+#define _gloffset_Vertex4f 144
+#define _gloffset_Vertex4fv 145
+#define _gloffset_Vertex4i 146
+#define _gloffset_Vertex4iv 147
+#define _gloffset_Vertex4s 148
+#define _gloffset_Vertex4sv 149
+#define _gloffset_ClipPlane 150
+#define _gloffset_ColorMaterial 151
+#define _gloffset_CullFace 152
+#define _gloffset_Fogf 153
+#define _gloffset_Fogfv 154
+#define _gloffset_Fogi 155
+#define _gloffset_Fogiv 156
+#define _gloffset_FrontFace 157
+#define _gloffset_Hint 158
+#define _gloffset_Lightf 159
+#define _gloffset_Lightfv 160
+#define _gloffset_Lighti 161
+#define _gloffset_Lightiv 162
+#define _gloffset_LightModelf 163
+#define _gloffset_LightModelfv 164
+#define _gloffset_LightModeli 165
+#define _gloffset_LightModeliv 166
+#define _gloffset_LineStipple 167
+#define _gloffset_LineWidth 168
+#define _gloffset_Materialf 169
+#define _gloffset_Materialfv 170
+#define _gloffset_Materiali 171
+#define _gloffset_Materialiv 172
+#define _gloffset_PointSize 173
+#define _gloffset_PolygonMode 174
+#define _gloffset_PolygonStipple 175
+#define _gloffset_Scissor 176
+#define _gloffset_ShadeModel 177
+#define _gloffset_TexParameterf 178
+#define _gloffset_TexParameterfv 179
+#define _gloffset_TexParameteri 180
+#define _gloffset_TexParameteriv 181
+#define _gloffset_TexImage1D 182
+#define _gloffset_TexImage2D 183
+#define _gloffset_TexEnvf 184
+#define _gloffset_TexEnvfv 185
+#define _gloffset_TexEnvi 186
+#define _gloffset_TexEnviv 187
+#define _gloffset_TexGend 188
+#define _gloffset_TexGendv 189
+#define _gloffset_TexGenf 190
+#define _gloffset_TexGenfv 191
+#define _gloffset_TexGeni 192
+#define _gloffset_TexGeniv 193
+#define _gloffset_FeedbackBuffer 194
+#define _gloffset_SelectBuffer 195
+#define _gloffset_RenderMode 196
+#define _gloffset_InitNames 197
+#define _gloffset_LoadName 198
+#define _gloffset_PassThrough 199
+#define _gloffset_PopName 200
+#define _gloffset_PushName 201
+#define _gloffset_DrawBuffer 202
+#define _gloffset_Clear 203
+#define _gloffset_ClearAccum 204
+#define _gloffset_ClearIndex 205
+#define _gloffset_ClearColor 206
+#define _gloffset_ClearStencil 207
+#define _gloffset_ClearDepth 208
+#define _gloffset_StencilMask 209
+#define _gloffset_ColorMask 210
+#define _gloffset_DepthMask 211
+#define _gloffset_IndexMask 212
+#define _gloffset_Accum 213
+#define _gloffset_Disable 214
+#define _gloffset_Enable 215
+#define _gloffset_Finish 216
+#define _gloffset_Flush 217
+#define _gloffset_PopAttrib 218
+#define _gloffset_PushAttrib 219
+#define _gloffset_Map1d 220
+#define _gloffset_Map1f 221
+#define _gloffset_Map2d 222
+#define _gloffset_Map2f 223
+#define _gloffset_MapGrid1d 224
+#define _gloffset_MapGrid1f 225
+#define _gloffset_MapGrid2d 226
+#define _gloffset_MapGrid2f 227
+#define _gloffset_EvalCoord1d 228
+#define _gloffset_EvalCoord1dv 229
+#define _gloffset_EvalCoord1f 230
+#define _gloffset_EvalCoord1fv 231
+#define _gloffset_EvalCoord2d 232
+#define _gloffset_EvalCoord2dv 233
+#define _gloffset_EvalCoord2f 234
+#define _gloffset_EvalCoord2fv 235
+#define _gloffset_EvalMesh1 236
+#define _gloffset_EvalPoint1 237
+#define _gloffset_EvalMesh2 238
+#define _gloffset_EvalPoint2 239
+#define _gloffset_AlphaFunc 240
+#define _gloffset_BlendFunc 241
+#define _gloffset_LogicOp 242
+#define _gloffset_StencilFunc 243
+#define _gloffset_StencilOp 244
+#define _gloffset_DepthFunc 245
+#define _gloffset_PixelZoom 246
+#define _gloffset_PixelTransferf 247
+#define _gloffset_PixelTransferi 248
+#define _gloffset_PixelStoref 249
+#define _gloffset_PixelStorei 250
+#define _gloffset_PixelMapfv 251
+#define _gloffset_PixelMapuiv 252
+#define _gloffset_PixelMapusv 253
+#define _gloffset_ReadBuffer 254
+#define _gloffset_CopyPixels 255
+#define _gloffset_ReadPixels 256
+#define _gloffset_DrawPixels 257
+#define _gloffset_GetBooleanv 258
+#define _gloffset_GetClipPlane 259
+#define _gloffset_GetDoublev 260
+#define _gloffset_GetError 261
+#define _gloffset_GetFloatv 262
+#define _gloffset_GetIntegerv 263
+#define _gloffset_GetLightfv 264
+#define _gloffset_GetLightiv 265
+#define _gloffset_GetMapdv 266
+#define _gloffset_GetMapfv 267
+#define _gloffset_GetMapiv 268
+#define _gloffset_GetMaterialfv 269
+#define _gloffset_GetMaterialiv 270
+#define _gloffset_GetPixelMapfv 271
+#define _gloffset_GetPixelMapuiv 272
+#define _gloffset_GetPixelMapusv 273
+#define _gloffset_GetPolygonStipple 274
+#define _gloffset_GetString 275
+#define _gloffset_GetTexEnvfv 276
+#define _gloffset_GetTexEnviv 277
+#define _gloffset_GetTexGendv 278
+#define _gloffset_GetTexGenfv 279
+#define _gloffset_GetTexGeniv 280
+#define _gloffset_GetTexImage 281
+#define _gloffset_GetTexParameterfv 282
+#define _gloffset_GetTexParameteriv 283
+#define _gloffset_GetTexLevelParameterfv 284
+#define _gloffset_GetTexLevelParameteriv 285
+#define _gloffset_IsEnabled 286
+#define _gloffset_IsList 287
+#define _gloffset_DepthRange 288
+#define _gloffset_Frustum 289
+#define _gloffset_LoadIdentity 290
+#define _gloffset_LoadMatrixf 291
+#define _gloffset_LoadMatrixd 292
+#define _gloffset_MatrixMode 293
+#define _gloffset_MultMatrixf 294
+#define _gloffset_MultMatrixd 295
+#define _gloffset_Ortho 296
+#define _gloffset_PopMatrix 297
+#define _gloffset_PushMatrix 298
+#define _gloffset_Rotated 299
+#define _gloffset_Rotatef 300
+#define _gloffset_Scaled 301
+#define _gloffset_Scalef 302
+#define _gloffset_Translated 303
+#define _gloffset_Translatef 304
+#define _gloffset_Viewport 305
+#define _gloffset_ArrayElement 306
+#define _gloffset_BindTexture 307
+#define _gloffset_ColorPointer 308
+#define _gloffset_DisableClientState 309
+#define _gloffset_DrawArrays 310
+#define _gloffset_DrawElements 311
+#define _gloffset_EdgeFlagPointer 312
+#define _gloffset_EnableClientState 313
+#define _gloffset_IndexPointer 314
+#define _gloffset_Indexub 315
+#define _gloffset_Indexubv 316
+#define _gloffset_InterleavedArrays 317
+#define _gloffset_NormalPointer 318
+#define _gloffset_PolygonOffset 319
+#define _gloffset_TexCoordPointer 320
+#define _gloffset_VertexPointer 321
+#define _gloffset_AreTexturesResident 322
+#define _gloffset_CopyTexImage1D 323
+#define _gloffset_CopyTexImage2D 324
+#define _gloffset_CopyTexSubImage1D 325
+#define _gloffset_CopyTexSubImage2D 326
+#define _gloffset_DeleteTextures 327
+#define _gloffset_GenTextures 328
+#define _gloffset_GetPointerv 329
+#define _gloffset_IsTexture 330
+#define _gloffset_PrioritizeTextures 331
+#define _gloffset_TexSubImage1D 332
+#define _gloffset_TexSubImage2D 333
+#define _gloffset_PopClientAttrib 334
+#define _gloffset_PushClientAttrib 335
+#define _gloffset_BlendColor 336
+#define _gloffset_BlendEquation 337
+#define _gloffset_DrawRangeElements 338
+#define _gloffset_ColorTable 339
+#define _gloffset_ColorTableParameterfv 340
+#define _gloffset_ColorTableParameteriv 341
+#define _gloffset_CopyColorTable 342
+#define _gloffset_GetColorTable 343
+#define _gloffset_GetColorTableParameterfv 344
+#define _gloffset_GetColorTableParameteriv 345
+#define _gloffset_ColorSubTable 346
+#define _gloffset_CopyColorSubTable 347
+#define _gloffset_ConvolutionFilter1D 348
+#define _gloffset_ConvolutionFilter2D 349
+#define _gloffset_ConvolutionParameterf 350
+#define _gloffset_ConvolutionParameterfv 351
+#define _gloffset_ConvolutionParameteri 352
+#define _gloffset_ConvolutionParameteriv 353
+#define _gloffset_CopyConvolutionFilter1D 354
+#define _gloffset_CopyConvolutionFilter2D 355
+#define _gloffset_GetConvolutionFilter 356
+#define _gloffset_GetConvolutionParameterfv 357
+#define _gloffset_GetConvolutionParameteriv 358
+#define _gloffset_GetSeparableFilter 359
+#define _gloffset_SeparableFilter2D 360
+#define _gloffset_GetHistogram 361
+#define _gloffset_GetHistogramParameterfv 362
+#define _gloffset_GetHistogramParameteriv 363
+#define _gloffset_GetMinmax 364
+#define _gloffset_GetMinmaxParameterfv 365
+#define _gloffset_GetMinmaxParameteriv 366
+#define _gloffset_Histogram 367
+#define _gloffset_Minmax 368
+#define _gloffset_ResetHistogram 369
+#define _gloffset_ResetMinmax 370
+#define _gloffset_TexImage3D 371
+#define _gloffset_TexSubImage3D 372
+#define _gloffset_CopyTexSubImage3D 373
+#define _gloffset_ActiveTextureARB 374
+#define _gloffset_ClientActiveTextureARB 375
+#define _gloffset_MultiTexCoord1dARB 376
+#define _gloffset_MultiTexCoord1dvARB 377
+#define _gloffset_MultiTexCoord1fARB 378
+#define _gloffset_MultiTexCoord1fvARB 379
+#define _gloffset_MultiTexCoord1iARB 380
+#define _gloffset_MultiTexCoord1ivARB 381
+#define _gloffset_MultiTexCoord1sARB 382
+#define _gloffset_MultiTexCoord1svARB 383
+#define _gloffset_MultiTexCoord2dARB 384
+#define _gloffset_MultiTexCoord2dvARB 385
+#define _gloffset_MultiTexCoord2fARB 386
+#define _gloffset_MultiTexCoord2fvARB 387
+#define _gloffset_MultiTexCoord2iARB 388
+#define _gloffset_MultiTexCoord2ivARB 389
+#define _gloffset_MultiTexCoord2sARB 390
+#define _gloffset_MultiTexCoord2svARB 391
+#define _gloffset_MultiTexCoord3dARB 392
+#define _gloffset_MultiTexCoord3dvARB 393
+#define _gloffset_MultiTexCoord3fARB 394
+#define _gloffset_MultiTexCoord3fvARB 395
+#define _gloffset_MultiTexCoord3iARB 396
+#define _gloffset_MultiTexCoord3ivARB 397
+#define _gloffset_MultiTexCoord3sARB 398
+#define _gloffset_MultiTexCoord3svARB 399
+#define _gloffset_MultiTexCoord4dARB 400
+#define _gloffset_MultiTexCoord4dvARB 401
+#define _gloffset_MultiTexCoord4fARB 402
+#define _gloffset_MultiTexCoord4fvARB 403
+#define _gloffset_MultiTexCoord4iARB 404
+#define _gloffset_MultiTexCoord4ivARB 405
+#define _gloffset_MultiTexCoord4sARB 406
+#define _gloffset_MultiTexCoord4svARB 407
+
+#if !defined(IN_DRI_DRIVER)
+
+#define _gloffset_AttachShader 408
+#define _gloffset_CreateProgram 409
+#define _gloffset_CreateShader 410
+#define _gloffset_DeleteProgram 411
+#define _gloffset_DeleteShader 412
+#define _gloffset_DetachShader 413
+#define _gloffset_GetAttachedShaders 414
+#define _gloffset_GetProgramInfoLog 415
+#define _gloffset_GetProgramiv 416
+#define _gloffset_GetShaderInfoLog 417
+#define _gloffset_GetShaderiv 418
+#define _gloffset_IsProgram 419
+#define _gloffset_IsShader 420
+#define _gloffset_StencilFuncSeparate 421
+#define _gloffset_StencilMaskSeparate 422
+#define _gloffset_StencilOpSeparate 423
+#define _gloffset_UniformMatrix2x3fv 424
+#define _gloffset_UniformMatrix2x4fv 425
+#define _gloffset_UniformMatrix3x2fv 426
+#define _gloffset_UniformMatrix3x4fv 427
+#define _gloffset_UniformMatrix4x2fv 428
+#define _gloffset_UniformMatrix4x3fv 429
+#define _gloffset_LoadTransposeMatrixdARB 430
+#define _gloffset_LoadTransposeMatrixfARB 431
+#define _gloffset_MultTransposeMatrixdARB 432
+#define _gloffset_MultTransposeMatrixfARB 433
+#define _gloffset_SampleCoverageARB 434
+#define _gloffset_CompressedTexImage1DARB 435
+#define _gloffset_CompressedTexImage2DARB 436
+#define _gloffset_CompressedTexImage3DARB 437
+#define _gloffset_CompressedTexSubImage1DARB 438
+#define _gloffset_CompressedTexSubImage2DARB 439
+#define _gloffset_CompressedTexSubImage3DARB 440
+#define _gloffset_GetCompressedTexImageARB 441
+#define _gloffset_DisableVertexAttribArrayARB 442
+#define _gloffset_EnableVertexAttribArrayARB 443
+#define _gloffset_GetProgramEnvParameterdvARB 444
+#define _gloffset_GetProgramEnvParameterfvARB 445
+#define _gloffset_GetProgramLocalParameterdvARB 446
+#define _gloffset_GetProgramLocalParameterfvARB 447
+#define _gloffset_GetProgramStringARB 448
+#define _gloffset_GetProgramivARB 449
+#define _gloffset_GetVertexAttribdvARB 450
+#define _gloffset_GetVertexAttribfvARB 451
+#define _gloffset_GetVertexAttribivARB 452
+#define _gloffset_ProgramEnvParameter4dARB 453
+#define _gloffset_ProgramEnvParameter4dvARB 454
+#define _gloffset_ProgramEnvParameter4fARB 455
+#define _gloffset_ProgramEnvParameter4fvARB 456
+#define _gloffset_ProgramLocalParameter4dARB 457
+#define _gloffset_ProgramLocalParameter4dvARB 458
+#define _gloffset_ProgramLocalParameter4fARB 459
+#define _gloffset_ProgramLocalParameter4fvARB 460
+#define _gloffset_ProgramStringARB 461
+#define _gloffset_VertexAttrib1dARB 462
+#define _gloffset_VertexAttrib1dvARB 463
+#define _gloffset_VertexAttrib1fARB 464
+#define _gloffset_VertexAttrib1fvARB 465
+#define _gloffset_VertexAttrib1sARB 466
+#define _gloffset_VertexAttrib1svARB 467
+#define _gloffset_VertexAttrib2dARB 468
+#define _gloffset_VertexAttrib2dvARB 469
+#define _gloffset_VertexAttrib2fARB 470
+#define _gloffset_VertexAttrib2fvARB 471
+#define _gloffset_VertexAttrib2sARB 472
+#define _gloffset_VertexAttrib2svARB 473
+#define _gloffset_VertexAttrib3dARB 474
+#define _gloffset_VertexAttrib3dvARB 475
+#define _gloffset_VertexAttrib3fARB 476
+#define _gloffset_VertexAttrib3fvARB 477
+#define _gloffset_VertexAttrib3sARB 478
+#define _gloffset_VertexAttrib3svARB 479
+#define _gloffset_VertexAttrib4NbvARB 480
+#define _gloffset_VertexAttrib4NivARB 481
+#define _gloffset_VertexAttrib4NsvARB 482
+#define _gloffset_VertexAttrib4NubARB 483
+#define _gloffset_VertexAttrib4NubvARB 484
+#define _gloffset_VertexAttrib4NuivARB 485
+#define _gloffset_VertexAttrib4NusvARB 486
+#define _gloffset_VertexAttrib4bvARB 487
+#define _gloffset_VertexAttrib4dARB 488
+#define _gloffset_VertexAttrib4dvARB 489
+#define _gloffset_VertexAttrib4fARB 490
+#define _gloffset_VertexAttrib4fvARB 491
+#define _gloffset_VertexAttrib4ivARB 492
+#define _gloffset_VertexAttrib4sARB 493
+#define _gloffset_VertexAttrib4svARB 494
+#define _gloffset_VertexAttrib4ubvARB 495
+#define _gloffset_VertexAttrib4uivARB 496
+#define _gloffset_VertexAttrib4usvARB 497
+#define _gloffset_VertexAttribPointerARB 498
+#define _gloffset_BindBufferARB 499
+#define _gloffset_BufferDataARB 500
+#define _gloffset_BufferSubDataARB 501
+#define _gloffset_DeleteBuffersARB 502
+#define _gloffset_GenBuffersARB 503
+#define _gloffset_GetBufferParameterivARB 504
+#define _gloffset_GetBufferPointervARB 505
+#define _gloffset_GetBufferSubDataARB 506
+#define _gloffset_IsBufferARB 507
+#define _gloffset_MapBufferARB 508
+#define _gloffset_UnmapBufferARB 509
+#define _gloffset_BeginQueryARB 510
+#define _gloffset_DeleteQueriesARB 511
+#define _gloffset_EndQueryARB 512
+#define _gloffset_GenQueriesARB 513
+#define _gloffset_GetQueryObjectivARB 514
+#define _gloffset_GetQueryObjectuivARB 515
+#define _gloffset_GetQueryivARB 516
+#define _gloffset_IsQueryARB 517
+#define _gloffset_AttachObjectARB 518
+#define _gloffset_CompileShaderARB 519
+#define _gloffset_CreateProgramObjectARB 520
+#define _gloffset_CreateShaderObjectARB 521
+#define _gloffset_DeleteObjectARB 522
+#define _gloffset_DetachObjectARB 523
+#define _gloffset_GetActiveUniformARB 524
+#define _gloffset_GetAttachedObjectsARB 525
+#define _gloffset_GetHandleARB 526
+#define _gloffset_GetInfoLogARB 527
+#define _gloffset_GetObjectParameterfvARB 528
+#define _gloffset_GetObjectParameterivARB 529
+#define _gloffset_GetShaderSourceARB 530
+#define _gloffset_GetUniformLocationARB 531
+#define _gloffset_GetUniformfvARB 532
+#define _gloffset_GetUniformivARB 533
+#define _gloffset_LinkProgramARB 534
+#define _gloffset_ShaderSourceARB 535
+#define _gloffset_Uniform1fARB 536
+#define _gloffset_Uniform1fvARB 537
+#define _gloffset_Uniform1iARB 538
+#define _gloffset_Uniform1ivARB 539
+#define _gloffset_Uniform2fARB 540
+#define _gloffset_Uniform2fvARB 541
+#define _gloffset_Uniform2iARB 542
+#define _gloffset_Uniform2ivARB 543
+#define _gloffset_Uniform3fARB 544
+#define _gloffset_Uniform3fvARB 545
+#define _gloffset_Uniform3iARB 546
+#define _gloffset_Uniform3ivARB 547
+#define _gloffset_Uniform4fARB 548
+#define _gloffset_Uniform4fvARB 549
+#define _gloffset_Uniform4iARB 550
+#define _gloffset_Uniform4ivARB 551
+#define _gloffset_UniformMatrix2fvARB 552
+#define _gloffset_UniformMatrix3fvARB 553
+#define _gloffset_UniformMatrix4fvARB 554
+#define _gloffset_UseProgramObjectARB 555
+#define _gloffset_ValidateProgramARB 556
+#define _gloffset_BindAttribLocationARB 557
+#define _gloffset_GetActiveAttribARB 558
+#define _gloffset_GetAttribLocationARB 559
+#define _gloffset_DrawBuffersARB 560
+#define _gloffset_PolygonOffsetEXT 561
+#define _gloffset_GetPixelTexGenParameterfvSGIS 562
+#define _gloffset_GetPixelTexGenParameterivSGIS 563
+#define _gloffset_PixelTexGenParameterfSGIS 564
+#define _gloffset_PixelTexGenParameterfvSGIS 565
+#define _gloffset_PixelTexGenParameteriSGIS 566
+#define _gloffset_PixelTexGenParameterivSGIS 567
+#define _gloffset_SampleMaskSGIS 568
+#define _gloffset_SamplePatternSGIS 569
+#define _gloffset_ColorPointerEXT 570
+#define _gloffset_EdgeFlagPointerEXT 571
+#define _gloffset_IndexPointerEXT 572
+#define _gloffset_NormalPointerEXT 573
+#define _gloffset_TexCoordPointerEXT 574
+#define _gloffset_VertexPointerEXT 575
+#define _gloffset_PointParameterfEXT 576
+#define _gloffset_PointParameterfvEXT 577
+#define _gloffset_LockArraysEXT 578
+#define _gloffset_UnlockArraysEXT 579
+#define _gloffset_CullParameterdvEXT 580
+#define _gloffset_CullParameterfvEXT 581
+#define _gloffset_SecondaryColor3bEXT 582
+#define _gloffset_SecondaryColor3bvEXT 583
+#define _gloffset_SecondaryColor3dEXT 584
+#define _gloffset_SecondaryColor3dvEXT 585
+#define _gloffset_SecondaryColor3fEXT 586
+#define _gloffset_SecondaryColor3fvEXT 587
+#define _gloffset_SecondaryColor3iEXT 588
+#define _gloffset_SecondaryColor3ivEXT 589
+#define _gloffset_SecondaryColor3sEXT 590
+#define _gloffset_SecondaryColor3svEXT 591
+#define _gloffset_SecondaryColor3ubEXT 592
+#define _gloffset_SecondaryColor3ubvEXT 593
+#define _gloffset_SecondaryColor3uiEXT 594
+#define _gloffset_SecondaryColor3uivEXT 595
+#define _gloffset_SecondaryColor3usEXT 596
+#define _gloffset_SecondaryColor3usvEXT 597
+#define _gloffset_SecondaryColorPointerEXT 598
+#define _gloffset_MultiDrawArraysEXT 599
+#define _gloffset_MultiDrawElementsEXT 600
+#define _gloffset_FogCoordPointerEXT 601
+#define _gloffset_FogCoorddEXT 602
+#define _gloffset_FogCoorddvEXT 603
+#define _gloffset_FogCoordfEXT 604
+#define _gloffset_FogCoordfvEXT 605
+#define _gloffset_PixelTexGenSGIX 606
+#define _gloffset_BlendFuncSeparateEXT 607
+#define _gloffset_FlushVertexArrayRangeNV 608
+#define _gloffset_VertexArrayRangeNV 609
+#define _gloffset_CombinerInputNV 610
+#define _gloffset_CombinerOutputNV 611
+#define _gloffset_CombinerParameterfNV 612
+#define _gloffset_CombinerParameterfvNV 613
+#define _gloffset_CombinerParameteriNV 614
+#define _gloffset_CombinerParameterivNV 615
+#define _gloffset_FinalCombinerInputNV 616
+#define _gloffset_GetCombinerInputParameterfvNV 617
+#define _gloffset_GetCombinerInputParameterivNV 618
+#define _gloffset_GetCombinerOutputParameterfvNV 619
+#define _gloffset_GetCombinerOutputParameterivNV 620
+#define _gloffset_GetFinalCombinerInputParameterfvNV 621
+#define _gloffset_GetFinalCombinerInputParameterivNV 622
+#define _gloffset_ResizeBuffersMESA 623
+#define _gloffset_WindowPos2dMESA 624
+#define _gloffset_WindowPos2dvMESA 625
+#define _gloffset_WindowPos2fMESA 626
+#define _gloffset_WindowPos2fvMESA 627
+#define _gloffset_WindowPos2iMESA 628
+#define _gloffset_WindowPos2ivMESA 629
+#define _gloffset_WindowPos2sMESA 630
+#define _gloffset_WindowPos2svMESA 631
+#define _gloffset_WindowPos3dMESA 632
+#define _gloffset_WindowPos3dvMESA 633
+#define _gloffset_WindowPos3fMESA 634
+#define _gloffset_WindowPos3fvMESA 635
+#define _gloffset_WindowPos3iMESA 636
+#define _gloffset_WindowPos3ivMESA 637
+#define _gloffset_WindowPos3sMESA 638
+#define _gloffset_WindowPos3svMESA 639
+#define _gloffset_WindowPos4dMESA 640
+#define _gloffset_WindowPos4dvMESA 641
+#define _gloffset_WindowPos4fMESA 642
+#define _gloffset_WindowPos4fvMESA 643
+#define _gloffset_WindowPos4iMESA 644
+#define _gloffset_WindowPos4ivMESA 645
+#define _gloffset_WindowPos4sMESA 646
+#define _gloffset_WindowPos4svMESA 647
+#define _gloffset_MultiModeDrawArraysIBM 648
+#define _gloffset_MultiModeDrawElementsIBM 649
+#define _gloffset_DeleteFencesNV 650
+#define _gloffset_FinishFenceNV 651
+#define _gloffset_GenFencesNV 652
+#define _gloffset_GetFenceivNV 653
+#define _gloffset_IsFenceNV 654
+#define _gloffset_SetFenceNV 655
+#define _gloffset_TestFenceNV 656
+#define _gloffset_AreProgramsResidentNV 657
+#define _gloffset_BindProgramNV 658
+#define _gloffset_DeleteProgramsNV 659
+#define _gloffset_ExecuteProgramNV 660
+#define _gloffset_GenProgramsNV 661
+#define _gloffset_GetProgramParameterdvNV 662
+#define _gloffset_GetProgramParameterfvNV 663
+#define _gloffset_GetProgramStringNV 664
+#define _gloffset_GetProgramivNV 665
+#define _gloffset_GetTrackMatrixivNV 666
+#define _gloffset_GetVertexAttribPointervNV 667
+#define _gloffset_GetVertexAttribdvNV 668
+#define _gloffset_GetVertexAttribfvNV 669
+#define _gloffset_GetVertexAttribivNV 670
+#define _gloffset_IsProgramNV 671
+#define _gloffset_LoadProgramNV 672
+#define _gloffset_ProgramParameters4dvNV 673
+#define _gloffset_ProgramParameters4fvNV 674
+#define _gloffset_RequestResidentProgramsNV 675
+#define _gloffset_TrackMatrixNV 676
+#define _gloffset_VertexAttrib1dNV 677
+#define _gloffset_VertexAttrib1dvNV 678
+#define _gloffset_VertexAttrib1fNV 679
+#define _gloffset_VertexAttrib1fvNV 680
+#define _gloffset_VertexAttrib1sNV 681
+#define _gloffset_VertexAttrib1svNV 682
+#define _gloffset_VertexAttrib2dNV 683
+#define _gloffset_VertexAttrib2dvNV 684
+#define _gloffset_VertexAttrib2fNV 685
+#define _gloffset_VertexAttrib2fvNV 686
+#define _gloffset_VertexAttrib2sNV 687
+#define _gloffset_VertexAttrib2svNV 688
+#define _gloffset_VertexAttrib3dNV 689
+#define _gloffset_VertexAttrib3dvNV 690
+#define _gloffset_VertexAttrib3fNV 691
+#define _gloffset_VertexAttrib3fvNV 692
+#define _gloffset_VertexAttrib3sNV 693
+#define _gloffset_VertexAttrib3svNV 694
+#define _gloffset_VertexAttrib4dNV 695
+#define _gloffset_VertexAttrib4dvNV 696
+#define _gloffset_VertexAttrib4fNV 697
+#define _gloffset_VertexAttrib4fvNV 698
+#define _gloffset_VertexAttrib4sNV 699
+#define _gloffset_VertexAttrib4svNV 700
+#define _gloffset_VertexAttrib4ubNV 701
+#define _gloffset_VertexAttrib4ubvNV 702
+#define _gloffset_VertexAttribPointerNV 703
+#define _gloffset_VertexAttribs1dvNV 704
+#define _gloffset_VertexAttribs1fvNV 705
+#define _gloffset_VertexAttribs1svNV 706
+#define _gloffset_VertexAttribs2dvNV 707
+#define _gloffset_VertexAttribs2fvNV 708
+#define _gloffset_VertexAttribs2svNV 709
+#define _gloffset_VertexAttribs3dvNV 710
+#define _gloffset_VertexAttribs3fvNV 711
+#define _gloffset_VertexAttribs3svNV 712
+#define _gloffset_VertexAttribs4dvNV 713
+#define _gloffset_VertexAttribs4fvNV 714
+#define _gloffset_VertexAttribs4svNV 715
+#define _gloffset_VertexAttribs4ubvNV 716
+#define _gloffset_AlphaFragmentOp1ATI 717
+#define _gloffset_AlphaFragmentOp2ATI 718
+#define _gloffset_AlphaFragmentOp3ATI 719
+#define _gloffset_BeginFragmentShaderATI 720
+#define _gloffset_BindFragmentShaderATI 721
+#define _gloffset_ColorFragmentOp1ATI 722
+#define _gloffset_ColorFragmentOp2ATI 723
+#define _gloffset_ColorFragmentOp3ATI 724
+#define _gloffset_DeleteFragmentShaderATI 725
+#define _gloffset_EndFragmentShaderATI 726
+#define _gloffset_GenFragmentShadersATI 727
+#define _gloffset_PassTexCoordATI 728
+#define _gloffset_SampleMapATI 729
+#define _gloffset_SetFragmentShaderConstantATI 730
+#define _gloffset_PointParameteriNV 731
+#define _gloffset_PointParameterivNV 732
+#define _gloffset_ActiveStencilFaceEXT 733
+#define _gloffset_BindVertexArrayAPPLE 734
+#define _gloffset_DeleteVertexArraysAPPLE 735
+#define _gloffset_GenVertexArraysAPPLE 736
+#define _gloffset_IsVertexArrayAPPLE 737
+#define _gloffset_GetProgramNamedParameterdvNV 738
+#define _gloffset_GetProgramNamedParameterfvNV 739
+#define _gloffset_ProgramNamedParameter4dNV 740
+#define _gloffset_ProgramNamedParameter4dvNV 741
+#define _gloffset_ProgramNamedParameter4fNV 742
+#define _gloffset_ProgramNamedParameter4fvNV 743
+#define _gloffset_DepthBoundsEXT 744
+#define _gloffset_BlendEquationSeparateEXT 745
+#define _gloffset_BindFramebufferEXT 746
+#define _gloffset_BindRenderbufferEXT 747
+#define _gloffset_CheckFramebufferStatusEXT 748
+#define _gloffset_DeleteFramebuffersEXT 749
+#define _gloffset_DeleteRenderbuffersEXT 750
+#define _gloffset_FramebufferRenderbufferEXT 751
+#define _gloffset_FramebufferTexture1DEXT 752
+#define _gloffset_FramebufferTexture2DEXT 753
+#define _gloffset_FramebufferTexture3DEXT 754
+#define _gloffset_GenFramebuffersEXT 755
+#define _gloffset_GenRenderbuffersEXT 756
+#define _gloffset_GenerateMipmapEXT 757
+#define _gloffset_GetFramebufferAttachmentParameterivEXT 758
+#define _gloffset_GetRenderbufferParameterivEXT 759
+#define _gloffset_IsFramebufferEXT 760
+#define _gloffset_IsRenderbufferEXT 761
+#define _gloffset_RenderbufferStorageEXT 762
+#define _gloffset_BlitFramebufferEXT 763
+#define _gloffset_FramebufferTextureLayerEXT 764
+#define _gloffset_StencilFuncSeparateATI 765
+#define _gloffset_ProgramEnvParameters4fvEXT 766
+#define _gloffset_ProgramLocalParameters4fvEXT 767
+#define _gloffset_GetQueryObjecti64vEXT 768
+#define _gloffset_GetQueryObjectui64vEXT 769
+#define _gloffset_FIRST_DYNAMIC 770
+
+#else
+
+#define _gloffset_AttachShader driDispatchRemapTable[AttachShader_remap_index]
+#define _gloffset_CreateProgram driDispatchRemapTable[CreateProgram_remap_index]
+#define _gloffset_CreateShader driDispatchRemapTable[CreateShader_remap_index]
+#define _gloffset_DeleteProgram driDispatchRemapTable[DeleteProgram_remap_index]
+#define _gloffset_DeleteShader driDispatchRemapTable[DeleteShader_remap_index]
+#define _gloffset_DetachShader driDispatchRemapTable[DetachShader_remap_index]
+#define _gloffset_GetAttachedShaders driDispatchRemapTable[GetAttachedShaders_remap_index]
+#define _gloffset_GetProgramInfoLog driDispatchRemapTable[GetProgramInfoLog_remap_index]
+#define _gloffset_GetProgramiv driDispatchRemapTable[GetProgramiv_remap_index]
+#define _gloffset_GetShaderInfoLog driDispatchRemapTable[GetShaderInfoLog_remap_index]
+#define _gloffset_GetShaderiv driDispatchRemapTable[GetShaderiv_remap_index]
+#define _gloffset_IsProgram driDispatchRemapTable[IsProgram_remap_index]
+#define _gloffset_IsShader driDispatchRemapTable[IsShader_remap_index]
+#define _gloffset_StencilFuncSeparate driDispatchRemapTable[StencilFuncSeparate_remap_index]
+#define _gloffset_StencilMaskSeparate driDispatchRemapTable[StencilMaskSeparate_remap_index]
+#define _gloffset_StencilOpSeparate driDispatchRemapTable[StencilOpSeparate_remap_index]
+#define _gloffset_UniformMatrix2x3fv driDispatchRemapTable[UniformMatrix2x3fv_remap_index]
+#define _gloffset_UniformMatrix2x4fv driDispatchRemapTable[UniformMatrix2x4fv_remap_index]
+#define _gloffset_UniformMatrix3x2fv driDispatchRemapTable[UniformMatrix3x2fv_remap_index]
+#define _gloffset_UniformMatrix3x4fv driDispatchRemapTable[UniformMatrix3x4fv_remap_index]
+#define _gloffset_UniformMatrix4x2fv driDispatchRemapTable[UniformMatrix4x2fv_remap_index]
+#define _gloffset_UniformMatrix4x3fv driDispatchRemapTable[UniformMatrix4x3fv_remap_index]
+#define _gloffset_LoadTransposeMatrixdARB driDispatchRemapTable[LoadTransposeMatrixdARB_remap_index]
+#define _gloffset_LoadTransposeMatrixfARB driDispatchRemapTable[LoadTransposeMatrixfARB_remap_index]
+#define _gloffset_MultTransposeMatrixdARB driDispatchRemapTable[MultTransposeMatrixdARB_remap_index]
+#define _gloffset_MultTransposeMatrixfARB driDispatchRemapTable[MultTransposeMatrixfARB_remap_index]
+#define _gloffset_SampleCoverageARB driDispatchRemapTable[SampleCoverageARB_remap_index]
+#define _gloffset_CompressedTexImage1DARB driDispatchRemapTable[CompressedTexImage1DARB_remap_index]
+#define _gloffset_CompressedTexImage2DARB driDispatchRemapTable[CompressedTexImage2DARB_remap_index]
+#define _gloffset_CompressedTexImage3DARB driDispatchRemapTable[CompressedTexImage3DARB_remap_index]
+#define _gloffset_CompressedTexSubImage1DARB driDispatchRemapTable[CompressedTexSubImage1DARB_remap_index]
+#define _gloffset_CompressedTexSubImage2DARB driDispatchRemapTable[CompressedTexSubImage2DARB_remap_index]
+#define _gloffset_CompressedTexSubImage3DARB driDispatchRemapTable[CompressedTexSubImage3DARB_remap_index]
+#define _gloffset_GetCompressedTexImageARB driDispatchRemapTable[GetCompressedTexImageARB_remap_index]
+#define _gloffset_DisableVertexAttribArrayARB driDispatchRemapTable[DisableVertexAttribArrayARB_remap_index]
+#define _gloffset_EnableVertexAttribArrayARB driDispatchRemapTable[EnableVertexAttribArrayARB_remap_index]
+#define _gloffset_GetProgramEnvParameterdvARB driDispatchRemapTable[GetProgramEnvParameterdvARB_remap_index]
+#define _gloffset_GetProgramEnvParameterfvARB driDispatchRemapTable[GetProgramEnvParameterfvARB_remap_index]
+#define _gloffset_GetProgramLocalParameterdvARB driDispatchRemapTable[GetProgramLocalParameterdvARB_remap_index]
+#define _gloffset_GetProgramLocalParameterfvARB driDispatchRemapTable[GetProgramLocalParameterfvARB_remap_index]
+#define _gloffset_GetProgramStringARB driDispatchRemapTable[GetProgramStringARB_remap_index]
+#define _gloffset_GetProgramivARB driDispatchRemapTable[GetProgramivARB_remap_index]
+#define _gloffset_GetVertexAttribdvARB driDispatchRemapTable[GetVertexAttribdvARB_remap_index]
+#define _gloffset_GetVertexAttribfvARB driDispatchRemapTable[GetVertexAttribfvARB_remap_index]
+#define _gloffset_GetVertexAttribivARB driDispatchRemapTable[GetVertexAttribivARB_remap_index]
+#define _gloffset_ProgramEnvParameter4dARB driDispatchRemapTable[ProgramEnvParameter4dARB_remap_index]
+#define _gloffset_ProgramEnvParameter4dvARB driDispatchRemapTable[ProgramEnvParameter4dvARB_remap_index]
+#define _gloffset_ProgramEnvParameter4fARB driDispatchRemapTable[ProgramEnvParameter4fARB_remap_index]
+#define _gloffset_ProgramEnvParameter4fvARB driDispatchRemapTable[ProgramEnvParameter4fvARB_remap_index]
+#define _gloffset_ProgramLocalParameter4dARB driDispatchRemapTable[ProgramLocalParameter4dARB_remap_index]
+#define _gloffset_ProgramLocalParameter4dvARB driDispatchRemapTable[ProgramLocalParameter4dvARB_remap_index]
+#define _gloffset_ProgramLocalParameter4fARB driDispatchRemapTable[ProgramLocalParameter4fARB_remap_index]
+#define _gloffset_ProgramLocalParameter4fvARB driDispatchRemapTable[ProgramLocalParameter4fvARB_remap_index]
+#define _gloffset_ProgramStringARB driDispatchRemapTable[ProgramStringARB_remap_index]
+#define _gloffset_VertexAttrib1dARB driDispatchRemapTable[VertexAttrib1dARB_remap_index]
+#define _gloffset_VertexAttrib1dvARB driDispatchRemapTable[VertexAttrib1dvARB_remap_index]
+#define _gloffset_VertexAttrib1fARB driDispatchRemapTable[VertexAttrib1fARB_remap_index]
+#define _gloffset_VertexAttrib1fvARB driDispatchRemapTable[VertexAttrib1fvARB_remap_index]
+#define _gloffset_VertexAttrib1sARB driDispatchRemapTable[VertexAttrib1sARB_remap_index]
+#define _gloffset_VertexAttrib1svARB driDispatchRemapTable[VertexAttrib1svARB_remap_index]
+#define _gloffset_VertexAttrib2dARB driDispatchRemapTable[VertexAttrib2dARB_remap_index]
+#define _gloffset_VertexAttrib2dvARB driDispatchRemapTable[VertexAttrib2dvARB_remap_index]
+#define _gloffset_VertexAttrib2fARB driDispatchRemapTable[VertexAttrib2fARB_remap_index]
+#define _gloffset_VertexAttrib2fvARB driDispatchRemapTable[VertexAttrib2fvARB_remap_index]
+#define _gloffset_VertexAttrib2sARB driDispatchRemapTable[VertexAttrib2sARB_remap_index]
+#define _gloffset_VertexAttrib2svARB driDispatchRemapTable[VertexAttrib2svARB_remap_index]
+#define _gloffset_VertexAttrib3dARB driDispatchRemapTable[VertexAttrib3dARB_remap_index]
+#define _gloffset_VertexAttrib3dvARB driDispatchRemapTable[VertexAttrib3dvARB_remap_index]
+#define _gloffset_VertexAttrib3fARB driDispatchRemapTable[VertexAttrib3fARB_remap_index]
+#define _gloffset_VertexAttrib3fvARB driDispatchRemapTable[VertexAttrib3fvARB_remap_index]
+#define _gloffset_VertexAttrib3sARB driDispatchRemapTable[VertexAttrib3sARB_remap_index]
+#define _gloffset_VertexAttrib3svARB driDispatchRemapTable[VertexAttrib3svARB_remap_index]
+#define _gloffset_VertexAttrib4NbvARB driDispatchRemapTable[VertexAttrib4NbvARB_remap_index]
+#define _gloffset_VertexAttrib4NivARB driDispatchRemapTable[VertexAttrib4NivARB_remap_index]
+#define _gloffset_VertexAttrib4NsvARB driDispatchRemapTable[VertexAttrib4NsvARB_remap_index]
+#define _gloffset_VertexAttrib4NubARB driDispatchRemapTable[VertexAttrib4NubARB_remap_index]
+#define _gloffset_VertexAttrib4NubvARB driDispatchRemapTable[VertexAttrib4NubvARB_remap_index]
+#define _gloffset_VertexAttrib4NuivARB driDispatchRemapTable[VertexAttrib4NuivARB_remap_index]
+#define _gloffset_VertexAttrib4NusvARB driDispatchRemapTable[VertexAttrib4NusvARB_remap_index]
+#define _gloffset_VertexAttrib4bvARB driDispatchRemapTable[VertexAttrib4bvARB_remap_index]
+#define _gloffset_VertexAttrib4dARB driDispatchRemapTable[VertexAttrib4dARB_remap_index]
+#define _gloffset_VertexAttrib4dvARB driDispatchRemapTable[VertexAttrib4dvARB_remap_index]
+#define _gloffset_VertexAttrib4fARB driDispatchRemapTable[VertexAttrib4fARB_remap_index]
+#define _gloffset_VertexAttrib4fvARB driDispatchRemapTable[VertexAttrib4fvARB_remap_index]
+#define _gloffset_VertexAttrib4ivARB driDispatchRemapTable[VertexAttrib4ivARB_remap_index]
+#define _gloffset_VertexAttrib4sARB driDispatchRemapTable[VertexAttrib4sARB_remap_index]
+#define _gloffset_VertexAttrib4svARB driDispatchRemapTable[VertexAttrib4svARB_remap_index]
+#define _gloffset_VertexAttrib4ubvARB driDispatchRemapTable[VertexAttrib4ubvARB_remap_index]
+#define _gloffset_VertexAttrib4uivARB driDispatchRemapTable[VertexAttrib4uivARB_remap_index]
+#define _gloffset_VertexAttrib4usvARB driDispatchRemapTable[VertexAttrib4usvARB_remap_index]
+#define _gloffset_VertexAttribPointerARB driDispatchRemapTable[VertexAttribPointerARB_remap_index]
+#define _gloffset_BindBufferARB driDispatchRemapTable[BindBufferARB_remap_index]
+#define _gloffset_BufferDataARB driDispatchRemapTable[BufferDataARB_remap_index]
+#define _gloffset_BufferSubDataARB driDispatchRemapTable[BufferSubDataARB_remap_index]
+#define _gloffset_DeleteBuffersARB driDispatchRemapTable[DeleteBuffersARB_remap_index]
+#define _gloffset_GenBuffersARB driDispatchRemapTable[GenBuffersARB_remap_index]
+#define _gloffset_GetBufferParameterivARB driDispatchRemapTable[GetBufferParameterivARB_remap_index]
+#define _gloffset_GetBufferPointervARB driDispatchRemapTable[GetBufferPointervARB_remap_index]
+#define _gloffset_GetBufferSubDataARB driDispatchRemapTable[GetBufferSubDataARB_remap_index]
+#define _gloffset_IsBufferARB driDispatchRemapTable[IsBufferARB_remap_index]
+#define _gloffset_MapBufferARB driDispatchRemapTable[MapBufferARB_remap_index]
+#define _gloffset_UnmapBufferARB driDispatchRemapTable[UnmapBufferARB_remap_index]
+#define _gloffset_BeginQueryARB driDispatchRemapTable[BeginQueryARB_remap_index]
+#define _gloffset_DeleteQueriesARB driDispatchRemapTable[DeleteQueriesARB_remap_index]
+#define _gloffset_EndQueryARB driDispatchRemapTable[EndQueryARB_remap_index]
+#define _gloffset_GenQueriesARB driDispatchRemapTable[GenQueriesARB_remap_index]
+#define _gloffset_GetQueryObjectivARB driDispatchRemapTable[GetQueryObjectivARB_remap_index]
+#define _gloffset_GetQueryObjectuivARB driDispatchRemapTable[GetQueryObjectuivARB_remap_index]
+#define _gloffset_GetQueryivARB driDispatchRemapTable[GetQueryivARB_remap_index]
+#define _gloffset_IsQueryARB driDispatchRemapTable[IsQueryARB_remap_index]
+#define _gloffset_AttachObjectARB driDispatchRemapTable[AttachObjectARB_remap_index]
+#define _gloffset_CompileShaderARB driDispatchRemapTable[CompileShaderARB_remap_index]
+#define _gloffset_CreateProgramObjectARB driDispatchRemapTable[CreateProgramObjectARB_remap_index]
+#define _gloffset_CreateShaderObjectARB driDispatchRemapTable[CreateShaderObjectARB_remap_index]
+#define _gloffset_DeleteObjectARB driDispatchRemapTable[DeleteObjectARB_remap_index]
+#define _gloffset_DetachObjectARB driDispatchRemapTable[DetachObjectARB_remap_index]
+#define _gloffset_GetActiveUniformARB driDispatchRemapTable[GetActiveUniformARB_remap_index]
+#define _gloffset_GetAttachedObjectsARB driDispatchRemapTable[GetAttachedObjectsARB_remap_index]
+#define _gloffset_GetHandleARB driDispatchRemapTable[GetHandleARB_remap_index]
+#define _gloffset_GetInfoLogARB driDispatchRemapTable[GetInfoLogARB_remap_index]
+#define _gloffset_GetObjectParameterfvARB driDispatchRemapTable[GetObjectParameterfvARB_remap_index]
+#define _gloffset_GetObjectParameterivARB driDispatchRemapTable[GetObjectParameterivARB_remap_index]
+#define _gloffset_GetShaderSourceARB driDispatchRemapTable[GetShaderSourceARB_remap_index]
+#define _gloffset_GetUniformLocationARB driDispatchRemapTable[GetUniformLocationARB_remap_index]
+#define _gloffset_GetUniformfvARB driDispatchRemapTable[GetUniformfvARB_remap_index]
+#define _gloffset_GetUniformivARB driDispatchRemapTable[GetUniformivARB_remap_index]
+#define _gloffset_LinkProgramARB driDispatchRemapTable[LinkProgramARB_remap_index]
+#define _gloffset_ShaderSourceARB driDispatchRemapTable[ShaderSourceARB_remap_index]
+#define _gloffset_Uniform1fARB driDispatchRemapTable[Uniform1fARB_remap_index]
+#define _gloffset_Uniform1fvARB driDispatchRemapTable[Uniform1fvARB_remap_index]
+#define _gloffset_Uniform1iARB driDispatchRemapTable[Uniform1iARB_remap_index]
+#define _gloffset_Uniform1ivARB driDispatchRemapTable[Uniform1ivARB_remap_index]
+#define _gloffset_Uniform2fARB driDispatchRemapTable[Uniform2fARB_remap_index]
+#define _gloffset_Uniform2fvARB driDispatchRemapTable[Uniform2fvARB_remap_index]
+#define _gloffset_Uniform2iARB driDispatchRemapTable[Uniform2iARB_remap_index]
+#define _gloffset_Uniform2ivARB driDispatchRemapTable[Uniform2ivARB_remap_index]
+#define _gloffset_Uniform3fARB driDispatchRemapTable[Uniform3fARB_remap_index]
+#define _gloffset_Uniform3fvARB driDispatchRemapTable[Uniform3fvARB_remap_index]
+#define _gloffset_Uniform3iARB driDispatchRemapTable[Uniform3iARB_remap_index]
+#define _gloffset_Uniform3ivARB driDispatchRemapTable[Uniform3ivARB_remap_index]
+#define _gloffset_Uniform4fARB driDispatchRemapTable[Uniform4fARB_remap_index]
+#define _gloffset_Uniform4fvARB driDispatchRemapTable[Uniform4fvARB_remap_index]
+#define _gloffset_Uniform4iARB driDispatchRemapTable[Uniform4iARB_remap_index]
+#define _gloffset_Uniform4ivARB driDispatchRemapTable[Uniform4ivARB_remap_index]
+#define _gloffset_UniformMatrix2fvARB driDispatchRemapTable[UniformMatrix2fvARB_remap_index]
+#define _gloffset_UniformMatrix3fvARB driDispatchRemapTable[UniformMatrix3fvARB_remap_index]
+#define _gloffset_UniformMatrix4fvARB driDispatchRemapTable[UniformMatrix4fvARB_remap_index]
+#define _gloffset_UseProgramObjectARB driDispatchRemapTable[UseProgramObjectARB_remap_index]
+#define _gloffset_ValidateProgramARB driDispatchRemapTable[ValidateProgramARB_remap_index]
+#define _gloffset_BindAttribLocationARB driDispatchRemapTable[BindAttribLocationARB_remap_index]
+#define _gloffset_GetActiveAttribARB driDispatchRemapTable[GetActiveAttribARB_remap_index]
+#define _gloffset_GetAttribLocationARB driDispatchRemapTable[GetAttribLocationARB_remap_index]
+#define _gloffset_DrawBuffersARB driDispatchRemapTable[DrawBuffersARB_remap_index]
+#define _gloffset_PolygonOffsetEXT driDispatchRemapTable[PolygonOffsetEXT_remap_index]
+#define _gloffset_GetPixelTexGenParameterfvSGIS driDispatchRemapTable[GetPixelTexGenParameterfvSGIS_remap_index]
+#define _gloffset_GetPixelTexGenParameterivSGIS driDispatchRemapTable[GetPixelTexGenParameterivSGIS_remap_index]
+#define _gloffset_PixelTexGenParameterfSGIS driDispatchRemapTable[PixelTexGenParameterfSGIS_remap_index]
+#define _gloffset_PixelTexGenParameterfvSGIS driDispatchRemapTable[PixelTexGenParameterfvSGIS_remap_index]
+#define _gloffset_PixelTexGenParameteriSGIS driDispatchRemapTable[PixelTexGenParameteriSGIS_remap_index]
+#define _gloffset_PixelTexGenParameterivSGIS driDispatchRemapTable[PixelTexGenParameterivSGIS_remap_index]
+#define _gloffset_SampleMaskSGIS driDispatchRemapTable[SampleMaskSGIS_remap_index]
+#define _gloffset_SamplePatternSGIS driDispatchRemapTable[SamplePatternSGIS_remap_index]
+#define _gloffset_ColorPointerEXT driDispatchRemapTable[ColorPointerEXT_remap_index]
+#define _gloffset_EdgeFlagPointerEXT driDispatchRemapTable[EdgeFlagPointerEXT_remap_index]
+#define _gloffset_IndexPointerEXT driDispatchRemapTable[IndexPointerEXT_remap_index]
+#define _gloffset_NormalPointerEXT driDispatchRemapTable[NormalPointerEXT_remap_index]
+#define _gloffset_TexCoordPointerEXT driDispatchRemapTable[TexCoordPointerEXT_remap_index]
+#define _gloffset_VertexPointerEXT driDispatchRemapTable[VertexPointerEXT_remap_index]
+#define _gloffset_PointParameterfEXT driDispatchRemapTable[PointParameterfEXT_remap_index]
+#define _gloffset_PointParameterfvEXT driDispatchRemapTable[PointParameterfvEXT_remap_index]
+#define _gloffset_LockArraysEXT driDispatchRemapTable[LockArraysEXT_remap_index]
+#define _gloffset_UnlockArraysEXT driDispatchRemapTable[UnlockArraysEXT_remap_index]
+#define _gloffset_CullParameterdvEXT driDispatchRemapTable[CullParameterdvEXT_remap_index]
+#define _gloffset_CullParameterfvEXT driDispatchRemapTable[CullParameterfvEXT_remap_index]
+#define _gloffset_SecondaryColor3bEXT driDispatchRemapTable[SecondaryColor3bEXT_remap_index]
+#define _gloffset_SecondaryColor3bvEXT driDispatchRemapTable[SecondaryColor3bvEXT_remap_index]
+#define _gloffset_SecondaryColor3dEXT driDispatchRemapTable[SecondaryColor3dEXT_remap_index]
+#define _gloffset_SecondaryColor3dvEXT driDispatchRemapTable[SecondaryColor3dvEXT_remap_index]
+#define _gloffset_SecondaryColor3fEXT driDispatchRemapTable[SecondaryColor3fEXT_remap_index]
+#define _gloffset_SecondaryColor3fvEXT driDispatchRemapTable[SecondaryColor3fvEXT_remap_index]
+#define _gloffset_SecondaryColor3iEXT driDispatchRemapTable[SecondaryColor3iEXT_remap_index]
+#define _gloffset_SecondaryColor3ivEXT driDispatchRemapTable[SecondaryColor3ivEXT_remap_index]
+#define _gloffset_SecondaryColor3sEXT driDispatchRemapTable[SecondaryColor3sEXT_remap_index]
+#define _gloffset_SecondaryColor3svEXT driDispatchRemapTable[SecondaryColor3svEXT_remap_index]
+#define _gloffset_SecondaryColor3ubEXT driDispatchRemapTable[SecondaryColor3ubEXT_remap_index]
+#define _gloffset_SecondaryColor3ubvEXT driDispatchRemapTable[SecondaryColor3ubvEXT_remap_index]
+#define _gloffset_SecondaryColor3uiEXT driDispatchRemapTable[SecondaryColor3uiEXT_remap_index]
+#define _gloffset_SecondaryColor3uivEXT driDispatchRemapTable[SecondaryColor3uivEXT_remap_index]
+#define _gloffset_SecondaryColor3usEXT driDispatchRemapTable[SecondaryColor3usEXT_remap_index]
+#define _gloffset_SecondaryColor3usvEXT driDispatchRemapTable[SecondaryColor3usvEXT_remap_index]
+#define _gloffset_SecondaryColorPointerEXT driDispatchRemapTable[SecondaryColorPointerEXT_remap_index]
+#define _gloffset_MultiDrawArraysEXT driDispatchRemapTable[MultiDrawArraysEXT_remap_index]
+#define _gloffset_MultiDrawElementsEXT driDispatchRemapTable[MultiDrawElementsEXT_remap_index]
+#define _gloffset_FogCoordPointerEXT driDispatchRemapTable[FogCoordPointerEXT_remap_index]
+#define _gloffset_FogCoorddEXT driDispatchRemapTable[FogCoorddEXT_remap_index]
+#define _gloffset_FogCoorddvEXT driDispatchRemapTable[FogCoorddvEXT_remap_index]
+#define _gloffset_FogCoordfEXT driDispatchRemapTable[FogCoordfEXT_remap_index]
+#define _gloffset_FogCoordfvEXT driDispatchRemapTable[FogCoordfvEXT_remap_index]
+#define _gloffset_PixelTexGenSGIX driDispatchRemapTable[PixelTexGenSGIX_remap_index]
+#define _gloffset_BlendFuncSeparateEXT driDispatchRemapTable[BlendFuncSeparateEXT_remap_index]
+#define _gloffset_FlushVertexArrayRangeNV driDispatchRemapTable[FlushVertexArrayRangeNV_remap_index]
+#define _gloffset_VertexArrayRangeNV driDispatchRemapTable[VertexArrayRangeNV_remap_index]
+#define _gloffset_CombinerInputNV driDispatchRemapTable[CombinerInputNV_remap_index]
+#define _gloffset_CombinerOutputNV driDispatchRemapTable[CombinerOutputNV_remap_index]
+#define _gloffset_CombinerParameterfNV driDispatchRemapTable[CombinerParameterfNV_remap_index]
+#define _gloffset_CombinerParameterfvNV driDispatchRemapTable[CombinerParameterfvNV_remap_index]
+#define _gloffset_CombinerParameteriNV driDispatchRemapTable[CombinerParameteriNV_remap_index]
+#define _gloffset_CombinerParameterivNV driDispatchRemapTable[CombinerParameterivNV_remap_index]
+#define _gloffset_FinalCombinerInputNV driDispatchRemapTable[FinalCombinerInputNV_remap_index]
+#define _gloffset_GetCombinerInputParameterfvNV driDispatchRemapTable[GetCombinerInputParameterfvNV_remap_index]
+#define _gloffset_GetCombinerInputParameterivNV driDispatchRemapTable[GetCombinerInputParameterivNV_remap_index]
+#define _gloffset_GetCombinerOutputParameterfvNV driDispatchRemapTable[GetCombinerOutputParameterfvNV_remap_index]
+#define _gloffset_GetCombinerOutputParameterivNV driDispatchRemapTable[GetCombinerOutputParameterivNV_remap_index]
+#define _gloffset_GetFinalCombinerInputParameterfvNV driDispatchRemapTable[GetFinalCombinerInputParameterfvNV_remap_index]
+#define _gloffset_GetFinalCombinerInputParameterivNV driDispatchRemapTable[GetFinalCombinerInputParameterivNV_remap_index]
+#define _gloffset_ResizeBuffersMESA driDispatchRemapTable[ResizeBuffersMESA_remap_index]
+#define _gloffset_WindowPos2dMESA driDispatchRemapTable[WindowPos2dMESA_remap_index]
+#define _gloffset_WindowPos2dvMESA driDispatchRemapTable[WindowPos2dvMESA_remap_index]
+#define _gloffset_WindowPos2fMESA driDispatchRemapTable[WindowPos2fMESA_remap_index]
+#define _gloffset_WindowPos2fvMESA driDispatchRemapTable[WindowPos2fvMESA_remap_index]
+#define _gloffset_WindowPos2iMESA driDispatchRemapTable[WindowPos2iMESA_remap_index]
+#define _gloffset_WindowPos2ivMESA driDispatchRemapTable[WindowPos2ivMESA_remap_index]
+#define _gloffset_WindowPos2sMESA driDispatchRemapTable[WindowPos2sMESA_remap_index]
+#define _gloffset_WindowPos2svMESA driDispatchRemapTable[WindowPos2svMESA_remap_index]
+#define _gloffset_WindowPos3dMESA driDispatchRemapTable[WindowPos3dMESA_remap_index]
+#define _gloffset_WindowPos3dvMESA driDispatchRemapTable[WindowPos3dvMESA_remap_index]
+#define _gloffset_WindowPos3fMESA driDispatchRemapTable[WindowPos3fMESA_remap_index]
+#define _gloffset_WindowPos3fvMESA driDispatchRemapTable[WindowPos3fvMESA_remap_index]
+#define _gloffset_WindowPos3iMESA driDispatchRemapTable[WindowPos3iMESA_remap_index]
+#define _gloffset_WindowPos3ivMESA driDispatchRemapTable[WindowPos3ivMESA_remap_index]
+#define _gloffset_WindowPos3sMESA driDispatchRemapTable[WindowPos3sMESA_remap_index]
+#define _gloffset_WindowPos3svMESA driDispatchRemapTable[WindowPos3svMESA_remap_index]
+#define _gloffset_WindowPos4dMESA driDispatchRemapTable[WindowPos4dMESA_remap_index]
+#define _gloffset_WindowPos4dvMESA driDispatchRemapTable[WindowPos4dvMESA_remap_index]
+#define _gloffset_WindowPos4fMESA driDispatchRemapTable[WindowPos4fMESA_remap_index]
+#define _gloffset_WindowPos4fvMESA driDispatchRemapTable[WindowPos4fvMESA_remap_index]
+#define _gloffset_WindowPos4iMESA driDispatchRemapTable[WindowPos4iMESA_remap_index]
+#define _gloffset_WindowPos4ivMESA driDispatchRemapTable[WindowPos4ivMESA_remap_index]
+#define _gloffset_WindowPos4sMESA driDispatchRemapTable[WindowPos4sMESA_remap_index]
+#define _gloffset_WindowPos4svMESA driDispatchRemapTable[WindowPos4svMESA_remap_index]
+#define _gloffset_MultiModeDrawArraysIBM driDispatchRemapTable[MultiModeDrawArraysIBM_remap_index]
+#define _gloffset_MultiModeDrawElementsIBM driDispatchRemapTable[MultiModeDrawElementsIBM_remap_index]
+#define _gloffset_DeleteFencesNV driDispatchRemapTable[DeleteFencesNV_remap_index]
+#define _gloffset_FinishFenceNV driDispatchRemapTable[FinishFenceNV_remap_index]
+#define _gloffset_GenFencesNV driDispatchRemapTable[GenFencesNV_remap_index]
+#define _gloffset_GetFenceivNV driDispatchRemapTable[GetFenceivNV_remap_index]
+#define _gloffset_IsFenceNV driDispatchRemapTable[IsFenceNV_remap_index]
+#define _gloffset_SetFenceNV driDispatchRemapTable[SetFenceNV_remap_index]
+#define _gloffset_TestFenceNV driDispatchRemapTable[TestFenceNV_remap_index]
+#define _gloffset_AreProgramsResidentNV driDispatchRemapTable[AreProgramsResidentNV_remap_index]
+#define _gloffset_BindProgramNV driDispatchRemapTable[BindProgramNV_remap_index]
+#define _gloffset_DeleteProgramsNV driDispatchRemapTable[DeleteProgramsNV_remap_index]
+#define _gloffset_ExecuteProgramNV driDispatchRemapTable[ExecuteProgramNV_remap_index]
+#define _gloffset_GenProgramsNV driDispatchRemapTable[GenProgramsNV_remap_index]
+#define _gloffset_GetProgramParameterdvNV driDispatchRemapTable[GetProgramParameterdvNV_remap_index]
+#define _gloffset_GetProgramParameterfvNV driDispatchRemapTable[GetProgramParameterfvNV_remap_index]
+#define _gloffset_GetProgramStringNV driDispatchRemapTable[GetProgramStringNV_remap_index]
+#define _gloffset_GetProgramivNV driDispatchRemapTable[GetProgramivNV_remap_index]
+#define _gloffset_GetTrackMatrixivNV driDispatchRemapTable[GetTrackMatrixivNV_remap_index]
+#define _gloffset_GetVertexAttribPointervNV driDispatchRemapTable[GetVertexAttribPointervNV_remap_index]
+#define _gloffset_GetVertexAttribdvNV driDispatchRemapTable[GetVertexAttribdvNV_remap_index]
+#define _gloffset_GetVertexAttribfvNV driDispatchRemapTable[GetVertexAttribfvNV_remap_index]
+#define _gloffset_GetVertexAttribivNV driDispatchRemapTable[GetVertexAttribivNV_remap_index]
+#define _gloffset_IsProgramNV driDispatchRemapTable[IsProgramNV_remap_index]
+#define _gloffset_LoadProgramNV driDispatchRemapTable[LoadProgramNV_remap_index]
+#define _gloffset_ProgramParameters4dvNV driDispatchRemapTable[ProgramParameters4dvNV_remap_index]
+#define _gloffset_ProgramParameters4fvNV driDispatchRemapTable[ProgramParameters4fvNV_remap_index]
+#define _gloffset_RequestResidentProgramsNV driDispatchRemapTable[RequestResidentProgramsNV_remap_index]
+#define _gloffset_TrackMatrixNV driDispatchRemapTable[TrackMatrixNV_remap_index]
+#define _gloffset_VertexAttrib1dNV driDispatchRemapTable[VertexAttrib1dNV_remap_index]
+#define _gloffset_VertexAttrib1dvNV driDispatchRemapTable[VertexAttrib1dvNV_remap_index]
+#define _gloffset_VertexAttrib1fNV driDispatchRemapTable[VertexAttrib1fNV_remap_index]
+#define _gloffset_VertexAttrib1fvNV driDispatchRemapTable[VertexAttrib1fvNV_remap_index]
+#define _gloffset_VertexAttrib1sNV driDispatchRemapTable[VertexAttrib1sNV_remap_index]
+#define _gloffset_VertexAttrib1svNV driDispatchRemapTable[VertexAttrib1svNV_remap_index]
+#define _gloffset_VertexAttrib2dNV driDispatchRemapTable[VertexAttrib2dNV_remap_index]
+#define _gloffset_VertexAttrib2dvNV driDispatchRemapTable[VertexAttrib2dvNV_remap_index]
+#define _gloffset_VertexAttrib2fNV driDispatchRemapTable[VertexAttrib2fNV_remap_index]
+#define _gloffset_VertexAttrib2fvNV driDispatchRemapTable[VertexAttrib2fvNV_remap_index]
+#define _gloffset_VertexAttrib2sNV driDispatchRemapTable[VertexAttrib2sNV_remap_index]
+#define _gloffset_VertexAttrib2svNV driDispatchRemapTable[VertexAttrib2svNV_remap_index]
+#define _gloffset_VertexAttrib3dNV driDispatchRemapTable[VertexAttrib3dNV_remap_index]
+#define _gloffset_VertexAttrib3dvNV driDispatchRemapTable[VertexAttrib3dvNV_remap_index]
+#define _gloffset_VertexAttrib3fNV driDispatchRemapTable[VertexAttrib3fNV_remap_index]
+#define _gloffset_VertexAttrib3fvNV driDispatchRemapTable[VertexAttrib3fvNV_remap_index]
+#define _gloffset_VertexAttrib3sNV driDispatchRemapTable[VertexAttrib3sNV_remap_index]
+#define _gloffset_VertexAttrib3svNV driDispatchRemapTable[VertexAttrib3svNV_remap_index]
+#define _gloffset_VertexAttrib4dNV driDispatchRemapTable[VertexAttrib4dNV_remap_index]
+#define _gloffset_VertexAttrib4dvNV driDispatchRemapTable[VertexAttrib4dvNV_remap_index]
+#define _gloffset_VertexAttrib4fNV driDispatchRemapTable[VertexAttrib4fNV_remap_index]
+#define _gloffset_VertexAttrib4fvNV driDispatchRemapTable[VertexAttrib4fvNV_remap_index]
+#define _gloffset_VertexAttrib4sNV driDispatchRemapTable[VertexAttrib4sNV_remap_index]
+#define _gloffset_VertexAttrib4svNV driDispatchRemapTable[VertexAttrib4svNV_remap_index]
+#define _gloffset_VertexAttrib4ubNV driDispatchRemapTable[VertexAttrib4ubNV_remap_index]
+#define _gloffset_VertexAttrib4ubvNV driDispatchRemapTable[VertexAttrib4ubvNV_remap_index]
+#define _gloffset_VertexAttribPointerNV driDispatchRemapTable[VertexAttribPointerNV_remap_index]
+#define _gloffset_VertexAttribs1dvNV driDispatchRemapTable[VertexAttribs1dvNV_remap_index]
+#define _gloffset_VertexAttribs1fvNV driDispatchRemapTable[VertexAttribs1fvNV_remap_index]
+#define _gloffset_VertexAttribs1svNV driDispatchRemapTable[VertexAttribs1svNV_remap_index]
+#define _gloffset_VertexAttribs2dvNV driDispatchRemapTable[VertexAttribs2dvNV_remap_index]
+#define _gloffset_VertexAttribs2fvNV driDispatchRemapTable[VertexAttribs2fvNV_remap_index]
+#define _gloffset_VertexAttribs2svNV driDispatchRemapTable[VertexAttribs2svNV_remap_index]
+#define _gloffset_VertexAttribs3dvNV driDispatchRemapTable[VertexAttribs3dvNV_remap_index]
+#define _gloffset_VertexAttribs3fvNV driDispatchRemapTable[VertexAttribs3fvNV_remap_index]
+#define _gloffset_VertexAttribs3svNV driDispatchRemapTable[VertexAttribs3svNV_remap_index]
+#define _gloffset_VertexAttribs4dvNV driDispatchRemapTable[VertexAttribs4dvNV_remap_index]
+#define _gloffset_VertexAttribs4fvNV driDispatchRemapTable[VertexAttribs4fvNV_remap_index]
+#define _gloffset_VertexAttribs4svNV driDispatchRemapTable[VertexAttribs4svNV_remap_index]
+#define _gloffset_VertexAttribs4ubvNV driDispatchRemapTable[VertexAttribs4ubvNV_remap_index]
+#define _gloffset_AlphaFragmentOp1ATI driDispatchRemapTable[AlphaFragmentOp1ATI_remap_index]
+#define _gloffset_AlphaFragmentOp2ATI driDispatchRemapTable[AlphaFragmentOp2ATI_remap_index]
+#define _gloffset_AlphaFragmentOp3ATI driDispatchRemapTable[AlphaFragmentOp3ATI_remap_index]
+#define _gloffset_BeginFragmentShaderATI driDispatchRemapTable[BeginFragmentShaderATI_remap_index]
+#define _gloffset_BindFragmentShaderATI driDispatchRemapTable[BindFragmentShaderATI_remap_index]
+#define _gloffset_ColorFragmentOp1ATI driDispatchRemapTable[ColorFragmentOp1ATI_remap_index]
+#define _gloffset_ColorFragmentOp2ATI driDispatchRemapTable[ColorFragmentOp2ATI_remap_index]
+#define _gloffset_ColorFragmentOp3ATI driDispatchRemapTable[ColorFragmentOp3ATI_remap_index]
+#define _gloffset_DeleteFragmentShaderATI driDispatchRemapTable[DeleteFragmentShaderATI_remap_index]
+#define _gloffset_EndFragmentShaderATI driDispatchRemapTable[EndFragmentShaderATI_remap_index]
+#define _gloffset_GenFragmentShadersATI driDispatchRemapTable[GenFragmentShadersATI_remap_index]
+#define _gloffset_PassTexCoordATI driDispatchRemapTable[PassTexCoordATI_remap_index]
+#define _gloffset_SampleMapATI driDispatchRemapTable[SampleMapATI_remap_index]
+#define _gloffset_SetFragmentShaderConstantATI driDispatchRemapTable[SetFragmentShaderConstantATI_remap_index]
+#define _gloffset_PointParameteriNV driDispatchRemapTable[PointParameteriNV_remap_index]
+#define _gloffset_PointParameterivNV driDispatchRemapTable[PointParameterivNV_remap_index]
+#define _gloffset_ActiveStencilFaceEXT driDispatchRemapTable[ActiveStencilFaceEXT_remap_index]
+#define _gloffset_BindVertexArrayAPPLE driDispatchRemapTable[BindVertexArrayAPPLE_remap_index]
+#define _gloffset_DeleteVertexArraysAPPLE driDispatchRemapTable[DeleteVertexArraysAPPLE_remap_index]
+#define _gloffset_GenVertexArraysAPPLE driDispatchRemapTable[GenVertexArraysAPPLE_remap_index]
+#define _gloffset_IsVertexArrayAPPLE driDispatchRemapTable[IsVertexArrayAPPLE_remap_index]
+#define _gloffset_GetProgramNamedParameterdvNV driDispatchRemapTable[GetProgramNamedParameterdvNV_remap_index]
+#define _gloffset_GetProgramNamedParameterfvNV driDispatchRemapTable[GetProgramNamedParameterfvNV_remap_index]
+#define _gloffset_ProgramNamedParameter4dNV driDispatchRemapTable[ProgramNamedParameter4dNV_remap_index]
+#define _gloffset_ProgramNamedParameter4dvNV driDispatchRemapTable[ProgramNamedParameter4dvNV_remap_index]
+#define _gloffset_ProgramNamedParameter4fNV driDispatchRemapTable[ProgramNamedParameter4fNV_remap_index]
+#define _gloffset_ProgramNamedParameter4fvNV driDispatchRemapTable[ProgramNamedParameter4fvNV_remap_index]
+#define _gloffset_DepthBoundsEXT driDispatchRemapTable[DepthBoundsEXT_remap_index]
+#define _gloffset_BlendEquationSeparateEXT driDispatchRemapTable[BlendEquationSeparateEXT_remap_index]
+#define _gloffset_BindFramebufferEXT driDispatchRemapTable[BindFramebufferEXT_remap_index]
+#define _gloffset_BindRenderbufferEXT driDispatchRemapTable[BindRenderbufferEXT_remap_index]
+#define _gloffset_CheckFramebufferStatusEXT driDispatchRemapTable[CheckFramebufferStatusEXT_remap_index]
+#define _gloffset_DeleteFramebuffersEXT driDispatchRemapTable[DeleteFramebuffersEXT_remap_index]
+#define _gloffset_DeleteRenderbuffersEXT driDispatchRemapTable[DeleteRenderbuffersEXT_remap_index]
+#define _gloffset_FramebufferRenderbufferEXT driDispatchRemapTable[FramebufferRenderbufferEXT_remap_index]
+#define _gloffset_FramebufferTexture1DEXT driDispatchRemapTable[FramebufferTexture1DEXT_remap_index]
+#define _gloffset_FramebufferTexture2DEXT driDispatchRemapTable[FramebufferTexture2DEXT_remap_index]
+#define _gloffset_FramebufferTexture3DEXT driDispatchRemapTable[FramebufferTexture3DEXT_remap_index]
+#define _gloffset_GenFramebuffersEXT driDispatchRemapTable[GenFramebuffersEXT_remap_index]
+#define _gloffset_GenRenderbuffersEXT driDispatchRemapTable[GenRenderbuffersEXT_remap_index]
+#define _gloffset_GenerateMipmapEXT driDispatchRemapTable[GenerateMipmapEXT_remap_index]
+#define _gloffset_GetFramebufferAttachmentParameterivEXT driDispatchRemapTable[GetFramebufferAttachmentParameterivEXT_remap_index]
+#define _gloffset_GetRenderbufferParameterivEXT driDispatchRemapTable[GetRenderbufferParameterivEXT_remap_index]
+#define _gloffset_IsFramebufferEXT driDispatchRemapTable[IsFramebufferEXT_remap_index]
+#define _gloffset_IsRenderbufferEXT driDispatchRemapTable[IsRenderbufferEXT_remap_index]
+#define _gloffset_RenderbufferStorageEXT driDispatchRemapTable[RenderbufferStorageEXT_remap_index]
+#define _gloffset_BlitFramebufferEXT driDispatchRemapTable[BlitFramebufferEXT_remap_index]
+#define _gloffset_FramebufferTextureLayerEXT driDispatchRemapTable[FramebufferTextureLayerEXT_remap_index]
+#define _gloffset_StencilFuncSeparateATI driDispatchRemapTable[StencilFuncSeparateATI_remap_index]
+#define _gloffset_ProgramEnvParameters4fvEXT driDispatchRemapTable[ProgramEnvParameters4fvEXT_remap_index]
+#define _gloffset_ProgramLocalParameters4fvEXT driDispatchRemapTable[ProgramLocalParameters4fvEXT_remap_index]
+#define _gloffset_GetQueryObjecti64vEXT driDispatchRemapTable[GetQueryObjecti64vEXT_remap_index]
+#define _gloffset_GetQueryObjectui64vEXT driDispatchRemapTable[GetQueryObjectui64vEXT_remap_index]
+
+#endif /* !defined(IN_DRI_DRIVER) */
+
+#endif /* !defined( _GLAPI_OFFSETS_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_x86_gcc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/prim_x86_gcc.h
@@ -0,0 +1,79 @@
+/****************************************************************************
+*
+* Inline helpers for x86emu
+*
+* Copyright (C) 2008 Bart Trojanowski, Symbio Technologies, LLC
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:     GNU C
+* Environment:  GCC on i386 or x86-64
+* Developer:    Bart Trojanowski
+*
+* Description:  This file defines a few x86 macros that can be used by the
+*               emulator to execute native instructions.
+*
+*               For PIC vs non-PIC code refer to:
+*               http://sam.zoy.org/blog/2007-04-13-shlib-with-non-pic-code-have-inline-assembly-and-pic-mix-well
+*
+****************************************************************************/
+#ifndef __X86EMU_PRIM_X86_GCC_H
+#define __X86EMU_PRIM_X86_GCC_H
+
+#include "x86emu/types.h"
+
+#if !defined(__GNUC__) || !(defined (__i386__) || defined(__i386) || defined(__AMD64__) || defined(__amd64__))
+#error This file is intended to be used by gcc on i386 or x86-64 system
+#endif
+
+#if defined(__PIC__) && defined(__i386__)
+
+#define X86EMU_HAS_HW_CPUID 1
+static inline void hw_cpuid (u32 *a, u32 *b, u32 *c, u32 *d)
+{
+    __asm__ __volatile__ ("pushl %%ebx      \n\t"
+                          "cpuid            \n\t"
+                          "movl %%ebx, %1   \n\t"
+                          "popl %%ebx       \n\t"
+                          : "=a" (*a), "=r" (*b),
+                            "=c" (*c), "=d" (*d)
+                          : "a" (*a), "c" (*c)
+                          : "cc");
+}
+
+#else /* ! (__PIC__ && __i386__) */
+
+#define x86EMU_HAS_HW_CPUID 1
+static inline void hw_cpuid (u32 *a, u32 *b, u32 *c, u32 *d)
+{
+    __asm__ __volatile__ ("cpuid"
+                          : "=a" (*a), "=b" (*b),
+                            "=c" (*c), "=d" (*d)
+                          : "a" (*a), "c" (*c)
+                          : "cc");
+}
+
+#endif /* __PIC__ && __i386__ */
+
+
+#endif /* __X86EMU_PRIM_X86_GCC_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86i2c.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86i2c.h
@@ -0,0 +1,106 @@
+/* 
+ *  Copyright (C) 1998 Itai Nahshon, Michael Schimek
+ */
+
+
+#ifndef _XF86I2C_H
+#define _XF86I2C_H
+
+#include "regionstr.h"
+
+typedef unsigned char  I2CByte;
+typedef unsigned short I2CSlaveAddr;
+
+typedef struct _I2CBusRec *I2CBusPtr;
+typedef struct _I2CDevRec *I2CDevPtr;
+
+/* I2C masters have to register themselves */
+
+typedef struct _I2CBusRec {
+    char *		BusName;
+    int			scrnIndex;
+    
+    void		(*I2CUDelay) (I2CBusPtr b, int usec);
+    
+    void		(*I2CPutBits)(I2CBusPtr b, int  scl, int  sda);
+    void		(*I2CGetBits)(I2CBusPtr b, int *scl, int *sda);
+
+    /* Look at the generic routines to see how these functions should behave. */
+
+    Bool        	(*I2CStart)  (I2CBusPtr b, int timeout);
+    Bool        	(*I2CAddress)(I2CDevPtr d, I2CSlaveAddr);
+    void        	(*I2CStop)   (I2CDevPtr d);
+    Bool		(*I2CPutByte)(I2CDevPtr d, I2CByte data);
+    Bool		(*I2CGetByte)(I2CDevPtr d, I2CByte *data, Bool);
+
+    DevUnion		DriverPrivate;
+
+    int         	HoldTime; 	/* 1 / bus clock frequency, 5 or 2 usec */
+
+    int			BitTimeout;	/* usec */
+    int 		ByteTimeout;	/* usec */
+    int			AcknTimeout;    /* usec */
+    int 		StartTimeout;	/* usec */
+    int                 RiseFallTime;   /* usec */
+
+    I2CDevPtr		FirstDev;
+    I2CBusPtr		NextBus;
+    Bool 		(*I2CWriteRead)(I2CDevPtr d, I2CByte *WriteBuffer, int nWrite,
+		                   I2CByte *ReadBuffer,  int nRead);
+} I2CBusRec;
+
+#define CreateI2CBusRec		xf86CreateI2CBusRec
+extern _X_EXPORT I2CBusPtr xf86CreateI2CBusRec(void);
+#define DestroyI2CBusRec	xf86DestroyI2CBusRec
+extern _X_EXPORT void xf86DestroyI2CBusRec(I2CBusPtr pI2CBus, Bool unalloc, Bool devs_too);
+#define I2CBusInit		xf86I2CBusInit
+extern _X_EXPORT Bool xf86I2CBusInit(I2CBusPtr pI2CBus);
+
+extern _X_EXPORT I2CBusPtr xf86I2CFindBus(int scrnIndex, char *name);
+extern _X_EXPORT int xf86I2CGetScreenBuses(int scrnIndex, I2CBusPtr **pppI2CBus);
+
+
+/* I2C slave devices */
+
+typedef struct _I2CDevRec {
+    char *		DevName;
+
+    int			BitTimeout;	/* usec */
+    int 		ByteTimeout;	/* usec */
+    int			AcknTimeout;    /* usec */
+    int 		StartTimeout;	/* usec */
+
+    I2CSlaveAddr	SlaveAddr;
+    I2CBusPtr		pI2CBus;
+    I2CDevPtr		NextDev;
+    DevUnion		DriverPrivate;
+} I2CDevRec;
+
+#define CreateI2CDevRec		xf86CreateI2CDevRec
+extern _X_EXPORT I2CDevPtr xf86CreateI2CDevRec(void);
+extern _X_EXPORT void xf86DestroyI2CDevRec(I2CDevPtr pI2CDev, Bool unalloc);
+#define I2CDevInit		xf86I2CDevInit
+extern _X_EXPORT Bool xf86I2CDevInit(I2CDevPtr pI2CDev);
+extern _X_EXPORT I2CDevPtr xf86I2CFindDev(I2CBusPtr, I2CSlaveAddr);
+
+/* See descriptions of these functions in xf86i2c.c */
+
+#define I2CProbeAddress		xf86I2CProbeAddress
+extern _X_EXPORT Bool xf86I2CProbeAddress(I2CBusPtr pI2CBus, I2CSlaveAddr);
+
+#define		I2C_WriteRead xf86I2CWriteRead
+extern _X_EXPORT Bool xf86I2CWriteRead(I2CDevPtr d, I2CByte *WriteBuffer, int nWrite,
+		                   I2CByte *ReadBuffer,  int nRead);
+#define 	xf86I2CRead(d, rb, nr) xf86I2CWriteRead(d, NULL, 0, rb, nr)
+
+extern _X_EXPORT Bool xf86I2CReadStatus(I2CDevPtr d, I2CByte *pbyte);
+extern _X_EXPORT Bool xf86I2CReadByte(I2CDevPtr d, I2CByte subaddr, I2CByte *pbyte);
+extern _X_EXPORT Bool xf86I2CReadBytes(I2CDevPtr d, I2CByte subaddr, I2CByte *pbyte, int n);
+extern _X_EXPORT Bool xf86I2CReadWord(I2CDevPtr d, I2CByte subaddr, unsigned short *pword);
+#define 	xf86I2CWrite(d, wb, nw) xf86I2CWriteRead(d, wb, nw, NULL, 0)
+extern _X_EXPORT Bool xf86I2CWriteByte(I2CDevPtr d, I2CByte subaddr, I2CByte byte);
+extern _X_EXPORT Bool xf86I2CWriteBytes(I2CDevPtr d, I2CByte subaddr, I2CByte *WriteBuffer, int nWrite);
+extern _X_EXPORT Bool xf86I2CWriteWord(I2CDevPtr d, I2CByte subaddr, unsigned short word);
+extern _X_EXPORT Bool xf86I2CWriteVec(I2CDevPtr d, I2CByte *vec, int nValues);
+
+#endif /*_XF86I2C_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mibstorest.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/mibstorest.h
@@ -0,0 +1,91 @@
+/*
+ * mibstorest.h
+ *
+ * internal structure definitions for mi backing store
+ */
+
+
+/*
+
+Copyright 1989, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+*/
+
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include "mibstore.h"
+#include "regionstr.h"
+
+/*
+ * One of these structures is allocated per GC used with a backing-store
+ * drawable.
+ */
+
+typedef struct {
+    GCPtr	    pBackingGC;	    /* Copy of the GC but with graphicsExposures
+				     * set FALSE and the clientClip set to
+				     * clip output to the valid regions of the
+				     * backing pixmap. */
+    int		    guarantee;      /* GuaranteeNothing, etc. */
+    unsigned long   serialNumber;   /* clientClip computed time */
+    unsigned long   stateChanges;   /* changes in parent gc since last copy */
+    GCOps	    *wrapOps;	    /* wrapped ops */
+    GCFuncs	    *wrapFuncs;	    /* wrapped funcs */
+} miBSGCRec, *miBSGCPtr;
+
+/*
+ * one of these structures is allocated per Window with backing store
+ */
+
+typedef struct {
+    PixmapPtr	  pBackingPixmap;   /* Pixmap for saved areas */
+    short	  x;		    /* origin of pixmap relative to window */
+    short	  y;
+    RegionRec	  SavedRegion;	    /* Valid area in pBackingPixmap */
+    char    	  viewable; 	    /* Tracks pWin->viewable so SavedRegion may
+				     * be initialized correctly when the window
+				     * is first mapped */
+    char    	  status;    	    /* StatusNoPixmap, etc. */
+    char	  backgroundState;  /* background type */
+    PixUnion	  background;	    /* background pattern */
+} miBSWindowRec, *miBSWindowPtr;
+
+#define StatusNoPixmap	1	/* pixmap has not been created */
+#define StatusVirtual	2	/* pixmap is virtual, tiled with background */
+#define StatusVDirty	3	/* pixmap is virtual, visiblt has contents */
+#define StatusBadAlloc	4	/* pixmap create failed, do not try again */
+#define StatusContents	5	/* pixmap is created, has valid contents */
+
+typedef struct {
+    /*
+     * screen func wrappers
+     */
+    CloseScreenProcPtr	CloseScreen;
+    GetImageProcPtr	GetImage;
+    GetSpansProcPtr	GetSpans;
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+    CreateGCProcPtr	CreateGC;
+    DestroyWindowProcPtr DestroyWindow;
+} miBSScreenRec, *miBSScreenPtr;
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/memrange.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/memrange.h
@@ -0,0 +1,69 @@
+/*
+ * Memory range attribute operations, peformed on /dev/mem
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _MEMRANGE_H
+#define _MEMRANGE_H
+
+/* Memory range attributes */
+#define MDF_UNCACHEABLE		(1<<0)	/* region not cached */
+#define MDF_WRITECOMBINE	(1<<1)	/* region supports "write combine"
+					 * action */
+#define MDF_WRITETHROUGH	(1<<2)	/* write-through cached */
+#define MDF_WRITEBACK		(1<<3)	/* write-back cached */
+#define MDF_WRITEPROTECT	(1<<4)	/* read-only region */
+#define MDF_ATTRMASK		(0x00ffffff)
+
+#define MDF_FIXBASE		(1<<24)	/* fixed base */
+#define MDF_FIXLEN		(1<<25)	/* fixed length */
+#define MDF_FIRMWARE		(1<<26)	/* set by firmware (XXX not useful?) */
+#define MDF_ACTIVE		(1<<27)	/* currently active */
+#define MDF_BOGUS		(1<<28)	/* we don't like it */
+#define MDF_FIXACTIVE		(1<<29)	/* can't be turned off */
+#define MDF_BUSY		(1<<30)	/* range is in use */
+
+struct mem_range_desc {
+	u_int64_t mr_base;
+	u_int64_t mr_len;
+	int     mr_flags;
+	char    mr_owner[8];
+};
+
+struct mem_range_op {
+	struct mem_range_desc *mo_desc;
+	int     mo_arg[2];
+#define MEMRANGE_SET_UPDATE	0
+#define MEMRANGE_SET_REMOVE	1
+	/* XXX want a flag that says "set and undo when I exit" */
+};
+#define MEMRANGE_GET	_IOWR('m', 50, struct mem_range_op)
+#define MEMRANGE_SET	_IOW('m', 51, struct mem_range_op)
+
+#ifdef _KERNEL
+
+struct mem_range_softc;
+struct mem_range_ops {
+	void    (*init) __P((struct mem_range_softc * sc));
+	int     (*set) __P((struct mem_range_softc * sc, struct mem_range_desc * mrd, int *arg));
+	void    (*initAP) __P((struct mem_range_softc * sc));
+};
+
+struct mem_range_softc {
+	struct mem_range_ops *mr_op;
+	int     mr_cap;
+	int     mr_ndesc;
+	struct mem_range_desc *mr_desc;
+};
+
+extern struct mem_range_softc mem_range_softc;
+
+extern int mem_range_attr_get __P((struct mem_range_desc * mrd, int *arg));
+extern int mem_range_attr_set __P((struct mem_range_desc * mrd, int *arg));
+extern void mem_range_AP_init __P((void));
+#endif
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setfocus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setfocus.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETFOCUS_H
+#define SETFOCUS_H 1
+
+int SProcXSetDeviceFocus(ClientPtr	/* client */
+    );
+
+int ProcXSetDeviceFocus(ClientPtr	/* client */
+    );
+
+#endif /* SETFOCUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda8425.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/tda8425.h
@@ -0,0 +1,41 @@
+#ifndef __TDA8425_H__
+#define __TDA8425_H__
+
+#include "xf86i2c.h"
+
+typedef struct {
+	I2CDevRec d;
+	
+	int mux;
+	int stereo;
+	int v_left;
+	int v_right;
+	int bass;
+	int treble;
+	int src_sel;
+	Bool mute;
+	} TDA8425Rec, *TDA8425Ptr;
+
+#define TDA8425_ADDR_1   0x82
+
+/* the third parameter is meant to force detection of tda8425.
+   This is because tda8425 is write-only and complete implementation
+   of I2C protocol is not always available. Besides address there is no good
+   way to autodetect it so we have to _know_ it is there anyway */
+   
+#define xf86_Detect_tda8425	Detect_tda8425
+extern _X_EXPORT TDA8425Ptr Detect_tda8425(I2CBusPtr b, I2CSlaveAddr addr,Bool force);
+#define xf86_tda8425_init	tda8425_init
+extern _X_EXPORT Bool tda8425_init(TDA8425Ptr t);
+#define xf86_tda8425_setaudio	tda8425_setaudio
+extern _X_EXPORT void tda8425_setaudio(TDA8425Ptr t);
+#define xf86_tda8425_mute	tda8425_mute
+extern _X_EXPORT void tda8425_mute(TDA8425Ptr t, Bool mute);
+
+#define TDA8425SymbolsList  \
+		"Detect_tda8425", \
+		"tda8425_init", \
+		"tda8425_setaudio", \
+		"tda8425_mute"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisetdevfocus.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xisetdevfocus.h
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XISETDEVFOCUS_H
+#define XISETDEVFOCUS_H 1
+
+int SProcXISetFocus(ClientPtr client);
+int ProcXISetFocus(ClientPtr client);
+
+int SProcXIGetFocus(ClientPtr client);
+int ProcXIGetFocus(ClientPtr client);
+
+void SRepXIGetFocus(ClientPtr client, int len, xXIGetFocusReply* rep);
+#endif /* XISETDEVFOCUS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Priv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86Priv.h
@@ -0,0 +1,161 @@
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * This file contains declarations for private XFree86 functions and variables,
+ * and definitions of private macros.
+ *
+ * "private" means not available to video drivers.
+ */
+
+#ifndef _XF86PRIV_H
+#define _XF86PRIV_H
+
+#include <pciaccess.h>
+
+#include "xf86Privstr.h"
+#include "propertyst.h"
+#include "input.h"
+
+/*
+ * Parameters set ONLY from the command line options
+ * The global state of these things is held in xf86InfoRec (when appropriate).
+ */
+extern _X_EXPORT const char *xf86ConfigFile;
+extern _X_EXPORT const char *xf86ConfigDir;
+extern _X_EXPORT  Bool xf86AllowMouseOpenFail;
+#ifdef XF86VIDMODE
+extern _X_EXPORT  Bool xf86VidModeDisabled;
+extern _X_EXPORT  Bool xf86VidModeAllowNonLocal;
+#endif 
+extern _X_EXPORT  Bool xf86fpFlag;
+extern _X_EXPORT  Bool xf86sFlag;
+extern _X_EXPORT  Bool xf86bsEnableFlag;
+extern _X_EXPORT  Bool xf86bsDisableFlag;
+extern _X_EXPORT  Bool xf86silkenMouseDisableFlag;
+extern _X_EXPORT  Bool xf86xkbdirFlag;
+#ifdef HAVE_ACPI
+extern _X_EXPORT  Bool xf86acpiDisableFlag;
+#endif
+extern _X_EXPORT  char *xf86LayoutName;
+extern _X_EXPORT  char *xf86ScreenName;
+extern _X_EXPORT  char *xf86PointerName;
+extern _X_EXPORT  char *xf86KeyboardName;
+extern _X_EXPORT  int xf86FbBpp;
+extern _X_EXPORT  int xf86Depth;
+extern _X_EXPORT  Pix24Flags xf86Pix24;
+extern _X_EXPORT  rgb xf86Weight;
+extern _X_EXPORT  Bool xf86FlipPixels;
+extern _X_EXPORT  Gamma xf86Gamma;
+extern _X_EXPORT  char *xf86ServerName;
+extern _X_EXPORT  struct pci_slot_match xf86IsolateDevice;
+
+/* Other parameters */
+
+extern _X_EXPORT  xf86InfoRec xf86Info;
+extern _X_EXPORT  const char *xf86ModulePath;
+extern _X_EXPORT  MessageType xf86ModPathFrom;
+extern _X_EXPORT  const char *xf86LogFile;
+extern _X_EXPORT  MessageType xf86LogFileFrom;
+extern _X_EXPORT  Bool xf86LogFileWasOpened;
+extern _X_EXPORT  serverLayoutRec xf86ConfigLayout;
+
+extern _X_EXPORT  DriverPtr *xf86DriverList;
+extern _X_EXPORT  int xf86NumDrivers;
+extern _X_EXPORT  Bool xf86Resetting;
+extern _X_EXPORT  Bool xf86Initialising;
+extern _X_EXPORT  int xf86NumScreens;
+extern _X_EXPORT  const char *xf86VisualNames[];
+extern _X_EXPORT  int xf86Verbose;                 /* verbosity level */
+extern _X_EXPORT  int xf86LogVerbose;		/* log file verbosity level */
+extern _X_EXPORT  Bool xorgHWAccess;
+
+extern _X_EXPORT  RootWinPropPtr *xf86RegisteredPropertiesTable;
+
+#ifndef DEFAULT_VERBOSE
+#define DEFAULT_VERBOSE		0
+#endif
+#ifndef DEFAULT_LOG_VERBOSE
+#define DEFAULT_LOG_VERBOSE	3
+#endif
+#ifndef DEFAULT_DPI
+#define DEFAULT_DPI		96
+#endif
+
+/* Function Prototypes */
+#ifndef _NO_XF86_PROTOTYPES
+
+/* xf86Bus.c */
+extern _X_EXPORT Bool xf86BusConfig(void);
+extern _X_EXPORT void xf86BusProbe(void);
+extern _X_EXPORT void xf86AccessEnter(void);
+extern _X_EXPORT void xf86AccessLeave(void);
+extern _X_EXPORT void xf86PostProbe(void);
+extern _X_EXPORT void xf86ClearEntityListForScreen(int scrnIndex);
+extern _X_EXPORT void xf86AddDevToEntity(int entityIndex, GDevPtr dev);
+extern _X_EXPORT void xf86PostScreenInit(void);
+
+/* xf86Config.c */
+
+extern _X_EXPORT Bool xf86PathIsSafe(const char *path);
+
+/* xf86DefaultModes */
+
+extern _X_EXPORT const DisplayModeRec xf86DefaultModes[];
+extern _X_EXPORT const int xf86NumDefaultModes;
+
+/* xf86Configure.c */
+extern _X_EXPORT void DoConfigure(void);
+
+/* xf86ShowOpts.c */
+extern _X_EXPORT void DoShowOptions(void);
+
+/* xf86Events.c */
+
+extern _X_EXPORT void xf86Wakeup(pointer blockData, int err, pointer pReadmask);
+extern _X_HIDDEN int xf86SigWrapper(int signo);
+extern _X_EXPORT void xf86HandlePMEvents(int fd, pointer data);
+extern _X_EXPORT int (*xf86PMGetEventFromOs)(int fd,pmEvent *events,int num);
+extern _X_EXPORT pmWait (*xf86PMConfirmEventToOs)(int fd,pmEvent event);
+
+/* xf86Helper.c */
+extern _X_EXPORT void xf86LogInit(void);
+extern _X_EXPORT void xf86CloseLog(void);
+
+/* xf86Init.c */
+extern _X_EXPORT Bool xf86LoadModules(char **list, pointer *optlist);
+extern _X_EXPORT int xf86SetVerbosity(int verb);
+extern _X_EXPORT int xf86SetLogVerbosity(int verb);
+extern _X_EXPORT Bool xf86CallDriverProbe( struct _DriverRec * drv, Bool detect_only );
+
+/* xf86Xinput.c */
+extern _X_EXPORT EventList *xf86Events;
+
+#endif /* _NO_XF86_PROTOTYPES */
+
+
+#endif /* _XF86PRIV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miscstruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/miscstruct.h
@@ -0,0 +1,66 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef MISCSTRUCT_H
+#define MISCSTRUCT_H 1
+
+#include "misc.h"
+#include <X11/Xprotostr.h>
+#include <pixman.h>
+
+typedef xPoint DDXPointRec;
+
+typedef struct pixman_box16 BoxRec;
+
+typedef union _DevUnion {
+    pointer		ptr;
+    long		val;
+    unsigned long	uval;
+    pointer		(*fptr)(void);
+} DevUnion;
+
+#endif /* MISCSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxdricommon.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxdricommon.h
@@ -0,0 +1,41 @@
+/*
+ * Copyright © 2008 Red Hat, Inc
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef _GLX_dri_common_h
+#define _GLX_dri_common_h
+
+typedef struct __GLXDRIconfig	__GLXDRIconfig;
+struct __GLXDRIconfig {
+    __GLXconfig config;
+    const __DRIconfig *driConfig;
+};
+
+__GLXconfig *
+glxConvertConfigs(const __DRIcoreExtension *core,
+		  const __DRIconfig **configs, unsigned int drawableType);
+
+extern const __DRIsystemTimeExtension systemTimeExtension;
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvdix.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xvdix.h
@@ -0,0 +1,275 @@
+/***********************************************************
+Copyright 1991 by Digital Equipment Corporation, Maynard, Massachusetts,
+and the Massachusetts Institute of Technology, Cambridge, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the names of Digital or MIT not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef XVDIX_H
+#define XVDIX_H
+/*
+** File: 
+**
+**   xvdix.h --- Xv device independent header file
+**
+** Author: 
+**
+**   David Carver (Digital Workstation Engineering/Project Athena)
+**
+** Revisions:
+**
+**   29.08.91 Carver
+**     - removed UnrealizeWindow wrapper unrealizing windows no longer 
+**       preempts video
+**
+**   11.06.91 Carver
+**     - changed SetPortControl to SetPortAttribute
+**     - changed GetPortControl to GetPortAttribute
+**     - changed QueryBestSize
+**
+**   15.05.91 Carver
+**     - version 2.0 upgrade
+**
+**   24.01.91 Carver
+**     - version 1.4 upgrade
+**
+*/
+
+#include "scrnintstr.h"
+#include <X11/extensions/Xvproto.h>
+
+#ifndef XorgLoader
+extern _X_EXPORT unsigned long XvExtensionGeneration;
+extern _X_EXPORT unsigned long XvScreenGeneration;
+extern _X_EXPORT unsigned long XvResourceGeneration;
+
+extern _X_EXPORT int XvReqCode;
+extern _X_EXPORT int XvEventBase;
+extern _X_EXPORT int XvErrorBase;
+
+extern _X_EXPORT unsigned long XvRTPort;
+extern _X_EXPORT unsigned long XvRTEncoding;
+extern _X_EXPORT unsigned long XvRTGrab;
+extern _X_EXPORT unsigned long XvRTVideoNotify;
+extern _X_EXPORT unsigned long XvRTVideoNotifyList;
+extern _X_EXPORT unsigned long XvRTPortNotify;
+#endif
+
+typedef struct {
+  int numerator;
+  int denominator;
+} XvRationalRec, *XvRationalPtr;
+
+typedef struct {
+  char depth;
+  unsigned long visual;
+} XvFormatRec, *XvFormatPtr;
+
+typedef struct {
+  unsigned long id;
+  ClientPtr client;
+} XvGrabRec, *XvGrabPtr;
+
+typedef struct _XvVideoNotifyRec {
+  struct _XvVideoNotifyRec *next;
+  ClientPtr client;
+  unsigned long id;
+  unsigned long mask;
+} XvVideoNotifyRec, *XvVideoNotifyPtr;
+
+typedef struct _XvPortNotifyRec {
+  struct _XvPortNotifyRec *next;
+  ClientPtr client;
+  unsigned long id;
+} XvPortNotifyRec, *XvPortNotifyPtr;
+
+typedef struct {
+  int id;
+  ScreenPtr pScreen;
+  char *name;
+  unsigned short width, height;
+  XvRationalRec rate;
+} XvEncodingRec, *XvEncodingPtr;
+
+typedef struct _XvAttributeRec {
+  int flags;
+  int min_value;
+  int max_value;
+  char *name;
+} XvAttributeRec, *XvAttributePtr;
+
+typedef struct {
+  int id;
+  int type;
+  int byte_order;
+  char guid[16];
+  int bits_per_pixel;
+  int format;
+  int num_planes;
+
+  /* for RGB formats only */
+  int depth;
+  unsigned int red_mask;       
+  unsigned int green_mask;   
+  unsigned int blue_mask;   
+
+  /* for YUV formats only */
+  unsigned int y_sample_bits;
+  unsigned int u_sample_bits;
+  unsigned int v_sample_bits;   
+  unsigned int horz_y_period;
+  unsigned int horz_u_period;
+  unsigned int horz_v_period;
+  unsigned int vert_y_period;
+  unsigned int vert_u_period;
+  unsigned int vert_v_period;
+  char component_order[32];
+  int scanline_order;
+} XvImageRec, *XvImagePtr; 
+
+typedef struct {
+  unsigned long base_id;
+  unsigned char type; 
+  char *name;
+  int nEncodings;
+  XvEncodingPtr pEncodings;  
+  int nFormats;
+  XvFormatPtr pFormats; 
+  int nAttributes;
+  XvAttributePtr pAttributes;
+  int nImages;
+  XvImagePtr pImages;
+  int nPorts;
+  struct _XvPortRec *pPorts;
+  ScreenPtr pScreen; 
+  int (* ddAllocatePort)(unsigned long, struct _XvPortRec*, 
+				struct _XvPortRec**);
+  int (* ddFreePort)(struct _XvPortRec*);
+  int (* ddPutVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16); 
+  int (* ddPutStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+  int (* ddGetVideo)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+  int (* ddGetStill)(ClientPtr, DrawablePtr,struct _XvPortRec*, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+  int (* ddStopVideo)(ClientPtr, struct _XvPortRec*, DrawablePtr);
+  int (* ddSetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32);
+  int (* ddGetPortAttribute)(ClientPtr, struct _XvPortRec*, Atom, INT32*);
+  int (* ddQueryBestSize)(ClientPtr, struct _XvPortRec*, CARD8,
+   				CARD16, CARD16,CARD16, CARD16, 
+				unsigned int*, unsigned int*);
+  int (* ddPutImage)(ClientPtr, DrawablePtr, struct _XvPortRec*, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16,
+				XvImagePtr, unsigned char*, Bool,
+				CARD16, CARD16);
+  int (* ddQueryImageAttributes)(ClientPtr, struct _XvPortRec*, XvImagePtr, 
+				CARD16*, CARD16*, int*, int*);
+  DevUnion devPriv;
+} XvAdaptorRec, *XvAdaptorPtr;
+
+typedef struct _XvPortRec {
+  unsigned long id;
+  XvAdaptorPtr pAdaptor;
+  XvPortNotifyPtr pNotify;
+  DrawablePtr pDraw;
+  ClientPtr client;
+  XvGrabRec grab;
+  TimeStamp time;
+  DevUnion devPriv;
+} XvPortRec, *XvPortPtr;
+
+#define VALIDATE_XV_PORT(portID, pPort, mode)\
+    {\
+	int rc = dixLookupResourceByType((pointer *)&(pPort), portID,\
+	                                 XvRTPort, client, mode);\
+	if (rc != Success)\
+	    return rc;\
+    }
+
+typedef struct {
+  int version, revision;
+  int nAdaptors;
+  XvAdaptorPtr pAdaptors;
+  DestroyWindowProcPtr DestroyWindow;
+  DestroyPixmapProcPtr DestroyPixmap;
+  CloseScreenProcPtr CloseScreen;
+  Bool (* ddCloseScreen)(int, ScreenPtr);
+  int (* ddQueryAdaptors)(ScreenPtr, XvAdaptorPtr*, int*);
+  DevUnion devPriv;
+} XvScreenRec, *XvScreenPtr;
+
+#define SCREEN_PROLOGUE(pScreen, field) ((pScreen)->field = ((XvScreenPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, XvScreenKey))->field)
+
+#define SCREEN_EPILOGUE(pScreen, field, wrapper)\
+    ((pScreen)->field = wrapper)
+
+/* Errors */
+
+#define _XvBadPort (XvBadPort+XvErrorBase)
+#define _XvBadEncoding (XvBadEncoding+XvErrorBase)
+
+#ifndef XorgLoader
+extern _X_EXPORT int ProcXvDispatch(ClientPtr);
+extern _X_EXPORT int SProcXvDispatch(ClientPtr);
+
+extern _X_EXPORT void XvExtensionInit(void);
+extern _X_EXPORT int XvScreenInit(ScreenPtr);
+extern _X_EXPORT DevPrivateKey XvGetScreenKey(void);
+extern _X_EXPORT unsigned long XvGetRTPort(void);
+extern _X_EXPORT int XvdiSendPortNotify(XvPortPtr, Atom, INT32);
+extern _X_EXPORT int XvdiVideoStopped(XvPortPtr, int);
+
+extern _X_EXPORT int XvdiPutVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiPutStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiGetVideo(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiGetStill(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16);
+extern _X_EXPORT int XvdiPutImage(ClientPtr, DrawablePtr, XvPortPtr, GCPtr,
+   				INT16, INT16, CARD16, CARD16, 
+				INT16, INT16, CARD16, CARD16,
+				XvImagePtr, unsigned char*, Bool,
+				CARD16, CARD16);
+extern _X_EXPORT int XvdiSelectVideoNotify(ClientPtr, DrawablePtr, BOOL);
+extern _X_EXPORT int XvdiSelectPortNotify(ClientPtr, XvPortPtr, BOOL);
+extern _X_EXPORT int XvdiSetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32);
+extern _X_EXPORT int XvdiGetPortAttribute(ClientPtr, XvPortPtr, Atom, INT32*);
+extern _X_EXPORT int XvdiStopVideo(ClientPtr, XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiPreemptVideo(ClientPtr, XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiMatchPort(XvPortPtr, DrawablePtr);
+extern _X_EXPORT int XvdiGrabPort(ClientPtr, XvPortPtr, Time, int *);
+extern _X_EXPORT int XvdiUngrabPort( ClientPtr, XvPortPtr, Time);
+#endif /* XorgLoader */
+
+#endif /* XVDIX_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/micmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/micmap.h
@@ -0,0 +1,63 @@
+
+#include "colormapst.h"
+
+#ifndef _MICMAP_H_
+#define _MICMAP_H_
+
+#define GetInstalledmiColormap(s) \
+    ((ColormapPtr) dixLookupPrivate(&(s)->devPrivates, micmapScrPrivateKey))
+#define SetInstalledmiColormap(s,c) \
+    (dixSetPrivate(&(s)->devPrivates, micmapScrPrivateKey, c))
+
+extern _X_EXPORT DevPrivateKeyRec micmapScrPrivateKeyRec;
+#define micmapScrPrivateKey (&micmapScrPrivateKeyRec)
+
+typedef Bool (* miInitVisualsProcPtr)(VisualPtr *, DepthPtr *, int *, int *,
+					int *, VisualID *, unsigned long, int,
+					int);
+
+extern _X_EXPORT int miListInstalledColormaps(ScreenPtr pScreen, Colormap *pmaps);
+extern _X_EXPORT void miInstallColormap(ColormapPtr pmap);
+extern _X_EXPORT void miUninstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void miResolveColor(unsigned short *, unsigned short *, unsigned short *,
+			VisualPtr);
+extern _X_EXPORT Bool miInitializeColormap(ColormapPtr);
+extern _X_EXPORT int miExpandDirectColors(ColormapPtr, int, xColorItem *, xColorItem *);
+extern _X_EXPORT Bool miCreateDefColormap(ScreenPtr);
+extern _X_EXPORT void miClearVisualTypes(void);
+extern _X_EXPORT Bool miSetVisualTypes(int, int, int, int);
+extern _X_EXPORT Bool miSetPixmapDepths(void);
+extern _X_EXPORT Bool miSetVisualTypesAndMasks(int depth, int visuals, int bitsPerRGB,
+			      int preferredCVC,
+			      Pixel redMask, Pixel greenMask, Pixel blueMask);
+extern _X_EXPORT int miGetDefaultVisualMask(int);
+extern _X_EXPORT Bool miInitVisuals(VisualPtr *, DepthPtr *, int *, int *, int *, VisualID *,
+			unsigned long, int, int);
+
+#define MAX_PSEUDO_DEPTH	10
+#define MIN_TRUE_DEPTH		6
+
+#define StaticGrayMask	(1 << StaticGray)
+#define GrayScaleMask	(1 << GrayScale)
+#define StaticColorMask	(1 << StaticColor)
+#define PseudoColorMask	(1 << PseudoColor)
+#define TrueColorMask	(1 << TrueColor)
+#define DirectColorMask	(1 << DirectColor)
+                
+#define ALL_VISUALS	(StaticGrayMask|\
+			 GrayScaleMask|\
+			 StaticColorMask|\
+			 PseudoColorMask|\
+			 TrueColorMask|\
+			 DirectColorMask)
+
+#define LARGE_VISUALS	(TrueColorMask|\
+			 DirectColorMask)
+
+#define SMALL_VISUALS	(StaticGrayMask|\
+			 GrayScaleMask|\
+			 StaticColorMask|\
+			 PseudoColorMask)
+
+#endif /* _MICMAP_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86DDC.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86DDC.h
@@ -0,0 +1,126 @@
+
+/* xf86DDC.h
+ *
+ * This file contains all information to interpret a standard EDIC block 
+ * transmitted by a display device via DDC (Display Data Channel). So far 
+ * there is no information to deal with optional EDID blocks.  
+ * DDC is a Trademark of VESA (Video Electronics Standard Association).
+ *
+ * Copyright 1998 by Egbert Eich <Egbert.Eich@Physik.TU-Darmstadt.DE>
+ */
+
+#ifndef XF86_DDC_H
+# define XF86_DDC_H
+
+#include "edid.h"
+#include "xf86i2c.h"
+#include "xf86str.h"
+
+/* speed up / slow down */
+typedef enum {
+  DDC_SLOW,
+  DDC_FAST
+} xf86ddcSpeed;
+
+typedef void (* DDC1SetSpeedProc)(ScrnInfoPtr, xf86ddcSpeed);
+
+extern _X_EXPORT xf86MonPtr xf86DoEDID_DDC1(
+    int scrnIndex, 
+    DDC1SetSpeedProc DDC1SetSpeed,
+    unsigned int (*DDC1Read)(ScrnInfoPtr)
+);
+
+extern _X_EXPORT xf86MonPtr xf86DoEDID_DDC2(
+   int scrnIndex,
+   I2CBusPtr pBus
+);
+
+extern _X_EXPORT xf86MonPtr xf86DoEEDID(int scrnIndex, I2CBusPtr pBus, Bool);
+
+extern _X_EXPORT xf86MonPtr xf86PrintEDID(
+    xf86MonPtr monPtr
+);
+
+extern _X_EXPORT xf86MonPtr xf86InterpretEDID(
+    int screenIndex, Uchar *block
+);
+
+extern _X_EXPORT xf86MonPtr xf86InterpretEEDID(
+    int screenIndex, Uchar *block
+);
+
+extern _X_EXPORT void
+xf86EdidMonitorSet(int scrnIndex, MonPtr Monitor, xf86MonPtr DDC);
+
+extern _X_EXPORT Bool xf86SetDDCproperties(
+    ScrnInfoPtr pScreen,
+    xf86MonPtr DDC
+);
+
+extern _X_EXPORT DisplayModePtr xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC);
+
+extern _X_EXPORT Bool
+xf86MonitorIsHDMI(xf86MonPtr mon);
+
+extern _X_EXPORT xf86MonPtr
+xf86DoDisplayID(int scrnIndex, I2CBusPtr pBus);
+
+extern _X_EXPORT void
+xf86DisplayIDMonitorSet(int scrnIndex, MonPtr mon, xf86MonPtr DDC);
+
+extern _X_EXPORT DisplayModePtr
+FindDMTMode(int hsize, int vsize, int refresh, Bool rb);
+
+extern _X_EXPORT const DisplayModeRec DMTModes[];
+
+/*
+ * Quirks to work around broken EDID data from various monitors.
+ */
+typedef enum {
+    DDC_QUIRK_NONE = 0,
+    /* First detailed mode is bogus, prefer largest mode at 60hz */
+    DDC_QUIRK_PREFER_LARGE_60 = 1 << 0,
+    /* 135MHz clock is too high, drop a bit */
+    DDC_QUIRK_135_CLOCK_TOO_HIGH = 1 << 1,
+    /* Prefer the largest mode at 75 Hz */
+    DDC_QUIRK_PREFER_LARGE_75 = 1 << 2,
+    /* Convert detailed timing's horizontal from units of cm to mm */
+    DDC_QUIRK_DETAILED_H_IN_CM = 1 << 3,
+    /* Convert detailed timing's vertical from units of cm to mm */
+    DDC_QUIRK_DETAILED_V_IN_CM = 1 << 4,
+    /* Detailed timing descriptors have bogus size values, so just take the
+     * maximum size and use that.
+     */
+    DDC_QUIRK_DETAILED_USE_MAXIMUM_SIZE = 1 << 5,
+    /* Monitor forgot to set the first detailed is preferred bit. */
+    DDC_QUIRK_FIRST_DETAILED_PREFERRED = 1 << 6,
+    /* use +hsync +vsync for detailed mode */
+    DDC_QUIRK_DETAILED_SYNC_PP = 1 << 7,
+    /* Force single-link DVI bandwidth limit */
+    DDC_QUIRK_DVI_SINGLE_LINK = 1 << 8,
+} ddc_quirk_t;
+
+DisplayModePtr xf86DDCGetModes(int scrnIndex, xf86MonPtr DDC);
+
+extern Bool
+xf86MonitorIsHDMI(xf86MonPtr mon);
+
+typedef void (* handle_detailed_fn)(struct detailed_monitor_section *,void *);
+
+void xf86ForEachDetailedBlock(xf86MonPtr mon,
+                              handle_detailed_fn,
+                              void *data);
+
+ddc_quirk_t
+xf86DDCDetectQuirks(int scrnIndex, xf86MonPtr DDC, Bool verbose);
+
+void xf86DetTimingApplyQuirks(struct detailed_monitor_section *det_mon,
+                              ddc_quirk_t quirks, int hsize, int vsize);
+
+typedef void (* handle_video_fn)(struct cea_video_block *, void *);
+
+void xf86ForEachVideoBlock(xf86MonPtr,
+                           handle_video_fn,
+                           void *);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/IBM.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/IBM.h
@@ -0,0 +1,385 @@
+
+#include <xf86RamDac.h>
+
+extern _X_EXPORT RamDacHelperRecPtr IBMramdacProbe(ScrnInfoPtr pScrn, RamDacSupportedInfoRecPtr ramdacs);
+extern _X_EXPORT void IBMramdacSave(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdacRestore(ScrnInfoPtr pScrn, RamDacRecPtr RamDacRec, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac526SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT void IBMramdac640SetBpp(ScrnInfoPtr pScrn, RamDacRegRecPtr RamDacRegRec);
+extern _X_EXPORT unsigned long IBMramdac526CalculateMNPCForClock(unsigned long RefClock,
+    unsigned long ReqClock, char IsPixClock, unsigned long MinClock,
+    unsigned long MaxClock, unsigned long *rM, unsigned long *rN,
+    unsigned long *rP, unsigned long *rC);
+extern _X_EXPORT unsigned long IBMramdac640CalculateMNPCForClock(unsigned long RefClock,
+    unsigned long ReqClock, char IsPixClock, unsigned long MinClock,
+    unsigned long MaxClock, unsigned long *rM, unsigned long *rN,
+    unsigned long *rP, unsigned long *rC);
+extern _X_EXPORT void IBMramdac526HWCursorInit(xf86CursorInfoPtr infoPtr);
+extern _X_EXPORT void IBMramdac640HWCursorInit(xf86CursorInfoPtr infoPtr);
+
+typedef void IBMramdac526SetBppProc(ScrnInfoPtr, RamDacRegRecPtr);
+extern _X_EXPORT IBMramdac526SetBppProc *IBMramdac526SetBppWeak(void);
+
+#define IBM524_RAMDAC		((VENDOR_IBM << 16) | 0x00)
+#define IBM524A_RAMDAC		((VENDOR_IBM << 16) | 0x01)
+#define IBM525_RAMDAC		((VENDOR_IBM << 16) | 0x02)
+#define IBM526_RAMDAC		((VENDOR_IBM << 16) | 0x03)
+#define IBM526DB_RAMDAC		((VENDOR_IBM << 16) | 0x04)
+#define IBM528_RAMDAC		((VENDOR_IBM << 16) | 0x05)
+#define IBM528A_RAMDAC		((VENDOR_IBM << 16) | 0x06)
+#define IBM624_RAMDAC		((VENDOR_IBM << 16) | 0x07)
+#define IBM624DB_RAMDAC		((VENDOR_IBM << 16) | 0x08)
+#define IBM640_RAMDAC		((VENDOR_IBM << 16) | 0x09)
+
+/*
+ * IBM Ramdac registers
+ */
+
+#define IBMRGB_REF_FREQ_1       14.31818
+#define IBMRGB_REF_FREQ_2       50.00000
+
+#define IBMRGB_rev		0x00
+#define IBMRGB_id		0x01
+#define IBMRGB_misc_clock	0x02
+#define IBMRGB_sync		0x03
+#define IBMRGB_hsync_pos	0x04
+#define IBMRGB_pwr_mgmt		0x05
+#define IBMRGB_dac_op		0x06
+#define IBMRGB_pal_ctrl		0x07
+#define IBMRGB_sysclk		0x08  /* not RGB525 */
+#define IBMRGB_pix_fmt		0x0a
+#define IBMRGB_8bpp		0x0b
+#define IBMRGB_16bpp		0x0c
+#define IBMRGB_24bpp		0x0d
+#define IBMRGB_32bpp		0x0e
+#define IBMRGB_pll_ctrl1	0x10
+#define IBMRGB_pll_ctrl2	0x11
+#define IBMRGB_pll_ref_div_fix	0x14
+#define IBMRGB_sysclk_ref_div	0x15  /* not RGB525 */
+#define IBMRGB_sysclk_vco_div	0x16  /* not RGB525 */
+/* #define IBMRGB_f0		0x20 */
+
+#define IBMRGB_sysclk_n		0x15
+#define IBMRGB_sysclk_m		0x16
+#define IBMRGB_sysclk_p		0x17
+#define IBMRGB_sysclk_c		0x18
+
+#define IBMRGB_m0		0x20
+#define IBMRGB_n0		0x21
+#define IBMRGB_p0		0x22
+#define IBMRGB_c0		0x23
+#define IBMRGB_m1		0x24
+#define IBMRGB_n1		0x25
+#define IBMRGB_p1		0x26
+#define IBMRGB_c1		0x27
+#define IBMRGB_m2		0x28
+#define IBMRGB_n2		0x29
+#define IBMRGB_p2		0x2a
+#define IBMRGB_c2		0x2b
+#define IBMRGB_m3		0x2c
+#define IBMRGB_n3		0x2d
+#define IBMRGB_p3		0x2e
+#define IBMRGB_c3		0x2f
+
+#define IBMRGB_curs		0x30
+#define IBMRGB_curs_xl		0x31
+#define IBMRGB_curs_xh		0x32
+#define IBMRGB_curs_yl		0x33
+#define IBMRGB_curs_yh		0x34
+#define IBMRGB_curs_hot_x	0x35
+#define IBMRGB_curs_hot_y	0x36
+#define IBMRGB_curs_col1_r	0x40
+#define IBMRGB_curs_col1_g	0x41
+#define IBMRGB_curs_col1_b	0x42
+#define IBMRGB_curs_col2_r	0x43
+#define IBMRGB_curs_col2_g	0x44
+#define IBMRGB_curs_col2_b	0x45
+#define IBMRGB_curs_col3_r	0x46
+#define IBMRGB_curs_col3_g	0x47
+#define IBMRGB_curs_col3_b	0x48
+#define IBMRGB_border_col_r	0x60
+#define IBMRGB_border_col_g	0x61
+#define IBMRGB_botder_col_b	0x62
+#define IBMRGB_key		0x68
+#define IBMRGB_key_mask		0x6C
+#define IBMRGB_misc1		0x70
+#define IBMRGB_misc2		0x71
+#define IBMRGB_misc3		0x72
+#define IBMRGB_misc4		0x73  /* not RGB525 */
+#define IBMRGB_key_control	0x78
+#define IBMRGB_dac_sense	0x82
+#define IBMRGB_misr_r		0x84
+#define IBMRGB_misr_g		0x86
+#define IBMRGB_misr_b		0x88
+#define IBMRGB_pll_vco_div_in	0x8e
+#define IBMRGB_pll_ref_div_in	0x8f
+#define IBMRGB_vram_mask_0	0x90
+#define IBMRGB_vram_mask_1	0x91
+#define IBMRGB_vram_mask_2	0x92
+#define IBMRGB_vram_mask_3	0x93
+#define IBMRGB_curs_array	0x100
+
+
+
+/* Constants rgb525.h */  
+
+/* RGB525_REVISION_LEVEL */
+#define RGB525_PRODUCT_REV_LEVEL        0xf0
+
+/* RGB525_ID */
+#define RGB525_PRODUCT_ID               0x01
+
+/* RGB525_MISC_CTRL_1 */
+#define MISR_CNTL_ENABLE                0x80
+#define VMSK_CNTL_ENABLE                0x40
+#define PADR_RDMT_RDADDR                0x0
+#define PADR_RDMT_PAL_STATE             0x20
+#define SENS_DSAB_DISABLE               0x10
+#define SENS_SEL_BIT3                   0x0
+#define SENS_SEL_BIT7                   0x08
+#define VRAM_SIZE_32                    0x0
+#define VRAM_SIZE_64                    0x01
+
+/* RGB525_MISC_CTRL_2 */
+#define PCLK_SEL_LCLK                   0x0
+#define PCLK_SEL_PLL                    0x40
+#define PCLK_SEL_EXT                    0x80
+#define INTL_MODE_ENABLE                0x20
+#define BLANK_CNTL_ENABLE               0x10
+#define COL_RES_6BIT                    0x0
+#define COL_RES_8BIT                    0x04
+#define PORT_SEL_VGA                    0x0
+#define PORT_SEL_VRAM                   0x01
+
+/* RGB525_MISC_CTRL_3 */
+#define SWAP_RB                         0x80
+#define SWAP_WORD_LOHI                  0x0
+#define SWAP_WORD_HILO                  0x10
+#define SWAP_NIB_HILO                   0x0
+#define SWAP_NIB_LOHI                   0x02
+
+/* RGB525_MISC_CLK_CTRL */
+#define DDOT_CLK_ENABLE                 0x0
+#define DDOT_CLK_DISABLE                0x80
+#define SCLK_ENABLE                     0x0
+#define SCLK_DISABLE                    0x40
+#define B24P_DDOT_PLL                   0x0
+#define B24P_DDOT_SCLK                  0x20
+#define DDOT_DIV_PLL_1                  0x0
+#define DDOT_DIV_PLL_2                  0x02
+#define DDOT_DIV_PLL_4                  0x04
+#define DDOT_DIV_PLL_8                  0x06
+#define DDOT_DIV_PLL_16                 0x08
+#define PLL_DISABLE                     0x0
+#define PLL_ENABLE                      0x01
+
+/* RGB525_SYNC_CTRL */
+#define DLY_CNTL_ADD                    0x0
+#define DLY_SYNC_NOADD                  0x80
+#define CSYN_INVT_DISABLE               0x0
+#define CSYN_INVT_ENABLE                0x40
+#define VSYN_INVT_DISABLE               0x0
+#define VSYN_INVT_ENABLE                0x20
+#define HSYN_INVT_DISABLE               0x0
+#define HSYN_INVT_ENABLE                0x10
+#define VSYN_CNTL_NORMAL                0x0
+#define VSYN_CNTL_HIGH                  0x04
+#define VSYN_CNTL_LOW                   0x08
+#define VSYN_CNTL_DISABLE               0x0C
+#define HSYN_CNTL_NORMAL                0x0
+#define HSYN_CNTL_HIGH                  0x01
+#define HSYN_CNTL_LOW                   0x02
+#define HSYN_CNTL_DISABLE               0x03
+
+/* RGB525_HSYNC_CTRL */
+#define HSYN_POS(n)                     (n)
+
+/* RGB525_POWER_MANAGEMENT */
+#define SCLK_PWR_NORMAL                 0x0
+#define SCLK_PWR_DISABLE                0x10
+#define DDOT_PWR_NORMAL                 0x0
+#define DDOT_PWR_DISABLE                0x08
+#define SYNC_PWR_NORMAL                 0x0
+#define SYNC_PWR_DISABLE                0x04
+#define ICLK_PWR_NORMAL                 0x0
+#define ICLK_PWR_DISABLE                0x02
+#define DAC_PWR_NORMAL                  0x0
+#define DAC_PWR_DISABLE                 0x01
+
+/* RGB525_DAC_OPERATION */
+#define SOG_DISABLE                     0x0
+#define SOG_ENABLE                      0x08
+#define BRB_NORMAL                      0x0
+#define BRB_ALWAYS                      0x04
+#define DSR_DAC_SLOW                    0x02
+#define DSR_DAC_FAST                    0x0
+#define DPE_DISABLE                     0x0
+#define DPE_ENABLE                      0x01
+
+/* RGB525_PALETTE_CTRL */
+#define SIXBIT_LINEAR_ENABLE            0x0
+#define SIXBIT_LINEAR_DISABLE           0x80
+#define PALETTE_PARITION(n)             (n)
+
+/* RGB525_PIXEL_FORMAT */
+#define PIXEL_FORMAT_4BPP               0x02
+#define PIXEL_FORMAT_8BPP               0x03
+#define PIXEL_FORMAT_16BPP              0x04
+#define PIXEL_FORMAT_24BPP              0x05
+#define PIXEL_FORMAT_32BPP              0x06
+
+/* RGB525_8BPP_CTRL */
+#define B8_DCOL_INDIRECT                0x0
+#define B8_DCOL_DIRECT                  0x01
+
+/* RGB525_16BPP_CTRL */
+#define B16_DCOL_INDIRECT               0x0
+#define B16_DCOL_DYNAMIC                0x40
+#define B16_DCOL_DIRECT                 0xC0
+#define B16_POL_FORCE_BYPASS            0x0
+#define B16_POL_FORCE_LOOKUP            0x20
+#define B16_ZIB                         0x0
+#define B16_LINEAR                      0x04
+#define B16_555                         0x0
+#define B16_565                         0x02
+#define B16_SPARSE                      0x0
+#define B16_CONTIGUOUS                  0x01
+
+/* RGB525_24BPP_CTRL */
+#define B24_DCOL_INDIRECT               0x0
+#define B24_DCOL_DIRECT                 0x01
+
+/* RGB525_32BPP_CTRL */
+#define B32_POL_FORCE_BYPASS            0x0
+#define B32_POL_FORCE_LOOKUP            0x04
+#define B32_DCOL_INDIRECT               0x0
+#define B32_DCOL_DYNAMIC                0x01
+#define B32_DCOL_DIRECT                 0x03
+
+/* RGB525_PLL_CTRL_1 */
+#define REF_SRC_REFCLK                  0x0
+#define REF_SRC_EXTCLK                  0x10
+#define PLL_EXT_FS_3_0                  0x0
+#define PLL_EXT_FS_2_0                  0x01
+#define PLL_CNTL2_3_0                   0x02
+#define PLL_CNTL2_2_0                   0x03
+
+/* RGB525_PLL_CTRL_2 */
+#define PLL_INT_FS_3_0(n)               (n)
+#define PLL_INT_FS_2_0(n)               (n)
+
+/* RGB525_PLL_REF_DIV_COUNT */
+#define REF_DIV_COUNT(n)                (n)
+
+/* RGB525_F0 - RGB525_F15 */
+#define VCO_DIV_COUNT(n)                (n)
+
+/* RGB525_PLL_REFCLK values */
+#define RGB525_PLL_REFCLK_MHz(n)        ((n)/2)
+
+/* RGB525_CURSOR_CONTROL */
+#define SMLC_PART_0                     0x0
+#define SMLC_PART_1                     0x40
+#define SMLC_PART_2                     0x80
+#define SMLC_PART_3                     0xC0
+#define PIX_ORDER_RL                    0x0
+#define PIX_ORDER_LR                    0x20
+#define LOC_READ_LAST                   0x0
+#define LOC_READ_ACTUAL                 0x10
+#define UPDT_CNTL_DELAYED               0x0
+#define UPDT_CNTL_IMMEDIATE             0x08
+#define CURSOR_SIZE_32                  0x0
+#define CURSOR_SIZE_64                  0x40
+#define CURSOR_MODE_OFF                 0x0
+#define CURSOR_MODE_3_COLOR             0x01
+#define CURSOR_MODE_2_COLOR_HL          0x02
+#define CURSOR_MODE_2_COLOR             0x03
+
+/* RGB525_REVISION_LEVEL */
+#define REVISION_LEVEL                  0xF0    /* predefined */
+
+/* RGB525_ID */
+#define ID_CODE                         0x01    /* predefined */
+
+/* MISR status */
+#define RGB525_MISR_DONE                0x01
+
+/* the IBMRGB640 is rather different from the rest of the RAMDACs,
+   so we define a completely new set of register names for it */
+#define RGB640_SER_07_00		0x02
+#define RGB640_SER_15_08		0x03
+#define RGB640_SER_23_16		0x04
+#define RGB640_SER_31_24		0x05
+#define RGB640_SER_WID_03_00		0x06
+#define RGB640_SER_WID_07_04		0x07
+#define RGB640_SER_MODE			0x08
+#define		IBM640_SER_2_1	0x00
+#define		IBM640_SER_4_1	0x01
+#define		IBM640_SER_8_1	0x02
+#define		IBM640_SER_16_1	0x03
+#define		IBM640_SER_16_3	0x05
+#define		IBM640_SER_5_1	0x06
+#define RGB640_PIXEL_INTERLEAVE		0x09
+#define RGB640_MISC_CONF		0x0a
+#define		IBM640_PCLK		0x00
+#define		IBM640_PCLK_2		0x40
+#define		IBM640_PCLK_4		0x80
+#define		IBM640_PCLK_8		0xc0
+#define		IBM640_PSIZE10		0x10
+#define		IBM640_LCI		0x08
+#define		IBM640_WIDCTL_MASK	0x07
+#define RGB640_VGA_CONTROL		0x0b
+#define 	IBM640_RDBK	0x04
+#define 	IBM640_PSIZE8	0x02
+#define		IBM640_VRAM	0x01
+#define RGB640_DAC_CONTROL		0x0d
+#define		IBM640_MONO	0x08
+#define		IBM640_DACENBL	0x04
+#define		IBM640_SHUNT	0x02
+#define		IBM640_SLOWSLEW	0x01
+#define RGB640_OUTPUT_CONTROL		0x0e
+#define		IBM640_RDAI	0x04
+#define		IBM640_WDAI	0x02
+#define		IBM640_WATCTL	0x01
+#define RGB640_SYNC_CONTROL		0x0f
+#define		IBM640_PWR	0x20
+#define		IBM640_VSP	0x10
+#define		IBM640_HSP	0x08
+#define		IBM640_CSE	0x04
+#define		IBM640_CSG	0x02
+#define		IBM640_BPE	0x01
+#define RGB640_PLL_N			0x10
+#define RGB640_PLL_M			0x11
+#define RGB640_PLL_P			0x12
+#define RGB640_PLL_CTL			0x13
+#define 	IBM640_PLL_EN	0x04
+#define		IBM640_PLL_HIGH	0x10
+#define		IBM640_PLL_LOW	0x01
+#define RGB640_AUX_PLL_CTL		0x17
+#define		IBM640_AUXPLL	0x04
+#define		IBM640_AUX_HI	0x02
+#define		IBM640_AUX_LO	0x01
+#define RGB640_CHROMA_KEY0		0x20
+#define RGB640_CHROMA_MASK0		0x21
+#define RGB640_CURS_X_LOW		0x40
+#define RGB640_CURS_X_HIGH		0x41
+#define RGB640_CURS_Y_LOW		0x42
+#define RGB640_CURS_Y_HIGH		0x43
+#define RGB640_CURS_OFFSETX		0x44
+#define RGB640_CURS_OFFSETY		0x45
+#define RGB640_CURSOR_CONTROL		0x4B
+#define		IBM640_CURS_OFF		0x00
+#define		IBM640_CURS_MODE0	0x01
+#define		IBM640_CURS_MODE1	0x02
+#define		IBM640_CURS_MODE2	0x03
+#define		IBM640_CURS_ADV		0x04
+#define RGB640_CROSSHAIR_CONTROL	0x57
+#define RGB640_VRAM_MASK0		0xf0
+#define RGB640_VRAM_MASK1		0xf1
+#define RGB640_VRAM_MASK2		0xf2
+#define RGB640_DIAGS			0xfa
+#define RGB640_CURS_WRITE		0x1000
+#define RGB640_CURS_COL0		0x4800
+#define RGB640_CURS_COL1		0x4801
+#define RGB640_CURS_COL2		0x4802
+#define RGB640_CURS_COL3		0x4803
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rgb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/rgb.h
@@ -0,0 +1,53 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef RGB_H
+#define RGB_H
+typedef struct _RGB {
+	unsigned short red, green, blue;
+	} RGB;
+#endif /* RGB_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxbyteorder.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxbyteorder.h
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright IBM Corporation 2006, 2007
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, THE AUTHORS, AND/OR THEIR SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file glxbyteorder.h
+ * Platform glue for handling byte-ordering issues in GLX protocol.
+ * 
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+#if !defined(__GLXBYTEORDER_H__)
+#define __GLXBYTEORDER_H__
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#if HAVE_BYTESWAP_H
+#include <byteswap.h>
+#elif defined(USE_SYS_ENDIAN_H)
+#include <sys/endian.h>
+#elif defined(__APPLE__)
+#include <libkern/OSByteOrder.h>
+#define bswap_16 OSSwapInt16
+#define bswap_32 OSSwapInt32
+#define bswap_64 OSSwapInt64
+#else
+#define	bswap_16(value)  \
+ 	((((value) & 0xff) << 8) | ((value) >> 8))
+
+#define	bswap_32(value)	\
+ 	(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
+ 	(uint32_t)bswap_16((uint16_t)((value) >> 16)))
+ 
+#define	bswap_64(value)	\
+ 	(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
+ 	    << 32) | \
+ 	(uint64_t)bswap_32((uint32_t)((value) >> 32)))
+#endif
+
+#endif /* !defined(__GLXBYTEORDER_H__) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaaWrapper.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaaWrapper.h
@@ -0,0 +1,10 @@
+
+#ifndef _XAA_WRAPPER_H
+# define _XAA_WRAPPER_H
+
+typedef void (*SyncFunc)(ScreenPtr);
+
+extern _X_EXPORT Bool xaaSetupWrapper(ScreenPtr pScreen,
+		     XAAInfoRecPtr infoPtr, int depth, SyncFunc *func);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinit.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinit.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2004 Red Hat Inc., Raleigh, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kem@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for initialization.  \see dmxinit.c */
+
+#ifndef DMXINIT_H
+#define DMXINIT_H
+
+#include "scrnintstr.h"
+
+extern Bool dmxOpenDisplay(DMXScreenInfo *dmxScreen);
+extern void dmxSetErrorHandler(DMXScreenInfo *dmxScreen);
+extern void dmxCheckForWM(DMXScreenInfo *dmxScreen);
+extern void dmxGetScreenAttribs(DMXScreenInfo *dmxScreen);
+extern Bool dmxGetVisualInfo(DMXScreenInfo *dmxScreen);
+extern void dmxGetColormaps(DMXScreenInfo *dmxScreen);
+extern void dmxGetPixmapFormats(DMXScreenInfo *dmxScreen);
+
+#endif /* DMXINIT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getbmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/getbmap.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETBMAP_H
+#define GETBMAP_H 1
+
+int SProcXGetDeviceButtonMapping(ClientPtr	/* client */
+    );
+
+int ProcXGetDeviceButtonMapping(ClientPtr	/* client */
+    );
+
+void SRepXGetDeviceButtonMapping(ClientPtr /* client */ ,
+				 int /* size */ ,
+				 xGetDeviceButtonMappingReply *	/* rep */
+    );
+
+#endif /* GETBMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xselinux.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xselinux.h
@@ -0,0 +1,139 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XSELINUX_H
+#define _XSELINUX_H
+
+/* Extension info */
+#define SELINUX_EXTENSION_NAME		"SELinux"
+#define SELINUX_MAJOR_VERSION		1
+#define SELINUX_MINOR_VERSION		1
+#define SELinuxNumberEvents		0
+#define SELinuxNumberErrors		0
+
+/* Extension protocol */
+#define X_SELinuxQueryVersion			0
+#define X_SELinuxSetDeviceCreateContext		1
+#define X_SELinuxGetDeviceCreateContext		2
+#define X_SELinuxSetDeviceContext		3
+#define X_SELinuxGetDeviceContext		4
+#define X_SELinuxSetDrawableCreateContext	5
+#define X_SELinuxGetDrawableCreateContext	6
+#define X_SELinuxGetDrawableContext		7
+#define X_SELinuxSetPropertyCreateContext	8
+#define X_SELinuxGetPropertyCreateContext	9
+#define X_SELinuxSetPropertyUseContext		10
+#define X_SELinuxGetPropertyUseContext		11
+#define X_SELinuxGetPropertyContext		12
+#define X_SELinuxGetPropertyDataContext		13
+#define X_SELinuxListProperties			14
+#define X_SELinuxSetSelectionCreateContext	15
+#define X_SELinuxGetSelectionCreateContext	16
+#define X_SELinuxSetSelectionUseContext		17
+#define X_SELinuxGetSelectionUseContext		18
+#define X_SELinuxGetSelectionContext		19
+#define X_SELinuxGetSelectionDataContext	20
+#define X_SELinuxListSelections			21
+#define X_SELinuxGetClientContext		22
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+    CARD8   client_major;
+    CARD8   client_minor;
+} SELinuxQueryVersionReq;
+
+typedef struct {
+    CARD8   type;
+    CARD8   pad1;
+    CARD16  sequenceNumber;
+    CARD32  length;
+    CARD16  server_major;
+    CARD16  server_minor;
+    CARD32  pad2;
+    CARD32  pad3;
+    CARD32  pad4;
+    CARD32  pad5;
+    CARD32  pad6; 
+} SELinuxQueryVersionReply;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+    CARD32  context_len;
+} SELinuxSetCreateContextReq;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+} SELinuxGetCreateContextReq;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+    CARD32  id;
+    CARD32  context_len;
+} SELinuxSetContextReq;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+    CARD32  id;
+} SELinuxGetContextReq;
+
+typedef struct {
+    CARD8   reqType;
+    CARD8   SELinuxReqType;
+    CARD16  length;
+    CARD32  window;
+    CARD32  property;
+} SELinuxGetPropertyContextReq;
+
+typedef struct {
+    CARD8   type;
+    CARD8   pad1;
+    CARD16  sequenceNumber;
+    CARD32  length;
+    CARD32  context_len;
+    CARD32  pad2;
+    CARD32  pad3;
+    CARD32  pad4;
+    CARD32  pad5;
+    CARD32  pad6;
+} SELinuxGetContextReply;
+
+typedef struct {
+    CARD8   type;
+    CARD8   pad1;
+    CARD16  sequenceNumber;
+    CARD32  length;
+    CARD32  count;
+    CARD32  pad2;
+    CARD32  pad3;
+    CARD32  pad4;
+    CARD32  pad5;
+    CARD32  pad6;
+} SELinuxListItemsReply;
+
+#endif /* _XSELINUX_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/midbe.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/midbe.h
@@ -0,0 +1,58 @@
+/******************************************************************************
+ * Copyright (c) 1994, 1995  Hewlett-Packard Company
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Hewlett-Packard
+ * Company shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Hewlett-Packard Company.
+ * 
+ *     Header file for users of machine-independent DBE code
+ *
+ *****************************************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef MIDBE_H
+#define MIDBE_H
+
+#include "privates.h"
+
+/* EXTERNS */
+
+extern Bool miDbeInit(
+    ScreenPtr           pScreen,
+    DbeScreenPrivPtr    pDbeScreenPriv
+);
+
+extern DevPrivateKeyRec dbeScreenPrivKeyRec;
+#define dbeScreenPrivKey (&dbeScreenPrivKeyRec)
+
+extern DevPrivateKeyRec dbeWindowPrivKeyRec;
+#define dbeWindowPrivKey (&dbeWindowPrivKeyRec)
+
+extern RESTYPE	dbeDrawableResType;
+extern RESTYPE	dbeWindowPrivResType;
+
+#endif /* MIDBE_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Configint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/Configint.h
@@ -0,0 +1,222 @@
+/*
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2002 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/* 
+ * These definitions are used through out the configuration file parser, but
+ * they should not be visible outside of the parser.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _Configint_h_
+#define _Configint_h_
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include "xf86Parser.h"
+
+typedef enum { PARSE_DECIMAL, PARSE_OCTAL, PARSE_HEX } ParserNumType;
+
+typedef struct
+{
+	int num;		/* returned number */
+	char *str;		/* private copy of the return-string */
+	double realnum;		/* returned number as a real */
+        ParserNumType numType;  /* used to enforce correct number formatting */
+}
+LexRec, *LexPtr;
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#include "configProcs.h"
+#include <stdlib.h>
+
+#define TestFree(a) if (a) { free (a); a = NULL; }
+
+#define parsePrologue(typeptr,typerec) typeptr ptr; \
+if( (ptr=calloc(1,sizeof(typerec))) == NULL ) { return NULL; }
+
+#define parsePrologueVoid(typeptr,typerec) int token; typeptr ptr; \
+if( (ptr=calloc(1,sizeof(typerec))) == NULL ) { return; }
+
+#define HANDLE_RETURN(f,func)\
+if ((ptr->f=func) == NULL)\
+{\
+	CLEANUP (ptr);\
+	return NULL;\
+}
+
+#define HANDLE_LIST(field,func,type)\
+{\
+type p = func ();\
+if (p == NULL)\
+{\
+	CLEANUP (ptr);\
+	return NULL;\
+}\
+else\
+{\
+	ptr->field = (type) xf86addListItem ((glp) ptr->field, (glp) p);\
+}\
+}
+
+#define Error(a,b) do { \
+			xf86parseError (a, b); CLEANUP (ptr); return NULL; \
+		   } while (0)
+
+/* 
+ * These are defines for error messages to promote consistency.
+ * error messages are preceded by the line number, section and file name,
+ * so these messages should be about the specific keyword and syntax in error.
+ * To help limit namespace polution, end each with _MSG.
+ * limit messages to 70 characters if possible.
+ */
+
+#define BAD_OPTION_MSG \
+"The Option keyword requires 1 or 2 quoted strings to follow it."
+#define INVALID_KEYWORD_MSG \
+"\"%s\" is not a valid keyword in this section."
+#define INVALID_SECTION_MSG \
+"\"%s\" is not a valid section name."
+#define UNEXPECTED_EOF_MSG \
+"Unexpected EOF. Missing EndSection keyword?"
+#define QUOTE_MSG \
+"The %s keyword requires a quoted string to follow it."
+#define NUMBER_MSG \
+"The %s keyword requires a number to follow it."
+#define POSITIVE_INT_MSG \
+"The %s keyword requires a positive integer to follow it."
+#define BOOL_MSG \
+"The %s keyword requires a boolean to follow it."
+#define ZAXISMAPPING_MSG \
+"The ZAxisMapping keyword requires 2 positive numbers or X or Y to follow it."
+#define AUTOREPEAT_MSG \
+"The AutoRepeat keyword requires 2 numbers (delay and rate) to follow it."
+#define XLEDS_MSG \
+"The XLeds keyword requries one or more numbers to follow it."
+#define DACSPEED_MSG \
+"The DacSpeed keyword must be followed by a list of up to %d numbers."
+#define DISPLAYSIZE_MSG \
+"The DisplaySize keyword must be followed by the width and height in mm."
+#define HORIZSYNC_MSG \
+"The HorizSync keyword must be followed by a list of numbers or ranges."
+#define VERTREFRESH_MSG \
+"The VertRefresh keyword must be followed by a list of numbers or ranges."
+#define VIEWPORT_MSG \
+"The Viewport keyword must be followed by an X and Y value."
+#define VIRTUAL_MSG \
+"The Virtual keyword must be followed by a width and height value."
+#define WEIGHT_MSG \
+"The Weight keyword must be followed by red, green and blue values."
+#define BLACK_MSG \
+"The Black keyword must be followed by red, green and blue values."
+#define WHITE_MSG \
+"The White keyword must be followed by red, green and blue values."
+#define SCREEN_MSG \
+"The Screen keyword must be followed by an optional number, a screen name\n" \
+"\tin quotes, and optional position/layout information."
+#define INVALID_SCR_MSG \
+"Invalid Screen line."
+#define INPUTDEV_MSG \
+"The InputDevice keyword must be followed by an input device name in quotes."
+#define INACTIVE_MSG \
+"The Inactive keyword must be followed by a Device name in quotes."
+#define UNDEFINED_SCREEN_MSG \
+"Undefined Screen \"%s\" referenced by ServerLayout \"%s\"."
+#define UNDEFINED_MODES_MSG \
+"Undefined Modes Section \"%s\" referenced by Monitor \"%s\"."
+#define UNDEFINED_DEVICE_MSG \
+"Undefined Device \"%s\" referenced by Screen \"%s\"."
+#define UNDEFINED_ADAPTOR_MSG \
+"Undefined VideoAdaptor \"%s\" referenced by Screen \"%s\"."
+#define ADAPTOR_REF_TWICE_MSG \
+"VideoAdaptor \"%s\" already referenced by Screen \"%s\"."
+#define UNDEFINED_DEVICE_LAY_MSG \
+"Undefined Device \"%s\" referenced by ServerLayout \"%s\"."
+#define UNDEFINED_INPUT_MSG \
+"Undefined InputDevice \"%s\" referenced by ServerLayout \"%s\"."
+#define NO_IDENT_MSG \
+"This section must have an Identifier line."
+#define ONLY_ONE_MSG \
+"This section must have only one of either %s line."
+#define UNDEFINED_INPUTDRIVER_MSG \
+"InputDevice section \"%s\" must have a Driver line."
+#define INVALID_GAMMA_MSG \
+"gamma correction value(s) expected\n either one value or three r/g/b values."
+#define GROUP_MSG \
+"The Group keyword must be followed by either a group name in quotes or\n" \
+"\ta numerical group id."
+#define MULTIPLE_MSG \
+"Multiple \"%s\" lines."
+#define MUST_BE_OCTAL_MSG \
+"The number \"%d\" given in this section must be in octal (0xxx) format."
+
+/* Warning messages */
+#define OBSOLETE_MSG \
+"Ignoring obsolete keyword \"%s\"."
+#define MOVED_TO_FLAGS_MSG \
+"Keyword \"%s\" is now an Option flag in the ServerFlags section."
+
+#endif /* _Configint_h_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xigetclientpointer.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xigetclientpointer.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GETCPTR_H
+#define GETCPTR_H 1
+int SProcXIGetClientPointer(ClientPtr /* client */);
+int ProcXIGetClientPointer(ClientPtr /* client */);
+void SRepXIGetClientPointer(ClientPtr /* client */,
+        int /* size */,
+        xXIGetClientPointerReply* /* rep */);
+
+#endif /* GETCPTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86InPriv.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86InPriv.h
@@ -0,0 +1,46 @@
+
+/*
+ * Copyright (c) 1999 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86InPriv_h
+#define _xf86InPriv_h
+
+/* xf86Globals.c */
+extern InputDriverPtr *xf86InputDriverList;
+extern int xf86NumInputDrivers;
+
+/* xf86Xinput.c */
+int xf86ActivateDevice(InputInfoPtr pInfo);
+
+/* xf86Helper.c */
+InputDriverPtr xf86LookupInputDriver(const char *name);
+
+#endif /* _xf86InPriv_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaalocal.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaalocal.h
@@ -0,0 +1,1755 @@
+
+#ifndef _XAALOCAL_H
+#define _XAALOCAL_H
+
+/* This file is very unorganized ! */
+
+
+#include "gcstruct.h"
+#include "regionstr.h"
+#include "xf86fbman.h"
+#include "xaa.h"
+#include "mi.h"
+#include "picturestr.h"
+
+#define GCWhenForced		(GCArcMode << 1)
+
+#define DO_COLOR_8x8		0x00000001
+#define DO_MONO_8x8		0x00000002
+#define DO_CACHE_BLT		0x00000003
+#define DO_COLOR_EXPAND		0x00000004
+#define DO_CACHE_EXPAND		0x00000005
+#define DO_IMAGE_WRITE		0x00000006
+#define DO_PIXMAP_COPY		0x00000007
+#define DO_SOLID		0x00000008
+
+
+typedef CARD32 * (*GlyphScanlineFuncPtr)(
+    CARD32 *base, unsigned int **glyphp, int line, int nglyph, int width
+);
+
+typedef CARD32 *(*StippleScanlineProcPtr)(CARD32*, CARD32*, int, int, int); 
+
+typedef void (*RectFuncPtr) (ScrnInfoPtr, int, int, int, int, int, int,
+					  XAACacheInfoPtr);
+typedef void (*TrapFuncPtr) (ScrnInfoPtr, int, int, int, int, int, int,
+					  int, int, int, int, int, int,
+					  XAACacheInfoPtr);
+
+
+
+typedef struct _XAAScreen {
+   CreateGCProcPtr 		CreateGC;
+   CloseScreenProcPtr 		CloseScreen;
+   GetImageProcPtr 		GetImage;
+   GetSpansProcPtr 		GetSpans;
+   CopyWindowProcPtr 		CopyWindow;
+   WindowExposuresProcPtr	WindowExposures;
+   CreatePixmapProcPtr 		CreatePixmap;
+   DestroyPixmapProcPtr 	DestroyPixmap;
+   ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+   XAAInfoRecPtr 		AccelInfoRec;
+   Bool                		(*EnterVT)(int, int);
+   void                		(*LeaveVT)(int, int);
+   int				(*SetDGAMode)(int, int, DGADevicePtr);
+   void				(*EnableDisableFBAccess)(int, Bool);
+    CompositeProcPtr            Composite;
+    GlyphsProcPtr               Glyphs;
+} XAAScreenRec, *XAAScreenPtr;
+
+#define	OPS_ARE_PIXMAP		0x00000001
+#define OPS_ARE_ACCEL		0x00000002
+
+typedef struct _XAAGC {
+    GCOps 	*wrapOps;
+    GCFuncs 	*wrapFuncs;
+    GCOps 	*XAAOps;
+    int		DashLength;
+    unsigned char* DashPattern;
+    unsigned long changes;
+    unsigned long flags;
+} XAAGCRec, *XAAGCPtr;
+
+#define REDUCIBILITY_CHECKED	0x00000001
+#define REDUCIBLE_TO_8x8	0x00000002
+#define REDUCIBLE_TO_2_COLOR	0x00000004
+#define DIRTY			0x00010000
+#define OFFSCREEN		0x00020000
+#define DGA_PIXMAP		0x00040000
+#define SHARED_PIXMAP		0x00080000
+#define LOCKED_PIXMAP		0x00100000
+
+#define REDUCIBILITY_MASK \
+ (REDUCIBILITY_CHECKED | REDUCIBLE_TO_8x8 | REDUCIBLE_TO_2_COLOR)
+
+typedef struct _XAAPixmap {
+    unsigned long flags;
+    CARD32 pattern0;
+    CARD32 pattern1;
+    int fg;
+    int bg;    
+    FBAreaPtr offscreenArea;
+    Bool freeData;
+} XAAPixmapRec, *XAAPixmapPtr;
+
+
+extern _X_EXPORT Bool
+XAACreateGC(
+    GCPtr pGC
+);
+
+extern _X_EXPORT Bool
+XAAInitAccel(
+    ScreenPtr pScreen, 
+    XAAInfoRecPtr infoRec
+);
+
+extern _X_EXPORT RegionPtr
+XAABitBlt(
+    DrawablePtr pSrcDrawable,
+    DrawablePtr pDstDrawable,
+    GC *pGC,
+    int srcx,
+    int srcy,
+    int width,
+    int height,
+    int dstx,
+    int dsty,
+    void (*doBitBlt)(DrawablePtr, DrawablePtr, GCPtr, RegionPtr, DDXPointPtr),
+    unsigned long bitPlane
+);
+
+extern _X_EXPORT void
+XAAScreenToScreenBitBlt(
+    ScrnInfoPtr pScrn,
+    int nbox,
+    DDXPointPtr pptSrc,
+    BoxPtr pbox,
+    int xdir, 
+    int ydir,
+    int alu,
+    unsigned int planemask
+);
+
+extern _X_EXPORT void
+XAADoBitBlt(
+    DrawablePtr	    pSrc, 
+    DrawablePtr     pDst,
+    GC		    *pGC,
+    RegionPtr	    prgnDst,
+    DDXPointPtr	    pptSrc
+);
+
+extern _X_EXPORT void
+XAADoImageWrite(
+    DrawablePtr	    pSrc, 
+    DrawablePtr     pDst,
+    GC		    *pGC,
+    RegionPtr	    prgnDst,
+    DDXPointPtr	    pptSrc
+);
+
+extern _X_EXPORT void
+XAADoImageRead(
+    DrawablePtr     pSrc,
+    DrawablePtr     pDst,
+    GC              *pGC,
+    RegionPtr       prgnDst,
+    DDXPointPtr     pptSrc
+);
+
+extern _X_EXPORT void
+XAACopyWindow(
+    WindowPtr pWin,
+    DDXPointRec ptOldOrg,
+    RegionPtr prgnSrc
+);
+
+
+extern _X_EXPORT RegionPtr
+XAACopyArea(
+    DrawablePtr pSrcDrawable,
+    DrawablePtr pDstDrawable,
+    GC *pGC,
+    int srcx, 
+    int srcy,
+    int width, 
+    int height,
+    int dstx, 
+    int dsty
+);
+
+extern _X_EXPORT void
+XAAValidateCopyArea(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidatePutImage(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw 
+);
+
+extern _X_EXPORT void
+XAAValidateCopyPlane(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidatePushPixels(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidateFillSpans(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidatePolyGlyphBlt(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidateImageGlyphBlt(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+extern _X_EXPORT void
+XAAValidatePolylines(
+   GCPtr         pGC,
+   unsigned long changes,
+   DrawablePtr   pDraw
+);
+
+
+extern _X_EXPORT RegionPtr
+XAACopyPlaneColorExpansion(
+    DrawablePtr		pSrc,
+    DrawablePtr		pDst,
+    GCPtr		pGC,
+    int			srcx, 
+    int			srcy,
+    int			width, 
+    int			height,
+    int			dstx, 
+    int			dsty,
+    unsigned long	bitPlane
+);
+
+
+extern _X_EXPORT void
+XAAPushPixelsSolidColorExpansion(
+    GCPtr	pGC,
+    PixmapPtr	pBitMap,
+    DrawablePtr pDrawable,
+    int		dx, 
+    int		dy, 
+    int		xOrg, 
+    int		yOrg
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpandMSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpand3MSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpandMSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpand3MSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpandLSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpand3LSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpandLSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapColorExpand3LSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpandMSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpand3MSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpandMSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpand3MSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpandLSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpand3LSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpandLSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapScanlineColorExpand3LSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h,
+    unsigned char *src,
+    int srcwidth,
+    int skipleft,
+    int fg, int bg,
+    int rop,
+    unsigned int planemask 
+);
+
+extern _X_EXPORT void
+XAAWritePixmap (
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int rop,
+   unsigned int planemask,
+   int transparency_color,
+   int bpp, int depth
+);
+
+extern _X_EXPORT void
+XAAWritePixmapScanline (
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int rop,
+   unsigned int planemask,
+   int transparency_color,
+   int bpp, int depth
+);
+
+typedef void (*ClipAndRenderRectsFunc)(GCPtr, int, BoxPtr, int, int); 
+
+
+extern _X_EXPORT void
+XAAClipAndRenderRects(
+   GCPtr pGC, 
+   ClipAndRenderRectsFunc func, 
+   int nrectFill, 
+   xRectangle *prectInit, 
+   int xorg, int yorg
+);
+
+
+typedef void (*ClipAndRenderSpansFunc)(GCPtr, int, DDXPointPtr, int*, 
+							int, int, int);
+
+extern _X_EXPORT void
+XAAClipAndRenderSpans(
+    GCPtr pGC, 
+    DDXPointPtr	ppt,
+    int		*pwidth,
+    int		nspans,
+    int		fSorted,
+    ClipAndRenderSpansFunc func,
+    int 	xorg,
+    int		yorg
+);
+
+
+extern _X_EXPORT void
+XAAFillSolidRects(
+    ScrnInfoPtr pScrn,
+    int fg, int rop,
+    unsigned int planemask,
+    int		nBox,
+    BoxPtr	pBox 
+);
+
+extern _X_EXPORT void
+XAAFillMono8x8PatternRects(
+    ScrnInfoPtr pScrn,
+    int	fg, int bg, int rop,
+    unsigned int planemask,
+    int	nBox,
+    BoxPtr pBox,
+    int pat0, int pat1,
+    int xorg, int yorg
+);
+
+extern _X_EXPORT void
+XAAFillMono8x8PatternRectsScreenOrigin(
+    ScrnInfoPtr pScrn,
+    int	fg, int bg, int rop,
+    unsigned int planemask,
+    int	nBox,
+    BoxPtr pBox,
+    int pat0, int pat1,
+    int xorg, int yorg
+);
+
+
+extern _X_EXPORT void
+XAAFillColor8x8PatternRectsScreenOrigin(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorigin, int yorigin,
+   XAACacheInfoPtr pCache
+);
+
+extern _X_EXPORT void
+XAAFillColor8x8PatternRects(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorigin, int yorigin,
+   XAACacheInfoPtr pCache
+);
+
+extern _X_EXPORT void
+XAAFillCacheBltRects(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   XAACacheInfoPtr pCache
+);
+
+extern _X_EXPORT void
+XAAFillCacheExpandRects(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillImageWriteRects(
+    ScrnInfoPtr pScrn,
+    int rop,
+    unsigned int planemask,
+    int nBox,
+    BoxPtr pBox,
+    int xorg, int yorg,
+    PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAPolyFillRect(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	nrectFill,
+    xRectangle *prectInit
+);
+
+
+extern _X_EXPORT void
+XAATEGlyphRendererMSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRenderer3MSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererMSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRenderer3MSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererLSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+
+extern _X_EXPORT void
+XAATEGlyphRenderer3LSBFirstFixedBase (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererLSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRenderer3LSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+
+extern _X_EXPORT void
+XAATEGlyphRendererScanlineMSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererScanline3MSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererScanlineLSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+extern _X_EXPORT void
+XAATEGlyphRendererScanline3LSBFirst (
+    ScrnInfoPtr pScrn,
+    int x, int y, int w, int h, int skipleft, int startline, 
+    unsigned int **glyphs, int glyphWidth,
+    int fg, int bg, int rop, unsigned planemask
+);
+
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncMSBFirstFixedBase[32])(
+   CARD32 *base, unsigned int **glyphp, int line, int nglyph, int width
+);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncMSBFirst[32])(
+   CARD32 *base, unsigned int **glyphp, int line, int nglyph, int width
+);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncLSBFirstFixedBase[32])(
+   CARD32 *base, unsigned int **glyphp, int line, int nglyph, int width
+);
+
+extern _X_EXPORT CARD32 *(*XAAGlyphScanlineFuncLSBFirst[32])(
+   CARD32 *base, unsigned int **glyphp, int line, int nglyph, int width
+);
+
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncMSBFirstFixedBase(void);
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncMSBFirst(void);
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncLSBFirstFixedBase(void);
+extern _X_EXPORT GlyphScanlineFuncPtr *XAAGetGlyphScanlineFuncLSBFirst(void);
+
+extern _X_EXPORT void
+XAAFillColorExpandRectsLSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRects3LSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRectsLSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRects3LSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRectsMSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRects3MSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRectsMSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandRects3MSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandRectsLSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandRects3LSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandRectsMSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandRects3MSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int nBox,
+   BoxPtr pBox,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpansLSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpans3LSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpansLSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpans3LSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpansMSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpans3MSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpansMSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillColorExpandSpans3MSBFirstFixedBase(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandSpansLSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandSpans3LSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAPutImage(
+    DrawablePtr pDraw,
+    GCPtr       pGC,
+    int         depth, 
+    int 	x, 
+    int		y, 
+    int		w, 
+    int		h,
+    int         leftPad,
+    int         format,
+    char        *pImage
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandSpansMSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillScanlineColorExpandSpans3MSBFirst(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncMSBFirstFixedBase[6])(
+   CARD32* base, CARD32* src, int offset, int width, int dwords
+);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncMSBFirst[6])(
+   CARD32* base, CARD32* src, int offset, int width, int dwords
+);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncLSBFirstFixedBase[6])(
+   CARD32* base, CARD32* src, int offset, int width, int dwords
+);
+
+extern _X_EXPORT CARD32 *(*XAAStippleScanlineFuncLSBFirst[6])(
+   CARD32* base, CARD32* src, int offset, int width, int dwords
+);
+
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFuncMSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFuncMSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFuncLSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFuncLSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFunc3MSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFunc3MSBFirst(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFunc3LSBFirstFixedBase(void);
+extern _X_EXPORT StippleScanlineProcPtr *XAAGetStippleScanlineFunc3LSBFirst(void);
+
+extern _X_EXPORT int
+XAAPolyText8TEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    char *chars
+);
+
+extern _X_EXPORT int
+XAAPolyText16TEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    unsigned short *chars
+);
+
+extern _X_EXPORT void
+XAAImageText8TEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    char *chars
+);
+
+extern _X_EXPORT void
+XAAImageText16TEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    unsigned short *chars
+);
+
+extern _X_EXPORT void
+XAAImageGlyphBltTEColorExpansion(
+    DrawablePtr pDrawable,
+    GCPtr pGC,
+    int xInit, int yInit,
+    unsigned int nglyph,
+    CharInfoPtr *ppci,
+    pointer pglyphBase
+);
+
+extern _X_EXPORT void
+XAAPolyGlyphBltTEColorExpansion(
+    DrawablePtr pDrawable,
+    GCPtr pGC,
+    int xInit, int yInit,
+    unsigned int nglyph,
+    CharInfoPtr *ppci,
+    pointer pglyphBase
+);
+
+
+extern _X_EXPORT int
+XAAPolyText8NonTEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    char *chars
+);
+
+extern _X_EXPORT int
+XAAPolyText16NonTEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    unsigned short *chars
+);
+
+extern _X_EXPORT void
+XAAImageText8NonTEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    char *chars
+);
+
+extern _X_EXPORT void
+XAAImageText16NonTEColorExpansion(
+    DrawablePtr pDraw,
+    GCPtr pGC,
+    int	x, int y,
+    int count,
+    unsigned short *chars
+);
+
+extern _X_EXPORT void
+XAAImageGlyphBltNonTEColorExpansion(
+    DrawablePtr pDrawable,
+    GCPtr pGC,
+    int xInit, int yInit,
+    unsigned int nglyph,
+    CharInfoPtr *ppci,
+    pointer pglyphBase
+);
+
+extern _X_EXPORT void
+XAAPolyGlyphBltNonTEColorExpansion(
+    DrawablePtr pDrawable,
+    GCPtr pGC,
+    int xInit, int yInit,
+    unsigned int nglyph,
+    CharInfoPtr *ppci,
+    pointer pglyphBase
+);
+
+
+extern _X_EXPORT void XAANonTEGlyphRenderer(
+   ScrnInfoPtr pScrn,
+   int x, int y, int n,
+   NonTEGlyphPtr glyphs,
+   BoxPtr pbox,
+   int fg, int rop,
+   unsigned int planemask
+);
+
+extern _X_EXPORT void
+XAAFillSolidSpans(
+   ScrnInfoPtr pScrn,
+   int fg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth, int fSorted 
+);
+
+extern _X_EXPORT void
+XAAFillMono8x8PatternSpans(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth, int fSorted,
+   int patx, int paty,
+   int xorg, int yorg 
+);
+
+extern _X_EXPORT void
+XAAFillMono8x8PatternSpansScreenOrigin(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth, int fSorted,
+   int patx, int paty,
+   int xorg, int yorg 
+);
+
+extern _X_EXPORT void
+XAAFillColor8x8PatternSpansScreenOrigin(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth, int fSorted,
+   XAACacheInfoPtr,
+   int xorigin, int yorigin 
+);
+
+extern _X_EXPORT void
+XAAFillColor8x8PatternSpans(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth, int fSorted,
+   XAACacheInfoPtr,
+   int xorigin, int yorigin 
+);
+
+extern _X_EXPORT void
+XAAFillCacheBltSpans(
+   ScrnInfoPtr pScrn,
+   int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr points,
+   int *widths,
+   int fSorted,
+   XAACacheInfoPtr pCache,
+   int xorg, int yorg
+);
+
+extern _X_EXPORT void
+XAAFillCacheExpandSpans(
+   ScrnInfoPtr pScrn,
+   int fg, int bg, int rop,
+   unsigned int planemask,
+   int n,
+   DDXPointPtr ppt,
+   int *pwidth,
+   int fSorted,
+   int xorg, int yorg,
+   PixmapPtr pPix
+);
+
+extern _X_EXPORT void
+XAAFillSpans(
+    DrawablePtr pDrawable,
+    GC		*pGC,
+    int		nInit,
+    DDXPointPtr pptInit,
+    int *pwidth,
+    int fSorted 
+);
+
+
+extern _X_EXPORT void
+XAAInitPixmapCache(
+    ScreenPtr pScreen, 
+    RegionPtr areas,
+    pointer data
+);
+
+extern _X_EXPORT void
+XAAWriteBitmapToCache(
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int fg, int bg
+);
+ 
+extern _X_EXPORT void
+XAAWriteBitmapToCacheLinear(
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int fg, int bg
+);
+
+extern _X_EXPORT void
+XAAWritePixmapToCache(
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int bpp, int depth
+);
+
+extern _X_EXPORT void
+XAAWritePixmapToCacheLinear(
+   ScrnInfoPtr pScrn,
+   int x, int y, int w, int h,
+   unsigned char *src,
+   int srcwidth,
+   int bpp, int depth
+);
+
+extern _X_EXPORT void
+XAASolidHorVertLineAsRects(
+   ScrnInfoPtr pScrn,
+   int x, int y, int len, int dir
+);
+
+extern _X_EXPORT void
+XAASolidHorVertLineAsTwoPoint(
+   ScrnInfoPtr pScrn,
+   int x, int y, int len, int dir
+);
+
+extern _X_EXPORT void
+XAASolidHorVertLineAsBresenham(
+   ScrnInfoPtr pScrn,
+   int x, int y, int len, int dir
+);
+
+
+extern _X_EXPORT void
+XAAPolyRectangleThinSolid(
+    DrawablePtr  pDrawable,
+    GCPtr        pGC,    
+    int	         nRectsInit,
+    xRectangle  *pRectsInit 
+);
+
+
+extern _X_EXPORT void
+XAAPolylinesWideSolid (
+   DrawablePtr	pDrawable,
+   GCPtr	pGC,
+   int		mode,
+   int 		npt,
+   DDXPointPtr	pPts
+);
+
+extern _X_EXPORT void
+XAAFillPolygonSolid(
+    DrawablePtr	pDrawable,
+    GCPtr	pGC,
+    int		shape,
+    int		mode,
+    int		count,
+    DDXPointPtr	ptsIn 
+);
+
+extern _X_EXPORT void
+XAAFillPolygonStippled(
+    DrawablePtr	pDrawable,
+    GCPtr	pGC,
+    int		shape,
+    int		mode,
+    int		count,
+    DDXPointPtr	ptsIn 
+);
+
+
+extern _X_EXPORT void
+XAAFillPolygonTiled(
+    DrawablePtr	pDrawable,
+    GCPtr	pGC,
+    int		shape,
+    int		mode,
+    int		count,
+    DDXPointPtr	ptsIn 
+);
+
+
+extern _X_EXPORT int
+XAAIsEasyPolygon(
+   DDXPointPtr ptsIn,
+   int count, 
+   BoxPtr extents,
+   int origin,		
+   DDXPointPtr *topPoint, 
+   int *topY, int *bottomY,
+   int shape
+);
+
+extern _X_EXPORT void
+XAAFillPolygonHelper(
+    ScrnInfoPtr pScrn,
+    DDXPointPtr	ptsIn,
+    int 	count,
+    DDXPointPtr topPoint,
+    int 	y,
+    int		maxy,
+    int		origin,
+    RectFuncPtr RectFunc,
+    TrapFuncPtr TrapFunc,
+    int 	xorg,
+    int		yorg,
+    XAACacheInfoPtr pCache
+);
+
+extern _X_EXPORT void
+XAAPolySegment(
+    DrawablePtr	pDrawable,
+    GCPtr	pGC,
+    int		nseg,
+    xSegment	*pSeg
+);
+
+extern _X_EXPORT void
+XAAPolyLines(
+    DrawablePtr pDrawable,
+    GCPtr	pGC,
+    int		mode,
+    int		npt,
+    DDXPointPtr pptInit
+);
+
+extern _X_EXPORT void
+XAAPolySegmentDashed(
+    DrawablePtr	pDrawable,
+    GCPtr	pGC,
+    int		nseg,
+    xSegment	*pSeg
+);
+
+extern _X_EXPORT void
+XAAPolyLinesDashed(
+    DrawablePtr pDrawable,
+    GCPtr	pGC,
+    int		mode,
+    int		npt,
+    DDXPointPtr pptInit
+);
+
+
+extern _X_EXPORT void
+XAAWriteMono8x8PatternToCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache);
+
+extern _X_EXPORT void
+XAAWriteColor8x8PatternToCache(
+   ScrnInfoPtr pScrn, 
+   PixmapPtr pPix, 
+   XAACacheInfoPtr pCache
+);
+
+extern _X_EXPORT void
+XAARotateMonoPattern(
+    int *pat0, int *pat1,
+    int xoffset, int yoffset,
+    Bool msbfirst
+);
+
+extern _X_EXPORT void XAAComputeDash(GCPtr pGC);
+
+extern _X_EXPORT void XAAMoveDWORDS_FixedBase(
+   register CARD32* dest,
+   register CARD32* src,
+   register int dwords 
+);
+
+extern _X_EXPORT void XAAMoveDWORDS_FixedSrc(
+   register CARD32* dest,
+   register CARD32* src,
+   register int dwords 
+);
+
+extern _X_EXPORT void XAAMoveDWORDS(
+   register CARD32* dest,
+   register CARD32* src,
+   register int dwords 
+);
+
+extern _X_EXPORT int
+XAAGetRectClipBoxes(
+    GCPtr pGC,
+    BoxPtr pboxClippedBase,
+    int nrectFill,
+    xRectangle *prectInit
+);
+
+extern _X_EXPORT void
+XAASetupOverlay8_32Planar(ScreenPtr);
+
+extern _X_EXPORT void
+XAAPolyFillArcSolid(DrawablePtr pDraw, GCPtr pGC, int narcs, xArc *parcs);
+ 
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheTile(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheMonoStipple(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACachePlanarMonoStipple(ScrnInfoPtr Scrn, PixmapPtr pPix);
+
+typedef XAACacheInfoPtr (*XAACachePlanarMonoStippleProc)(ScrnInfoPtr, PixmapPtr);
+extern _X_EXPORT XAACachePlanarMonoStippleProc XAAGetCachePlanarMonoStipple(void);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheStipple(ScrnInfoPtr Scrn, PixmapPtr pPix, int fg, int bg);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheMono8x8Pattern(ScrnInfoPtr Scrn, int pat0, int pat1);
+
+extern _X_EXPORT XAACacheInfoPtr
+XAACacheColor8x8Pattern(ScrnInfoPtr Scrn, PixmapPtr pPix, int fg, int bg);
+
+extern _X_EXPORT void
+XAATileCache(ScrnInfoPtr pScrn, XAACacheInfoPtr pCache, int w, int h);
+ 
+extern _X_EXPORT void XAAClosePixmapCache(ScreenPtr pScreen);
+void XAAInvalidatePixmapCache(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool XAACheckStippleReducibility(PixmapPtr pPixmap);
+extern _X_EXPORT Bool XAACheckTileReducibility(PixmapPtr pPixmap, Bool checkMono);
+
+extern _X_EXPORT int XAAStippledFillChooser(GCPtr pGC);
+extern _X_EXPORT int XAAOpaqueStippledFillChooser(GCPtr pGC);
+extern _X_EXPORT int XAATiledFillChooser(GCPtr pGC);
+
+extern _X_EXPORT void XAAMoveInOffscreenPixmaps(ScreenPtr pScreen);
+extern _X_EXPORT void XAAMoveOutOffscreenPixmaps(ScreenPtr pScreen);
+extern _X_EXPORT void XAARemoveAreaCallback(FBAreaPtr area);
+extern _X_EXPORT void XAAMoveOutOffscreenPixmap(PixmapPtr pPix);
+extern _X_EXPORT Bool XAAInitStateWrap(ScreenPtr pScreen, XAAInfoRecPtr infoRec);
+
+extern _X_EXPORT void
+XAAComposite (CARD8      op,
+	      PicturePtr pSrc,
+	      PicturePtr pMask,
+	      PicturePtr pDst,
+	      INT16      xSrc,
+	      INT16      ySrc,
+	      INT16      xMask,
+	      INT16      yMask,
+	      INT16      xDst,
+	      INT16      yDst,
+	      CARD16     width,
+	      CARD16     height);
+
+
+extern _X_EXPORT Bool
+XAADoComposite (CARD8      op,
+              PicturePtr pSrc,
+              PicturePtr pMask,
+              PicturePtr pDst,
+              INT16      xSrc,
+              INT16      ySrc,
+              INT16      xMask,
+              INT16      yMask,
+              INT16      xDst,
+              INT16      yDst,
+              CARD16     width,
+              CARD16     height);
+
+
+extern _X_EXPORT void
+XAAGlyphs (CARD8         op,
+	   PicturePtr    pSrc,
+	   PicturePtr    pDst,
+	   PictFormatPtr maskFormat,
+	   INT16         xSrc,
+	   INT16         ySrc,
+	   int           nlist,
+	   GlyphListPtr  list,
+	   GlyphPtr      *glyphs);
+
+extern _X_EXPORT Bool
+XAADoGlyphs (CARD8         op,
+           PicturePtr    pSrc,
+           PicturePtr    pDst,
+           PictFormatPtr maskFormat,
+           INT16         xSrc,
+           INT16         ySrc,
+           int           nlist,
+           GlyphListPtr  list,
+           GlyphPtr      *glyphs);
+
+
+
+/* helpers */
+extern _X_EXPORT void
+XAA_888_plus_PICT_a8_to_8888 (
+    CARD32 color,
+    CARD8  *alphaPtr,   /* in bytes */
+    int    alphaPitch,
+    CARD32  *dstPtr,
+    int    dstPitch,	/* in dwords */
+    int    width,
+    int    height
+);
+
+extern _X_EXPORT Bool
+XAAGetRGBAFromPixel(
+    CARD32 pixel,
+    CARD16 *red,
+    CARD16 *green,
+    CARD16 *blue,
+    CARD16 *alpha,
+    CARD32 format
+);
+
+
+extern _X_EXPORT Bool
+XAAGetPixelFromRGBA (
+    CARD32 *pixel,
+    CARD16 red,
+    CARD16 green,
+    CARD16 blue,
+    CARD16 alpha,
+    CARD32 format
+);
+
+/* XXX should be static */
+extern _X_EXPORT GCOps XAAFallbackOps;
+extern _X_EXPORT GCOps *XAAGetFallbackOps(void);
+extern _X_EXPORT GCFuncs XAAGCFuncs;
+extern _X_EXPORT DevPrivateKey XAAGetScreenKey(void);
+extern _X_EXPORT DevPrivateKey XAAGetGCKey(void);
+extern _X_EXPORT DevPrivateKey XAAGetPixmapKey(void);
+
+extern _X_EXPORT unsigned int XAAShiftMasks[32];
+
+extern _X_EXPORT unsigned int byte_expand3[256], byte_reversed_expand3[256];
+
+extern _X_EXPORT CARD32 XAAReverseBitOrder(CARD32 data);
+
+#define GET_XAASCREENPTR_FROM_SCREEN(pScreen)\
+    dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey())
+
+#define GET_XAASCREENPTR_FROM_GC(pGC)\
+    dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey())
+
+#define GET_XAASCREENPTR_FROM_DRAWABLE(pDraw)\
+    dixLookupPrivate(&(pDraw)->pScreen->devPrivates, XAAGetScreenKey())
+
+#define GET_XAAINFORECPTR_FROM_SCREEN(pScreen)\
+((XAAScreenPtr)dixLookupPrivate(&(pScreen)->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_GC(pGC)\
+((XAAScreenPtr)dixLookupPrivate(&(pGC)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_DRAWABLE(pDraw)\
+((XAAScreenPtr)dixLookupPrivate(&(pDraw)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define GET_XAAINFORECPTR_FROM_SCRNINFOPTR(pScrn)\
+((XAAScreenPtr)dixLookupPrivate(&(pScrn)->pScreen->devPrivates, XAAGetScreenKey()))->AccelInfoRec
+
+#define XAA_GET_PIXMAP_PRIVATE(pix)\
+    (XAAPixmapPtr)dixLookupPrivate(&(pix)->devPrivates, XAAGetPixmapKey())
+
+#define CHECK_RGB_EQUAL(c) (!((((c) >> 8) ^ (c)) & 0xffff))
+
+#define CHECK_FG(pGC, flags) \
+	(!(flags & RGB_EQUAL) || CHECK_RGB_EQUAL(pGC->fgPixel))
+
+#define CHECK_BG(pGC, flags) \
+	(!(flags & RGB_EQUAL) || CHECK_RGB_EQUAL(pGC->bgPixel))
+
+#define CHECK_ROP(pGC, flags) \
+	(!(flags & GXCOPY_ONLY) || (pGC->alu == GXcopy))
+
+#define CHECK_ROPSRC(pGC, flags) \
+	(!(flags & ROP_NEEDS_SOURCE) || ((pGC->alu != GXclear) && \
+	(pGC->alu != GXnoop) && (pGC->alu != GXinvert) && \
+	(pGC->alu != GXset)))
+
+#define CHECK_PLANEMASK(pGC, flags) \
+	(!(flags & NO_PLANEMASK) || \
+	((pGC->planemask & infoRec->FullPlanemasks[pGC->depth - 1]) == \
+          infoRec->FullPlanemasks[pGC->depth - 1]))
+
+#define CHECK_COLORS(pGC, flags) \
+	(!(flags & RGB_EQUAL) || \
+	(CHECK_RGB_EQUAL(pGC->fgPixel) && CHECK_RGB_EQUAL(pGC->bgPixel)))
+
+#define CHECK_NO_GXCOPY(pGC, flags) \
+	((pGC->alu != GXcopy) || !(flags & NO_GXCOPY) || \
+	((pGC->planemask & infoRec->FullPlanemask) != infoRec->FullPlanemask))
+
+#define IS_OFFSCREEN_PIXMAP(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->offscreenArea)	
+
+#define PIXMAP_IS_SHARED(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->flags & SHARED_PIXMAP)
+
+#define OFFSCREEN_PIXMAP_LOCKED(pPix)\
+        ((XAA_GET_PIXMAP_PRIVATE((PixmapPtr)(pPix)))->flags & LOCKED_PIXMAP)
+
+#define XAA_DEPTH_BUG(pGC) \
+        ((pGC->depth == 32) && (pGC->bgPixel == 0xffffffff))
+
+#define DELIST_OFFSCREEN_PIXMAP(pPix) { \
+	PixmapLinkPtr _pLink, _prev; \
+	_pLink = infoRec->OffscreenPixmaps; \
+	_prev = NULL; \
+	while(_pLink) { \
+	    if(_pLink->pPix == pPix) { \
+		if(_prev) _prev->next = _pLink->next; \
+		else infoRec->OffscreenPixmaps = _pLink->next; \
+		free(_pLink); \
+		break; \
+	    } \
+	    _prev = _pLink; \
+	    _pLink = _pLink->next; \
+        }}
+	
+
+#define SWAP_BITS_IN_BYTES(v) \
+ (((0x01010101 & (v)) << 7) | ((0x02020202 & (v)) << 5) | \
+  ((0x04040404 & (v)) << 3) | ((0x08080808 & (v)) << 1) | \
+  ((0x10101010 & (v)) >> 1) | ((0x20202020 & (v)) >> 3) | \
+  ((0x40404040 & (v)) >> 5) | ((0x80808080 & (v)) >> 7))
+
+/*
+ * Moved XAAPixmapCachePrivate here from xaaPCache.c, since driver
+ * replacements for CacheMonoStipple need access to it
+ */
+
+typedef struct {
+   int Num512x512;
+   int Current512;
+   XAACacheInfoPtr Info512;
+   int Num256x256;
+   int Current256;
+   XAACacheInfoPtr Info256;
+   int Num128x128;
+   int Current128;
+   XAACacheInfoPtr Info128;
+   int NumMono;
+   int CurrentMono;
+   XAACacheInfoPtr InfoMono;
+   int NumColor;
+   int CurrentColor;
+   XAACacheInfoPtr InfoColor;
+   int NumPartial;
+   int CurrentPartial;
+   XAACacheInfoPtr InfoPartial;
+   DDXPointRec MonoOffsets[64];
+   DDXPointRec ColorOffsets[64];
+} XAAPixmapCachePrivate, *XAAPixmapCachePrivatePtr;
+
+
+#endif /* _XAALOCAL_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxclient.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxclient.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 1995  X Consortium
+ * Copyright 2004 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT, THE X CONSORTIUM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the X Consortium
+ * shall not be used in advertising or otherwise to promote the sale,
+ * use or other dealings in this Software without prior written
+ * authorization from the X Consortium.
+ */
+
+/*
+ * Derived from hw/xnest/Xnest.h by Rickard E. (Rik) Faith <faith@redhat.com>
+ */
+
+/** \file
+ * This file includes all client-side include files with proper wrapping.
+ */
+
+#ifndef _DMXCLIENT_H_
+#define _DMXCLIENT_H_
+
+#define GC XlibGC
+
+#ifdef _XSERVER64
+#define DMX64
+#undef _XSERVER64
+typedef unsigned long XID64;
+typedef unsigned long Mask64;
+typedef unsigned long Atom64;
+typedef unsigned long VisualID64;
+typedef unsigned long Time64;
+#define XID           XID64
+#define Mask          Mask64
+#define Atom          Atom64
+#define VisualID      VisualID64
+#define Time          Time64
+typedef XID           Window64;
+typedef XID           Drawable64;
+typedef XID           Font64;
+typedef XID           Pixmap64;
+typedef XID           Cursor64;
+typedef XID           Colormap64;
+typedef XID           GContext64;
+typedef XID           KeySym64;
+#define Window        Window64
+#define Drawable      Drawable64
+#define Font          Font64
+#define Pixmap        Pixmap64
+#define Cursor        Cursor64
+#define Colormap      Colormap64
+#define GContext      GContext64
+#define KeySym        KeySym64
+#endif
+
+#include <X11/Xlib.h>
+#include <X11/Xlibint.h>        /* For _XExtension */
+#include <X11/X.h>              /* from glxserver.h */
+#include <X11/Xmd.h>            /* from glxserver.h */
+#include <X11/Xproto.h>
+#include <X11/Xutil.h>
+#include <X11/Xatom.h>
+#include <X11/cursorfont.h>
+#include <X11/Xmu/SysUtil.h>    /* For XmuSnprintf */
+
+#include <X11/extensions/shape.h>
+
+#include <X11/extensions/Xrender.h>
+#undef PictFormatType
+
+#include <X11/extensions/XKB.h>
+#include "xkbstr.h"
+
+#include <X11/extensions/XI.h>
+
+/* Always include these, since we query them even if we don't export XINPUT. */
+#include <X11/extensions/XInput.h> /* For XDevice */
+#include <X11/extensions/Xext.h>
+
+#undef GC
+
+#ifdef DMX64
+#define _XSERVER64
+#undef XID
+#undef Mask
+#undef Atom
+#undef VisualID
+#undef Time
+#undef Window
+#undef Drawable
+#undef Font
+#undef Pixmap
+#undef Cursor
+#undef Colormap
+#undef GContext
+#undef KeySym
+#endif
+
+/* These are in exglobals.h, but that conflicts with xkbsrv.h */
+extern int ProximityIn;
+extern int ProximityOut;
+extern int DeviceValuator;
+extern int DeviceMotionNotify;
+extern int DeviceFocusIn;
+extern int DeviceFocusOut;
+extern int DeviceStateNotify;
+extern int DeviceMappingNotify;
+extern int ChangeDeviceNotify;
+
+/* Some protocol gets included last, after undefines. */
+#include <X11/XKBlib.h>
+#include <X11/extensions/XKBproto.h>
+#include "xkbstr.h"
+#undef XPointer
+#include <X11/extensions/XIproto.h>
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/inputstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/inputstr.h
@@ -0,0 +1,614 @@
+/************************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+********************************************************/
+
+
+#ifndef INPUTSTRUCT_H
+#define INPUTSTRUCT_H
+
+#include <pixman.h>
+#include "input.h"
+#include "window.h"
+#include "dixstruct.h"
+#include "cursorstr.h"
+#include "geext.h"
+#include "privates.h"
+
+#define BitIsOn(ptr, bit) (((BYTE *) (ptr))[(bit)>>3] & (1 << ((bit) & 7)))
+#define SetBit(ptr, bit)  (((BYTE *) (ptr))[(bit)>>3] |= (1 << ((bit) & 7)))
+#define ClearBit(ptr, bit) (((BYTE *)(ptr))[(bit)>>3] &= ~(1 << ((bit) & 7)))
+
+#define SameClient(obj,client) \
+	(CLIENT_BITS((obj)->resource) == (client)->clientAsMask)
+
+#define EMASKSIZE	MAXDEVICES + 2
+
+/* This is the last XI2 event supported by the server. If you add
+ * events to the protocol, the server will not support these events until
+ * this number here is bumped.
+ */
+#define XI2LASTEVENT    17 /* XI_RawMotion */
+#define XI2MASKSIZE     ((XI2LASTEVENT + 7)/8) /* no of bits for masks */
+
+/**
+ * This struct stores the core event mask for each client except the client
+ * that created the window.
+ *
+ * Each window that has events selected from other clients has at least one of
+ * these masks. If multiple clients selected for events on the same window,
+ * these masks are in a linked list.
+ *
+ * The event mask for the client that created the window is stored in
+ * win->eventMask instead.
+ *
+ * The resource id is simply a fake client ID to associate this mask with a
+ * client.
+ *
+ * Kludge: OtherClients and InputClients must be compatible, see code.
+ */
+typedef struct _OtherClients {
+    OtherClientsPtr	next; /**< Pointer to the next mask */
+    XID			resource; /**< id for putting into resource manager */
+    Mask		mask; /**< Core event mask */
+} OtherClients;
+
+/**
+ * This struct stores the XI event mask for each client.
+ *
+ * Each window that has events selected has at least one of these masks. If
+ * multiple client selected for events on the same window, these masks are in
+ * a linked list.
+ */
+typedef struct _InputClients {
+    InputClientsPtr	next; /**< Pointer to the next mask */
+    XID			resource; /**< id for putting into resource manager */
+    Mask		mask[EMASKSIZE]; /**< Actual XI event mask, deviceid is index */
+    /** XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
+} InputClients;
+
+/**
+ * Combined XI event masks from all devices.
+ *
+ * This is the XI equivalent of the deliverableEvents, eventMask and
+ * dontPropagate mask of the WindowRec (or WindowOptRec).
+ *
+ * A window that has an XI client selecting for events has exactly one
+ * OtherInputMasks struct and exactly one InputClients struct hanging off
+ * inputClients. Each further client appends to the inputClients list.
+ * Each Mask field is per-device, with the device id as the index.
+ * Exception: for non-device events (Presence events), the MAXDEVICES
+ * deviceid is used.
+ */
+typedef struct _OtherInputMasks {
+    /**
+     * Bitwise OR of all masks by all clients and the window's parent's masks.
+     */
+    Mask		deliverableEvents[EMASKSIZE];
+    /**
+     * Bitwise OR of all masks by all clients on this window.
+     */
+    Mask		inputEvents[EMASKSIZE];
+    /** The do-not-propagate masks for each device. */
+    Mask		dontPropagateMask[EMASKSIZE];
+    /** The clients that selected for events */
+    InputClientsPtr	inputClients;
+    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
+} OtherInputMasks;
+
+/*
+ * The following structure gets used for both active and passive grabs. For
+ * active grabs some of the fields (e.g. modifiers) are not used. However,
+ * that is not much waste since there aren't many active grabs (one per
+ * keyboard/pointer device) going at once in the server.
+ */
+
+#define MasksPerDetailMask 8		/* 256 keycodes and 256 possible
+                                           modifier combinations, but only	
+                                           3 buttons. */
+
+typedef struct _DetailRec {		/* Grab details may be bit masks */
+    unsigned int        exact;
+    Mask                *pMask;
+} DetailRec;
+
+typedef enum {
+    GRABTYPE_CORE,
+    GRABTYPE_XI,
+    GRABTYPE_XI2
+} GrabType;
+
+union _GrabMask {
+    Mask core;
+    Mask xi;
+    char xi2mask[EMASKSIZE][XI2MASKSIZE];
+};
+
+/**
+ * Central struct for device grabs. 
+ * The same struct is used for both core grabs and device grabs, with
+ * different fields being set. 
+ * If the grab is a core grab (GrabPointer/GrabKeyboard), then the eventMask
+ * is a combination of standard event masks (i.e. PointerMotionMask |
+ * ButtonPressMask).
+ * If the grab is a device grab (GrabDevice), then the eventMask is a
+ * combination of event masks for a given XI event type (see SetEventInfo).
+ *
+ * If the grab is a result of a ButtonPress, then eventMask is the core mask
+ * and deviceMask is set to the XI event mask for the grab.
+ */
+typedef struct _GrabRec {
+    GrabPtr		next;		/* for chain of passive grabs */
+    XID			resource;
+    DeviceIntPtr	device;
+    WindowPtr		window;
+    unsigned		ownerEvents:1;
+    unsigned		keyboardMode:1;
+    unsigned		pointerMode:1;
+    GrabType		grabtype;
+    CARD8		type;		/* event type */
+    DetailRec		modifiersDetail;
+    DeviceIntPtr	modifierDevice;
+    DetailRec		detail;		/* key or button */
+    WindowPtr		confineTo;	/* always NULL for keyboards */
+    CursorPtr		cursor;		/* always NULL for keyboards */
+    Mask		eventMask;
+    Mask                deviceMask;     
+    /* XI2 event masks. One per device, each bit is a mask of (1 << type) */
+    unsigned char       xi2mask[EMASKSIZE][XI2MASKSIZE];
+} GrabRec;
+
+typedef struct _KeyClassRec {
+    int			sourceid;
+    CARD8		down[DOWN_LENGTH];
+    CARD8		postdown[DOWN_LENGTH];
+    int                 modifierKeyCount[8];
+    struct _XkbSrvInfo *xkbInfo;
+} KeyClassRec, *KeyClassPtr;
+
+typedef struct _AxisInfo {
+    int		resolution;
+    int		min_resolution;
+    int		max_resolution;
+    int		min_value;
+    int		max_value;
+    Atom	label;
+} AxisInfo, *AxisInfoPtr;
+
+typedef struct _ValuatorAccelerationRec {
+    int                         number;
+    PointerAccelSchemeProc      AccelSchemeProc;
+    void                       *accelData; /* at disposal of AccelScheme */
+    DeviceCallbackProc          AccelCleanupProc;
+} ValuatorAccelerationRec, *ValuatorAccelerationPtr;
+
+typedef struct _ValuatorClassRec {
+    int                   sourceid;
+    int		 	  numMotionEvents;
+    int                   first_motion;
+    int                   last_motion;
+    void                  *motion; /* motion history buffer. Different layout
+                                      for MDs and SDs!*/
+    WindowPtr             motionHintWindow;
+
+    AxisInfoPtr 	  axes;
+    unsigned short	  numAxes;
+    double		  *axisVal; /* always absolute, but device-coord system */
+    CARD8	 	  mode;
+    ValuatorAccelerationRec	accelScheme;
+} ValuatorClassRec, *ValuatorClassPtr;
+
+typedef struct _ButtonClassRec {
+    int			sourceid;
+    CARD8		numButtons;
+    CARD8		buttonsDown;	/* number of buttons currently down
+                                           This counts logical buttons, not
+					   physical ones, i.e if some buttons
+					   are mapped to 0, they're not counted
+					   here */
+    unsigned short	state;
+    Mask		motionMask;
+    CARD8		down[DOWN_LENGTH];
+    CARD8		postdown[DOWN_LENGTH];
+    CARD8		map[MAP_LENGTH];
+    union _XkbAction    *xkb_acts;
+    Atom		labels[MAX_BUTTONS];
+} ButtonClassRec, *ButtonClassPtr;
+
+typedef struct _FocusClassRec {
+    int		sourceid;
+    WindowPtr	win; /* May be set to a int constant (e.g. PointerRootWin)! */
+    int		revert;
+    TimeStamp	time;
+    WindowPtr	*trace;
+    int		traceSize;
+    int		traceGood;
+} FocusClassRec, *FocusClassPtr;
+
+typedef struct _ProximityClassRec {
+    int		sourceid;
+    char	pad;
+} ProximityClassRec, *ProximityClassPtr;
+
+typedef struct _AbsoluteClassRec {
+    int         sourceid;
+    /* Calibration. */
+    int         min_x;
+    int         max_x;
+    int         min_y;
+    int         max_y;
+    int         flip_x;
+    int         flip_y;
+    int		rotation;
+    int         button_threshold;
+
+    /* Area. */
+    int         offset_x;
+    int         offset_y;
+    int         width;
+    int         height;
+    int         screen;
+    XID		following;
+} AbsoluteClassRec, *AbsoluteClassPtr;
+
+typedef struct _KbdFeedbackClassRec *KbdFeedbackPtr;
+typedef struct _PtrFeedbackClassRec *PtrFeedbackPtr;
+typedef struct _IntegerFeedbackClassRec *IntegerFeedbackPtr;
+typedef struct _StringFeedbackClassRec *StringFeedbackPtr;
+typedef struct _BellFeedbackClassRec *BellFeedbackPtr;
+typedef struct _LedFeedbackClassRec *LedFeedbackPtr;
+
+typedef struct _KbdFeedbackClassRec {
+    BellProcPtr		BellProc;
+    KbdCtrlProcPtr	CtrlProc;
+    KeybdCtrl	 	ctrl;
+    KbdFeedbackPtr	next;
+    struct _XkbSrvLedInfo *xkb_sli;
+} KbdFeedbackClassRec;
+
+typedef struct _PtrFeedbackClassRec {
+    PtrCtrlProcPtr	CtrlProc;
+    PtrCtrl		ctrl;
+    PtrFeedbackPtr	next;
+} PtrFeedbackClassRec;
+
+typedef struct _IntegerFeedbackClassRec {
+    IntegerCtrlProcPtr	CtrlProc;
+    IntegerCtrl	 	ctrl;
+    IntegerFeedbackPtr	next;
+} IntegerFeedbackClassRec;
+
+typedef struct _StringFeedbackClassRec {
+    StringCtrlProcPtr	CtrlProc;
+    StringCtrl	 	ctrl;
+    StringFeedbackPtr	next;
+} StringFeedbackClassRec;
+
+typedef struct _BellFeedbackClassRec {
+    BellProcPtr		BellProc;
+    BellCtrlProcPtr	CtrlProc;
+    BellCtrl	 	ctrl;
+    BellFeedbackPtr	next;
+} BellFeedbackClassRec;
+
+typedef struct _LedFeedbackClassRec {
+    LedCtrlProcPtr	CtrlProc;
+    LedCtrl	 	ctrl;
+    LedFeedbackPtr	next;
+    struct _XkbSrvLedInfo *xkb_sli;
+} LedFeedbackClassRec;
+
+
+typedef struct _ClassesRec {
+    KeyClassPtr		key;
+    ValuatorClassPtr	valuator;
+    ButtonClassPtr	button;
+    FocusClassPtr	focus;
+    ProximityClassPtr	proximity;
+    AbsoluteClassPtr    absolute;
+    KbdFeedbackPtr	kbdfeed;
+    PtrFeedbackPtr	ptrfeed;
+    IntegerFeedbackPtr	intfeed;
+    StringFeedbackPtr	stringfeed;
+    BellFeedbackPtr	bell;
+    LedFeedbackPtr	leds;
+} ClassesRec;
+
+
+/**
+ * Sprite information for a device.
+ */
+typedef struct {
+    CursorPtr	current;
+    BoxRec	hotLimits;	/* logical constraints of hot spot */
+    Bool	confined;	/* confined to screen */
+    RegionPtr	hotShape;	/* additional logical shape constraint */
+    BoxRec	physLimits;	/* physical constraints of hot spot */
+    WindowPtr	win;		/* window of logical position */
+    HotSpot	hot;		/* logical pointer position */
+    HotSpot	hotPhys;	/* physical pointer position */
+#ifdef PANORAMIX
+    ScreenPtr	screen;		/* all others are in Screen 0 coordinates */
+    RegionRec   Reg1;	        /* Region 1 for confining motion */
+    RegionRec   Reg2;		/* Region 2 for confining virtual motion */
+    WindowPtr   windows[MAXSCREENS];
+    WindowPtr	confineWin;	/* confine window */ 
+#endif
+    /* The window trace information is used at dix/events.c to avoid having
+     * to compute all the windows between the root and the current pointer
+     * window each time a button or key goes down. The grabs on each of those
+     * windows must be checked.
+     * spriteTraces should only be used at dix/events.c! */
+    WindowPtr *spriteTrace;
+    int spriteTraceSize;
+    int spriteTraceGood;
+
+    /* Due to delays between event generation and event processing, it is
+     * possible that the pointer has crossed screen boundaries between the
+     * time in which it begins generating events and the time when
+     * those events are processed.
+     *
+     * pEnqueueScreen: screen the pointer was on when the event was generated
+     * pDequeueScreen: screen the pointer was on when the event is processed
+     */
+    ScreenPtr pEnqueueScreen;
+    ScreenPtr pDequeueScreen;
+
+} SpriteRec, *SpritePtr;
+
+/* Device properties */
+typedef struct _XIPropertyValue
+{
+    Atom                type;           /* ignored by server */
+    short               format;         /* format of data for swapping - 8,16,32 */
+    long                size;           /* size of data in (format/8) bytes */
+    pointer             data;           /* private to client */
+} XIPropertyValueRec;
+
+typedef struct _XIProperty
+{
+    struct _XIProperty   *next;
+    Atom                  propertyName;
+    BOOL                  deletable;    /* clients can delete this prop? */
+    XIPropertyValueRec    value;
+} XIPropertyRec;
+
+typedef XIPropertyRec      *XIPropertyPtr;
+typedef XIPropertyValueRec *XIPropertyValuePtr;
+
+
+typedef struct _XIPropertyHandler
+{
+    struct _XIPropertyHandler* next;
+    long id;
+    int (*SetProperty) (DeviceIntPtr dev,
+                        Atom property,
+                        XIPropertyValuePtr prop,
+                        BOOL checkonly);
+    int (*GetProperty) (DeviceIntPtr dev,
+                        Atom property);
+    int (*DeleteProperty) (DeviceIntPtr dev,
+                           Atom property);
+} XIPropertyHandler, *XIPropertyHandlerPtr;
+
+/* states for devices */
+
+#define NOT_GRABBED		0
+#define THAWED			1
+#define THAWED_BOTH		2	/* not a real state */
+#define FREEZE_NEXT_EVENT	3
+#define FREEZE_BOTH_NEXT_EVENT	4
+#define FROZEN			5	/* any state >= has device frozen */
+#define FROZEN_NO_EVENT		5
+#define FROZEN_WITH_EVENT	6
+#define THAW_OTHERS		7
+
+
+typedef struct _GrabInfoRec {
+    TimeStamp	    grabTime;
+    Bool            fromPassiveGrab;    /* true if from passive grab */
+    Bool            implicitGrab;       /* implicit from ButtonPress */
+    GrabRec         activeGrab;
+    GrabPtr         grab;
+    CARD8           activatingKey;
+    void	    (*ActivateGrab) (
+                    DeviceIntPtr /*device*/,
+                    GrabPtr /*grab*/,
+                    TimeStamp /*time*/,
+                    Bool /*autoGrab*/);
+    void	    (*DeactivateGrab)(
+                    DeviceIntPtr /*device*/);
+    struct {
+	Bool		frozen;
+	int		state;
+	GrabPtr		other;		/* if other grab has this frozen */
+	DeviceEvent	*event;		/* saved to be replayed */
+    } sync;
+} GrabInfoRec, *GrabInfoPtr;
+
+typedef struct _SpriteInfoRec {
+    /* sprite must always point to a valid sprite. For devices sharing the
+     * sprite, let sprite point to a paired spriteOwner's sprite. */
+    SpritePtr           sprite;      /* sprite information */
+    Bool                spriteOwner; /* True if device owns the sprite */
+    DeviceIntPtr        paired;      /* The paired device. Keyboard if
+                                        spriteOwner is TRUE, otherwise the
+                                        pointer that owns the sprite. */ 
+
+    /* keep states for animated cursor */
+    struct {
+        CursorPtr       pCursor;
+        ScreenPtr       pScreen;
+        int             elt;
+        CARD32          time;
+    } anim;
+} SpriteInfoRec, *SpriteInfoPtr;
+
+/* device types */
+#define MASTER_POINTER          1
+#define MASTER_KEYBOARD         2
+#define SLAVE                   3
+
+typedef struct _DeviceIntRec {
+    DeviceRec	public;
+    DeviceIntPtr next;
+    Bool	startup;		/* true if needs to be turned on at
+				          server intialization time */
+    DeviceProc	deviceProc;		/* proc(DevicePtr, DEVICE_xx). It is
+					  used to initialize, turn on, or
+					  turn off the device */
+    Bool	inited;			/* TRUE if INIT returns Success */
+    Bool        enabled;                /* TRUE if ON returns Success */
+    Bool        coreEvents;             /* TRUE if device also sends core */
+    GrabInfoRec deviceGrab;             /* grab on the device */
+    int         type;                   /* MASTER_POINTER, MASTER_KEYBOARD, SLAVE */
+    Atom		xinput_type;
+    char		*name;
+    int			id;
+    KeyClassPtr		key;
+    ValuatorClassPtr	valuator;
+    ButtonClassPtr	button;
+    FocusClassPtr	focus;
+    ProximityClassPtr	proximity;
+    AbsoluteClassPtr    absolute;
+    KbdFeedbackPtr	kbdfeed;
+    PtrFeedbackPtr	ptrfeed;
+    IntegerFeedbackPtr	intfeed;
+    StringFeedbackPtr	stringfeed;
+    BellFeedbackPtr	bell;
+    LedFeedbackPtr	leds;
+    struct _XkbInterest *xkb_interest;
+    char                *config_info; /* used by the hotplug layer */
+    ClassesPtr		unused_classes; /* for master devices */
+    int			saved_master_id;	/* for slaves while grabbed */
+    PrivateRec		*devPrivates;
+    DeviceUnwrapProc    unwrapProc;
+    SpriteInfoPtr       spriteInfo;
+    union {
+        DeviceIntPtr        master;     /* master device */
+        DeviceIntPtr        lastSlave;  /* last slave device used */
+    } u;
+
+    /* last valuator values recorded, not posted to client;
+     * for slave devices, valuators is in device coordinates
+     * for master devices, valuators is in screen coordinates
+     * see dix/getevents.c
+     * remainder supports acceleration
+     */
+    struct {
+        int             valuators[MAX_VALUATORS];
+        float           remainder[MAX_VALUATORS];
+        int             numValuators;
+        DeviceIntPtr    slave;
+    } last;
+
+    /* Input device property handling. */
+    struct {
+        XIPropertyPtr   properties;
+        XIPropertyHandlerPtr handlers; /* NULL-terminated */
+    } properties;
+
+    /* coordinate transformation matrix for absolute input devices */
+    struct pixman_f_transform transform;
+
+    /* XTest related master device id */
+    int xtest_master_id;
+} DeviceIntRec;
+
+typedef struct {
+    int			numDevices;	/* total number of devices */
+    DeviceIntPtr	devices;	/* all devices turned on */
+    DeviceIntPtr	off_devices;	/* all devices turned off */
+    DeviceIntPtr	keyboard;	/* the main one for the server */
+    DeviceIntPtr	pointer;
+    DeviceIntPtr	all_devices;
+    DeviceIntPtr	all_master_devices;
+} InputInfo;
+
+extern _X_EXPORT InputInfo inputInfo;
+
+/* for keeping the events for devices grabbed synchronously */
+typedef struct _QdEvent *QdEventPtr;
+typedef struct _QdEvent {
+    QdEventPtr		next;
+    DeviceIntPtr	device;
+    ScreenPtr		pScreen;	/* what screen the pointer was on */
+    unsigned long	months;		/* milliseconds is in the event */
+    InternalEvent	*event;
+} QdEventRec;
+
+/**
+ * syncEvents is the global structure for queued events.
+ *
+ * Devices can be frozen through GrabModeSync pointer grabs. If this is the
+ * case, events from these devices are added to "pending" instead of being
+ * processed normally. When the device is unfrozen, events in "pending" are
+ * replayed and processed as if they would come from the device directly.
+ */
+typedef struct _EventSyncInfo {
+    QdEventPtr          pending, /**<  list of queued events */
+                        *pendtail; /**< last event in list */
+    /** The device to replay events for. Only set in AllowEvents(), in which
+     * case it is set to the device specified in the request. */
+    DeviceIntPtr        replayDev;      /* kludgy rock to put flag for */
+
+    /**
+     * The window the events are supposed to be replayed on.
+     * This window may be set to the grab's window (but only when
+     * Replay{Pointer|Keyboard} is given in the XAllowEvents()
+     * request. */
+    WindowPtr           replayWin;      /*   ComputeFreezes            */
+    /**
+     * Flag to indicate whether we're in the process of
+     * replaying events. Only set in ComputeFreezes(). */
+    Bool                playingEvents;
+    TimeStamp           time;
+} EventSyncInfoRec, *EventSyncInfoPtr;
+
+extern EventSyncInfoRec syncEvents;
+
+#endif /* INPUTSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fboverlay.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fboverlay.h
@@ -0,0 +1,123 @@
+/*
+ *
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN 
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _FBOVERLAY_H_
+#define _FBOVERLAY_H_
+
+#include "privates.h"
+
+extern _X_EXPORT DevPrivateKey fbOverlayGetScreenPrivateKey(void);
+
+#ifndef FB_OVERLAY_MAX
+#define FB_OVERLAY_MAX	2
+#endif
+
+typedef	void	(*fbOverlayPaintKeyProc) (DrawablePtr, RegionPtr, CARD32, int);
+
+typedef struct _fbOverlayLayer {
+    union {
+	struct {
+	    pointer	pbits;
+	    int		width;
+	    int		depth;
+	} init;
+	struct {
+	    PixmapPtr	pixmap;
+	    RegionRec	region;
+	} run;
+    } u;
+    CARD32	key;	    /* special pixel value */
+} FbOverlayLayer;
+
+typedef struct _fbOverlayScrPriv {
+    int			    nlayers;
+    fbOverlayPaintKeyProc   PaintKey;
+    miCopyProc		    CopyWindow;
+    FbOverlayLayer	    layer[FB_OVERLAY_MAX];
+} FbOverlayScrPrivRec, *FbOverlayScrPrivPtr;
+
+#define fbOverlayGetScrPriv(s) \
+    dixLookupPrivate(&(s)->devPrivates, fbOverlayGetScreenPrivateKey())
+extern _X_EXPORT Bool
+fbOverlayCreateWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+fbOverlayCloseScreen (int iScreen, ScreenPtr pScreen);
+
+extern _X_EXPORT int
+fbOverlayWindowLayer(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+fbOverlayCreateScreenResources(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+fbOverlayPaintKey (DrawablePtr	pDrawable,
+		   RegionPtr	pRegion,
+		   CARD32	pixel,
+		   int		layer);
+extern _X_EXPORT void
+fbOverlayUpdateLayerRegion (ScreenPtr	pScreen,
+			    int		layer,
+			    RegionPtr	prgn);
+
+    
+extern _X_EXPORT void
+fbOverlayCopyWindow(WindowPtr	pWin,
+		    DDXPointRec	ptOldOrg,
+		    RegionPtr	prgnSrc);
+    
+extern _X_EXPORT void
+fbOverlayWindowExposures (WindowPtr	pWin,
+			  RegionPtr	prgn,
+			  RegionPtr	other_exposed);
+
+extern _X_EXPORT Bool
+fbOverlaySetupScreen(ScreenPtr	pScreen,
+		     pointer	pbits1,
+		     pointer	pbits2,
+		     int	xsize,
+		     int	ysize,
+		     int	dpix,
+		     int	dpiy,
+		     int	width1,
+		     int	width2,
+		     int	bpp1,
+		     int	bpp2);
+
+extern _X_EXPORT Bool
+fbOverlayFinishScreenInit(ScreenPtr	pScreen,
+			  pointer	pbits1,
+			  pointer	pbits2,
+			  int		xsize,
+			  int		ysize,
+			  int		dpix,
+			  int		dpiy,
+			  int		width1,
+			  int		width2,
+			  int		bpp1,
+			  int		bpp2,
+			  int		depth1,
+			  int		depth2);
+
+#endif /* _FBOVERLAY_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xselinuxint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xselinuxint.h
@@ -0,0 +1,561 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XSELINUXINT_H
+#define _XSELINUXINT_H
+
+#include <selinux/selinux.h>
+#include <selinux/avc.h>
+
+#include "globals.h"
+#include "dixaccess.h"
+#include "dixstruct.h"
+#include "privates.h"
+#include "resource.h"
+#include "registry.h"
+#include "inputstr.h"
+#include "xselinux.h"
+
+/*
+ * Types
+ */
+
+#define COMMAND_LEN 64
+
+/* subject state (clients and devices only) */
+typedef struct {
+    security_id_t sid;
+    security_id_t dev_create_sid;
+    security_id_t win_create_sid;
+    security_id_t sel_create_sid;
+    security_id_t prp_create_sid;
+    security_id_t sel_use_sid;
+    security_id_t prp_use_sid;
+    struct avc_entry_ref aeref;
+    char command[COMMAND_LEN];
+    int privileged;
+} SELinuxSubjectRec;
+
+/* object state */
+typedef struct {
+    security_id_t sid;
+    int poly;
+} SELinuxObjectRec;
+
+/*
+ * Globals
+ */
+
+extern DevPrivateKeyRec subjectKeyRec;
+#define subjectKey (&subjectKeyRec)
+extern DevPrivateKeyRec objectKeyRec;
+#define objectKey (&objectKeyRec)
+extern DevPrivateKeyRec dataKeyRec;
+#define dataKey (&dataKeyRec)
+
+/*
+ * Label functions
+ */
+
+int
+SELinuxAtomToSID(Atom atom, int prop, SELinuxObjectRec **obj_rtn);
+
+int
+SELinuxSelectionToSID(Atom selection, SELinuxSubjectRec *subj,
+		      security_id_t *sid_rtn, int *poly_rtn);
+
+int
+SELinuxPropertyToSID(Atom property, SELinuxSubjectRec *subj,
+		     security_id_t *sid_rtn, int *poly_rtn);
+
+int
+SELinuxEventToSID(unsigned type, security_id_t sid_of_window,
+		  SELinuxObjectRec *sid_return);
+
+int
+SELinuxExtensionToSID(const char *name, security_id_t *sid_rtn);
+
+security_class_t
+SELinuxTypeToClass(RESTYPE type);
+
+security_context_t
+SELinuxDefaultClientLabel(void);
+
+void
+SELinuxLabelInit(void);
+
+void
+SELinuxLabelReset(void);
+
+/*
+ * Security module functions
+ */
+
+void
+SELinuxFlaskInit(void);
+
+void
+SELinuxFlaskReset(void);
+
+
+/*
+ * Private Flask definitions
+ */
+
+/* Security class constants */
+#define SECCLASS_X_DRAWABLE		1
+#define SECCLASS_X_SCREEN		2
+#define SECCLASS_X_GC			3
+#define SECCLASS_X_FONT			4
+#define SECCLASS_X_COLORMAP		5
+#define SECCLASS_X_PROPERTY		6
+#define SECCLASS_X_SELECTION		7
+#define SECCLASS_X_CURSOR		8
+#define SECCLASS_X_CLIENT		9
+#define SECCLASS_X_POINTER		10
+#define SECCLASS_X_KEYBOARD		11
+#define SECCLASS_X_SERVER		12
+#define SECCLASS_X_EXTENSION		13
+#define SECCLASS_X_EVENT		14
+#define SECCLASS_X_FAKEEVENT		15
+#define SECCLASS_X_RESOURCE		16
+
+#ifdef _XSELINUX_NEED_FLASK_MAP
+/* Mapping from DixAccess bits to Flask permissions */
+static struct security_class_mapping map[] = {
+    { "x_drawable",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "list_property",	/* DixListPropAccess */
+          "get_property",	/* DixGetPropAccess */
+          "set_property",	/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "list_child",		/* DixListAccess */
+          "add_child",		/* DixAddAccess */
+          "remove_child",	/* DixRemoveAccess */
+          "hide",		/* DixHideAccess */
+          "show",		/* DixShowAccess */
+          "blend",		/* DixBlendAccess */
+          "override",		/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "send",		/* DixSendAccess */
+          "receive",		/* DixReceiveAccess */
+          "",			/* DixUseAccess */
+          "manage",		/* DixManageAccess */
+          NULL }},
+    { "x_screen",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "saver_getattr",	/* DixListPropAccess */
+          "saver_setattr",	/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "hide_cursor",	/* DixHideAccess */
+          "show_cursor",	/* DixShowAccess */
+          "saver_hide",		/* DixBlendAccess */
+          "saver_show",		/* DixGrabAccess */
+          NULL }},
+    { "x_gc",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          NULL }},
+    { "x_font",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "",			/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "add_glyph",		/* DixAddAccess */
+          "remove_glyph",	/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          NULL }},
+    { "x_colormap",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "",			/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "add_color",		/* DixAddAccess */
+          "remove_color",	/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "install",		/* DixInstallAccess */
+          "uninstall",		/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          NULL }},
+    { "x_property",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "write",		/* DixBlendAccess */
+          NULL }},
+    { "x_selection",
+        { "read",		/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "setattr",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          NULL }},
+    { "x_cursor",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          NULL }},
+    { "x_client",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "",			/* DixUseAccess */
+          "manage",		/* DixManageAccess */
+          NULL }},
+    { "x_pointer",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "list_property",	/* DixListPropAccess */
+          "get_property",	/* DixGetPropAccess */
+          "set_property",	/* DixSetPropAccess */
+          "getfocus",		/* DixGetFocusAccess */
+          "setfocus",		/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "add",		/* DixAddAccess */
+          "remove",		/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "grab",		/* DixGrabAccess */
+          "freeze",		/* DixFreezeAccess */
+          "force_cursor",	/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          "manage",		/* DixManageAccess */
+          "",			/* DixDebugAccess */
+          "bell",		/* DixBellAccess */
+          NULL }},
+    { "x_keyboard",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "destroy",		/* DixDestroyAccess */
+          "create",		/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "list_property",	/* DixListPropAccess */
+          "get_property",	/* DixGetPropAccess */
+          "set_property",	/* DixSetPropAccess */
+          "getfocus",		/* DixGetFocusAccess */
+          "setfocus",		/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "add",		/* DixAddAccess */
+          "remove",		/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "grab",		/* DixGrabAccess */
+          "freeze",		/* DixFreezeAccess */
+          "force_cursor",	/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          "manage",		/* DixManageAccess */
+          "",			/* DixDebugAccess */
+          "bell",		/* DixBellAccess */
+          NULL }},
+    { "x_server",
+        { "record",		/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "getattr",		/* DixGetAttrAccess */
+          "setattr",		/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "grab",		/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "",			/* DixUseAccess */
+          "manage",		/* DixManageAccess */
+          "debug",		/* DixDebugAccess */
+          NULL }},
+    { "x_extension",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "query",		/* DixGetAttrAccess */
+          "",			/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "",			/* DixSendAccess */
+          "",			/* DixReceiveAccess */
+          "use",		/* DixUseAccess */
+          NULL }},
+    { "x_event",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "",			/* DixGetAttrAccess */
+          "",			/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "send",		/* DixSendAccess */
+          "receive",		/* DixReceiveAccess */
+          NULL }},
+    { "x_synthetic_event",
+        { "",			/* DixReadAccess */
+          "",			/* DixWriteAccess */
+          "",			/* DixDestroyAccess */
+          "",			/* DixCreateAccess */
+          "",			/* DixGetAttrAccess */
+          "",			/* DixSetAttrAccess */
+          "",			/* DixListPropAccess */
+          "",			/* DixGetPropAccess */
+          "",			/* DixSetPropAccess */
+          "",			/* DixGetFocusAccess */
+          "",			/* DixSetFocusAccess */
+          "",			/* DixListAccess */
+          "",			/* DixAddAccess */
+          "",			/* DixRemoveAccess */
+          "",			/* DixHideAccess */
+          "",			/* DixShowAccess */
+          "",			/* DixBlendAccess */
+          "",			/* DixGrabAccess */
+          "",			/* DixFreezeAccess */
+          "",			/* DixForceAccess */
+          "",			/* DixInstallAccess */
+          "",			/* DixUninstallAccess */
+          "send",		/* DixSendAccess */
+          "receive",		/* DixReceiveAccess */
+          NULL }},
+    { "x_resource",
+        { "read",		/* DixReadAccess */
+          "write",		/* DixWriteAccess */
+          "write",		/* DixDestroyAccess */
+          "write",		/* DixCreateAccess */
+          "read",		/* DixGetAttrAccess */
+          "write",		/* DixSetAttrAccess */
+          "read",		/* DixListPropAccess */
+          "read",		/* DixGetPropAccess */
+          "write",		/* DixSetPropAccess */
+          "read",		/* DixGetFocusAccess */
+          "write",		/* DixSetFocusAccess */
+          "read",		/* DixListAccess */
+          "write",		/* DixAddAccess */
+          "write",		/* DixRemoveAccess */
+          "write",		/* DixHideAccess */
+          "read",		/* DixShowAccess */
+          "read",		/* DixBlendAccess */
+          "write",		/* DixGrabAccess */
+          "write",		/* DixFreezeAccess */
+          "write",		/* DixForceAccess */
+          "write",		/* DixInstallAccess */
+          "write",		/* DixUninstallAccess */
+          "write",		/* DixSendAccess */
+          "read",		/* DixReceiveAccess */
+          "read",		/* DixUseAccess */
+          "write",		/* DixManageAccess */
+          "read",		/* DixDebugAccess */
+          "write",		/* DixBellAccess */
+          NULL }},
+    { NULL }
+};
+
+/* x_resource "read" bits from the list above */
+#define SELinuxReadMask (DixReadAccess|DixGetAttrAccess|DixListPropAccess| \
+			 DixGetPropAccess|DixGetFocusAccess|DixListAccess| \
+			 DixShowAccess|DixBlendAccess|DixReceiveAccess| \
+			 DixUseAccess|DixDebugAccess)
+
+#endif /* _XSELINUX_NEED_FLASK_MAP */
+#endif /* _XSELINUXINT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setbmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/setbmap.h
@@ -0,0 +1,44 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SETBMAP_H
+#define SETBMAP_H 1
+
+int SProcXSetDeviceButtonMapping(ClientPtr	/* client */
+    );
+
+int ProcXSetDeviceButtonMapping(ClientPtr	/* client */
+    );
+
+void SRepXSetDeviceButtonMapping(ClientPtr /* client */ ,
+				 int /* size */ ,
+				 xSetDeviceButtonMappingReply *	/* rep */
+    );
+
+#endif /* SETBMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxsingle.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxsingle.h
@@ -0,0 +1,54 @@
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+#ifndef __GLXSINGLE_H
+#define __GLXSINGLE_H
+
+extern int __glXForwardSingleReq( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardPipe0WithReply( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardAllWithReply( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXForwardSingleReqSwap( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXForwardPipe0WithReplySwap( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardPipe0WithReplySwapsv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardPipe0WithReplySwapiv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardPipe0WithReplySwapdv( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXForwardAllWithReplySwap( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardAllWithReplySwapsv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardAllWithReplySwapiv( __GLXclientState *cl, GLbyte *pc );
+extern int __glXForwardAllWithReplySwapdv( __GLXclientState *cl, GLbyte *pc );
+
+extern int __glXDisp_ReadPixels(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDispSwap_GetTexImage(__GLXclientState *cl, GLbyte *pc);
+extern int __glXDispSwap_GetColorTable(__GLXclientState *cl, GLbyte *pc);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dix-config-apple-verbatim.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dix-config-apple-verbatim.h
@@ -0,0 +1,8 @@
+/* Do not include this file directly.  It is included at the end of <dix-config.h> */
+
+/* Correctly set _XSERVER64 for OSX fat binaries */
+#if defined(__LP64__) && !defined(_XSERVER64)
+#define _XSERVER64 1
+#elif !defined(__LP64__) && defined(_XSERVER64)
+#undef _XSERVER64
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86fbman.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86fbman.h
@@ -0,0 +1,226 @@
+
+/*
+ * Copyright (c) 1998-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifndef _XF86FBMAN_H
+#define _XF86FBMAN_H
+
+
+#include "scrnintstr.h"
+#include "regionstr.h"
+
+
+#define FAVOR_AREA_THEN_WIDTH		0
+#define FAVOR_AREA_THEN_HEIGHT		1
+#define FAVOR_WIDTH_THEN_AREA		2
+#define FAVOR_HEIGHT_THEN_AREA		3
+
+#define PRIORITY_LOW			0
+#define PRIORITY_NORMAL			1
+#define PRIORITY_EXTREME		2
+
+
+typedef struct _FBArea {
+   ScreenPtr    pScreen;
+   BoxRec   	box;
+   int 		granularity;
+   void 	(*MoveAreaCallback)(struct _FBArea*, struct _FBArea*);
+   void 	(*RemoveAreaCallback)(struct _FBArea*);
+   DevUnion 	devPrivate;
+} FBArea, *FBAreaPtr;
+
+typedef struct _FBLinear {
+   ScreenPtr    pScreen;
+   int		size;
+   int 		offset;
+   int 		granularity;
+   void 	(*MoveLinearCallback)(struct _FBLinear*, struct _FBLinear*);
+   void 	(*RemoveLinearCallback)(struct _FBLinear*);
+   DevUnion 	devPrivate;
+} FBLinear, *FBLinearPtr;
+
+typedef void (*FreeBoxCallbackProcPtr)(ScreenPtr, RegionPtr, pointer);
+typedef void (*MoveAreaCallbackProcPtr)(FBAreaPtr, FBAreaPtr);
+typedef void (*RemoveAreaCallbackProcPtr)(FBAreaPtr);
+
+typedef void (*MoveLinearCallbackProcPtr)(FBLinearPtr, FBLinearPtr);
+typedef void (*RemoveLinearCallbackProcPtr)(FBLinearPtr);
+
+
+typedef struct {
+    FBAreaPtr (*AllocateOffscreenArea)(
+		ScreenPtr pScreen, 
+		int w, int h,
+		int granularity,
+		MoveAreaCallbackProcPtr moveCB,
+		RemoveAreaCallbackProcPtr removeCB,
+		pointer privData);
+    void      (*FreeOffscreenArea)(FBAreaPtr area);
+    Bool      (*ResizeOffscreenArea)(FBAreaPtr area, int w, int h);
+    Bool      (*QueryLargestOffscreenArea)(
+		ScreenPtr pScreen,
+		int *width, int *height,
+		int granularity,
+		int preferences,
+		int priority);
+    Bool      (*RegisterFreeBoxCallback)( 
+		ScreenPtr pScreen,  
+		FreeBoxCallbackProcPtr FreeBoxCallback,
+		pointer devPriv);
+/* linear functions */
+    FBLinearPtr (*AllocateOffscreenLinear)(
+		ScreenPtr pScreen, 
+		int size,
+		int granularity,
+		MoveLinearCallbackProcPtr moveCB,
+		RemoveLinearCallbackProcPtr removeCB,
+		pointer privData);
+    void      (*FreeOffscreenLinear)(FBLinearPtr area);
+    Bool      (*ResizeOffscreenLinear)(FBLinearPtr area, int size);
+    Bool      (*QueryLargestOffscreenLinear)(
+		ScreenPtr pScreen,
+		int *size,
+		int granularity,
+		int priority);
+    Bool      (*PurgeOffscreenAreas) (ScreenPtr);
+} FBManagerFuncs, *FBManagerFuncsPtr;
+
+
+extern _X_EXPORT Bool xf86RegisterOffscreenManager(
+    ScreenPtr pScreen, 
+    FBManagerFuncsPtr funcs
+);
+
+extern _X_EXPORT Bool
+xf86InitFBManagerRegion(
+    ScreenPtr pScreen, 
+    RegionPtr ScreenRegion
+);
+
+extern _X_EXPORT Bool
+xf86InitFBManagerArea(
+    ScreenPtr pScreen,
+    int PixalArea,
+    int Verbosity
+);
+
+extern _X_EXPORT Bool
+xf86InitFBManager(
+    ScreenPtr pScreen, 
+    BoxPtr FullBox
+);
+
+extern _X_EXPORT Bool
+xf86InitFBManagerLinear(
+    ScreenPtr pScreen, 
+    int offset,
+    int size
+);
+
+extern _X_EXPORT Bool
+xf86FBManagerRunning(
+    ScreenPtr pScreen
+);
+
+extern _X_EXPORT FBAreaPtr
+xf86AllocateOffscreenArea (
+   ScreenPtr pScreen, 
+   int w, int h,
+   int granularity,
+   MoveAreaCallbackProcPtr moveCB,
+   RemoveAreaCallbackProcPtr removeCB,
+   pointer privData
+);
+
+extern _X_EXPORT FBAreaPtr
+xf86AllocateLinearOffscreenArea (
+   ScreenPtr pScreen, 
+   int length,
+   int granularity,
+   MoveAreaCallbackProcPtr moveCB,
+   RemoveAreaCallbackProcPtr removeCB,
+   pointer privData
+);
+
+extern _X_EXPORT FBLinearPtr
+xf86AllocateOffscreenLinear (
+   ScreenPtr pScreen, 
+   int length,
+   int granularity,
+   MoveLinearCallbackProcPtr moveCB,
+   RemoveLinearCallbackProcPtr removeCB,
+   pointer privData
+);
+
+extern _X_EXPORT void xf86FreeOffscreenArea(FBAreaPtr area);
+extern _X_EXPORT void xf86FreeOffscreenLinear(FBLinearPtr area);
+
+extern _X_EXPORT Bool
+xf86ResizeOffscreenArea(
+   FBAreaPtr resize,
+   int w, int h
+);
+
+extern _X_EXPORT Bool
+xf86ResizeOffscreenLinear(
+   FBLinearPtr resize,
+   int size
+);
+
+
+extern _X_EXPORT Bool
+xf86RegisterFreeBoxCallback(
+    ScreenPtr pScreen,  
+    FreeBoxCallbackProcPtr FreeBoxCallback,
+    pointer devPriv
+);
+
+extern _X_EXPORT Bool
+xf86PurgeUnlockedOffscreenAreas(
+    ScreenPtr pScreen
+);
+
+
+extern _X_EXPORT Bool
+xf86QueryLargestOffscreenArea(
+    ScreenPtr pScreen,
+    int *width, int *height,
+    int granularity,
+    int preferences,
+    int priority
+);
+
+extern _X_EXPORT Bool
+xf86QueryLargestOffscreenLinear(
+    ScreenPtr pScreen,
+    int *size,
+    int granularity,
+    int priority
+);
+
+
+#endif /* _XF86FBMAN_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/windowstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/windowstr.h
@@ -0,0 +1,218 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef WINDOWSTRUCT_H
+#define WINDOWSTRUCT_H
+
+#include "window.h"
+#include "pixmapstr.h"
+#include "regionstr.h"
+#include "cursor.h"
+#include "property.h"
+#include "resource.h"	/* for ROOT_WINDOW_ID_BASE */
+#include "dix.h"
+#include "privates.h"
+#include "miscstruct.h"
+#include <X11/Xprotostr.h>
+#include "opaque.h"
+
+#define GuaranteeNothing	0
+#define GuaranteeVisBack	1
+
+#define SameBackground(as, a, bs, b)				\
+    ((as) == (bs) && ((as) == None ||				\
+		      (as) == ParentRelative ||			\
+ 		      SamePixUnion(a,b,as == BackgroundPixel)))
+
+#define SameBorder(as, a, bs, b)				\
+    EqualPixUnion(as, a, bs, b)
+
+/* used as NULL-terminated list */
+typedef struct _DevCursorNode {
+    CursorPtr                   cursor;
+    DeviceIntPtr                dev;
+    struct _DevCursorNode*      next;
+} DevCursNodeRec, *DevCursNodePtr, *DevCursorList;
+
+typedef struct _WindowOpt {
+    VisualID		visual;		   /* default: same as parent */
+    CursorPtr		cursor;		   /* default: window.cursorNone */
+    Colormap		colormap;	   /* default: same as parent */
+    Mask		dontPropagateMask; /* default: window.dontPropagate */
+    Mask		otherEventMasks;   /* default: 0 */
+    struct _OtherClients *otherClients;	   /* default: NULL */
+    struct _GrabRec	*passiveGrabs;	   /* default: NULL */
+    PropertyPtr		userProps;	   /* default: NULL */
+    unsigned long	backingBitPlanes;  /* default: ~0L */
+    unsigned long	backingPixel;	   /* default: 0 */
+    RegionPtr		boundingShape;	   /* default: NULL */
+    RegionPtr		clipShape;	   /* default: NULL */
+    RegionPtr		inputShape;	   /* default: NULL */
+    struct _OtherInputMasks *inputMasks;   /* default: NULL */
+    DevCursorList       deviceCursors;     /* default: NULL */
+} WindowOptRec, *WindowOptPtr;
+
+#define BackgroundPixel	    2L
+#define BackgroundPixmap    3L
+
+/*
+ * The redirectDraw field can have one of three values:
+ *
+ *  RedirectDrawNone
+ *	A normal window; painted into the same pixmap as the parent
+ *	and clipping parent and siblings to its geometry. These
+ *	windows get a clip list equal to the intersection of their
+ *	geometry with the parent geometry, minus the geometry
+ *	of overlapping None and Clipped siblings.
+ *  RedirectDrawAutomatic
+ *	A redirected window which clips parent and sibling drawing.
+ *	Contents for these windows are manage inside the server.
+ *	These windows get an internal clip list equal to their
+ *	geometry.
+ *  RedirectDrawManual
+ *	A redirected window which does not clip parent and sibling
+ *	drawing; the window must be represented within the parent
+ *	geometry by the client performing the redirection management.
+ *	Contents for these windows are managed outside the server.
+ *	These windows get an internal clip list equal to their
+ *	geometry.
+ */
+
+#define RedirectDrawNone	0
+#define RedirectDrawAutomatic	1
+#define RedirectDrawManual	2
+
+typedef struct _Window {
+    DrawableRec		drawable;
+    PrivateRec		*devPrivates;
+    WindowPtr		parent;		/* ancestor chain */
+    WindowPtr		nextSib;	/* next lower sibling */
+    WindowPtr		prevSib;	/* next higher sibling */
+    WindowPtr		firstChild;	/* top-most child */
+    WindowPtr		lastChild;	/* bottom-most child */
+    RegionRec		clipList;	/* clipping rectangle for output */
+    RegionRec		borderClip;	/* NotClippedByChildren + border */
+    union _Validate	*valdata;
+    RegionRec		winSize;
+    RegionRec		borderSize;
+    DDXPointRec		origin;		/* position relative to parent */
+    unsigned short	borderWidth;
+    unsigned short	deliverableEvents; /* all masks from all clients */
+    Mask		eventMask;      /* mask from the creating client */
+    PixUnion		background;
+    PixUnion		border;
+    pointer		backStorage;	/* null when BS disabled */
+    WindowOptPtr	optional;
+    unsigned		backgroundState:2; /* None, Relative, Pixel, Pixmap */
+    unsigned		borderIsPixel:1;
+    unsigned		cursorIsNone:1;	/* else real cursor (might inherit) */
+    unsigned		backingStore:2;
+    unsigned		saveUnder:1;
+    unsigned		DIXsaveUnder:1;
+    unsigned		bitGravity:4;
+    unsigned		winGravity:4;
+    unsigned		overrideRedirect:1;
+    unsigned		visibility:2;
+    unsigned		mapped:1;
+    unsigned		realized:1;	/* ancestors are all mapped */
+    unsigned		viewable:1;	/* realized && InputOutput */
+    unsigned		dontPropagate:3;/* index into DontPropagateMasks */
+    unsigned		forcedBS:1;	/* system-supplied backingStore */
+    unsigned		redirectDraw:2;	/* COMPOSITE rendering redirect */
+    unsigned		forcedBG:1;	/* must have an opaque background */
+#ifdef ROOTLESS
+    unsigned		rootlessUnhittable:1;	/* doesn't hit-test */
+#endif
+} WindowRec;
+
+/*
+ * Ok, a bunch of macros for accessing the optional record
+ * fields (or filling the appropriate default value)
+ */
+
+extern _X_EXPORT Mask	DontPropagateMasks[];
+
+#define wTrackParent(w,field)	((w)->optional ? \
+				    (w)->optional->field \
+ 				 : FindWindowWithOptional(w)->optional->field)
+#define wUseDefault(w,field,def)	((w)->optional ? \
+				    (w)->optional->field \
+				 : def)
+
+#define wVisual(w)		wTrackParent(w, visual)
+#define wCursor(w)		((w)->cursorIsNone ? None : wTrackParent(w, cursor))
+#define wColormap(w)		((w)->drawable.class == InputOnly ? None : wTrackParent(w, colormap))
+#define wDontPropagateMask(w)	wUseDefault(w, dontPropagateMask, DontPropagateMasks[(w)->dontPropagate])
+#define wOtherEventMasks(w)	wUseDefault(w, otherEventMasks, 0)
+#define wOtherClients(w)	wUseDefault(w, otherClients, NULL)
+#define wOtherInputMasks(w)	wUseDefault(w, inputMasks, NULL)
+#define wPassiveGrabs(w)	wUseDefault(w, passiveGrabs, NULL)
+#define wUserProps(w)		wUseDefault(w, userProps, NULL)
+#define wBackingBitPlanes(w)	wUseDefault(w, backingBitPlanes, ~0L)
+#define wBackingPixel(w)	wUseDefault(w, backingPixel, 0)
+#define wBoundingShape(w)	wUseDefault(w, boundingShape, NULL)
+#define wClipShape(w)		wUseDefault(w, clipShape, NULL)
+#define wInputShape(w)          wUseDefault(w, inputShape, NULL)
+#define wClient(w)		(clients[CLIENT_ID((w)->drawable.id)])
+#define wBorderWidth(w)		((int) (w)->borderWidth)
+
+/* true when w needs a border drawn. */
+
+#define HasBorder(w)	((w)->borderWidth || wClipShape(w))
+
+typedef struct _ScreenSaverStuff *ScreenSaverStuffPtr;
+
+#define SCREEN_IS_BLANKED   0
+#define SCREEN_ISNT_SAVED   1
+#define SCREEN_IS_TILED     2
+#define SCREEN_IS_BLACK	    3
+
+#define HasSaverWindow(pScreen)   (pScreen->screensaver.pWindow != NullWindow)
+
+extern _X_EXPORT int screenIsSaved;
+
+#endif /* WINDOWSTRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/XIstubs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/XIstubs.h
@@ -0,0 +1,63 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifndef XI_STUBS_H
+#define XI_STUBS_H 1
+
+extern _X_EXPORT void
+CloseInputDevice (
+	DeviceIntPtr           /* d */,
+	ClientPtr              /* client */);
+
+extern _X_EXPORT void
+AddOtherInputDevices (void);
+
+extern _X_EXPORT void
+OpenInputDevice (
+	DeviceIntPtr           /* dev */,
+	ClientPtr              /* client */,
+	int *                  /* status */);
+
+extern _X_EXPORT int
+SetDeviceMode (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int                    /* mode */);
+
+extern _X_EXPORT int
+SetDeviceValuators (
+	ClientPtr              /* client */,
+	DeviceIntPtr           /* dev */,
+	int *                  /* valuators */,
+	int                    /* first_valuator */,
+	int                    /* num_valuators */);
+
+extern _X_EXPORT int
+ChangeDeviceControl (
+	ClientPtr             /* client */,
+	DeviceIntPtr          /* dev */,
+	xDeviceCtl *          /* control */);
+
+#endif /* XI_STUBS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/picturestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/picturestr.h
@@ -0,0 +1,699 @@
+/*
+ * Copyright © 2000 SuSE, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of SuSE not be used in advertising or
+ * publicity pertaining to distribution of the software without specific,
+ * written prior permission.  SuSE makes no representations about the
+ * suitability of this software for any purpose.  It is provided "as is"
+ * without express or implied warranty.
+ *
+ * SuSE DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL SuSE
+ * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+ * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Author:  Keith Packard, SuSE, Inc.
+ */
+
+#ifndef _PICTURESTR_H_
+#define _PICTURESTR_H_
+
+#include "scrnintstr.h"
+#include "glyphstr.h"
+#include "resource.h"
+#include "privates.h"
+
+typedef struct _DirectFormat {
+    CARD16	    red, redMask;
+    CARD16	    green, greenMask;
+    CARD16	    blue, blueMask;
+    CARD16	    alpha, alphaMask;
+} DirectFormatRec;
+
+typedef struct _IndexFormat {
+    VisualID	    vid;
+    ColormapPtr	    pColormap;
+    int		    nvalues;
+    xIndexValue	    *pValues;
+    void	    *devPrivate;
+} IndexFormatRec;
+
+typedef struct _PictFormat {
+    CARD32	    id;
+    CARD32	    format;	    /* except bpp */
+    unsigned char   type;
+    unsigned char   depth;
+    DirectFormatRec direct;
+    IndexFormatRec  index;
+} PictFormatRec;
+
+typedef struct pixman_vector PictVector, *PictVectorPtr;
+typedef struct pixman_transform PictTransform, *PictTransformPtr;
+
+#define pict_f_vector pixman_f_vector
+#define pict_f_transform pixman_f_transform
+
+#define PICT_GRADIENT_STOPTABLE_SIZE 1024
+#define SourcePictTypeSolidFill 0
+#define SourcePictTypeLinear 1
+#define SourcePictTypeRadial 2
+#define SourcePictTypeConical 3
+
+#define SourcePictClassUnknown    0
+#define SourcePictClassHorizontal 1
+#define SourcePictClassVertical   2
+
+typedef struct _PictSolidFill {
+    unsigned int type;
+    unsigned int class;
+    CARD32 color;
+} PictSolidFill, *PictSolidFillPtr;
+
+typedef struct _PictGradientStop {
+    xFixed x;
+    xRenderColor color;
+} PictGradientStop, *PictGradientStopPtr;
+
+typedef struct _PictGradient {
+    unsigned int type;
+    unsigned int class;
+    int nstops;
+    PictGradientStopPtr stops;
+    int stopRange;
+    CARD32 *colorTable;
+    int colorTableSize;
+} PictGradient, *PictGradientPtr;
+
+typedef struct _PictLinearGradient {
+    unsigned int type;
+    unsigned int class;
+    int nstops;
+    PictGradientStopPtr stops;
+    int stopRange;
+    CARD32 *colorTable;
+    int colorTableSize;
+    xPointFixed p1;
+    xPointFixed p2;
+} PictLinearGradient, *PictLinearGradientPtr;
+
+typedef struct _PictCircle {
+    xFixed x;
+    xFixed y;
+    xFixed radius;
+} PictCircle, *PictCirclePtr;
+
+typedef struct _PictRadialGradient {
+    unsigned int type;
+    unsigned int class;
+    int nstops;
+    PictGradientStopPtr stops;
+    int stopRange;
+    CARD32 *colorTable;
+    int colorTableSize;
+    PictCircle c1;
+    PictCircle c2;
+    double cdx;
+    double cdy;
+    double dr;
+    double A;
+} PictRadialGradient, *PictRadialGradientPtr;
+
+typedef struct _PictConicalGradient {
+    unsigned int type;
+    unsigned int class;
+    int nstops;
+    PictGradientStopPtr stops;
+    int stopRange;
+    CARD32 *colorTable;
+    int colorTableSize;
+    xPointFixed center;
+    xFixed angle;
+} PictConicalGradient, *PictConicalGradientPtr;
+
+typedef union _SourcePict {
+    unsigned int type;
+    PictSolidFill solidFill;
+    PictGradient gradient;
+    PictLinearGradient linear;
+    PictRadialGradient radial;
+    PictConicalGradient conical;
+} SourcePict, *SourcePictPtr;
+
+typedef struct _Picture {
+    DrawablePtr	    pDrawable;
+    PictFormatPtr   pFormat;
+    PictFormatShort format;	    /* PICT_FORMAT */
+    int		    refcnt;
+    CARD32	    id;
+    PicturePtr	    pNext;	    /* chain on same drawable */
+
+    unsigned int    repeat : 1;
+    unsigned int    graphicsExposures : 1;
+    unsigned int    subWindowMode : 1;
+    unsigned int    polyEdge : 1;
+    unsigned int    polyMode : 1;
+    unsigned int    freeCompClip : 1;
+    unsigned int    clientClipType : 2;
+    unsigned int    componentAlpha : 1;
+    unsigned int    repeatType : 2;
+    unsigned int    unused : 21;
+
+    PicturePtr	    alphaMap;
+    DDXPointRec	    alphaOrigin;
+
+    DDXPointRec	    clipOrigin;
+    pointer	    clientClip;
+
+    Atom	    dither;
+
+    unsigned long   stateChanges;
+    unsigned long   serialNumber;
+
+    RegionPtr	    pCompositeClip;
+
+    PrivateRec	    *devPrivates;
+
+    PictTransform   *transform;
+
+    int		    filter;
+    xFixed	    *filter_params;
+    int		    filter_nparams;
+    SourcePictPtr   pSourcePict;
+} PictureRec;
+
+typedef Bool (*PictFilterValidateParamsProcPtr) (ScreenPtr pScreen, int id,
+						 xFixed *params, int nparams,
+						 int *width, int *height);
+typedef struct {
+    char			    *name;
+    int				    id;
+    PictFilterValidateParamsProcPtr ValidateParams;
+    int				    width, height;
+} PictFilterRec, *PictFilterPtr;
+
+#define PictFilterNearest	0
+#define PictFilterBilinear	1
+
+#define PictFilterFast		2
+#define PictFilterGood		3
+#define PictFilterBest		4
+
+#define PictFilterConvolution	5
+
+typedef struct {
+    char	    *alias;
+    int		    alias_id;
+    int		    filter_id;
+} PictFilterAliasRec, *PictFilterAliasPtr;
+
+typedef int	(*CreatePictureProcPtr)	    (PicturePtr pPicture);
+typedef void	(*DestroyPictureProcPtr)    (PicturePtr pPicture);
+typedef int	(*ChangePictureClipProcPtr) (PicturePtr	pPicture,
+					     int	clipType,
+					     pointer    value,
+					     int	n);
+typedef void	(*DestroyPictureClipProcPtr)(PicturePtr	pPicture);
+
+typedef int	(*ChangePictureTransformProcPtr)    (PicturePtr	    pPicture,
+						     PictTransform  *transform);
+
+typedef int	(*ChangePictureFilterProcPtr)	(PicturePtr	pPicture,
+						 int		filter,
+						 xFixed		*params,
+						 int		nparams);
+
+typedef void	(*DestroyPictureFilterProcPtr)	(PicturePtr pPicture);
+
+typedef void	(*ChangePictureProcPtr)	    (PicturePtr pPicture,
+					     Mask	mask);
+typedef void	(*ValidatePictureProcPtr)    (PicturePtr pPicture,
+					     Mask       mask);
+typedef void	(*CompositeProcPtr)	    (CARD8	op,
+					     PicturePtr pSrc,
+					     PicturePtr pMask,
+					     PicturePtr pDst,
+					     INT16	xSrc,
+					     INT16	ySrc,
+					     INT16	xMask,
+					     INT16	yMask,
+					     INT16	xDst,
+					     INT16	yDst,
+					     CARD16	width,
+					     CARD16	height);
+
+typedef void	(*GlyphsProcPtr)	    (CARD8      op,
+					     PicturePtr pSrc,
+					     PicturePtr pDst,
+					     PictFormatPtr  maskFormat,
+					     INT16      xSrc,
+					     INT16      ySrc,
+					     int	nlists,
+					     GlyphListPtr   lists,
+					     GlyphPtr	*glyphs);
+
+typedef void	(*CompositeRectsProcPtr)    (CARD8	    op,
+					     PicturePtr	    pDst,
+					     xRenderColor   *color,
+					     int	    nRect,
+					     xRectangle	    *rects);
+
+typedef void	(*RasterizeTrapezoidProcPtr)(PicturePtr	    pMask,
+					     xTrapezoid	    *trap,
+					     int	    x_off,
+					     int	    y_off);
+
+typedef void	(*TrapezoidsProcPtr)	    (CARD8	    op,
+					     PicturePtr	    pSrc,
+					     PicturePtr	    pDst,
+					     PictFormatPtr  maskFormat,
+					     INT16	    xSrc,
+					     INT16	    ySrc,
+					     int	    ntrap,
+					     xTrapezoid	    *traps);
+
+typedef void	(*TrianglesProcPtr)	    (CARD8	    op,
+					     PicturePtr	    pSrc,
+					     PicturePtr	    pDst,
+					     PictFormatPtr  maskFormat,
+					     INT16	    xSrc,
+					     INT16	    ySrc,
+					     int	    ntri,
+					     xTriangle	    *tris);
+
+typedef void	(*TriStripProcPtr)	    (CARD8	    op,
+					     PicturePtr	    pSrc,
+					     PicturePtr	    pDst,
+					     PictFormatPtr  maskFormat,
+					     INT16	    xSrc,
+					     INT16	    ySrc,
+					     int	    npoint,
+					     xPointFixed    *points);
+
+typedef void	(*TriFanProcPtr)	    (CARD8	    op,
+					     PicturePtr	    pSrc,
+					     PicturePtr	    pDst,
+					     PictFormatPtr  maskFormat,
+					     INT16	    xSrc,
+					     INT16	    ySrc,
+					     int	    npoint,
+					     xPointFixed    *points);
+
+typedef Bool	(*InitIndexedProcPtr)	    (ScreenPtr	    pScreen,
+					     PictFormatPtr  pFormat);
+
+typedef void	(*CloseIndexedProcPtr)	    (ScreenPtr	    pScreen,
+					     PictFormatPtr  pFormat);
+
+typedef void	(*UpdateIndexedProcPtr)	    (ScreenPtr	    pScreen,
+					     PictFormatPtr  pFormat,
+					     int	    ndef,
+					     xColorItem	    *pdef);
+
+typedef void	(*AddTrapsProcPtr)	    (PicturePtr	    pPicture,
+					     INT16	    xOff,
+					     INT16	    yOff,
+					     int	    ntrap,
+					     xTrap	    *traps);
+
+typedef void	(*AddTrianglesProcPtr)	    (PicturePtr	    pPicture,
+					     INT16	    xOff,
+					     INT16	    yOff,
+					     int	    ntri,
+					     xTriangle	    *tris);
+
+typedef Bool	(*RealizeGlyphProcPtr)	    (ScreenPtr	    pScreen,
+					     GlyphPtr	    glyph);
+
+typedef void	(*UnrealizeGlyphProcPtr)    (ScreenPtr	    pScreen,
+					     GlyphPtr	    glyph);
+
+typedef struct _PictureScreen {
+    PictFormatPtr		formats;
+    PictFormatPtr		fallback;
+    int				nformats;
+
+    CreatePictureProcPtr	CreatePicture;
+    DestroyPictureProcPtr	DestroyPicture;
+    ChangePictureClipProcPtr	ChangePictureClip;
+    DestroyPictureClipProcPtr	DestroyPictureClip;
+
+    ChangePictureProcPtr	ChangePicture;
+    ValidatePictureProcPtr	ValidatePicture;
+
+    CompositeProcPtr		Composite;
+    GlyphsProcPtr		Glyphs; /* unused */
+    CompositeRectsProcPtr	CompositeRects;
+
+    DestroyWindowProcPtr	DestroyWindow;
+    CloseScreenProcPtr		CloseScreen;
+
+    StoreColorsProcPtr		StoreColors;
+
+    InitIndexedProcPtr		InitIndexed;
+    CloseIndexedProcPtr		CloseIndexed;
+    UpdateIndexedProcPtr	UpdateIndexed;
+
+    int				subpixel;
+
+    PictFilterPtr		filters;
+    int				nfilters;
+    PictFilterAliasPtr		filterAliases;
+    int				nfilterAliases;
+
+    /**
+     * Called immediately after a picture's transform is changed through the
+     * SetPictureTransform request.  Not called for source-only pictures.
+     */
+    ChangePictureTransformProcPtr   ChangePictureTransform;
+
+    /**
+     * Called immediately after a picture's transform is changed through the
+     * SetPictureFilter request.  Not called for source-only pictures.
+     */
+    ChangePictureFilterProcPtr	ChangePictureFilter;
+
+    DestroyPictureFilterProcPtr	DestroyPictureFilter;
+
+    TrapezoidsProcPtr		Trapezoids;
+    TrianglesProcPtr		Triangles;
+    TriStripProcPtr		TriStrip;
+    TriFanProcPtr		TriFan;
+
+    RasterizeTrapezoidProcPtr	RasterizeTrapezoid;
+
+    AddTrianglesProcPtr		AddTriangles;
+
+    AddTrapsProcPtr		AddTraps;
+
+    RealizeGlyphProcPtr   	RealizeGlyph;
+    UnrealizeGlyphProcPtr 	UnrealizeGlyph;
+
+} PictureScreenRec, *PictureScreenPtr;
+
+extern _X_EXPORT DevPrivateKeyRec PictureScreenPrivateKeyRec;
+#define PictureScreenPrivateKey (&PictureScreenPrivateKeyRec)
+
+extern _X_EXPORT DevPrivateKeyRec PictureWindowPrivateKeyRec;
+#define	PictureWindowPrivateKey (&PictureWindowPrivateKeyRec)
+
+extern _X_EXPORT RESTYPE	PictureType;
+extern _X_EXPORT RESTYPE	PictFormatType;
+extern _X_EXPORT RESTYPE	GlyphSetType;
+
+#define GetPictureScreen(s) ((PictureScreenPtr)dixLookupPrivate(&(s)->devPrivates, PictureScreenPrivateKey))
+#define GetPictureScreenIfSet(s) (dixPrivateKeyRegistered(PictureScreenPrivateKey) ? GetPictureScreen(s) : NULL)
+#define SetPictureScreen(s,p) dixSetPrivate(&(s)->devPrivates, PictureScreenPrivateKey, p)
+#define GetPictureWindow(w) ((PicturePtr)dixLookupPrivate(&(w)->devPrivates, PictureWindowPrivateKey))
+#define SetPictureWindow(w,p) dixSetPrivate(&(w)->devPrivates, PictureWindowPrivateKey, p)
+
+#define VERIFY_PICTURE(pPicture, pid, client, mode) {\
+    int rc = dixLookupResourceByType((pointer)&(pPicture), pid,\
+	                             PictureType, client, mode);\
+    if (rc != Success)\
+	return rc;\
+}
+
+#define VERIFY_ALPHA(pPicture, pid, client, mode) {\
+    if (pid == None) \
+	pPicture = 0; \
+    else { \
+	VERIFY_PICTURE(pPicture, pid, client, mode); \
+    } \
+} \
+
+extern _X_EXPORT Bool
+PictureDestroyWindow (WindowPtr pWindow);
+
+extern _X_EXPORT Bool
+PictureCloseScreen (int Index, ScreenPtr pScreen);
+
+extern _X_EXPORT void
+PictureStoreColors (ColormapPtr pColormap, int ndef, xColorItem *pdef);
+
+extern _X_EXPORT Bool
+PictureInitIndexedFormat (ScreenPtr pScreen, PictFormatPtr format);
+
+extern _X_EXPORT Bool
+PictureSetSubpixelOrder (ScreenPtr pScreen, int subpixel);
+
+extern _X_EXPORT int
+PictureGetSubpixelOrder (ScreenPtr pScreen);
+
+extern _X_EXPORT PictFormatPtr
+PictureCreateDefaultFormats (ScreenPtr pScreen, int *nformatp);
+
+extern _X_EXPORT PictFormatPtr
+PictureMatchVisual (ScreenPtr pScreen, int depth, VisualPtr pVisual);
+
+extern _X_EXPORT PictFormatPtr
+PictureMatchFormat (ScreenPtr pScreen, int depth, CARD32 format);
+
+extern _X_EXPORT Bool
+PictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats);
+
+extern _X_EXPORT int
+PictureGetFilterId (char *filter, int len, Bool makeit);
+
+extern _X_EXPORT char *
+PictureGetFilterName (int id);
+
+extern _X_EXPORT int
+PictureAddFilter (ScreenPtr			    pScreen,
+		  char				    *filter,
+		  PictFilterValidateParamsProcPtr   ValidateParams,
+		  int				    width,
+		  int				    height);
+
+extern _X_EXPORT Bool
+PictureSetFilterAlias (ScreenPtr pScreen, char *filter, char *alias);
+
+extern _X_EXPORT Bool
+PictureSetDefaultFilters (ScreenPtr pScreen);
+
+extern _X_EXPORT void
+PictureResetFilters (ScreenPtr pScreen);
+
+extern _X_EXPORT PictFilterPtr
+PictureFindFilter (ScreenPtr pScreen, char *name, int len);
+
+extern _X_EXPORT int
+SetPicturePictFilter (PicturePtr pPicture, PictFilterPtr pFilter,
+		      xFixed *params, int nparams);
+
+extern _X_EXPORT int
+SetPictureFilter (PicturePtr pPicture, char *name, int len,
+		  xFixed *params, int nparams);
+
+extern _X_EXPORT Bool
+PictureFinishInit (void);
+
+extern _X_EXPORT void
+SetPictureToDefaults (PicturePtr pPicture);
+
+extern _X_EXPORT PicturePtr
+CreatePicture (Picture		pid,
+	       DrawablePtr	pDrawable,
+	       PictFormatPtr	pFormat,
+	       Mask		mask,
+	       XID		*list,
+	       ClientPtr	client,
+	       int		*error);
+
+extern _X_EXPORT int
+ChangePicture (PicturePtr	pPicture,
+	       Mask		vmask,
+	       XID		*vlist,
+	       DevUnion		*ulist,
+	       ClientPtr	client);
+
+extern _X_EXPORT int
+SetPictureClipRects (PicturePtr	pPicture,
+		     int	xOrigin,
+		     int	yOrigin,
+		     int	nRect,
+		     xRectangle	*rects);
+
+extern _X_EXPORT int
+SetPictureClipRegion (PicturePtr    pPicture,
+		      int	    xOrigin,
+		      int	    yOrigin,
+		      RegionPtr	    pRegion);
+
+extern _X_EXPORT int
+SetPictureTransform (PicturePtr	    pPicture,
+		     PictTransform  *transform);
+
+extern _X_EXPORT void
+CopyPicture (PicturePtr	pSrc,
+	     Mask	mask,
+	     PicturePtr	pDst);
+
+extern _X_EXPORT void
+ValidatePicture(PicturePtr pPicture);
+
+extern _X_EXPORT int
+FreePicture (pointer	pPicture,
+	     XID	pid);
+
+extern _X_EXPORT int
+FreePictFormat (pointer	pPictFormat,
+		XID     pid);
+
+extern _X_EXPORT void
+CompositePicture (CARD8		op,
+		  PicturePtr	pSrc,
+		  PicturePtr	pMask,
+		  PicturePtr	pDst,
+		  INT16		xSrc,
+		  INT16		ySrc,
+		  INT16		xMask,
+		  INT16		yMask,
+		  INT16		xDst,
+		  INT16		yDst,
+		  CARD16	width,
+		  CARD16	height);
+
+extern _X_EXPORT void
+CompositeGlyphs (CARD8		op,
+		 PicturePtr	pSrc,
+		 PicturePtr	pDst,
+		 PictFormatPtr	maskFormat,
+		 INT16		xSrc,
+		 INT16		ySrc,
+		 int		nlist,
+		 GlyphListPtr	lists,
+		 GlyphPtr	*glyphs);
+
+extern _X_EXPORT void
+CompositeRects (CARD8		op,
+		PicturePtr	pDst,
+		xRenderColor	*color,
+		int		nRect,
+		xRectangle      *rects);
+
+extern _X_EXPORT void
+CompositeTrapezoids (CARD8	    op,
+		     PicturePtr	    pSrc,
+		     PicturePtr	    pDst,
+		     PictFormatPtr  maskFormat,
+		     INT16	    xSrc,
+		     INT16	    ySrc,
+		     int	    ntrap,
+		     xTrapezoid	    *traps);
+
+extern _X_EXPORT void
+CompositeTriangles (CARD8	    op,
+		    PicturePtr	    pSrc,
+		    PicturePtr	    pDst,
+		    PictFormatPtr   maskFormat,
+		    INT16	    xSrc,
+		    INT16	    ySrc,
+		    int		    ntriangles,
+		    xTriangle	    *triangles);
+
+extern _X_EXPORT void
+CompositeTriStrip (CARD8	    op,
+		   PicturePtr	    pSrc,
+		   PicturePtr	    pDst,
+		   PictFormatPtr    maskFormat,
+		   INT16	    xSrc,
+		   INT16	    ySrc,
+		   int		    npoints,
+		   xPointFixed	    *points);
+
+extern _X_EXPORT void
+CompositeTriFan (CARD8		op,
+		 PicturePtr	pSrc,
+		 PicturePtr	pDst,
+		 PictFormatPtr	maskFormat,
+		 INT16		xSrc,
+		 INT16		ySrc,
+		 int		npoints,
+		 xPointFixed	*points);
+
+extern _X_EXPORT CARD32
+PictureGradientColor (PictGradientStopPtr stop1,
+		      PictGradientStopPtr stop2,
+		      CARD32	          x);
+
+extern _X_EXPORT void RenderExtensionInit (void);
+
+Bool
+AnimCurInit (ScreenPtr pScreen);
+
+int
+AnimCursorCreate (CursorPtr *cursors, CARD32 *deltas, int ncursor, CursorPtr *ppCursor, ClientPtr client, XID cid);
+
+extern _X_EXPORT void
+AddTraps (PicturePtr	pPicture,
+	  INT16		xOff,
+	  INT16		yOff,
+	  int		ntraps,
+	  xTrap		*traps);
+
+extern _X_EXPORT PicturePtr
+CreateSolidPicture (Picture pid,
+                    xRenderColor *color,
+                    int *error);
+
+extern _X_EXPORT PicturePtr
+CreateLinearGradientPicture (Picture pid,
+                             xPointFixed *p1,
+                             xPointFixed *p2,
+                             int nStops,
+                             xFixed *stops,
+                             xRenderColor *colors,
+                             int *error);
+
+extern _X_EXPORT PicturePtr
+CreateRadialGradientPicture (Picture pid,
+                             xPointFixed *inner,
+                             xPointFixed *outer,
+                             xFixed innerRadius,
+                             xFixed outerRadius,
+                             int nStops,
+                             xFixed *stops,
+                             xRenderColor *colors,
+                             int *error);
+
+extern _X_EXPORT PicturePtr
+CreateConicalGradientPicture (Picture pid,
+                              xPointFixed *center,
+                              xFixed angle,
+                              int nStops,
+                              xFixed *stops,
+                              xRenderColor *colors,
+                              int *error);
+
+#ifdef PANORAMIX
+extern _X_EXPORT void PanoramiXRenderInit (void);
+extern _X_EXPORT void PanoramiXRenderReset (void);
+#endif
+
+/*
+ * matrix.c
+ */
+
+extern _X_EXPORT void
+PictTransform_from_xRenderTransform (PictTransformPtr pict,
+				     xRenderTransform *render);
+
+extern _X_EXPORT void
+xRenderTransform_from_PictTransform (xRenderTransform *render,
+				     PictTransformPtr pict);
+
+extern _X_EXPORT Bool
+PictureTransformPoint (PictTransformPtr transform,
+		       PictVectorPtr	vector);
+
+extern _X_EXPORT Bool
+PictureTransformPoint3d (PictTransformPtr transform,
+                         PictVectorPtr	vector);
+
+#endif /* _PICTURESTR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/types.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/types.h
@@ -0,0 +1,81 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for x86 emulator type definitions.
+*
+****************************************************************************/
+
+
+#ifndef __X86EMU_TYPES_H
+#define __X86EMU_TYPES_H
+
+#ifndef NO_SYS_HEADERS
+#include <sys/types.h>
+#endif
+
+/*
+ * The following kludge is an attempt to work around typedef conflicts with
+ * <sys/types.h>.
+ */
+#define u8   x86emuu8
+#define u16  x86emuu16
+#define u32  x86emuu32
+#define u64  x86emuu64
+#define s8   x86emus8
+#define s16  x86emus16
+#define s32  x86emus32
+#define s64  x86emus64
+#define uint x86emuuint
+#define sint x86emusint
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#include <stdint.h>
+
+typedef uint8_t				u8;
+typedef uint16_t			u16;
+typedef uint32_t			u32;
+typedef uint64_t	 		u64;
+
+typedef int8_t 				s8;
+typedef int16_t				s16;
+typedef int32_t				s32;
+typedef int64_t				s64;
+
+typedef unsigned int			uint;
+typedef int 				sint;
+
+typedef u16 X86EMU_pioAddr;
+
+#endif	/* __X86EMU_TYPES_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extension.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extension.h
@@ -0,0 +1,67 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef EXTENSION_H
+#define EXTENSION_H 
+
+_XFUNCPROTOBEGIN
+
+extern _X_EXPORT unsigned short StandardMinorOpcode(ClientPtr /*client*/);
+
+extern _X_EXPORT unsigned short MinorOpcodeOfRequest(ClientPtr /*client*/);
+
+extern _X_EXPORT Bool EnableDisableExtension(char *name, Bool enable);
+
+extern _X_EXPORT void EnableDisableExtensionError(char *name, Bool enable);
+
+extern _X_EXPORT void InitExtensions(int argc, char **argv);
+
+extern _X_EXPORT void CloseDownExtensions(void);
+
+_XFUNCPROTOEND
+
+#endif /* EXTENSION_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-common.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/usb-common.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to common USB support.  \see usb-common.c \see usb-mouse.c
+ * \see usb-keyboard.c \see usb-other.c */
+
+#ifndef _USB_COMMON_H_
+#define _USB_COMMON_H_
+typedef enum {
+    usbMouse,
+    usbKeyboard,
+    usbOther
+} usbType;
+
+extern pointer usbCreatePrivate(DeviceIntPtr pDevice);
+extern void    usbDestroyPrivate(pointer priv);
+extern void    usbRead(DevicePtr pDev,
+                       dmxMotionProcPtr motion,
+                       dmxEnqueueProcPtr enqueue,
+                       int minButton,
+                       DMXBlockType block);
+extern void    usbInit(DevicePtr pDev, usbType type);
+extern void    usbOff(DevicePtr pDev);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86tokens.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xf86tokens.h
@@ -0,0 +1,295 @@
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef _xf86_tokens_h
+#define _xf86_tokens_h
+
+/* Undefine symbols that some OSs might define */
+#undef IOBASE
+
+/* 
+ * Each token should have a unique value regardless of the section
+ * it is used in.
+ */
+
+typedef enum {
+    /* errno-style tokens */
+    OBSOLETE_TOKEN	= -5,
+    EOF_TOKEN		= -4,
+    LOCK_TOKEN		= -3,
+    ERROR_TOKEN		= -2,
+
+    /* value type tokens */
+    NUMBER		= 1,
+    STRING,
+
+    /* Tokens that can appear in many sections */
+    SECTION,
+    SUBSECTION,
+    ENDSECTION,
+    ENDSUBSECTION,
+    IDENTIFIER,
+    VENDOR,
+    DASH,
+    COMMA,
+    OPTION,
+    COMMENT,
+
+    /* Frequency units */
+    HRZ,
+    KHZ,
+    MHZ,
+
+    /* File tokens */
+    FONTPATH,
+    MODULEPATH,
+    LOGFILEPATH,
+    XKBDIR,
+
+    /* Server Flag tokens.  These are deprecated in favour of generic Options */
+    NOTRAPSIGNALS,
+    DONTZAP,
+    DONTZOOM,
+    DISABLEVIDMODE,
+    ALLOWNONLOCAL,
+    DISABLEMODINDEV,
+    MODINDEVALLOWNONLOCAL,
+    ALLOWMOUSEOPENFAIL,
+    BLANKTIME,
+    STANDBYTIME,
+    SUSPENDTIME,
+    OFFTIME,
+    DEFAULTLAYOUT,
+
+    /* Monitor tokens */
+    MODEL,
+    MODELINE,
+    DISPLAYSIZE,
+    HORIZSYNC,
+    VERTREFRESH,
+    MODE,
+    GAMMA,
+    USEMODES,
+
+    /* Modes tokens */
+    /* no new ones */
+
+    /* Mode tokens */
+    DOTCLOCK,
+    HTIMINGS,
+    VTIMINGS,
+    FLAGS,
+    HSKEW,
+    BCAST,
+    VSCAN,
+    ENDMODE,
+
+    /* Screen tokens */
+    OBSDRIVER,
+    MDEVICE,
+    MONITOR,
+    SCREENNO,
+    DEFAULTDEPTH,
+    DEFAULTBPP,
+    DEFAULTFBBPP,
+    
+    /* VideoAdaptor tokens */
+    VIDEOADAPTOR,
+
+    /* Mode timing tokens */
+    TT_INTERLACE,
+    TT_PHSYNC,
+    TT_NHSYNC,
+    TT_PVSYNC,
+    TT_NVSYNC,
+    TT_CSYNC,
+    TT_PCSYNC,
+    TT_NCSYNC,
+    TT_DBLSCAN,
+    TT_HSKEW,
+    TT_BCAST,
+    TT_VSCAN,
+    TT_CUSTOM,
+
+    /* Module tokens */
+    LOAD,
+    LOAD_DRIVER,
+    DISABLE,
+    
+    /* Device tokens */
+    DRIVER,
+    CHIPSET,
+    CLOCKS,
+    VIDEORAM,
+    BOARD,
+    IOBASE,
+    RAMDAC,
+    DACSPEED,
+    BIOSBASE,
+    MEMBASE,
+    CLOCKCHIP,
+    CHIPID,
+    CHIPREV,
+    CARD,
+    BUSID,
+    TEXTCLOCKFRQ,
+    IRQ,
+
+    /* Keyboard tokens */
+    AUTOREPEAT,
+    XLEDS,
+    KPROTOCOL,
+    XKBKEYMAP,
+    XKBCOMPAT,
+    XKBTYPES,
+    XKBKEYCODES,
+    XKBGEOMETRY,
+    XKBSYMBOLS,
+    XKBDISABLE,
+    PANIX106,
+    XKBRULES,
+    XKBMODEL,
+    XKBLAYOUT,
+    XKBVARIANT,
+    XKBOPTIONS,
+    /* The next two have become ServerFlags options */
+    VTSYSREQ,
+    /* Obsolete keyboard tokens */
+    SERVERNUM,
+    LEFTALT,
+    RIGHTALT,
+    SCROLLLOCK_TOK,
+    RIGHTCTL,
+    /* arguments for the above obsolete tokens */
+    CONF_KM_META,
+    CONF_KM_COMPOSE,
+    CONF_KM_MODESHIFT,
+    CONF_KM_MODELOCK,
+    CONF_KM_SCROLLLOCK,
+    CONF_KM_CONTROL,
+
+    /* Pointer tokens */
+    EMULATE3,
+    BAUDRATE,
+    SAMPLERATE,
+    PRESOLUTION,
+    CLEARDTR,
+    CLEARRTS,
+    CHORDMIDDLE,
+    PROTOCOL,
+    PDEVICE,
+    EM3TIMEOUT,
+    DEVICE_NAME,
+    ALWAYSCORE,
+    PBUTTONS,
+    ZAXISMAPPING,
+
+    /* Pointer Z axis mapping tokens */
+    XAXIS,
+    YAXIS,
+
+    /* Display tokens */
+    MODES,
+    VIEWPORT,
+    VIRTUAL,
+    VISUAL,
+    BLACK_TOK,
+    WHITE_TOK,
+    DEPTH,
+    BPP,
+    WEIGHT,
+    
+    /* Layout Tokens */
+    SCREEN,
+    INACTIVE,
+    INPUTDEVICE,
+
+    /* Adjaceny Tokens */
+    RIGHTOF,
+    LEFTOF,
+    ABOVE,
+    BELOW,
+    RELATIVE,
+    ABSOLUTE,
+
+    /* Vendor Tokens */
+    VENDORNAME,
+
+    /* DRI Tokens */
+    GROUP,
+    BUFFERS,
+
+    /* InputClass Tokens */
+    MATCH_PRODUCT,
+    MATCH_VENDOR,
+    MATCH_DEVICE_PATH,
+    MATCH_OS,
+    MATCH_PNPID,
+    MATCH_USBID,
+    MATCH_DRIVER,
+    MATCH_TAG,
+    MATCH_IS_KEYBOARD,
+    MATCH_IS_POINTER,
+    MATCH_IS_JOYSTICK,
+    MATCH_IS_TABLET,
+    MATCH_IS_TOUCHPAD,
+    MATCH_IS_TOUCHSCREEN
+} ParserTokens;
+
+#endif /* _xf86_tokens_h */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xace.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xace.h
@@ -0,0 +1,131 @@
+/************************************************************
+
+Author: Eamon Walsh <ewalsh@tycho.nsa.gov>
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+this permission notice appear in supporting documentation.  This permission
+notice shall be included in all copies or substantial portions of the
+Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+********************************************************/
+
+#ifndef _XACE_H
+#define _XACE_H
+
+#ifdef XACE
+
+#define XACE_MAJOR_VERSION		2
+#define XACE_MINOR_VERSION		0
+
+#include "pixmap.h"
+#include "region.h"
+#include "window.h"
+#include "property.h"
+#include "selection.h"
+
+/* Default window background */
+#define XaceBackgroundNoneState(w) ((w)->forcedBG ? BackgroundPixel : None)
+
+/* security hooks */
+/* Constants used to identify the available security hooks
+ */
+#define XACE_CORE_DISPATCH		0
+#define XACE_EXT_DISPATCH		1
+#define XACE_RESOURCE_ACCESS		2
+#define XACE_DEVICE_ACCESS		3
+#define XACE_PROPERTY_ACCESS		4
+#define XACE_SEND_ACCESS		5
+#define XACE_RECEIVE_ACCESS		6
+#define XACE_CLIENT_ACCESS		7
+#define XACE_EXT_ACCESS			8
+#define XACE_SERVER_ACCESS		9
+#define XACE_SELECTION_ACCESS		10
+#define XACE_SCREEN_ACCESS		11
+#define XACE_SCREENSAVER_ACCESS		12
+#define XACE_AUTH_AVAIL			13
+#define XACE_KEY_AVAIL			14
+#define XACE_AUDIT_BEGIN		15
+#define XACE_AUDIT_END			16
+#define XACE_NUM_HOOKS			17
+
+extern _X_EXPORT CallbackListPtr XaceHooks[XACE_NUM_HOOKS];
+
+/* Entry point for hook functions.  Called by Xserver.
+ * Required by libdbe and libextmod
+ */
+extern _X_EXPORT int XaceHook(
+    int /*hook*/,
+    ... /*appropriate args for hook*/
+    ); 
+
+/* Special-cased hook functions
+ */
+extern _X_EXPORT int XaceHookDispatch(ClientPtr ptr, int major);
+extern _X_EXPORT int XaceHookPropertyAccess(ClientPtr ptr, WindowPtr pWin,
+				   PropertyPtr *ppProp, Mask access_mode);
+extern _X_EXPORT int XaceHookSelectionAccess(ClientPtr ptr,
+				   Selection **ppSel, Mask access_mode);
+extern _X_EXPORT void XaceHookAuditEnd(ClientPtr ptr, int result);
+
+/* Register a callback for a given hook.
+ */
+#define XaceRegisterCallback(hook,callback,data) \
+    AddCallback(XaceHooks+(hook), callback, data)
+
+/* Unregister an existing callback for a given hook.
+ */
+#define XaceDeleteCallback(hook,callback,data) \
+    DeleteCallback(XaceHooks+(hook), callback, data)
+
+/* XTrans wrappers for use by security modules
+ */
+extern _X_EXPORT int XaceGetConnectionNumber(ClientPtr ptr);
+extern _X_EXPORT int XaceIsLocal(ClientPtr ptr);
+
+/* From the original Security extension...
+ */
+
+extern _X_EXPORT void XaceCensorImage(
+    ClientPtr client,
+    RegionPtr pVisibleRegion,
+    long widthBytesLine,
+    DrawablePtr pDraw,
+    int x, int y, int w, int h,
+    unsigned int format,
+    char * pBuf
+    );
+
+#else /* XACE */
+
+/* Default window background */
+#define XaceBackgroundNoneState(w)		None
+
+/* Define calls away when XACE is not being built. */
+
+#ifdef __GNUC__
+#define XaceHook(args...) Success
+#define XaceHookDispatch(args...) Success
+#define XaceHookPropertyAccess(args...) Success
+#define XaceHookSelectionAccess(args...) Success
+#define XaceHookAuditEnd(args...) { ; }
+#define XaceCensorImage(args...) { ; }
+#else
+#define XaceHook(...) Success
+#define XaceHookDispatch(...) Success
+#define XaceHookPropertyAccess(...) Success
+#define XaceHookSelectionAccess(...) Success
+#define XaceHookAuditEnd(...) { ; }
+#define XaceCensorImage(...) { ; }
+#endif
+
+#endif /* XACE */
+
+#endif /* _XACE_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sendexev.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/sendexev.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef SENDEXEV_H
+#define SENDEXEV_H 1
+
+int SProcXSendExtensionEvent(ClientPtr	/* client */
+    );
+
+int ProcXSendExtensionEvent(ClientPtr	/* client */
+    );
+
+#endif /* SENDEXEV_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdevk.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/grabdevk.h
@@ -0,0 +1,39 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef GRABDEVK_H
+#define GRABDEVK_H 1
+
+int SProcXGrabDeviceKey(ClientPtr	/* client */
+    );
+
+int ProcXGrabDeviceKey(ClientPtr	/* client */
+    );
+
+#endif /* GRABDEVK_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgptr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/chgptr.h
@@ -0,0 +1,48 @@
+/************************************************************
+
+Copyright 1996 by Thomas E. Dickey <dickey@clark.net>
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of the above listed
+copyright holder(s) not be used in advertising or publicity pertaining
+to distribution of the software without specific, written prior
+permission.
+
+THE ABOVE LISTED COPYRIGHT HOLDER(S) DISCLAIM ALL WARRANTIES WITH REGARD
+TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS, IN NO EVENT SHALL THE ABOVE LISTED COPYRIGHT HOLDER(S) BE
+LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+********************************************************/
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef CHGPTR_H
+#define CHGPTR_H 1
+
+int SProcXChangePointerDevice(ClientPtr	/* client */
+    );
+
+int ProcXChangePointerDevice(ClientPtr	/* client */
+    );
+
+void DeleteFocusClassDeviceStruct(DeviceIntPtr	/* dev */
+    );
+
+void SendEventToAllWindows(DeviceIntPtr /* dev */ ,
+			   Mask /* mask */ ,
+			   xEvent * /* ev */ ,
+			   int	/* count */
+    );
+
+#endif /* CHGPTR_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fb.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fb.h
@@ -0,0 +1,2091 @@
+/*
+ *
+ * Copyright © 1998 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+
+#ifndef _FB_H_
+#define _FB_H_
+
+#include <X11/X.h>
+#include <pixman.h>
+
+#include "scrnintstr.h"
+#include "pixmap.h"
+#include "pixmapstr.h"
+#include "region.h"
+#include "gcstruct.h"
+#include "colormap.h"
+#include "miscstruct.h"
+#include "servermd.h"
+#include "windowstr.h"
+#include "privates.h"
+#include "mi.h"
+#include "migc.h"
+#include "mibstore.h"
+#include "picturestr.h"
+
+#ifdef FB_ACCESS_WRAPPER
+
+#include "wfbrename.h"
+#define FBPREFIX(x) wfb##x
+#define WRITE(ptr, val) ((*wfbWriteMemory)((ptr), (val), sizeof(*(ptr))))
+#define READ(ptr) ((*wfbReadMemory)((ptr), sizeof(*(ptr))))
+
+#define MEMCPY_WRAPPED(dst, src, size) do {                       \
+    size_t _i;                                                    \
+    CARD8 *_dst = (CARD8*)(dst), *_src = (CARD8*)(src);           \
+    for(_i = 0; _i < size; _i++) {                                \
+        WRITE(_dst +_i, READ(_src + _i));                         \
+    }                                                             \
+} while(0)
+
+#define MEMSET_WRAPPED(dst, val, size) do {                       \
+    size_t _i;                                                    \
+    CARD8 *_dst = (CARD8*)(dst);                                  \
+    for(_i = 0; _i < size; _i++) {                                \
+        WRITE(_dst +_i, (val));                                   \
+    }                                                             \
+} while(0)
+
+#else
+
+#define FBPREFIX(x) fb##x
+#define WRITE(ptr, val) (*(ptr) = (val))
+#define READ(ptr) (*(ptr))
+#define MEMCPY_WRAPPED(dst, src, size) memcpy((dst), (src), (size))
+#define MEMSET_WRAPPED(dst, val, size) memset((dst), (val), (size))
+
+#endif
+
+/*
+ * This single define controls the basic size of data manipulated
+ * by this software; it must be log2(sizeof (FbBits) * 8)
+ */
+
+#ifndef FB_SHIFT
+#define FB_SHIFT    LOG2_BITMAP_PAD
+#endif
+
+#if FB_SHIFT < LOG2_BITMAP_PAD
+    error FB_SHIFT must be >= LOG2_BITMAP_PAD
+#endif
+    
+#define FB_UNIT	    (1 << FB_SHIFT)
+#define FB_HALFUNIT (1 << (FB_SHIFT-1))
+#define FB_MASK	    (FB_UNIT - 1)
+#define FB_ALLONES  ((FbBits) -1)
+    
+#if GLYPHPADBYTES != 4
+#error "GLYPHPADBYTES must be 4"
+#endif
+/* whether to bother to include 24bpp support */
+#ifndef FBNO24BIT
+#define FB_24BIT
+#endif
+
+/*
+ * Unless otherwise instructed, fb includes code to advertise 24bpp
+ * windows with 32bpp image format for application compatibility
+ */
+
+#ifdef FB_24BIT
+#ifndef FBNO24_32
+#define FB_24_32BIT
+#endif
+#endif
+
+#define FB_STIP_SHIFT	LOG2_BITMAP_PAD
+#define FB_STIP_UNIT	(1 << FB_STIP_SHIFT)
+#define FB_STIP_MASK	(FB_STIP_UNIT - 1)
+#define FB_STIP_ALLONES	((FbStip) -1)
+    
+#define FB_STIP_ODDSTRIDE(s)	(((s) & (FB_MASK >> FB_STIP_SHIFT)) != 0)
+#define FB_STIP_ODDPTR(p)	((((long) (p)) & (FB_MASK >> 3)) != 0)
+    
+#define FbStipStrideToBitsStride(s) (((s) >> (FB_SHIFT - FB_STIP_SHIFT)))
+#define FbBitsStrideToStipStride(s) (((s) << (FB_SHIFT - FB_STIP_SHIFT)))
+    
+#define FbFullMask(n)   ((n) == FB_UNIT ? FB_ALLONES : ((((FbBits) 1) << n) - 1))
+    
+#if FB_SHIFT == 6
+# ifdef WIN32
+typedef unsigned __int64    FbBits;
+# else
+#  if defined(__alpha__) || defined(__alpha) || \
+      defined(ia64) || defined(__ia64__) || \
+      defined(__sparc64__) || defined(_LP64) || \
+      defined(__s390x__) || \
+      defined(amd64) || defined (__amd64__) || \
+      defined (__powerpc64__)
+typedef unsigned long	    FbBits;
+#  else
+typedef unsigned long long  FbBits;
+#  endif
+# endif
+#endif
+
+#if FB_SHIFT == 5
+typedef CARD32		    FbBits;
+#endif
+
+#if FB_SHIFT == 4
+typedef CARD16		    FbBits;
+#endif
+
+#if LOG2_BITMAP_PAD == FB_SHIFT
+typedef FbBits		    FbStip;
+#else
+# if LOG2_BITMAP_PAD == 5
+typedef CARD32		    FbStip;
+# endif
+#endif
+
+typedef int		    FbStride;
+
+
+#ifdef FB_DEBUG
+extern _X_EXPORT void fbValidateDrawable(DrawablePtr d);
+extern _X_EXPORT void fbInitializeDrawable(DrawablePtr d);
+extern _X_EXPORT void fbSetBits (FbStip *bits, int stride, FbStip data);
+#define FB_HEAD_BITS   (FbStip) (0xbaadf00d)
+#define FB_TAIL_BITS   (FbStip) (0xbaddf0ad)
+#else
+#define fbValidateDrawable(d)
+#define fdInitializeDrawable(d)
+#endif
+
+#include "fbrop.h"
+
+#if BITMAP_BIT_ORDER == LSBFirst
+#define FbScrLeft(x,n)	((x) >> (n))
+#define FbScrRight(x,n)	((x) << (n))
+/* #define FbLeftBits(x,n)	((x) & ((((FbBits) 1) << (n)) - 1)) */
+#define FbLeftStipBits(x,n) ((x) & ((((FbStip) 1) << (n)) - 1))
+#define FbStipMoveLsb(x,s,n)	(FbStipRight (x,(s)-(n)))
+#define FbPatternOffsetBits	0
+#else
+#define FbScrLeft(x,n)	((x) << (n))
+#define FbScrRight(x,n)	((x) >> (n))
+/* #define FbLeftBits(x,n)	((x) >> (FB_UNIT - (n))) */
+#define FbLeftStipBits(x,n) ((x) >> (FB_STIP_UNIT - (n)))
+#define FbStipMoveLsb(x,s,n)	(x)
+#define FbPatternOffsetBits	(sizeof (FbBits) - 1)
+#endif
+
+#include "micoord.h"
+
+#define FbStipLeft(x,n)	FbScrLeft(x,n)
+#define FbStipRight(x,n) FbScrRight(x,n)
+
+#define FbRotLeft(x,n)	FbScrLeft(x,n) | (n ? FbScrRight(x,FB_UNIT-n) : 0)
+#define FbRotRight(x,n)	FbScrRight(x,n) | (n ? FbScrLeft(x,FB_UNIT-n) : 0)
+
+#define FbRotStipLeft(x,n)  FbStipLeft(x,n) | (n ? FbStipRight(x,FB_STIP_UNIT-n) : 0)
+#define FbRotStipRight(x,n)  FbStipRight(x,n) | (n ? FbStipLeft(x,FB_STIP_UNIT-n) : 0)
+
+#define FbLeftMask(x)	    ( ((x) & FB_MASK) ? \
+			     FbScrRight(FB_ALLONES,(x) & FB_MASK) : 0)
+#define FbRightMask(x)	    ( ((FB_UNIT - (x)) & FB_MASK) ? \
+			     FbScrLeft(FB_ALLONES,(FB_UNIT - (x)) & FB_MASK) : 0)
+
+#define FbLeftStipMask(x)   ( ((x) & FB_STIP_MASK) ? \
+			     FbStipRight(FB_STIP_ALLONES,(x) & FB_STIP_MASK) : 0)
+#define FbRightStipMask(x)  ( ((FB_STIP_UNIT - (x)) & FB_STIP_MASK) ? \
+			     FbScrLeft(FB_STIP_ALLONES,(FB_STIP_UNIT - (x)) & FB_STIP_MASK) : 0)
+
+#define FbBitsMask(x,w)	(FbScrRight(FB_ALLONES,(x) & FB_MASK) & \
+			 FbScrLeft(FB_ALLONES,(FB_UNIT - ((x) + (w))) & FB_MASK))
+
+#define FbStipMask(x,w)	(FbStipRight(FB_STIP_ALLONES,(x) & FB_STIP_MASK) & \
+			 FbStipLeft(FB_STIP_ALLONES,(FB_STIP_UNIT - ((x)+(w))) & FB_STIP_MASK))
+
+
+#define FbMaskBits(x,w,l,n,r) { \
+    n = (w); \
+    r = FbRightMask((x)+n); \
+    l = FbLeftMask(x); \
+    if (l) { \
+	n -= FB_UNIT - ((x) & FB_MASK); \
+	if (n < 0) { \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	} \
+    } \
+    n >>= FB_SHIFT; \
+}
+
+#ifdef FBNOPIXADDR
+#define FbMaskBitsBytes(x,w,copy,l,lb,n,r,rb) FbMaskBits(x,w,l,n,r)
+#define FbDoLeftMaskByteRRop(dst,lb,l,and,xor) { \
+    *dst = FbDoMaskRRop(*dst,and,xor,l); \
+}
+#define FbDoRightMaskByteRRop(dst,rb,r,and,xor) { \
+    *dst = FbDoMaskRRop(*dst,and,xor,r); \
+}
+#else
+
+#define FbByteMaskInvalid   0x10
+
+#define FbPatternOffset(o,t)  ((o) ^ (FbPatternOffsetBits & ~(sizeof (t) - 1)))
+
+#define FbPtrOffset(p,o,t)		((t *) ((CARD8 *) (p) + (o)))
+#define FbSelectPatternPart(xor,o,t)	((xor) >> (FbPatternOffset (o,t) << 3))
+#define FbStorePart(dst,off,t,xor)	(WRITE(FbPtrOffset(dst,off,t), \
+					 FbSelectPart(xor,off,t)))
+#ifndef FbSelectPart
+#define FbSelectPart(x,o,t) FbSelectPatternPart(x,o,t)
+#endif
+
+#define FbMaskBitsBytes(x,w,copy,l,lb,n,r,rb) { \
+    n = (w); \
+    lb = 0; \
+    rb = 0; \
+    r = FbRightMask((x)+n); \
+    if (r) { \
+	/* compute right byte length */ \
+	if ((copy) && (((x) + n) & 7) == 0) { \
+	    rb = (((x) + n) & FB_MASK) >> 3; \
+	} else { \
+	    rb = FbByteMaskInvalid; \
+	} \
+    } \
+    l = FbLeftMask(x); \
+    if (l) { \
+	/* compute left byte length */ \
+	if ((copy) && ((x) & 7) == 0) { \
+	    lb = ((x) & FB_MASK) >> 3; \
+	} else { \
+	    lb = FbByteMaskInvalid; \
+	} \
+	/* subtract out the portion painted by leftMask */ \
+	n -= FB_UNIT - ((x) & FB_MASK); \
+	if (n < 0) { \
+	    if (lb != FbByteMaskInvalid) { \
+		if (rb == FbByteMaskInvalid) { \
+		    lb = FbByteMaskInvalid; \
+		} else if (rb) { \
+		    lb |= (rb - lb) << (FB_SHIFT - 3); \
+		    rb = 0; \
+		} \
+	    } \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	}\
+    } \
+    n >>= FB_SHIFT; \
+}
+
+#if FB_SHIFT == 6
+#define FbDoLeftMaskByteRRop6Cases(dst,xor) \
+    case (sizeof (FbBits) - 7) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (5 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 7) | (6 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 7): \
+	FbStorePart(dst,sizeof (FbBits) - 7,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 6) | (5 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 6): \
+	FbStorePart(dst,sizeof (FbBits) - 6,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 5) | (4 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 5): \
+	FbStorePart(dst,sizeof (FbBits) - 5,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	break; \
+    case (sizeof (FbBits) - 4) | (3 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD16,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 4): \
+	FbStorePart(dst,sizeof (FbBits) - 4,CARD32,xor); \
+	break;
+
+#define FbDoRightMaskByteRRop6Cases(dst,xor) \
+    case 4: \
+	FbStorePart(dst,0,CARD32,xor); \
+	break; \
+    case 5: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD8,xor); \
+	break; \
+    case 6: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD16,xor); \
+	break; \
+    case 7: \
+	FbStorePart(dst,0,CARD32,xor); \
+	FbStorePart(dst,4,CARD16,xor); \
+	FbStorePart(dst,6,CARD8,xor); \
+	break;
+#else
+#define FbDoLeftMaskByteRRop6Cases(dst,xor)
+#define FbDoRightMaskByteRRop6Cases(dst,xor)
+#endif
+
+#define FbDoLeftMaskByteRRop(dst,lb,l,and,xor) { \
+    switch (lb) { \
+    FbDoLeftMaskByteRRop6Cases(dst,xor) \
+    case (sizeof (FbBits) - 3) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 3) | (2 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case (sizeof (FbBits) - 2) | (1 << (FB_SHIFT - 3)): \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD8,xor); \
+	break; \
+    case sizeof (FbBits) - 3: \
+	FbStorePart(dst,sizeof (FbBits) - 3,CARD8,xor); \
+    case sizeof (FbBits) - 2: \
+	FbStorePart(dst,sizeof (FbBits) - 2,CARD16,xor); \
+	break; \
+    case sizeof (FbBits) - 1: \
+	FbStorePart(dst,sizeof (FbBits) - 1,CARD8,xor); \
+	break; \
+    default: \
+	WRITE(dst, FbDoMaskRRop(READ(dst), and, xor, l)); \
+	break; \
+    } \
+}
+
+
+#define FbDoRightMaskByteRRop(dst,rb,r,and,xor) { \
+    switch (rb) { \
+    case 1: \
+	FbStorePart(dst,0,CARD8,xor); \
+	break; \
+    case 2: \
+	FbStorePart(dst,0,CARD16,xor); \
+	break; \
+    case 3: \
+	FbStorePart(dst,0,CARD16,xor); \
+	FbStorePart(dst,2,CARD8,xor); \
+	break; \
+    FbDoRightMaskByteRRop6Cases(dst,xor) \
+    default: \
+	WRITE(dst, FbDoMaskRRop (READ(dst), and, xor, r)); \
+    } \
+}
+#endif
+
+#define FbMaskStip(x,w,l,n,r) { \
+    n = (w); \
+    r = FbRightStipMask((x)+n); \
+    l = FbLeftStipMask(x); \
+    if (l) { \
+	n -= FB_STIP_UNIT - ((x) & FB_STIP_MASK); \
+	if (n < 0) { \
+	    n = 0; \
+	    l &= r; \
+	    r = 0; \
+	} \
+    } \
+    n >>= FB_STIP_SHIFT; \
+}
+
+/*
+ * These macros are used to transparently stipple
+ * in copy mode; the expected usage is with 'n' constant
+ * so all of the conditional parts collapse into a minimal
+ * sequence of partial word writes
+ *
+ * 'n' is the bytemask of which bytes to store, 'a' is the address
+ * of the FbBits base unit, 'o' is the offset within that unit
+ *
+ * The term "lane" comes from the hardware term "byte-lane" which
+ */
+
+#define FbLaneCase1(n,a,o)						\
+    if ((n) == 0x01) {							\
+	WRITE((CARD8 *) ((a)+FbPatternOffset(o,CARD8)), fgxor);		\
+    }
+
+#define FbLaneCase2(n,a,o)						\
+    if ((n) == 0x03) {							\
+	WRITE((CARD16 *) ((a)+FbPatternOffset(o,CARD16)), fgxor);	\
+    } else {								\
+	FbLaneCase1((n)&1,a,o)						\
+	FbLaneCase1((n)>>1,a,(o)+1)					\
+    }
+
+#define FbLaneCase4(n,a,o)						\
+    if ((n) == 0x0f) {							\
+	WRITE((CARD32 *) ((a)+FbPatternOffset(o,CARD32)), fgxor);	\
+    } else {								\
+	FbLaneCase2((n)&3,a,o)						\
+	FbLaneCase2((n)>>2,a,(o)+2)					\
+    }
+
+#define FbLaneCase8(n,a,o)						\
+    if ((n) == 0x0ff) {							\
+	*(FbBits *) ((a)+(o)) = fgxor;					\
+    } else {								\
+	FbLaneCase4((n)&15,a,o)						\
+	FbLaneCase4((n)>>4,a,(o)+4)					\
+    }
+
+#if FB_SHIFT == 6
+#define FbLaneCase(n,a)   FbLaneCase8(n,(CARD8 *) (a),0)
+#endif
+
+#if FB_SHIFT == 5
+#define FbLaneCase(n,a)   FbLaneCase4(n,(CARD8 *) (a),0)
+#endif
+
+/* Rotate a filled pixel value to the specified alignement */
+#define FbRot24(p,b)	    (FbScrRight(p,b) | FbScrLeft(p,24-(b)))
+#define FbRot24Stip(p,b)    (FbStipRight(p,b) | FbStipLeft(p,24-(b)))
+
+/* step a filled pixel value to the next/previous FB_UNIT alignment */
+#define FbNext24Pix(p)	(FbRot24(p,(24-FB_UNIT%24)))
+#define FbPrev24Pix(p)	(FbRot24(p,FB_UNIT%24))
+#define FbNext24Stip(p)	(FbRot24(p,(24-FB_STIP_UNIT%24)))
+#define FbPrev24Stip(p)	(FbRot24(p,FB_STIP_UNIT%24))
+
+/* step a rotation value to the next/previous rotation value */
+#if FB_UNIT == 64
+#define FbNext24Rot(r)        ((r) == 16 ? 0 : (r) + 8)
+#define FbPrev24Rot(r)        ((r) == 0 ? 16 : (r) - 8)
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define FbFirst24Rot(x)		(((x) + 8) % 24)
+#else
+#define FbFirst24Rot(x)		((x) % 24)
+#endif
+
+#endif
+
+#if FB_UNIT == 32
+#define FbNext24Rot(r)        ((r) == 0 ? 16 : (r) - 8)
+#define FbPrev24Rot(r)        ((r) == 16 ? 0 : (r) + 8)
+
+#if IMAGE_BYTE_ORDER == MSBFirst
+#define FbFirst24Rot(x)		(((x) + 16) % 24)
+#else
+#define FbFirst24Rot(x)		((x) % 24)
+#endif
+#endif
+
+#define FbNext24RotStip(r)        ((r) == 0 ? 16 : (r) - 8)
+#define FbPrev24RotStip(r)        ((r) == 16 ? 0 : (r) + 8)
+
+/* Whether 24-bit specific code is needed for this filled pixel value */
+#define FbCheck24Pix(p)	((p) == FbNext24Pix(p))
+
+/* Macros for dealing with dashing */
+
+#define FbDashDeclare	\
+    unsigned char	*__dash, *__firstDash, *__lastDash
+    
+#define FbDashInit(pGC,pPriv,dashOffset,dashlen,even) {	    \
+    (even) = TRUE;					    \
+    __firstDash = (pGC)->dash;				    \
+    __lastDash = __firstDash + (pGC)->numInDashList;	    \
+    (dashOffset) %= (pPriv)->dashLength;		    \
+							    \
+    __dash = __firstDash;				    \
+    while ((dashOffset) >= ((dashlen) = *__dash))	    \
+    {							    \
+	(dashOffset) -= (dashlen);			    \
+	(even) = 1-(even);				    \
+	if (++__dash == __lastDash)			    \
+	    __dash = __firstDash;			    \
+    }							    \
+    (dashlen) -= (dashOffset);				    \
+}
+
+#define FbDashNext(dashlen) {				    \
+    if (++__dash == __lastDash)				    \
+	__dash = __firstDash;				    \
+    (dashlen) = *__dash;				    \
+}
+
+/* as numInDashList is always even, this case can skip a test */
+
+#define FbDashNextEven(dashlen) {			    \
+    (dashlen) = *++__dash;				    \
+}
+
+#define FbDashNextOdd(dashlen)	FbDashNext(dashlen)
+
+#define FbDashStep(dashlen,even) {			    \
+    if (!--(dashlen)) {					    \
+	FbDashNext(dashlen);				    \
+	(even) = 1-(even);				    \
+    }							    \
+}
+
+extern _X_EXPORT DevPrivateKey
+fbGetGCPrivateKey (void);
+
+extern _X_EXPORT DevPrivateKey
+fbGetWinPrivateKey (void);
+
+extern _X_EXPORT const GCOps	fbGCOps;
+extern _X_EXPORT const GCFuncs	fbGCFuncs;
+
+#ifdef FB_24_32BIT
+#define FB_SCREEN_PRIVATE
+#endif
+
+/* Framebuffer access wrapper */
+typedef FbBits (*ReadMemoryProcPtr)(const void *src, int size);
+typedef void (*WriteMemoryProcPtr)(void *dst, FbBits value, int size);
+typedef void (*SetupWrapProcPtr)(ReadMemoryProcPtr  *pRead,
+                                 WriteMemoryProcPtr *pWrite,
+                                 DrawablePtr         pDraw);
+typedef void (*FinishWrapProcPtr)(DrawablePtr pDraw);
+
+#ifdef FB_ACCESS_WRAPPER
+
+#define fbPrepareAccess(pDraw) \
+	fbGetScreenPrivate((pDraw)->pScreen)->setupWrap( \
+		&wfbReadMemory, \
+		&wfbWriteMemory, \
+		(pDraw))
+#define fbFinishAccess(pDraw) \
+	fbGetScreenPrivate((pDraw)->pScreen)->finishWrap(pDraw)
+
+#else
+
+#define fbPrepareAccess(pPix)
+#define fbFinishAccess(pDraw)
+
+#endif
+
+
+#ifdef FB_SCREEN_PRIVATE
+extern _X_EXPORT DevPrivateKey
+fbGetScreenPrivateKey(void);
+
+/* private field of a screen */
+typedef struct {
+    unsigned char	win32bpp;	/* window bpp for 32-bpp images */
+    unsigned char	pix32bpp;	/* pixmap bpp for 32-bpp images */
+#ifdef FB_ACCESS_WRAPPER
+    SetupWrapProcPtr	setupWrap;	/* driver hook to set pixmap access wrapping */
+    FinishWrapProcPtr	finishWrap;	/* driver hook to clean up pixmap access wrapping */
+#endif
+} FbScreenPrivRec, *FbScreenPrivPtr;
+
+#define fbGetScreenPrivate(pScreen) ((FbScreenPrivPtr) \
+				     dixLookupPrivate(&(pScreen)->devPrivates, fbGetScreenPrivateKey()))
+#endif
+
+/* private field of GC */
+typedef struct {
+    FbBits		and, xor;	/* reduced rop values */
+    FbBits		bgand, bgxor;	/* for stipples */
+    FbBits		fg, bg, pm;	/* expanded and filled */
+    unsigned int	dashLength;	/* total of all dash elements */
+    unsigned char    	oneRect;	/* clip list is single rectangle */
+    unsigned char    	evenStipple;	/* stipple is even */
+    unsigned char    	bpp;		/* current drawable bpp */
+} FbGCPrivRec, *FbGCPrivPtr;
+
+#define fbGetGCPrivate(pGC)	((FbGCPrivPtr)\
+				 dixLookupPrivate(&(pGC)->devPrivates, fbGetGCPrivateKey()))
+
+#define fbGetCompositeClip(pGC) ((pGC)->pCompositeClip)
+#define fbGetExpose(pGC)	((pGC)->fExpose)
+#define fbGetFreeCompClip(pGC)	((pGC)->freeCompClip)
+#define fbGetRotatedPixmap(pGC)	((pGC)->pRotatedPixmap)
+
+#define fbGetScreenPixmap(s)	((PixmapPtr) (s)->devPrivate)
+#define fbGetWindowPixmap(pWin)	((PixmapPtr)\
+				 dixLookupPrivate(&((WindowPtr)(pWin))->devPrivates, fbGetWinPrivateKey()))
+
+#ifdef ROOTLESS
+#define __fbPixDrawableX(pPix)	((pPix)->drawable.x)
+#define __fbPixDrawableY(pPix)	((pPix)->drawable.y)
+#else
+#define __fbPixDrawableX(pPix)	0
+#define __fbPixDrawableY(pPix)	0
+#endif
+
+#ifdef COMPOSITE
+#define __fbPixOffXWin(pPix)	(__fbPixDrawableX(pPix) - (pPix)->screen_x)
+#define __fbPixOffYWin(pPix)	(__fbPixDrawableY(pPix) - (pPix)->screen_y)
+#else
+#define __fbPixOffXWin(pPix)	(__fbPixDrawableX(pPix))
+#define __fbPixOffYWin(pPix)	(__fbPixDrawableY(pPix))
+#endif
+#define __fbPixOffXPix(pPix)	(__fbPixDrawableX(pPix))
+#define __fbPixOffYPix(pPix)	(__fbPixDrawableY(pPix))
+
+#define fbGetDrawablePixmap(pDrawable, pixmap, xoff, yoff) {			\
+    if ((pDrawable)->type != DRAWABLE_PIXMAP) { 				\
+	(pixmap) = fbGetWindowPixmap(pDrawable);				\
+	(xoff) = __fbPixOffXWin(pixmap); 					\
+	(yoff) = __fbPixOffYWin(pixmap); 					\
+    } else { 									\
+	(pixmap) = (PixmapPtr) (pDrawable);					\
+	(xoff) = __fbPixOffXPix(pixmap); 					\
+	(yoff) = __fbPixOffYPix(pixmap); 					\
+    } 										\
+    fbPrepareAccess(pDrawable); 						\
+}
+
+#define fbGetPixmapBitsData(pixmap, pointer, stride, bpp) {			\
+    (pointer) = (FbBits *) (pixmap)->devPrivate.ptr; 			       	\
+    (stride) = ((int) (pixmap)->devKind) / sizeof (FbBits); (void)(stride);	\
+    (bpp) = (pixmap)->drawable.bitsPerPixel;  (void)(bpp); 			\
+}
+
+#define fbGetPixmapStipData(pixmap, pointer, stride, bpp) {			\
+    (pointer) = (FbStip *) (pixmap)->devPrivate.ptr; 			       	\
+    (stride) = ((int) (pixmap)->devKind) / sizeof (FbStip); (void)(stride);	\
+    (bpp) = (pixmap)->drawable.bitsPerPixel;  (void)(bpp); 			\
+}
+
+#define fbGetDrawable(pDrawable, pointer, stride, bpp, xoff, yoff) { 		\
+    PixmapPtr   _pPix; 								\
+    fbGetDrawablePixmap(pDrawable, _pPix, xoff, yoff); 				\
+    fbGetPixmapBitsData(_pPix, pointer, stride, bpp);				\
+}
+
+#define fbGetStipDrawable(pDrawable, pointer, stride, bpp, xoff, yoff) { 	\
+    PixmapPtr   _pPix; 								\
+    fbGetDrawablePixmap(pDrawable, _pPix, xoff, yoff);				\
+    fbGetPixmapStipData(_pPix, pointer, stride, bpp);				\
+}
+
+/*
+ * XFree86 empties the root BorderClip when the VT is inactive,
+ * here's a macro which uses that to disable GetImage and GetSpans
+ */
+
+#define fbWindowEnabled(pWin) \
+    RegionNotEmpty(&(pWin)->drawable.pScreen->root->borderClip)
+
+#define fbDrawableEnabled(pDrawable) \
+    ((pDrawable)->type == DRAWABLE_PIXMAP ? \
+     TRUE : fbWindowEnabled((WindowPtr) pDrawable))
+
+#define FbPowerOfTwo(w)	    (((w) & ((w) - 1)) == 0)
+/*
+ * Accelerated tiles are power of 2 width <= FB_UNIT
+ */
+#define FbEvenTile(w)	    ((w) <= FB_UNIT && FbPowerOfTwo(w))
+/*
+ * Accelerated stipples are power of 2 width and <= FB_UNIT/dstBpp
+ * with dstBpp a power of 2 as well
+ */
+#define FbEvenStip(w,bpp)   ((w) * (bpp) <= FB_UNIT && FbPowerOfTwo(w) && FbPowerOfTwo(bpp))
+
+/*
+ * fb24_32.c
+ */
+extern _X_EXPORT void
+fb24_32GetSpans(DrawablePtr	pDrawable, 
+		int		wMax, 
+		DDXPointPtr	ppt, 
+		int		*pwidth, 
+		int		nspans, 
+		char		*pchardstStart);
+
+extern _X_EXPORT void
+fb24_32SetSpans (DrawablePtr	    pDrawable,
+		 GCPtr		    pGC,
+		 char		    *src,
+		 DDXPointPtr	    ppt,
+		 int		    *pwidth,
+		 int		    nspans,
+		 int		    fSorted);
+
+extern _X_EXPORT void
+fb24_32PutZImage (DrawablePtr	pDrawable,
+		  RegionPtr	pClip,
+		  int		alu,
+		  FbBits	pm,
+		  int		x,
+		  int		y,
+		  int		width,
+		  int		height,
+		  CARD8		*src,
+		  FbStride	srcStride);
+    
+extern _X_EXPORT void
+fb24_32GetImage (DrawablePtr     pDrawable,
+		 int             x,
+		 int             y,
+		 int             w,
+		 int             h,
+		 unsigned int    format,
+		 unsigned long   planeMask,
+		 char            *d);
+
+extern _X_EXPORT void
+fb24_32CopyMtoN (DrawablePtr pSrcDrawable,
+		 DrawablePtr pDstDrawable,
+		 GCPtr       pGC,
+		 BoxPtr      pbox,
+		 int         nbox,
+		 int         dx,
+		 int         dy,
+		 Bool        reverse,
+		 Bool        upsidedown,
+		 Pixel       bitplane,
+		 void        *closure);
+
+extern _X_EXPORT PixmapPtr
+fb24_32ReformatTile(PixmapPtr pOldTile, int bitsPerPixel);
+    
+extern _X_EXPORT Bool
+fb24_32CreateScreenResources(ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+fb24_32ModifyPixmapHeader (PixmapPtr   pPixmap,
+			   int         width,
+			   int         height,
+			   int         depth,
+			   int         bitsPerPixel,
+			   int         devKind,
+			   pointer     pPixData);
+
+/*
+ * fballpriv.c
+ */
+extern _X_EXPORT Bool
+fbAllocatePrivates(ScreenPtr pScreen, DevPrivateKey *pGCIndex);
+    
+/*
+ * fbarc.c
+ */
+
+extern _X_EXPORT void
+fbPolyArc (DrawablePtr	pDrawable,
+	   GCPtr	pGC,
+	   int		narcs,
+	   xArc		*parcs);
+
+/*
+ * fbbits.c
+ */
+
+extern _X_EXPORT void
+fbBresSolid8(DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    dashOffset,
+	     int	    signdx,
+	     int	    signdy,
+	     int	    axis,
+	     int	    x,
+	     int	    y,
+	     int	    e,
+	     int	    e1,
+	     int	    e3,
+	     int	    len);
+
+extern _X_EXPORT void
+fbBresDash8 (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    dashOffset,
+	     int	    signdx,
+	     int	    signdy,
+	     int	    axis,
+	     int	    x,
+	     int	    y,
+	     int	    e,
+	     int	    e1,
+	     int	    e3,
+	     int	    len);
+
+extern _X_EXPORT void
+fbDots8 (FbBits	    *dst,
+	 FbStride   dstStride,
+	 int	    dstBpp,
+	 BoxPtr	    pBox,
+	 xPoint	    *pts,
+	 int	    npt,
+	 int	    xorg,
+	 int	    yorg,
+	 int	    xoff,
+	 int	    yoff,
+	 FbBits	    and,
+	 FbBits	    xor);
+
+extern _X_EXPORT void
+fbArc8 (FbBits	    *dst,
+	FbStride    dstStride,
+	int	    dstBpp,
+	xArc	    *arc,
+	int	    dx,
+	int	    dy,
+	FbBits	    and,
+	FbBits	    xor);
+
+extern _X_EXPORT void
+fbGlyph8 (FbBits    *dstLine,
+	  FbStride  dstStride,
+	  int	    dstBpp,
+	  FbStip    *stipple,
+	  FbBits    fg,
+	  int	    height,
+	  int	    shift);
+
+extern _X_EXPORT void
+fbPolyline8 (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    mode,
+	     int	    npt,
+	     DDXPointPtr    ptsOrig);
+
+extern _X_EXPORT void
+fbPolySegment8 (DrawablePtr pDrawable,
+		GCPtr	    pGC,
+		int	    nseg,
+		xSegment    *pseg);
+
+extern _X_EXPORT void
+fbBresSolid16(DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    dashOffset,
+	      int	    signdx,
+	      int	    signdy,
+	      int	    axis,
+	      int	    x,
+	      int	    y,
+	      int	    e,
+	      int	    e1,
+	      int	    e3,
+	      int	    len);
+
+extern _X_EXPORT void
+fbBresDash16(DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    dashOffset,
+	     int	    signdx,
+	     int	    signdy,
+	     int	    axis,
+	     int	    x,
+	     int	    y,
+	     int	    e,
+	     int	    e1,
+	     int	    e3,
+	     int	    len);
+
+extern _X_EXPORT void
+fbDots16(FbBits	    *dst,
+	 FbStride   dstStride,
+	 int	    dstBpp,
+	 BoxPtr	    pBox,
+	 xPoint	    *pts,
+	 int	    npt,
+	 int	    xorg,
+	 int	    yorg,
+	 int	    xoff,
+	 int	    yoff,
+	 FbBits	    and,
+	 FbBits	    xor);
+
+extern _X_EXPORT void
+fbArc16(FbBits	    *dst,
+	FbStride    dstStride,
+	int	    dstBpp,
+	xArc	    *arc,
+	int	    dx,
+	int	    dy,
+	FbBits	    and,
+	FbBits	    xor);
+
+extern _X_EXPORT void
+fbGlyph16(FbBits    *dstLine,
+	  FbStride  dstStride,
+	  int	    dstBpp,
+	  FbStip    *stipple,
+	  FbBits    fg,
+	  int	    height,
+	  int	    shift);
+
+extern _X_EXPORT void
+fbPolyline16 (DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    mode,
+	      int	    npt,
+	      DDXPointPtr   ptsOrig);
+
+extern _X_EXPORT void
+fbPolySegment16 (DrawablePtr	pDrawable,
+		 GCPtr		pGC,
+		 int		nseg,
+		 xSegment	*pseg);
+
+
+extern _X_EXPORT void
+fbBresSolid24(DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    dashOffset,
+	      int	    signdx,
+	      int	    signdy,
+	      int	    axis,
+	      int	    x,
+	      int	    y,
+	      int	    e,
+	      int	    e1,
+	      int	    e3,
+	      int	    len);
+
+extern _X_EXPORT void
+fbBresDash24(DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    dashOffset,
+	     int	    signdx,
+	     int	    signdy,
+	     int	    axis,
+	     int	    x,
+	     int	    y,
+	     int	    e,
+	     int	    e1,
+	     int	    e3,
+	     int	    len);
+
+extern _X_EXPORT void
+fbDots24(FbBits	    *dst,
+	 FbStride   dstStride,
+	 int	    dstBpp,
+	 BoxPtr	    pBox,
+	 xPoint	    *pts,
+	 int	    npt,
+	 int	    xorg,
+	 int	    yorg,
+	 int	    xoff,
+	 int	    yoff,
+	 FbBits	    and,
+	 FbBits	    xor);
+
+extern _X_EXPORT void
+fbArc24(FbBits	    *dst,
+	FbStride    dstStride,
+	int	    dstBpp,
+	xArc	    *arc,
+	int	    dx,
+	int	    dy,
+	FbBits	    and,
+	FbBits	    xor);
+
+extern _X_EXPORT void
+fbGlyph24(FbBits    *dstLine,
+	  FbStride  dstStride,
+	  int	    dstBpp,
+	  FbStip    *stipple,
+	  FbBits    fg,
+	  int	    height,
+	  int	    shift);
+
+extern _X_EXPORT void
+fbPolyline24 (DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    mode,
+	      int	    npt,
+	      DDXPointPtr   ptsOrig);
+
+extern _X_EXPORT void
+fbPolySegment24 (DrawablePtr	pDrawable,
+		 GCPtr		pGC,
+		 int		nseg,
+		 xSegment	*pseg);
+
+
+extern _X_EXPORT void
+fbBresSolid32(DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    dashOffset,
+	      int	    signdx,
+	      int	    signdy,
+	      int	    axis,
+	      int	    x,
+	      int	    y,
+	      int	    e,
+	      int	    e1,
+	      int	    e3,
+	      int	    len);
+
+extern _X_EXPORT void
+fbBresDash32(DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    dashOffset,
+	     int	    signdx,
+	     int	    signdy,
+	     int	    axis,
+	     int	    x,
+	     int	    y,
+	     int	    e,
+	     int	    e1,
+	     int	    e3,
+	     int	    len);
+
+extern _X_EXPORT void
+fbDots32(FbBits	    *dst,
+	 FbStride   dstStride,
+	 int	    dstBpp,
+	 BoxPtr	    pBox,
+	 xPoint	    *pts,
+	 int	    npt,
+	 int	    xorg,
+	 int	    yorg,
+	 int	    xoff,
+	 int	    yoff,
+	 FbBits	    and,
+	 FbBits	    xor);
+
+extern _X_EXPORT void
+fbArc32(FbBits	    *dst,
+	FbStride    dstStride,
+	int	    dstBpp,
+	xArc	    *arc,
+	int	    dx,
+	int	    dy,
+	FbBits	    and,
+	FbBits	    xor);
+
+extern _X_EXPORT void
+fbGlyph32(FbBits    *dstLine,
+	  FbStride  dstStride,
+	  int	    dstBpp,
+	  FbStip    *stipple,
+	  FbBits    fg,
+	  int	    height,
+	  int	    shift);
+extern _X_EXPORT void
+fbPolyline32 (DrawablePtr   pDrawable,
+	      GCPtr	    pGC,
+	      int	    mode,
+	      int	    npt,
+	      DDXPointPtr   ptsOrig);
+
+extern _X_EXPORT void
+fbPolySegment32 (DrawablePtr	pDrawable,
+		 GCPtr		pGC,
+		 int		nseg,
+		 xSegment	*pseg);
+
+/*
+ * fbblt.c
+ */
+extern _X_EXPORT void
+fbBlt (FbBits   *src, 
+       FbStride	srcStride,
+       int	srcX,
+       
+       FbBits   *dst,
+       FbStride dstStride,
+       int	dstX,
+       
+       int	width, 
+       int	height,
+       
+       int	alu,
+       FbBits	pm,
+       int	bpp,
+       
+       Bool	reverse,
+       Bool	upsidedown);
+
+extern _X_EXPORT void
+fbBlt24 (FbBits	    *srcLine,
+	 FbStride   srcStride,
+	 int	    srcX,
+
+	 FbBits	    *dstLine,
+	 FbStride   dstStride,
+	 int	    dstX,
+
+	 int	    width, 
+	 int	    height,
+
+	 int	    alu,
+	 FbBits	    pm,
+
+	 Bool	    reverse,
+	 Bool	    upsidedown);
+    
+extern _X_EXPORT void
+fbBltStip (FbStip   *src,
+	   FbStride srcStride,	    /* in FbStip units, not FbBits units */
+	   int	    srcX,
+	   
+	   FbStip   *dst,
+	   FbStride dstStride,	    /* in FbStip units, not FbBits units */
+	   int	    dstX,
+
+	   int	    width, 
+	   int	    height,
+
+	   int	    alu,
+	   FbBits   pm,
+	   int	    bpp);
+    
+/*
+ * fbbltone.c
+ */
+extern _X_EXPORT void
+fbBltOne (FbStip   *src,
+	  FbStride srcStride,
+	  int	   srcX,
+	  FbBits   *dst,
+	  FbStride dstStride,
+	  int	   dstX,
+	  int	   dstBpp,
+
+	  int	   width,
+	  int	   height,
+
+	  FbBits   fgand,
+	  FbBits   fbxor,
+	  FbBits   bgand,
+	  FbBits   bgxor);
+ 
+#ifdef FB_24BIT
+extern _X_EXPORT void
+fbBltOne24 (FbStip    *src,
+	  FbStride  srcStride,	    /* FbStip units per scanline */
+	  int	    srcX,	    /* bit position of source */
+	  FbBits    *dst,
+	  FbStride  dstStride,	    /* FbBits units per scanline */
+	  int	    dstX,	    /* bit position of dest */
+	  int	    dstBpp,	    /* bits per destination unit */
+
+	  int	    width,	    /* width in bits of destination */
+	  int	    height,	    /* height in scanlines */
+
+	  FbBits    fgand,	    /* rrop values */
+	  FbBits    fgxor,
+	  FbBits    bgand,
+	  FbBits    bgxor);
+#endif
+
+extern _X_EXPORT void
+fbBltPlane (FbBits	    *src,
+	    FbStride	    srcStride,
+	    int		    srcX,
+	    int		    srcBpp,
+
+	    FbStip	    *dst,
+	    FbStride	    dstStride,
+	    int		    dstX,
+	    
+	    int		    width,
+	    int		    height,
+	    
+	    FbStip	    fgand,
+	    FbStip	    fgxor,
+	    FbStip	    bgand,
+	    FbStip	    bgxor,
+	    Pixel	    planeMask);
+
+/*
+ * fbcmap.c
+ */
+extern _X_EXPORT int
+fbListInstalledColormaps(ScreenPtr pScreen, Colormap *pmaps);
+
+extern _X_EXPORT void
+fbInstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void
+fbUninstallColormap(ColormapPtr pmap);
+
+extern _X_EXPORT void
+fbResolveColor(unsigned short	*pred, 
+	       unsigned short	*pgreen, 
+	       unsigned short	*pblue,
+	       VisualPtr	pVisual);
+
+extern _X_EXPORT Bool
+fbInitializeColormap(ColormapPtr pmap);
+
+extern _X_EXPORT int
+fbExpandDirectColors (ColormapPtr   pmap, 
+		      int	    ndef,
+		      xColorItem    *indefs,
+		      xColorItem    *outdefs);
+
+extern _X_EXPORT Bool
+fbCreateDefColormap(ScreenPtr pScreen);
+
+extern _X_EXPORT void
+fbClearVisualTypes(void);
+
+extern _X_EXPORT Bool
+fbHasVisualTypes (int depth);
+
+extern _X_EXPORT Bool
+fbSetVisualTypes (int depth, int visuals, int bitsPerRGB);
+
+extern _X_EXPORT Bool
+fbSetVisualTypesAndMasks (int depth, int visuals, int bitsPerRGB,
+			  Pixel redMask, Pixel greenMask, Pixel blueMask);
+
+extern _X_EXPORT Bool
+fbInitVisuals (VisualPtr    *visualp, 
+	       DepthPtr	    *depthp,
+	       int	    *nvisualp,
+	       int	    *ndepthp,
+	       int	    *rootDepthp,
+	       VisualID	    *defaultVisp,
+	       unsigned long	sizes,
+	       int	    bitsPerRGB);
+
+/*
+ * fbcopy.c
+ */
+
+/* Compatibility definition, to be removed at next ABI change. */
+typedef void   (*fbCopyProc) (DrawablePtr  pSrcDrawable,
+                              DrawablePtr  pDstDrawable,
+                              GCPtr        pGC,
+                              BoxPtr       pDstBox,
+                              int          nbox,
+                              int          dx,
+                              int          dy,
+                              Bool         reverse,
+                              Bool         upsidedown,
+                              Pixel        bitplane,
+                              void         *closure);
+
+extern _X_EXPORT void
+fbCopyNtoN (DrawablePtr	pSrcDrawable,
+	    DrawablePtr	pDstDrawable,
+	    GCPtr	pGC,
+	    BoxPtr	pbox,
+	    int		nbox,
+	    int		dx,
+	    int		dy,
+	    Bool	reverse,
+	    Bool	upsidedown,
+	    Pixel	bitplane,
+	    void	*closure);
+
+/* Compatibility wrapper, to be removed at next ABI change. */
+extern _X_EXPORT void
+fbCopyRegion (DrawablePtr   pSrcDrawable,
+             DrawablePtr   pDstDrawable,
+             GCPtr         pGC,
+             RegionPtr     pDstRegion,
+             int           dx,
+             int           dy,
+             fbCopyProc    copyProc,
+             Pixel         bitPlane,
+             void          *closure);
+
+/* Compatibility wrapper, to be removed at next ABI change. */
+extern _X_EXPORT RegionPtr
+fbDoCopy (DrawablePtr  pSrcDrawable,
+         DrawablePtr   pDstDrawable,
+         GCPtr         pGC,
+         int           xIn,
+         int           yIn,
+         int           widthSrc,
+         int           heightSrc,
+         int           xOut,
+         int           yOut,
+         fbCopyProc    copyProc,
+         Pixel         bitplane,
+         void          *closure);
+
+extern _X_EXPORT void
+fbCopy1toN (DrawablePtr	pSrcDrawable,
+	    DrawablePtr	pDstDrawable,
+	    GCPtr	pGC,
+	    BoxPtr	pbox,
+	    int		nbox,
+	    int		dx,
+	    int		dy,
+	    Bool	reverse,
+	    Bool	upsidedown,
+	    Pixel	bitplane,
+	    void	*closure);
+
+extern _X_EXPORT void
+fbCopyNto1 (DrawablePtr	pSrcDrawable,
+	    DrawablePtr	pDstDrawable,
+	    GCPtr	pGC,
+	    BoxPtr	pbox,
+	    int		nbox,
+	    int		dx,
+	    int		dy,
+	    Bool	reverse,
+	    Bool	upsidedown,
+	    Pixel	bitplane,
+	    void	*closure);
+
+extern _X_EXPORT RegionPtr
+fbCopyArea (DrawablePtr	pSrcDrawable,
+	    DrawablePtr	pDstDrawable,
+	    GCPtr	pGC,
+	    int		xIn, 
+	    int		yIn,
+	    int		widthSrc, 
+	    int		heightSrc,
+	    int		xOut, 
+	    int		yOut);
+
+extern _X_EXPORT RegionPtr
+fbCopyPlane (DrawablePtr    pSrcDrawable,
+	     DrawablePtr    pDstDrawable,
+	     GCPtr	    pGC,
+	     int	    xIn, 
+	     int	    yIn,
+	     int	    widthSrc, 
+	     int	    heightSrc,
+	     int	    xOut, 
+	     int	    yOut,
+	     unsigned long  bitplane);
+
+/*
+ * fbfill.c
+ */
+extern _X_EXPORT void
+fbFill (DrawablePtr pDrawable,
+	GCPtr	    pGC,
+	int	    x,
+	int	    y,
+	int	    width,
+	int	    height);
+
+extern _X_EXPORT void
+fbSolidBoxClipped (DrawablePtr	pDrawable,
+		   RegionPtr	pClip,
+		   int		xa,
+		   int		ya,
+		   int		xb,
+		   int		yb,
+		   FbBits	and,
+		   FbBits	xor);
+
+/*
+ * fbfillrect.c
+ */
+extern _X_EXPORT void
+fbPolyFillRect(DrawablePtr  pDrawable, 
+	       GCPtr	    pGC, 
+	       int	    nrectInit,
+	       xRectangle   *prectInit);
+
+#define fbPolyFillArc miPolyFillArc
+
+#define fbFillPolygon miFillPolygon
+
+/*
+ * fbfillsp.c
+ */
+extern _X_EXPORT void
+fbFillSpans (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    nInit,
+	     DDXPointPtr    pptInit,
+	     int	    *pwidthInit,
+	     int	    fSorted);
+
+
+/*
+ * fbgc.c
+ */
+
+extern _X_EXPORT Bool
+fbCreateGC(GCPtr pGC);
+
+extern _X_EXPORT void
+fbPadPixmap (PixmapPtr pPixmap);
+    
+extern _X_EXPORT void
+fbValidateGC(GCPtr pGC, unsigned long changes, DrawablePtr pDrawable);
+
+/*
+ * fbgetsp.c
+ */
+extern _X_EXPORT void
+fbGetSpans(DrawablePtr	pDrawable, 
+	   int		wMax, 
+	   DDXPointPtr	ppt, 
+	   int		*pwidth, 
+	   int		nspans, 
+	   char		*pchardstStart);
+
+/*
+ * fbglyph.c
+ */
+
+extern _X_EXPORT Bool
+fbGlyphIn (RegionPtr	pRegion,
+	   int		x,
+	   int		y,
+	   int		width,
+	   int		height);
+    
+extern _X_EXPORT void
+fbPolyGlyphBlt (DrawablePtr	pDrawable,
+		GCPtr		pGC,
+		int		x, 
+		int		y,
+		unsigned int	nglyph,
+		CharInfoPtr	*ppci,
+		pointer		pglyphBase);
+
+extern _X_EXPORT void
+fbImageGlyphBlt (DrawablePtr	pDrawable,
+		 GCPtr		pGC,
+		 int		x,
+		 int		y,
+		 unsigned int	nglyph,
+		 CharInfoPtr	*ppci,
+		 pointer	pglyphBase);
+
+/*
+ * fbimage.c
+ */
+
+extern _X_EXPORT void
+fbPutImage (DrawablePtr	pDrawable,
+	    GCPtr	pGC,
+	    int		depth,
+	    int		x,
+	    int		y,
+	    int		w,
+	    int		h,
+	    int		leftPad,
+	    int		format,
+	    char	*pImage);
+
+extern _X_EXPORT void
+fbPutZImage (DrawablePtr	pDrawable,
+	     RegionPtr		pClip,
+	     int		alu,
+	     FbBits		pm,
+	     int		x,
+	     int		y,
+	     int		width,
+	     int		height,
+	     FbStip		*src,
+	     FbStride		srcStride);
+
+extern _X_EXPORT void
+fbPutXYImage (DrawablePtr	pDrawable,
+	      RegionPtr		pClip,
+	      FbBits		fg,
+	      FbBits		bg,
+	      FbBits		pm,
+	      int		alu,
+	      Bool		opaque,
+	      
+	      int		x,
+	      int		y,
+	      int		width,
+	      int		height,
+
+	      FbStip		*src,
+	      FbStride		srcStride,
+	      int		srcX);
+
+extern _X_EXPORT void
+fbGetImage (DrawablePtr	    pDrawable,
+	    int		    x,
+	    int		    y,
+	    int		    w,
+	    int		    h,
+	    unsigned int    format,
+	    unsigned long   planeMask,
+	    char	    *d);
+/*
+ * fbline.c
+ */
+
+extern _X_EXPORT void
+fbZeroLine (DrawablePtr	pDrawable,
+	    GCPtr	pGC,
+	    int		mode,
+	    int		npt,
+	    DDXPointPtr	ppt);
+
+extern _X_EXPORT void
+fbZeroSegment (DrawablePtr  pDrawable,
+	       GCPtr	    pGC,
+	       int	    nseg,
+	       xSegment	    *pSegs);
+
+extern _X_EXPORT void
+fbPolyLine (DrawablePtr	pDrawable,
+	    GCPtr	pGC,
+	    int		mode,
+	    int		npt,
+	    DDXPointPtr	ppt);
+
+extern _X_EXPORT void
+fbFixCoordModePrevious (int npt,
+			DDXPointPtr ppt);
+
+extern _X_EXPORT void
+fbPolySegment (DrawablePtr  pDrawable,
+	       GCPtr	    pGC,
+	       int	    nseg,
+	       xSegment	    *pseg);
+
+#define fbPolyRectangle	miPolyRectangle
+
+/*
+ * fbpict.c
+ */
+
+extern _X_EXPORT Bool
+fbPictureInit (ScreenPtr pScreen,
+	       PictFormatPtr formats,
+	       int nformats);
+
+/*
+ * fbpixmap.c
+ */
+
+extern _X_EXPORT PixmapPtr
+fbCreatePixmapBpp (ScreenPtr pScreen, int width, int height, int depth, int bpp,
+		   unsigned usage_hint);
+
+extern _X_EXPORT PixmapPtr
+fbCreatePixmap (ScreenPtr pScreen, int width, int height, int depth,
+		unsigned usage_hint);
+
+extern _X_EXPORT Bool
+fbDestroyPixmap (PixmapPtr pPixmap);
+
+extern _X_EXPORT RegionPtr
+fbPixmapToRegion(PixmapPtr pPix);
+
+/*
+ * fbpoint.c
+ */
+
+extern _X_EXPORT void
+fbDots (FbBits	    *dstOrig,
+	FbStride    dstStride,
+	int	    dstBpp,
+	BoxPtr	    pBox,
+	xPoint	    *pts,
+	int	    npt,
+	int	    xorg,
+	int	    yorg,
+	int	    xoff,
+	int	    yoff,
+	FbBits	    andOrig,
+	FbBits	    xorOrig);
+
+extern _X_EXPORT void
+fbPolyPoint (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     int	    mode,
+	     int	    npt,
+	     xPoint	    *pptInit);
+
+/*
+ * fbpush.c
+ */
+extern _X_EXPORT void
+fbPushPattern (DrawablePtr  pDrawable,
+	       GCPtr	    pGC,
+	       
+	       FbStip	    *src,
+	       FbStride	    srcStride,
+	       int	    srcX,
+
+	       int	    x,
+	       int	    y,
+
+	       int	    width,
+	       int	    height);
+
+extern _X_EXPORT void
+fbPushFill (DrawablePtr	pDrawable,
+	    GCPtr	pGC,
+
+	    FbStip	*src,
+	    FbStride	srcStride,
+	    int		srcX,
+	    
+	    int		x,
+	    int		y,
+	    int		width,
+	    int		height);
+
+extern _X_EXPORT void
+fbPushImage (DrawablePtr    pDrawable,
+	     GCPtr	    pGC,
+	     
+	     FbStip	    *src,
+	     FbStride	    srcStride,
+	     int	    srcX,
+
+	     int	    x,
+	     int	    y,
+	     int	    width,
+	     int	    height);
+
+extern _X_EXPORT void
+fbPushPixels (GCPtr	    pGC,
+	      PixmapPtr	    pBitmap,
+	      DrawablePtr   pDrawable,
+	      int	    dx,
+	      int	    dy,
+	      int	    xOrg,
+	      int	    yOrg);
+
+
+/*
+ * fbscreen.c
+ */
+
+extern _X_EXPORT Bool
+fbCloseScreen (int indx, ScreenPtr pScreen);
+
+extern _X_EXPORT Bool
+fbRealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern _X_EXPORT Bool
+fbUnrealizeFont(ScreenPtr pScreen, FontPtr pFont);
+
+extern _X_EXPORT void
+fbQueryBestSize (int class, 
+		 unsigned short *width, unsigned short *height,
+		 ScreenPtr pScreen);
+
+extern _X_EXPORT PixmapPtr
+_fbGetWindowPixmap (WindowPtr pWindow);
+
+extern _X_EXPORT void
+_fbSetWindowPixmap (WindowPtr pWindow, PixmapPtr pPixmap);
+
+extern _X_EXPORT Bool
+fbSetupScreen(ScreenPtr	pScreen, 
+	      pointer	pbits,		/* pointer to screen bitmap */
+	      int	xsize, 		/* in pixels */
+	      int	ysize,
+	      int	dpix,		/* dots per inch */
+	      int	dpiy,
+	      int	width,		/* pixel width of frame buffer */
+	      int	bpp);		/* bits per pixel of frame buffer */
+
+extern _X_EXPORT Bool
+wfbFinishScreenInit(ScreenPtr	pScreen,
+		    pointer	pbits,
+		    int		xsize,
+		    int		ysize,
+		    int		dpix,
+		    int		dpiy,
+		    int		width,
+		    int		bpp,
+		    SetupWrapProcPtr setupWrap,
+		    FinishWrapProcPtr finishWrap);
+
+extern _X_EXPORT Bool
+wfbScreenInit(ScreenPtr	pScreen,
+	      pointer	pbits,
+	      int	xsize,
+	      int	ysize,
+	      int	dpix,
+	      int	dpiy,
+	      int	width,
+	      int	bpp,
+	      SetupWrapProcPtr setupWrap,
+	      FinishWrapProcPtr finishWrap);
+
+extern _X_EXPORT Bool
+fbFinishScreenInit(ScreenPtr	pScreen,
+		   pointer	pbits,
+		   int		xsize,
+		   int		ysize,
+		   int		dpix,
+		   int		dpiy,
+		   int		width,
+		   int		bpp);
+
+extern _X_EXPORT Bool
+fbScreenInit(ScreenPtr	pScreen,
+	     pointer	pbits,
+	     int	xsize,
+	     int	ysize,
+	     int	dpix,
+	     int	dpiy,
+	     int	width,
+	     int	bpp);
+    
+/*
+ * fbseg.c
+ */
+typedef void	FbBres (DrawablePtr	pDrawable,
+			GCPtr		pGC,
+			int		dashOffset,
+			int		signdx,
+			int		signdy,
+			int		axis,
+			int		x,
+			int		y,
+			int		e,
+			int		e1,
+			int		e3,
+			int		len);
+
+extern _X_EXPORT FbBres fbBresSolid, fbBresDash, fbBresFill, fbBresFillDash;
+/*
+ * fbsetsp.c
+ */
+
+extern _X_EXPORT void
+fbSetSpans (DrawablePtr	    pDrawable,
+	    GCPtr	    pGC,
+	    char	    *src,
+	    DDXPointPtr	    ppt,
+	    int		    *pwidth,
+	    int		    nspans,
+	    int		    fSorted);
+
+extern _X_EXPORT FbBres *
+fbSelectBres (DrawablePtr   pDrawable,
+	      GCPtr	    pGC);
+
+extern _X_EXPORT void
+fbBres (DrawablePtr	pDrawable,
+	GCPtr		pGC,
+	int		dashOffset,
+	int		signdx,
+	int		signdy,
+	int		axis,
+	int		x,
+	int		y,
+	int		e,
+	int		e1,
+	int		e3,
+	int		len);
+
+extern _X_EXPORT void
+fbSegment (DrawablePtr	pDrawable,
+	   GCPtr	pGC,
+	   int		xa,
+	   int		ya,
+	   int		xb,
+	   int		yb,
+	   Bool		drawLast,
+	   int		*dashOffset);
+
+
+/*
+ * fbsolid.c
+ */
+
+extern _X_EXPORT void
+fbSolid (FbBits	    *dst,
+	 FbStride   dstStride,
+	 int	    dstX,
+	 int	    bpp,
+
+	 int	    width,
+	 int	    height,
+
+	 FbBits	    and,
+	 FbBits	    xor);
+
+#ifdef FB_24BIT
+extern _X_EXPORT void
+fbSolid24 (FbBits   *dst,
+	   FbStride dstStride,
+	   int	    dstX,
+
+	   int	    width,
+	   int	    height,
+
+	   FbBits   and,
+	   FbBits   xor);
+#endif
+
+/*
+ * fbstipple.c
+ */
+
+extern _X_EXPORT void
+fbTransparentSpan (FbBits   *dst,
+		   FbBits   stip,
+		   FbBits   fgxor,
+		   int	    n);
+
+extern _X_EXPORT void
+fbEvenStipple (FbBits   *dst,
+	       FbStride dstStride,
+	       int	dstX,
+	       int	dstBpp,
+
+	       int	width,
+	       int	height,
+
+	       FbStip   *stip,
+	       FbStride	stipStride,
+	       int	stipHeight,
+
+	       FbBits   fgand,
+	       FbBits   fgxor,
+	       FbBits   bgand,
+	       FbBits   bgxor,
+
+	       int	xRot,
+	       int	yRot);
+
+extern _X_EXPORT void
+fbOddStipple (FbBits	*dst,
+	      FbStride	dstStride,
+	      int	dstX,
+	      int	dstBpp,
+
+	      int	width,
+	      int	height,
+
+	      FbStip	*stip,
+	      FbStride	stipStride,
+	      int	stipWidth,
+	      int	stipHeight,
+
+	      FbBits	fgand,
+	      FbBits	fgxor,
+	      FbBits	bgand,
+	      FbBits	bgxor,
+
+	      int	xRot,
+	      int	yRot);
+
+extern _X_EXPORT void
+fbStipple (FbBits   *dst,
+	   FbStride dstStride,
+	   int	    dstX,
+	   int	    dstBpp,
+
+	   int	    width,
+	   int	    height,
+
+	   FbStip   *stip,
+	   FbStride stipStride,
+	   int	    stipWidth,
+	   int	    stipHeight,
+	   Bool	    even,
+
+	   FbBits   fgand,
+	   FbBits   fgxor,
+	   FbBits   bgand,
+	   FbBits   bgxor,
+
+	   int	    xRot,
+	   int	    yRot);
+
+/*
+ * fbtile.c
+ */
+
+extern _X_EXPORT void
+fbEvenTile (FbBits	*dst,
+	    FbStride	dstStride,
+	    int		dstX,
+
+	    int		width,
+	    int		height,
+
+	    FbBits	*tile,
+	    FbStride	tileStride,
+	    int		tileHeight,
+
+	    int		alu,
+	    FbBits	pm,
+	    int		xRot,
+	    int		yRot);
+
+extern _X_EXPORT void
+fbOddTile (FbBits	*dst,
+	   FbStride	dstStride,
+	   int		dstX,
+
+	   int		width,
+	   int		height,
+
+	   FbBits	*tile,
+	   FbStride	tileStride,
+	   int		tileWidth,
+	   int		tileHeight,
+
+	   int		alu,
+	   FbBits	pm,
+	   int		bpp,
+	   
+	   int		xRot,
+	   int		yRot);
+
+extern _X_EXPORT void
+fbTile (FbBits	    *dst,
+	FbStride    dstStride,
+	int	    dstX,
+
+	int	    width,
+	int	    height,
+
+	FbBits	    *tile,
+	FbStride    tileStride,
+	int	    tileWidth,
+	int	    tileHeight,
+	
+	int	    alu,
+	FbBits	    pm,
+	int	    bpp,
+	
+	int	    xRot,
+	int	    yRot);
+
+/*
+ * fbutil.c
+ */
+extern _X_EXPORT FbBits
+fbReplicatePixel (Pixel p, int bpp);
+
+extern _X_EXPORT void
+fbReduceRasterOp (int rop, FbBits fg, FbBits pm, FbBits *andp, FbBits *xorp);
+
+#ifdef FB_ACCESS_WRAPPER
+extern _X_EXPORT ReadMemoryProcPtr wfbReadMemory;
+extern _X_EXPORT WriteMemoryProcPtr wfbWriteMemory;
+#endif
+
+/*
+ * fbwindow.c
+ */
+
+extern _X_EXPORT Bool
+fbCreateWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+fbDestroyWindow(WindowPtr pWin);
+
+extern _X_EXPORT Bool
+fbMapWindow(WindowPtr pWindow);
+
+extern _X_EXPORT Bool
+fbPositionWindow(WindowPtr pWin, int x, int y);
+
+extern _X_EXPORT Bool
+fbUnmapWindow(WindowPtr pWindow);
+    
+extern _X_EXPORT void
+fbCopyWindowProc (DrawablePtr	pSrcDrawable,
+		  DrawablePtr	pDstDrawable,
+		  GCPtr		pGC,
+		  BoxPtr	pbox,
+		  int		nbox,
+		  int		dx,
+		  int		dy,
+		  Bool		reverse,
+		  Bool		upsidedown,
+		  Pixel		bitplane,
+		  void		*closure);
+
+extern _X_EXPORT void
+fbCopyWindow(WindowPtr	    pWin, 
+	     DDXPointRec    ptOldOrg, 
+	     RegionPtr	    prgnSrc);
+
+extern _X_EXPORT Bool
+fbChangeWindowAttributes(WindowPtr pWin, unsigned long mask);
+
+extern _X_EXPORT void
+fbFillRegionSolid (DrawablePtr	pDrawable,
+		   RegionPtr	pRegion,
+		   FbBits	and,
+		   FbBits	xor);
+
+extern _X_EXPORT pixman_image_t *
+image_from_pict (PicturePtr	pict,
+		 Bool		has_clip,
+		 int		*xoff,
+		 int		*yoff);
+
+extern _X_EXPORT void free_pixman_pict (PicturePtr, pixman_image_t *);
+
+#endif /* _FB_H_ */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xserver-properties.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xserver-properties.h
@@ -0,0 +1,191 @@
+/*
+ * Copyright 2008 Red Hat, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software")
+ * to deal in the software without restriction, including without limitation
+ * on the rights to use, copy, modify, merge, publish, distribute, sub
+ * license, and/or sell copies of the Software, and to permit persons to whom
+ * them Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTIBILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES, OR OTHER LIABILITY, WHETHER
+ * IN AN ACTION OF CONTRACT, TORT, OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/* Properties managed by the server. */
+
+#ifndef _XSERVER_PROPERTIES_H_
+#define _XSERVER_PROPERTIES_H_
+
+/* Type for a 4 byte float. Storage format IEEE 754 in client's default
+ * byte-ordering. */
+#define XATOM_FLOAT "FLOAT"
+
+/* BOOL. 0 - device disabled, 1 - device enabled */
+#define XI_PROP_ENABLED      "Device Enabled"
+/* BOOL. If present, device is a virtual XTEST device */
+#define XI_PROP_XTEST_DEVICE  "XTEST Device"
+
+/* Coordinate transformation matrix for absolute input devices
+ * FLOAT, 9 values in row-major order, coordinates in 0..1 range:
+ * [c0 c1 c2]   [x]
+ * [c3 c4 c5] * [y]
+ * [c6 c7 c8]   [1] */
+#define XI_PROP_TRANSFORM "Coordinate Transformation Matrix"
+
+/* Pointer acceleration properties */
+/* INTEGER of any format */
+#define ACCEL_PROP_PROFILE_NUMBER "Device Accel Profile"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_CONSTANT_DECELERATION "Device Accel Constant Deceleration"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_ADAPTIVE_DECELERATION "Device Accel Adaptive Deceleration"
+/* FLOAT, format 32 */
+#define ACCEL_PROP_VELOCITY_SCALING "Device Accel Velocity Scaling"
+
+
+/* Axis labels */
+#define AXIS_LABEL_PROP "Axis Labels"
+
+#define AXIS_LABEL_PROP_REL_X           "Rel X"
+#define AXIS_LABEL_PROP_REL_Y           "Rel Y"
+#define AXIS_LABEL_PROP_REL_Z           "Rel Z"
+#define AXIS_LABEL_PROP_REL_RX          "Rel Rotary X"
+#define AXIS_LABEL_PROP_REL_RY          "Rel Rotary Y"
+#define AXIS_LABEL_PROP_REL_RZ          "Rel Rotary Z"
+#define AXIS_LABEL_PROP_REL_HWHEEL      "Rel Horiz Wheel"
+#define AXIS_LABEL_PROP_REL_DIAL        "Rel Dial"
+#define AXIS_LABEL_PROP_REL_WHEEL       "Rel Vert Wheel"
+#define AXIS_LABEL_PROP_REL_MISC        "Rel Misc"
+
+/*
+ * Absolute axes
+ */
+
+#define AXIS_LABEL_PROP_ABS_X           "Abs X"
+#define AXIS_LABEL_PROP_ABS_Y           "Abs Y"
+#define AXIS_LABEL_PROP_ABS_Z           "Abs Z"
+#define AXIS_LABEL_PROP_ABS_RX          "Abs Rotary X"
+#define AXIS_LABEL_PROP_ABS_RY          "Abs Rotary Y"
+#define AXIS_LABEL_PROP_ABS_RZ          "Abs Rotary Z"
+#define AXIS_LABEL_PROP_ABS_THROTTLE    "Abs Throttle"
+#define AXIS_LABEL_PROP_ABS_RUDDER      "Abs Rudder"
+#define AXIS_LABEL_PROP_ABS_WHEEL       "Abs Wheel"
+#define AXIS_LABEL_PROP_ABS_GAS         "Abs Gas"
+#define AXIS_LABEL_PROP_ABS_BRAKE       "Abs Brake"
+#define AXIS_LABEL_PROP_ABS_HAT0X       "Abs Hat 0 X"
+#define AXIS_LABEL_PROP_ABS_HAT0Y       "Abs Hat 0 Y"
+#define AXIS_LABEL_PROP_ABS_HAT1X       "Abs Hat 1 X"
+#define AXIS_LABEL_PROP_ABS_HAT1Y       "Abs Hat 1 Y"
+#define AXIS_LABEL_PROP_ABS_HAT2X       "Abs Hat 2 X"
+#define AXIS_LABEL_PROP_ABS_HAT2Y       "Abs Hat 2 Y"
+#define AXIS_LABEL_PROP_ABS_HAT3X       "Abs Hat 3 X"
+#define AXIS_LABEL_PROP_ABS_HAT3Y       "Abs Hat 3 Y"
+#define AXIS_LABEL_PROP_ABS_PRESSURE    "Abs Pressure"
+#define AXIS_LABEL_PROP_ABS_DISTANCE    "Abs Distance"
+#define AXIS_LABEL_PROP_ABS_TILT_X      "Abs Tilt X"
+#define AXIS_LABEL_PROP_ABS_TILT_Y      "Abs Tilt Y"
+#define AXIS_LABEL_PROP_ABS_TOOL_WIDTH  "Abs Tool Width"
+#define AXIS_LABEL_PROP_ABS_VOLUME      "Abs Volume"
+#define AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR "Abs MT Touch Major"
+#define AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR "Abs MT Touch Minor"
+#define AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR "Abs MT Width Major"
+#define AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR "Abs MT Width Minor"
+#define AXIS_LABEL_PROP_ABS_MT_ORIENTATION "Abs MT Orientation"
+#define AXIS_LABEL_PROP_ABS_MT_POSITION_X  "Abs MT Position X"
+#define AXIS_LABEL_PROP_ABS_MT_POSITION_Y  "Abs MT Position Y"
+#define AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE   "Abs MT Tool Type"
+#define AXIS_LABEL_PROP_ABS_MT_BLOB_ID     "Abs MT Blob ID"
+#define AXIS_LABEL_PROP_ABS_MT_TRACKING_ID "Abs MT Tracking ID"
+#define AXIS_LABEL_PROP_ABS_MT_PRESSURE    "Abs MT Pressure"
+#define AXIS_LABEL_PROP_ABS_MISC        "Abs Misc"
+
+/* Button names */
+#define BTN_LABEL_PROP "Button Labels"
+
+/* Default label */
+#define BTN_LABEL_PROP_BTN_UNKNOWN      "Button Unknown"
+/* Wheel buttons */
+#define BTN_LABEL_PROP_BTN_WHEEL_UP     "Button Wheel Up"
+#define BTN_LABEL_PROP_BTN_WHEEL_DOWN   "Button Wheel Down"
+#define BTN_LABEL_PROP_BTN_HWHEEL_LEFT  "Button Horiz Wheel Left"
+#define BTN_LABEL_PROP_BTN_HWHEEL_RIGHT "Button Horiz Wheel Right"
+
+/* The following are from linux/input.h */
+#define BTN_LABEL_PROP_BTN_0            "Button 0"
+#define BTN_LABEL_PROP_BTN_1            "Button 1"
+#define BTN_LABEL_PROP_BTN_2            "Button 2"
+#define BTN_LABEL_PROP_BTN_3            "Button 3"
+#define BTN_LABEL_PROP_BTN_4            "Button 4"
+#define BTN_LABEL_PROP_BTN_5            "Button 5"
+#define BTN_LABEL_PROP_BTN_6            "Button 6"
+#define BTN_LABEL_PROP_BTN_7            "Button 7"
+#define BTN_LABEL_PROP_BTN_8            "Button 8"
+#define BTN_LABEL_PROP_BTN_9            "Button 9"
+
+#define BTN_LABEL_PROP_BTN_LEFT         "Button Left"
+#define BTN_LABEL_PROP_BTN_RIGHT        "Button Right"
+#define BTN_LABEL_PROP_BTN_MIDDLE       "Button Middle"
+#define BTN_LABEL_PROP_BTN_SIDE         "Button Side"
+#define BTN_LABEL_PROP_BTN_EXTRA        "Button Extra"
+#define BTN_LABEL_PROP_BTN_FORWARD      "Button Forward"
+#define BTN_LABEL_PROP_BTN_BACK         "Button Back"
+#define BTN_LABEL_PROP_BTN_TASK         "Button Task"
+
+#define BTN_LABEL_PROP_BTN_TRIGGER      "Button Trigger"
+#define BTN_LABEL_PROP_BTN_THUMB        "Button Thumb"
+#define BTN_LABEL_PROP_BTN_THUMB2       "Button Thumb2"
+#define BTN_LABEL_PROP_BTN_TOP          "Button Top"
+#define BTN_LABEL_PROP_BTN_TOP2         "Button Top2"
+#define BTN_LABEL_PROP_BTN_PINKIE       "Button Pinkie"
+#define BTN_LABEL_PROP_BTN_BASE         "Button Base"
+#define BTN_LABEL_PROP_BTN_BASE2        "Button Base2"
+#define BTN_LABEL_PROP_BTN_BASE3        "Button Base3"
+#define BTN_LABEL_PROP_BTN_BASE4        "Button Base4"
+#define BTN_LABEL_PROP_BTN_BASE5        "Button Base5"
+#define BTN_LABEL_PROP_BTN_BASE6        "Button Base6"
+#define BTN_LABEL_PROP_BTN_DEAD         "Button Dead"
+
+#define BTN_LABEL_PROP_BTN_A            "Button A"
+#define BTN_LABEL_PROP_BTN_B            "Button B"
+#define BTN_LABEL_PROP_BTN_C            "Button C"
+#define BTN_LABEL_PROP_BTN_X            "Button X"
+#define BTN_LABEL_PROP_BTN_Y            "Button Y"
+#define BTN_LABEL_PROP_BTN_Z            "Button Z"
+#define BTN_LABEL_PROP_BTN_TL           "Button T Left"
+#define BTN_LABEL_PROP_BTN_TR           "Button T Right"
+#define BTN_LABEL_PROP_BTN_TL2          "Button T Left2"
+#define BTN_LABEL_PROP_BTN_TR2          "Button T Right2"
+#define BTN_LABEL_PROP_BTN_SELECT       "Button Select"
+#define BTN_LABEL_PROP_BTN_START        "Button Start"
+#define BTN_LABEL_PROP_BTN_MODE         "Button Mode"
+#define BTN_LABEL_PROP_BTN_THUMBL       "Button Thumb Left"
+#define BTN_LABEL_PROP_BTN_THUMBR       "Button Thumb Right"
+
+#define BTN_LABEL_PROP_BTN_TOOL_PEN             "Button Tool Pen"
+#define BTN_LABEL_PROP_BTN_TOOL_RUBBER          "Button Tool Rubber"
+#define BTN_LABEL_PROP_BTN_TOOL_BRUSH           "Button Tool Brush"
+#define BTN_LABEL_PROP_BTN_TOOL_PENCIL          "Button Tool Pencil"
+#define BTN_LABEL_PROP_BTN_TOOL_AIRBRUSH        "Button Tool Airbrush"
+#define BTN_LABEL_PROP_BTN_TOOL_FINGER          "Button Tool Finger"
+#define BTN_LABEL_PROP_BTN_TOOL_MOUSE           "Button Tool Mouse"
+#define BTN_LABEL_PROP_BTN_TOOL_LENS            "Button Tool Lens"
+#define BTN_LABEL_PROP_BTN_TOUCH                "Button Touch"
+#define BTN_LABEL_PROP_BTN_STYLUS               "Button Stylus"
+#define BTN_LABEL_PROP_BTN_STYLUS2              "Button Stylus2"
+#define BTN_LABEL_PROP_BTN_TOOL_DOUBLETAP       "Button Tool Doubletap"
+#define BTN_LABEL_PROP_BTN_TOOL_TRIPLETAP       "Button Tool Tripletap"
+
+#define BTN_LABEL_PROP_BTN_GEAR_DOWN            "Button Gear down"
+#define BTN_LABEL_PROP_BTN_GEAR_UP              "Button Gear up"
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fpu.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/fpu.h
@@ -0,0 +1,61 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for FPU instruction decoding.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_FPU_H
+#define __X86EMU_FPU_H
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+/* these have to be defined, whether 8087 support compiled in or not. */
+
+extern void x86emuOp_esc_coprocess_d8 (u8 op1);
+extern void x86emuOp_esc_coprocess_d9 (u8 op1);
+extern void x86emuOp_esc_coprocess_da (u8 op1);
+extern void x86emuOp_esc_coprocess_db (u8 op1);
+extern void x86emuOp_esc_coprocess_dc (u8 op1);
+extern void x86emuOp_esc_coprocess_dd (u8 op1);
+extern void x86emuOp_esc_coprocess_de (u8 op1);
+extern void x86emuOp_esc_coprocess_df (u8 op1);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_FPU_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaarop.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xaarop.h
@@ -0,0 +1,311 @@
+/*
+
+   int XAAHelpSolidROP(ScrnInfoPtr pScrn, int *fg, int pm, int *rop)
+
+	For use with solid fills emulated by solid 8x8 patterns.  You 
+	give it the foreground, planemask and X rop and it will replace 
+	the foreground with a new one and the rop with the appropriate 
+	MS triadic raster op.  The function will return which components 
+	(S-P) need to be enabled.  
+
+
+   int XAAHelpPatternROP(ScrnInfoPtr pScrn, int *fg, int *bg, int pm, int *rop)
+
+	For use with 8x8 opaque pattern fills.  You give it the foreground, 	
+	and background, planemask and X rop and it will replace the 
+	foreground and background with new ones and the rop with the 
+	appropriate MS triadic raster op.  The function will return which 
+	components (S-P) need to be enabled.  
+
+
+	   ROP_PAT - Means to enable 8x8 mono patterns (all bits 
+		     set for solid patterns).  Set the foreground and
+		     background as returned by the function.  
+
+	   ROP_SRC - Means a source of color == planemask should be used.
+
+
+*/
+
+#ifndef _XAAROP_H
+#define _XAAROP_H
+
+#define ROP_DST		0x00000001
+#define ROP_SRC		0x00000002
+#define ROP_PAT		0x00000004
+
+#define ROP_0		0x00
+#define ROP_DPSoon	0x01
+#define ROP_DPSona	0x02
+#define ROP_PSon	0x03
+#define ROP_SDPona	0x04
+#define ROP_DPon	0x05
+#define ROP_PDSxnon	0x06
+#define ROP_PDSaon	0x07
+#define ROP_SDPnaa	0x08
+#define ROP_PDSxon	0x09
+#define ROP_DPna	0x0A
+#define ROP_PSDnaon	0x0B
+#define ROP_SPna	0x0C
+#define ROP_PDSnaon	0x0D
+#define ROP_PDSonon	0x0E
+#define ROP_Pn		0x0F
+#define ROP_PDSona	0x10
+#define ROP_DSon	0x11
+#define ROP_SDPxnon	0x12
+#define ROP_SDPaon	0x13
+#define ROP_DPSxnon	0x14
+#define ROP_DPSaon	0x15
+#define ROP_PSDPSanaxx	0x16
+#define ROP_SSPxDSxaxn	0x17
+#define ROP_SPxPDxa	0x18
+#define ROP_SDPSanaxn	0x19
+#define ROP_PDSPaox	0x1A
+#define ROP_SDPSxaxn	0x1B
+#define ROP_PSDPaox	0x1C
+#define ROP_DSPDxaxn	0x1D
+#define ROP_PDSox	0x1E
+#define ROP_PDSoan	0x1F
+#define ROP_DPSnaa	0x20
+#define ROP_SDPxon	0x21
+#define ROP_DSna	0x22
+#define ROP_SPDnaon	0x23
+#define ROP_SPxDSxa	0x24
+#define ROP_PDSPanaxn	0x25
+#define ROP_SDPSaox	0x26
+#define ROP_SDPSxnox	0x27
+#define ROP_DPSxa	0x28
+#define ROP_PSDPSaoxxn	0x29
+#define ROP_DPSana	0x2A
+#define ROP_SSPxPDxaxn	0x2B
+#define ROP_SPDSoax	0x2C
+#define ROP_PSDnox	0x2D
+#define ROP_PSDPxox	0x2E
+#define ROP_PSDnoan	0x2F
+#define ROP_PSna	0x30
+#define ROP_SDPnaon	0x31
+#define ROP_SDPSoox	0x32
+#define ROP_Sn		0x33
+#define ROP_SPDSaox	0x34
+#define ROP_SPDSxnox	0x35
+#define ROP_SDPox	0x36
+#define ROP_SDPoan	0x37
+#define ROP_PSDPoax	0x38
+#define ROP_SPDnox	0x39
+#define ROP_SPDSxox	0x3A
+#define ROP_SPDnoan	0x3B
+#define ROP_PSx		0x3C
+#define ROP_SPDSonox	0x3D
+#define ROP_SPDSnaox	0x3E
+#define ROP_PSan	0x3F
+#define ROP_PSDnaa	0x40
+#define ROP_DPSxon	0x41
+#define ROP_SDxPDxa	0x42
+#define ROP_SPDSanaxn	0x43
+#define ROP_SDna	0x44
+#define ROP_DPSnaon	0x45
+#define ROP_DSPDaox	0x46
+#define ROP_PSDPxaxn	0x47
+#define ROP_SDPxa	0x48
+#define ROP_PDSPDaoxxn	0x49
+#define ROP_DPSDoax	0x4A
+#define ROP_PDSnox	0x4B
+#define ROP_SDPana	0x4C
+#define ROP_SSPxDSxoxn	0x4D
+#define ROP_PDSPxox	0x4E
+#define ROP_PDSnoan	0x4F
+#define ROP_PDna	0x50
+#define ROP_DSPnaon	0x51
+#define ROP_DPSDaox	0x52
+#define ROP_SPDSxaxn	0x53
+#define ROP_DPSonon	0x54
+#define ROP_Dn		0x55
+#define ROP_DPSox	0x56
+#define ROP_DPSoan	0x57
+#define ROP_PDSPoax	0x58
+#define ROP_DPSnox	0x59
+#define ROP_DPx		0x5A
+#define ROP_DPSDonox	0x5B
+#define ROP_DPSDxox	0x5C
+#define ROP_DPSnoan	0x5D
+#define ROP_DPSDnaox	0x5E
+#define ROP_DPan	0x5F
+#define ROP_PDSxa	0x60
+#define ROP_DSPDSaoxxn	0x61
+#define ROP_DSPDoax	0x62
+#define ROP_SDPnox	0x63
+#define ROP_SDPSoax	0x64
+#define ROP_DSPnox	0x65
+#define ROP_DSx		0x66
+#define ROP_SDPSonox	0x67
+#define ROP_DSPDSonoxxn	0x68
+#define ROP_PDSxxn	0x69
+#define ROP_DPSax	0x6A
+#define ROP_PSDPSoaxxn	0x6B
+#define ROP_SDPax	0x6C
+#define ROP_PDSPDoaxxn	0x6D
+#define ROP_SDPSnoax	0x6E
+#define ROP_PDSxnan	0x6F
+#define ROP_PDSana	0x70
+#define ROP_SSDxPDxaxn	0x71
+#define ROP_SDPSxox	0x72
+#define ROP_SDPnoan	0x73
+#define ROP_DSPDxox	0x74
+#define ROP_DSPnoan	0x75
+#define ROP_SDPSnaox	0x76
+#define ROP_DSan	0x77
+#define ROP_PDSax	0x78
+#define ROP_DSPDSoaxxn	0x79
+#define ROP_DPSDnoax	0x7A
+#define ROP_SDPxnan	0x7B
+#define ROP_SPDSnoax	0x7C
+#define ROP_DPSxnan	0x7D
+#define ROP_SPxDSxo	0x7E
+#define ROP_DPSaan	0x7F
+#define ROP_DPSaa	0x80
+#define ROP_SPxDSxon	0x81
+#define ROP_DPSxna	0x82
+#define ROP_SPDSnoaxn	0x83
+#define ROP_SDPxna	0x84
+#define ROP_PDSPnoaxn	0x85
+#define ROP_DSPDSoaxx	0x86
+#define ROP_PDSaxn	0x87
+#define ROP_DSa		0x88
+#define ROP_SDPSnaoxn	0x89
+#define ROP_DSPnoa	0x8A
+#define ROP_DSPDxoxn	0x8B
+#define ROP_SDPnoa	0x8C
+#define ROP_SDPSxoxn	0x8D
+#define ROP_SSDxPDxax	0x8E
+#define ROP_PDSanan	0x8F
+#define ROP_PDSxna	0x90
+#define ROP_SDPSnoaxn	0x91
+#define ROP_DPSDPoaxx	0x92
+#define ROP_SPDaxn	0x93
+#define ROP_PSDPSoaxx	0x94
+#define ROP_DPSaxn	0x95
+#define ROP_DPSxx	0x96
+#define ROP_PSDPSonoxx	0x97
+#define ROP_SDPSonoxn	0x98
+#define ROP_DSxn	0x99
+#define ROP_DPSnax	0x9A
+#define ROP_SDPSoaxn	0x9B
+#define ROP_SPDnax	0x9C
+#define ROP_DSPDoaxn	0x9D
+#define ROP_DSPDSaoxx	0x9E
+#define ROP_PDSxan	0x9F
+#define ROP_DPa		0xA0
+#define ROP_PDSPnaoxn	0xA1
+#define ROP_DPSnoa	0xA2
+#define ROP_DPSDxoxn	0xA3
+#define ROP_PDSPonoxn	0xA4
+#define ROP_PDxn	0xA5
+#define ROP_DSPnax	0xA6
+#define ROP_PDSPoaxn	0xA7
+#define ROP_DPSoa	0xA8
+#define ROP_DPSoxn	0xA9
+#define ROP_D		0xAA
+#define ROP_DPSono	0xAB
+#define ROP_SPDSxax	0xAC
+#define ROP_DPSDaoxn	0xAD
+#define ROP_DSPnao	0xAE
+#define ROP_DPno	0xAF
+#define ROP_PDSnoa	0xB0
+#define ROP_PDSPxoxn	0xB1
+#define ROP_SSPxDSxox	0xB2
+#define ROP_SDPanan	0xB3
+#define ROP_PSDnax	0xB4
+#define ROP_DPSDoaxn	0xB5
+#define ROP_DPSDPaoxx	0xB6
+#define ROP_SDPxan	0xB7
+#define ROP_PSDPxax	0xB8
+#define ROP_DSPDaoxn	0xB9
+#define ROP_DPSnao	0xBA
+#define ROP_DSno	0xBB
+#define ROP_SPDSanax	0xBC
+#define ROP_SDxPDxan	0xBD
+#define ROP_DPSxo	0xBE
+#define ROP_DPSano	0xBF
+#define ROP_Psa		0xC0
+#define ROP_SPDSnaoxn	0xC1
+#define ROP_SPDSonoxn	0xC2
+#define ROP_PSxn	0xC3
+#define ROP_SPDnoa	0xC4
+#define ROP_SPDSxoxn	0xC5
+#define ROP_SDPnax	0xC6
+#define ROP_PSDPoaxn	0xC7
+#define ROP_SDPoa	0xC8
+#define ROP_SPDoxn	0xC9
+#define ROP_DPSDxax	0xCA
+#define ROP_SPDSaoxn	0xCB
+#define ROP_S		0xCC
+#define ROP_SDPono	0xCD
+#define ROP_SDPnao	0xCE
+#define ROP_SPno	0xCF
+#define ROP_PSDnoa	0xD0
+#define ROP_PSDPxoxn	0xD1
+#define ROP_PDSnax	0xD2
+#define ROP_SPDSoaxn	0xD3
+#define ROP_SSPxPDxax	0xD4
+#define ROP_DPSanan	0xD5
+#define ROP_PSDPSaoxx	0xD6
+#define ROP_DPSxan	0xD7
+#define ROP_PDSPxax	0xD8
+#define ROP_SDPSaoxn	0xD9
+#define ROP_DPSDanax	0xDA
+#define ROP_SPxDSxan	0xDB
+#define ROP_SPDnao	0xDC
+#define ROP_SDno	0xDD
+#define ROP_SDPxo	0xDE
+#define ROP_SDPano	0xDF
+#define ROP_PDSoa	0xE0
+#define ROP_PDSoxn	0xE1
+#define ROP_DSPDxax	0xE2
+#define ROP_PSDPaoxn	0xE3
+#define ROP_SDPSxax	0xE4
+#define ROP_PDSPaoxn	0xE5
+#define ROP_SDPSanax	0xE6
+#define ROP_SPxPDxan	0xE7
+#define ROP_SSPxDSxax	0xE8
+#define ROP_DSPDSanaxxn	0xE9
+#define ROP_DPSao	0xEA
+#define ROP_DPSxno	0xEB
+#define ROP_SDPao	0xEC
+#define ROP_SDPxno	0xED
+#define ROP_DSo		0xEE
+#define ROP_SDPnoo	0xEF
+#define ROP_P		0xF0
+#define ROP_PDSono	0xF1
+#define ROP_PDSnao	0xF2
+#define ROP_PSno	0xF3
+#define ROP_PSDnao	0xF4
+#define ROP_PDno	0xF5
+#define ROP_PDSxo	0xF6
+#define ROP_PDSano	0xF7
+#define ROP_PDSao	0xF8
+#define ROP_PDSxno	0xF9
+#define ROP_DPo		0xFA
+#define ROP_DPSnoo	0xFB
+#define ROP_PSo		0xFC
+#define ROP_PSDnoo	0xFD
+#define ROP_DPSoo	0xFE
+#define ROP_1		0xFF
+
+#define NO_SRC_ROP(rop) \
+   ((rop == GXnoop) || (rop == GXset) || (rop == GXclear) || (rop == GXinvert))
+
+extern _X_EXPORT int XAAHelpSolidROP(ScrnInfoPtr pScrn, int *fg, int pm, int *rop);
+extern _X_EXPORT int XAAHelpPatternROP(ScrnInfoPtr pScrn, int *fg, int *bg, int pm, int *rop);
+
+/* XXX These four should be static, but it breaks the 6.7.0 ABI. */
+extern _X_EXPORT int XAACopyROP[16];
+extern _X_EXPORT int XAACopyROP_PM[16];
+extern _X_EXPORT int XAAPatternROP[16];
+extern _X_EXPORT int XAAPatternROP_PM[16];
+
+extern _X_EXPORT int XAAGetCopyROP(int i);
+extern _X_EXPORT int XAAGetCopyROP_PM(int i);
+extern _X_EXPORT int XAAGetPatternROP(int i);
+extern _X_EXPORT int XAAGetPatternROP_PM(int i);
+
+#endif /* _XAAROP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_size.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/indirect_size.h
@@ -0,0 +1,88 @@
+/* DO NOT EDIT - This file generated automatically by glX_proto_size.py (from Mesa) script */
+
+/*
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#if !defined( _INDIRECT_SIZE_H_ )
+#  define _INDIRECT_SIZE_H_
+
+/**
+ * \file
+ * Prototypes for functions used to determine the number of data elements in
+ * various GLX protocol messages.
+ *
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+
+#  if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))
+#    define PURE __attribute__((pure))
+#  else
+#    define PURE
+#  endif
+
+#  if defined(__i386__) && defined(__GNUC__) && !defined(__CYGWIN__) && !defined(__MINGW32__)
+#    define FASTCALL __attribute__((fastcall))
+#  else
+#    define FASTCALL
+#  endif
+
+#  if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))) && defined(__ELF__)
+#    define INTERNAL  __attribute__((visibility("internal")))
+#  else
+#    define INTERNAL
+#  endif
+
+extern INTERNAL PURE FASTCALL GLint __glCallLists_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glFogfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glFogiv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glLightfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glLightiv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glLightModelfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glLightModeliv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMaterialfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMaterialiv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexEnvfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexEnviv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexGendv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexGenfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glTexGeniv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMap1d_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMap1f_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMap2d_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glMap2f_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glColorTableParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glColorTableParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glConvolutionParameterfv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glConvolutionParameteriv_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glPointParameterfvEXT_size(GLenum);
+extern INTERNAL PURE FASTCALL GLint __glPointParameterivNV_size(GLenum);
+
+#  undef PURE
+#  undef FASTCALL
+#  undef INTERNAL
+
+#endif /* !defined( _INDIRECT_SIZE_H_ ) */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxdrawable.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxdrawable.h
@@ -0,0 +1,66 @@
+#ifndef _GLX_drawable_h_
+#define _GLX_drawable_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+typedef struct {
+
+    DrawablePtr pDraw;
+    __GLXvisualConfig *pGlxVisual;
+    __GLXscreenInfo *pGlxScreen;
+    __GLXFBConfig *pFBConfig;
+    ScreenPtr pScreen;
+    Bool idExists;
+    int refcnt;
+    XID *be_xids;
+
+} __GLXpixmap;
+
+typedef struct {
+    DrawablePtr pDraw;
+    int type;
+    Bool idExists;
+    int refcnt;                         /* contexts bound */
+    __GLXFBConfig *pGlxFBConfig;
+    ScreenPtr pScreen;
+} __glXWindow;
+
+
+typedef struct {
+    __GLXscreenInfo *pGlxScreen;
+    __GLXFBConfig *pFBConfig;
+    ScreenPtr pScreen;
+    Bool idExists;
+    int refcnt;
+    XID *be_xids;
+} __glXPbuffer;
+
+#endif /* !__GLX_drawable_h__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapi.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapi.h
@@ -0,0 +1,171 @@
+/*
+ * Mesa 3-D graphics library
+ * Version:  7.1
+ *
+ * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+
+/**
+ * \mainpage Mesa GL API Module
+ *
+ * \section GLAPIIntroduction Introduction
+ *
+ * The Mesa GL API module is responsible for dispatching all the
+ * gl*() functions.  All GL functions are dispatched by jumping through
+ * the current dispatch table (basically a struct full of function
+ * pointers.)
+ *
+ * A per-thread current dispatch table and per-thread current context
+ * pointer are managed by this module too.
+ *
+ * This module is intended to be non-Mesa-specific so it can be used
+ * with the X/DRI libGL also.
+ */
+
+
+#ifndef _GLAPI_H
+#define _GLAPI_H
+
+#define GL_GLEXT_PROTOTYPES
+
+#include "GL/gl.h"
+#include "GL/glext.h"
+#include "glthread.h"
+
+
+struct _glapi_table;
+
+typedef void (*_glapi_proc)(void); /* generic function pointer */
+
+typedef void (*_glapi_warning_func)(void *ctx, const char *str, ...);
+
+
+#if defined(USE_MGL_NAMESPACE)
+#define _glapi_set_dispatch _mglapi_set_dispatch
+#define _glapi_get_dispatch _mglapi_get_dispatch
+#define _glapi_set_context _mglapi_set_context
+#define _glapi_get_context _mglapi_get_context
+#define _glapi_Context _mglapi_Context
+#define _glapi_Dispatch _mglapi_Dispatch
+#endif
+
+
+/*
+ * Number of extension functions which we can dynamically add at runtime.
+ */
+#define MAX_EXTENSION_FUNCS 300
+
+
+/**
+ ** Define the GET_CURRENT_CONTEXT() macro.
+ ** \param C local variable which will hold the current context.
+ **/
+#if defined (GLX_USE_TLS)
+
+const extern void *_glapi_Context;
+const extern struct _glapi_table *_glapi_Dispatch;
+
+extern __thread void * _glapi_tls_Context
+    __attribute__((tls_model("initial-exec")));
+
+# define GET_CURRENT_CONTEXT(C)  GLcontext *C = (GLcontext *) _glapi_tls_Context
+
+#else
+
+extern void *_glapi_Context;
+extern struct _glapi_table *_glapi_Dispatch;
+
+# ifdef THREADS
+#  define GET_CURRENT_CONTEXT(C)  GLcontext *C = (GLcontext *) (_glapi_Context ? _glapi_Context : _glapi_get_context())
+# else
+#  define GET_CURRENT_CONTEXT(C)  GLcontext *C = (GLcontext *) _glapi_Context
+# endif
+
+#endif /* defined (GLX_USE_TLS) */
+
+
+/**
+ ** GL API public functions
+ **/
+
+extern void
+_glapi_noop_enable_warnings(GLboolean enable);
+
+extern void
+_glapi_set_warning_func(_glapi_warning_func func);
+
+extern void
+_glapi_check_multithread(void);
+
+
+extern void
+_glapi_set_context(void *context);
+
+
+extern void *
+_glapi_get_context(void);
+
+
+extern void
+_glapi_set_dispatch(struct _glapi_table *dispatch);
+
+
+extern struct _glapi_table *
+_glapi_get_dispatch(void);
+
+
+extern int
+_glapi_begin_dispatch_override(struct _glapi_table *override);
+
+
+extern void
+_glapi_end_dispatch_override(int layer);
+
+
+struct _glapi_table *
+_glapi_get_override_dispatch(int layer);
+
+
+extern GLuint
+_glapi_get_dispatch_table_size(void);
+
+
+extern void
+_glapi_check_table(const struct _glapi_table *table);
+
+
+extern int
+_glapi_add_dispatch( const char * const * function_names,
+		     const char * parameter_signature );
+
+extern GLint
+_glapi_get_proc_offset(const char *funcName);
+
+
+extern _glapi_proc
+_glapi_get_proc_address(const char *funcName);
+
+
+extern const char *
+_glapi_get_proc_name(GLuint offset);
+
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinputinit.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxinputinit.h
@@ -0,0 +1,291 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for low-level input support.  \see dmxinputinit.c */
+
+#ifndef _DMXINPUTINIT_H_
+#define _DMXINPUTINIT_H_
+
+#include "dmx.h"
+#include "dmxinput.h"
+#include "dmxlog.h"
+
+
+#define DMX_LOCAL_DEFAULT_KEYBOARD "kbd"
+#define DMX_LOCAL_DEFAULT_POINTER  "ps2"
+#define DMX_MAX_BUTTONS            256
+#define DMX_MOTION_SIZE            256
+#define DMX_MAX_VALUATORS          32
+#define DMX_MAX_AXES               32
+#define DMX_MAX_XINPUT_EVENT_TYPES 100
+#define DMX_MAP_ENTRIES            16 /* Must be a power of 2 */
+#define DMX_MAP_MASK               (DMX_MAP_ENTRIES - 1)
+
+typedef enum {
+    DMX_FUNCTION_GRAB,
+    DMX_FUNCTION_TERMINATE,
+    DMX_FUNCTION_FINE
+} DMXFunctionType;
+
+typedef enum {
+    DMX_LOCAL_HIGHLEVEL,
+    DMX_LOCAL_KEYBOARD,
+    DMX_LOCAL_MOUSE,
+    DMX_LOCAL_OTHER
+} DMXLocalInputType;
+
+typedef enum {
+    DMX_LOCAL_TYPE_LOCAL,
+    DMX_LOCAL_TYPE_CONSOLE,
+    DMX_LOCAL_TYPE_BACKEND,
+    DMX_LOCAL_TYPE_COMMON
+} DMXLocalInputExtType;
+
+typedef enum {
+    DMX_RELATIVE,
+    DMX_ABSOLUTE,
+    DMX_ABSOLUTE_CONFINED
+} DMXMotionType;
+
+/** Stores information from low-level device that is used to initialize
+ * the device at the dix level. */
+typedef struct _DMXLocalInitInfo {
+    int                  keyboard; /**< Non-zero if the device is a keyboard */
+    
+    int                  keyClass; /**< Non-zero if keys are present */
+    KeySymsRec           keySyms;  /**< Key symbols */
+    int                  freemap;  /**< If non-zero, free keySyms.map */
+    CARD8                modMap[MAP_LENGTH]; /**< Modifier map */
+    XkbDescPtr           xkb;       /**< XKB description */
+    XkbComponentNamesRec names;     /**< XKB component names */
+    int                  freenames; /**< Non-zero if names should be free'd */
+    int                  force;     /**< Do not allow command line override */
+
+    int                  buttonClass; /**< Non-zero if buttons are present */
+    int                  numButtons;  /**< Number of buttons */
+    unsigned char        map[DMX_MAX_BUTTONS]; /**< Button map */
+
+    int                  valuatorClass; /**< Non-zero if valuators are
+                                         * present */
+    int                  numRelAxes;    /**< Number of relative axes */
+    int                  numAbsAxes;    /**< Number of absolute axes */
+    int                  minval[DMX_MAX_AXES]; /**< Minimum values */
+    int                  maxval[DMX_MAX_AXES]; /**< Maximum values */
+    int                  res[DMX_MAX_AXES];    /**< Resolution */
+    int                  minres[DMX_MAX_AXES]; /**< Minimum resolutions */
+    int                  maxres[DMX_MAX_AXES]; /**< Maximum resolutions */
+
+    int                  focusClass;       /**< Non-zero if device can
+                                            * cause focus */
+    int                  proximityClass;   /**< Non-zero if device
+                                            * causes proximity events */
+    int                  kbdFeedbackClass; /**< Non-zero if device has
+                                            * keyboard feedback */ 
+    int                  ptrFeedbackClass; /**< Non-zero if device has
+                                            * pointer feedback */
+    int                  ledFeedbackClass; /**< Non-zero if device has
+                                            * LED indicators */
+    int                  belFeedbackClass; /**< Non-zero if device has a
+                                            * bell */ 
+    int                  intFeedbackClass; /**< Non-zero if device has
+                                            * integer feedback */
+    int                  strFeedbackClass; /**< Non-zero if device has
+                                            * string feedback */
+
+    int                  maxSymbols;          /**< Maximum symbols */
+    int                  maxSymbolsSupported; /**< Maximum symbols supported */
+    KeySym               *symbols;            /**< Key symbols */
+} DMXLocalInitInfo, *DMXLocalInitInfoPtr;
+
+typedef pointer (*dmxCreatePrivateProcPtr)(DeviceIntPtr);
+typedef void    (*dmxDestroyPrivateProcPtr)(pointer);
+                
+typedef void    (*dmxInitProcPtr)(DevicePtr);
+typedef void    (*dmxReInitProcPtr)(DevicePtr);
+typedef void    (*dmxLateReInitProcPtr)(DevicePtr);
+typedef void    (*dmxGetInfoProcPtr)(DevicePtr, DMXLocalInitInfoPtr);
+typedef int     (*dmxOnProcPtr)(DevicePtr);
+typedef void    (*dmxOffProcPtr)(DevicePtr);
+typedef void    (*dmxUpdatePositionProcPtr)(pointer, int x, int y);
+                
+typedef void    (*dmxVTPreSwitchProcPtr)(pointer);  /* Turn I/O Off */
+typedef void    (*dmxVTPostSwitchProcPtr)(pointer); /* Turn I/O On */
+typedef void    (*dmxVTSwitchReturnProcPtr)(pointer);
+typedef int     (*dmxVTSwitchProcPtr)(pointer, int vt,
+                                      dmxVTSwitchReturnProcPtr, pointer);
+                
+typedef void    (*dmxMotionProcPtr)(DevicePtr,
+                                    int *valuators,
+                                    int firstAxis,
+                                    int axesCount,
+                                    DMXMotionType type,
+                                    DMXBlockType block);
+typedef void    (*dmxEnqueueProcPtr)(DevicePtr, int type, int detail,
+                                     KeySym keySym, XEvent *e,
+                                     DMXBlockType block);
+typedef int     (*dmxCheckSpecialProcPtr)(DevicePtr, KeySym keySym);
+typedef void    (*dmxCollectEventsProcPtr)(DevicePtr,
+                                           dmxMotionProcPtr,
+                                           dmxEnqueueProcPtr,
+                                           dmxCheckSpecialProcPtr,
+                                           DMXBlockType);
+typedef void    (*dmxProcessInputProcPtr)(pointer);
+typedef void    (*dmxUpdateInfoProcPtr)(pointer, DMXUpdateType, WindowPtr);
+typedef int     (*dmxFunctionsProcPtr)(pointer, DMXFunctionType);
+                
+typedef void    (*dmxKBCtrlProcPtr)(DevicePtr, KeybdCtrl *ctrl);
+typedef void    (*dmxMCtrlProcPtr)(DevicePtr, PtrCtrl *ctrl);
+typedef void    (*dmxKBBellProcPtr)(DevicePtr, int percent,
+                                    int volume, int pitch, int duration);
+
+/** Stores a mapping between the device id on the remote X server and
+ * the id on the DMX server */
+typedef struct _DMXEventMap {
+    int remote;                 /**< Event number on remote X server */
+    int server;                 /**< Event number (unbiased) on DMX server */
+} DMXEventMap;
+
+/** This is the device-independent structure used by the low-level input
+ * routines.  The contents are not exposed to top-level .c files (except
+ * dmxextensions.c).  \see dmxinput.h \see dmxextensions.c */
+typedef struct _DMXLocalInputInfo {
+    const char               *name;   /**< Device name */
+    DMXLocalInputType        type;    /**< Device type  */
+    DMXLocalInputExtType     extType; /**< Extended device type */
+    int                      binding; /**< Count of how many consecutive
+                                       * structs are bound to the same
+                                       * device */
+    
+                                /* Low-level (e.g., keyboard/mouse drivers) */
+
+    dmxCreatePrivateProcPtr  create_private;  /**< Create
+                                               * device-dependent
+                                               * private */
+    dmxDestroyPrivateProcPtr destroy_private; /**< Destroy
+                                               * device-dependent
+                                               * private */
+    dmxInitProcPtr           init;            /**< Initialize device  */
+    dmxReInitProcPtr         reinit;          /**< Reinitialize device
+                                               * (during a
+                                               * reconfiguration) */
+    dmxLateReInitProcPtr     latereinit;      /**< Reinitialize a device
+                                               * (called very late
+                                               * during a
+                                               * reconfiguration) */
+    dmxGetInfoProcPtr        get_info;        /**< Get device information */
+    dmxOnProcPtr             on;              /**< Turn device on */
+    dmxOffProcPtr            off;             /**< Turn device off */
+    dmxUpdatePositionProcPtr update_position; /**< Called when another
+                                               * device updates the
+                                               * cursor position */
+    dmxVTPreSwitchProcPtr    vt_pre_switch;   /**< Called before a VT switch */
+    dmxVTPostSwitchProcPtr   vt_post_switch;  /**< Called after a VT switch */
+    dmxVTSwitchProcPtr       vt_switch;       /**< Causes a VT switch */
+
+    dmxCollectEventsProcPtr  collect_events;  /**< Collect and enqueue
+                                               * events from the
+                                               * device*/
+    dmxProcessInputProcPtr   process_input;   /**< Process event (from
+                                               * queue)  */
+    dmxFunctionsProcPtr      functions;
+    dmxUpdateInfoProcPtr     update_info;     /**< Update window layout
+                                               * information */
+
+    dmxMCtrlProcPtr          mCtrl;           /**< Pointer control */
+    dmxKBCtrlProcPtr         kCtrl;           /**< Keyboard control */
+    dmxKBBellProcPtr         kBell;           /**< Bell control */
+
+    pointer                  private;         /**< Device-dependent private  */
+    int                      isCore;          /**< Is a DMX core device  */
+    int                      sendsCore;       /**< Sends DMX core events */
+    KeybdCtrl                kctrl;           /**< Keyboard control */
+    PtrCtrl                  mctrl;           /**< Pointer control */
+
+    DeviceIntPtr             pDevice;         /**< X-level device  */
+    int                      inputIdx;        /**< High-level index */
+    int                      lastX, lastY;    /**< Last known position;
+                                               * for XInput in
+                                               * dmxevents.c */ 
+
+    int                      head;            /**< XInput motion history
+                                               * head */
+    int                      tail;            /**< XInput motion history
+                                               * tail */
+    unsigned long            *history;        /**< XInput motion history */
+    int                      *valuators;      /**< Cache of previous values */
+    
+                                /* for XInput ChangePointerDevice */
+    int                      (*savedMotionProc)(DeviceIntPtr,
+                                                xTimecoord *,
+                                                unsigned long,
+                                                unsigned long,
+                                                ScreenPtr);
+    int                      savedMotionEvents; /**< Saved motion events */
+    int                      savedSendsCore;    /**< Saved sends-core flag */
+
+    DMXEventMap              map[DMX_MAP_ENTRIES]; /**< XInput device id map */
+    int                      mapOptimize;          /**< XInput device id
+                                                    * map
+                                                    * optimization */
+
+    long                     deviceId;    /**< device id on remote side,
+                                           * if any */
+    const char               *deviceName; /**< devive name on remote
+                                           * side, if any */
+} DMXLocalInputInfoRec;
+
+extern DMXLocalInputInfoPtr dmxLocalCorePointer, dmxLocalCoreKeyboard;
+
+extern void                 dmxLocalInitInput(DMXInputInfo *dmxInput);
+extern DMXLocalInputInfoPtr dmxInputCopyLocal(DMXInputInfo *dmxInput,
+                                              DMXLocalInputInfoPtr s);
+
+extern void dmxChangePointerControl(DeviceIntPtr pDevice, PtrCtrl *ctrl);
+extern void dmxKeyboardKbdCtrlProc(DeviceIntPtr pDevice, KeybdCtrl *ctrl);
+extern void dmxKeyboardBellProc(int percent, DeviceIntPtr pDevice,
+                                pointer ctrl, int unknown);
+
+extern int  dmxInputExtensionErrorHandler(Display *dsp, _Xconst char *name,
+                                          _Xconst char *reason);
+
+extern int          dmxInputDetach(DMXInputInfo *dmxInput);
+extern void         dmxInputDetachAll(DMXScreenInfo *dmxScreen);
+extern int          dmxInputDetachId(int id);
+extern DMXInputInfo *dmxInputLocateId(int id);
+extern int          dmxInputAttachConsole(const char *name, int isCore,
+                                          int *id);
+extern int          dmxInputAttachBackend(int physicalScreen, int isCore,
+                                          int *id);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/x86emu.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/x86emu.h
@@ -0,0 +1,198 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for public specific functions.
+*               Any application linking against us should only
+*               include this header
+*
+****************************************************************************/
+
+#ifndef __X86EMU_X86EMU_H
+#define __X86EMU_X86EMU_H
+
+#ifdef SCITECH
+#include "scitech.h"
+#define	X86API	_ASMAPI
+#define	X86APIP	_ASMAPIP
+typedef int X86EMU_pioAddr;
+#else
+#include "x86emu/types.h"
+#define	X86API
+#define	X86APIP	*
+#endif
+#include "x86emu/regs.h"
+
+/*---------------------- Macros and type definitions ----------------------*/
+
+#ifdef PACK
+# pragma	PACK   /* Don't pack structs with function pointers! */
+#endif
+
+/****************************************************************************
+REMARKS:
+Data structure containing ponters to programmed I/O functions used by the
+emulator. This is used so that the user program can hook all programmed
+I/O for the emulator to handled as necessary by the user program. By
+default the emulator contains simple functions that do not do access the
+hardware in any way. To allow the emualtor access the hardware, you will
+need to override the programmed I/O functions using the X86EMU_setupPioFuncs
+function.
+
+HEADER:
+x86emu.h
+
+MEMBERS:
+inb		- Function to read a byte from an I/O port
+inw		- Function to read a word from an I/O port
+inl     - Function to read a dword from an I/O port
+outb	- Function to write a byte to an I/O port
+outw    - Function to write a word to an I/O port
+outl    - Function to write a dword to an I/O port
+****************************************************************************/
+typedef struct {
+	u8  	(X86APIP inb)(X86EMU_pioAddr addr);
+	u16 	(X86APIP inw)(X86EMU_pioAddr addr);
+	u32 	(X86APIP inl)(X86EMU_pioAddr addr);
+	void 	(X86APIP outb)(X86EMU_pioAddr addr, u8 val);
+	void 	(X86APIP outw)(X86EMU_pioAddr addr, u16 val);
+	void 	(X86APIP outl)(X86EMU_pioAddr addr, u32 val);
+	} X86EMU_pioFuncs;
+
+/****************************************************************************
+REMARKS:
+Data structure containing ponters to memory access functions used by the
+emulator. This is used so that the user program can hook all memory
+access functions as necessary for the emulator. By default the emulator
+contains simple functions that only access the internal memory of the
+emulator. If you need specialised functions to handle access to different
+types of memory (ie: hardware framebuffer accesses and BIOS memory access
+etc), you will need to override this using the X86EMU_setupMemFuncs
+function.
+
+HEADER:
+x86emu.h
+
+MEMBERS:
+rdb		- Function to read a byte from an address
+rdw		- Function to read a word from an address
+rdl     - Function to read a dword from an address
+wrb		- Function to write a byte to an address
+wrw    	- Function to write a word to an address
+wrl    	- Function to write a dword to an address
+****************************************************************************/
+typedef struct {
+	u8  	(X86APIP rdb)(u32 addr);
+	u16 	(X86APIP rdw)(u32 addr);
+	u32 	(X86APIP rdl)(u32 addr);
+	void 	(X86APIP wrb)(u32 addr, u8 val);
+	void 	(X86APIP wrw)(u32 addr, u16 val);
+	void	(X86APIP wrl)(u32 addr, u32 val);
+	} X86EMU_memFuncs;
+
+/****************************************************************************
+  Here are the default memory read and write
+  function in case they are needed as fallbacks.
+***************************************************************************/
+extern u8 X86API rdb(u32 addr);
+extern u16 X86API rdw(u32 addr);
+extern u32 X86API rdl(u32 addr);
+extern void X86API wrb(u32 addr, u8 val);
+extern void X86API wrw(u32 addr, u16 val);
+extern void X86API wrl(u32 addr, u32 val);
+
+#ifdef END_PACK
+# pragma	END_PACK
+#endif
+
+/*--------------------- type definitions -----------------------------------*/
+
+typedef void (X86APIP X86EMU_intrFuncs)(int num);
+extern X86EMU_intrFuncs _X86EMU_intrTab[256];
+
+/*-------------------------- Function Prototypes --------------------------*/
+
+#ifdef  __cplusplus
+extern "C" {            			/* Use "C" linkage when in C++ mode */
+#endif
+
+void 	X86EMU_setupMemFuncs(X86EMU_memFuncs *funcs);
+void 	X86EMU_setupPioFuncs(X86EMU_pioFuncs *funcs);
+void 	X86EMU_setupIntrFuncs(X86EMU_intrFuncs funcs[]);
+void 	X86EMU_prepareForInt(int num);
+
+/* decode.c */
+
+void 	X86EMU_exec(void);
+void 	X86EMU_halt_sys(void);
+
+#ifdef	DEBUG
+#define	HALT_SYS()	\
+	printk("halt_sys: file %s, line %d\n", __FILE__, __LINE__), \
+	X86EMU_halt_sys()
+#else
+#define	HALT_SYS()	X86EMU_halt_sys()
+#endif
+
+/* Debug options */
+
+#define DEBUG_DECODE_F          0x000001 /* print decoded instruction  */
+#define DEBUG_TRACE_F           0x000002 /* dump regs before/after execution */
+#define DEBUG_STEP_F            0x000004
+#define DEBUG_DISASSEMBLE_F     0x000008
+#define DEBUG_BREAK_F           0x000010
+#define DEBUG_SVC_F             0x000020
+#define DEBUG_SAVE_IP_CS_F      0x000040
+#define DEBUG_FS_F              0x000080
+#define DEBUG_PROC_F            0x000100
+#define DEBUG_SYSINT_F          0x000200 /* bios system interrupts. */
+#define DEBUG_TRACECALL_F       0x000400
+#define DEBUG_INSTRUMENT_F      0x000800
+#define DEBUG_MEM_TRACE_F       0x001000 
+#define DEBUG_IO_TRACE_F        0x002000 
+#define DEBUG_TRACECALL_REGS_F  0x004000
+#define DEBUG_DECODE_NOPRINT_F  0x008000 
+#define DEBUG_EXIT              0x010000
+#define DEBUG_SYS_F             (DEBUG_SVC_F|DEBUG_FS_F|DEBUG_PROC_F)
+
+void 	X86EMU_trace_regs(void);
+void 	X86EMU_trace_xregs(void);
+void 	X86EMU_dump_memory(u16 seg, u16 off, u32 amt);
+int 	X86EMU_trace_on(void);
+int 	X86EMU_trace_off(void);
+
+#ifdef  __cplusplus
+}                       			/* End of "C" linkage for C++   	*/
+#endif
+
+#endif /* __X86EMU_X86EMU_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxcontext.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glxcontext.h
@@ -0,0 +1,111 @@
+#ifndef _GLX_context_h_
+#define _GLX_context_h_
+
+/*
+ * SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
+ * Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice including the dates of first publication and
+ * either this permission notice or a reference to
+ * http://oss.sgi.com/projects/FreeB/
+ * shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+ * SILICON GRAPHICS, INC. BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ * Except as contained in this notice, the name of Silicon Graphics, Inc.
+ * shall not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization from
+ * Silicon Graphics, Inc.
+ */
+
+typedef struct __GLXcontextRec __GLXcontext;
+
+#include "GL/internal/glcore.h"
+
+struct __GLXcontextRec {
+    /*
+    ** list of context structs
+    */
+    struct __GLXcontextRec *last;
+    struct __GLXcontextRec *next;
+
+    /*
+    ** Pointer to screen info data for this context.  This is set
+    ** when the context is created.
+    */
+    ScreenPtr pScreen;
+    __GLXscreenInfo *pGlxScreen;
+
+    /*
+    ** This context is created with respect to this visual.
+    */
+    VisualRec *pVisual;
+    __GLXvisualConfig *pGlxVisual;
+    __GLXFBConfig *pFBConfig;
+
+    /*
+    ** The XID of this context.
+    */
+    XID id;
+    XID *real_ids;
+
+    /*
+    ** The XID of the shareList context.
+    */
+    XID share_id;
+
+    /*
+    ** Visual id.
+    */
+    VisualID vid;
+    VisualID *real_vids;
+
+    /*
+    ** screen number.
+    */
+    GLint screen;
+
+    /*
+    ** Whether this context's ID still exists.
+    */
+    GLboolean idExists;
+    
+    /*
+    ** Whether this context is current for some client.
+    */
+    GLboolean isCurrent;
+    
+    /*
+    ** Buffers for feedback and selection.
+    */
+    GLfloat *feedbackBuf;
+    GLint feedbackBufSize;	/* number of elements allocated */
+    GLuint *selectBuf;
+    GLint selectBufSize;	/* number of elements allocated */
+
+    /*
+    ** Set only if current drawable is a glx pixmap.
+    */
+    __GLXpixmap *pGlxPixmap;
+    __GLXpixmap *pGlxReadPixmap;
+    __glXWindow *pGlxWindow;
+    __glXWindow *pGlxReadWindow;
+    __glXPbuffer *pGlxPbuffer;
+    __glXPbuffer *pGlxReadPbuffer;
+
+};
+
+#endif /* !__GLX_context_h__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dbestruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dbestruct.h
@@ -0,0 +1,214 @@
+/******************************************************************************
+ * 
+ * Copyright (c) 1994, 1995  Hewlett-Packard Company
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL HEWLETT-PACKARD COMPANY BE LIABLE FOR ANY CLAIM,
+ * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
+ * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR
+ * THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Hewlett-Packard
+ * Company shall not be used in advertising or otherwise to promote the
+ * sale, use or other dealings in this Software without prior written
+ * authorization from the Hewlett-Packard Company.
+ * 
+ *     Header file for DIX-related DBE
+ *
+ *****************************************************************************/
+
+#ifndef DBE_STRUCT_H
+#define DBE_STRUCT_H
+
+
+/* INCLUDES */
+
+#define NEED_DBE_PROTOCOL
+#include <X11/extensions/dbeproto.h>
+#include "windowstr.h"
+#include "privates.h"
+
+typedef struct
+{
+    VisualID    visual;    /* one visual ID that supports double-buffering */
+    int         depth;     /* depth of visual in bits                      */
+    int         perflevel; /* performance level of visual                  */
+}
+XdbeVisualInfo;
+
+typedef struct
+{
+    int                 count;          /* number of items in visual_depth   */
+    XdbeVisualInfo      *visinfo;       /* list of visuals & depths for scrn */
+}
+XdbeScreenVisualInfo;
+
+/* DEFINES */
+
+#define DBE_SCREEN_PRIV(pScreen) ((DbeScreenPrivPtr) \
+    dixLookupPrivate(&(pScreen)->devPrivates, dbeScreenPrivKey))
+
+#define DBE_SCREEN_PRIV_FROM_DRAWABLE(pDrawable) \
+    DBE_SCREEN_PRIV((pDrawable)->pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_WINDOW_PRIV(pDbeWindowPriv) \
+    DBE_SCREEN_PRIV((pDbeWindowPriv)->pWindow->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_WINDOW(pWindow) \
+    DBE_SCREEN_PRIV((pWindow)->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_PIXMAP(pPixmap) \
+    DBE_SCREEN_PRIV((pPixmap)->drawable.pScreen)
+
+#define DBE_SCREEN_PRIV_FROM_GC(pGC)\
+    DBE_SCREEN_PRIV((pGC)->pScreen)
+
+#define DBE_WINDOW_PRIV(pWin) ((DbeWindowPrivPtr) \
+    dixLookupPrivate(&(pWin)->devPrivates, dbeWindowPrivKey))
+
+/* Initial size of the buffer ID array in the window priv. */
+#define DBE_INIT_MAX_IDS	2
+
+/* Reallocation increment for the buffer ID array. */
+#define DBE_INCR_MAX_IDS	4
+
+/* Marker for free elements in the buffer ID array. */
+#define DBE_FREE_ID_ELEMENT	0
+
+extern _X_EXPORT void DbeExtensionInit (void);
+
+/* TYPEDEFS */
+
+/* Record used to pass swap information between DIX and DDX swapping
+ * procedures.
+ */
+typedef struct _DbeSwapInfoRec
+{
+    WindowPtr		pWindow;
+    unsigned char	swapAction;
+
+} DbeSwapInfoRec, *DbeSwapInfoPtr;
+
+/*
+ ******************************************************************************
+ ** Per-window data
+ ******************************************************************************
+ */
+
+typedef struct _DbeWindowPrivRec
+{
+    /* A pointer to the window with which the DBE window private (buffer) is
+     * associated.
+     */
+    WindowPtr		pWindow;
+
+    /* Last known swap action for this buffer.  Legal values for this field
+     * are XdbeUndefined, XdbeBackground, XdbeUntouched, and XdbeCopied.
+     */
+    unsigned char	swapAction;
+
+    /* Last known buffer size.
+     */
+    unsigned short	width, height;
+
+    /* Coordinates used for static gravity when the window is positioned.
+     */
+    short		x, y;
+
+    /* Number of XIDs associated with this buffer.
+     */
+    int			nBufferIDs;
+
+    /* Capacity of the current buffer ID array, IDs. */
+    int			maxAvailableIDs;
+
+    /* Pointer to the array of buffer IDs.  This initially points to initIDs.
+     * When the static limit of the initIDs array is reached, the array is
+     * reallocated and this pointer is set to the new array instead of initIDs.
+     */
+    XID			*IDs;
+
+    /* Initial array of buffer IDs.  We are defining the XID array within the
+     * window priv to optimize for data locality.  In most cases, only one
+     * buffer will be associated with a window.  Having the array declared
+     * here can prevent us from accessing the data in another memory page,
+     * possibly resulting in a page swap and loss of performance.  Initially we
+     * will use this array to store buffer IDs.  For situations where we have
+     * more IDs than can fit in this static array, we will allocate a larger
+     * array to use, possibly suffering a performance loss. 
+     */
+    XID			initIDs[DBE_INIT_MAX_IDS];
+
+    /* Device-specific private information.
+     */
+    PrivateRec		*devPrivates;
+
+} DbeWindowPrivRec, *DbeWindowPrivPtr;
+
+
+/*
+ ******************************************************************************
+ ** Per-screen data
+ ******************************************************************************
+ */
+
+typedef struct _DbeScreenPrivRec
+{
+    /* Wrapped functions
+     * It is the responsibilty of the DDX layer to wrap PositionWindow().
+     * DbeExtensionInit wraps DestroyWindow().
+     */
+    PositionWindowProcPtr PositionWindow;
+    DestroyWindowProcPtr  DestroyWindow;
+
+    /* Per-screen DIX routines */
+    Bool	(*SetupBackgroundPainter)(
+		WindowPtr /*pWin*/,
+		GCPtr /*pGC*/
+);
+
+    /* Per-screen DDX routines */
+    Bool	(*GetVisualInfo)(
+		ScreenPtr /*pScreen*/,
+		XdbeScreenVisualInfo * /*pVisInfo*/
+);
+    int		(*AllocBackBufferName)(
+		WindowPtr /*pWin*/,
+		XID /*bufId*/,
+		int /*swapAction*/
+);
+    int		(*SwapBuffers)(
+		ClientPtr /*client*/,
+		int * /*pNumWindows*/,
+		DbeSwapInfoPtr /*swapInfo*/
+);
+    void	(*BeginIdiom)(
+		ClientPtr /*client*/
+);
+    void	(*EndIdiom)(
+		ClientPtr /*client*/
+);
+    void	(*WinPrivDelete)(
+		DbeWindowPrivPtr /*pDbeWindowPriv*/,
+		XID /*bufId*/
+);
+    void	(*ResetProc)(
+		ScreenPtr /*pScreen*/
+);
+
+} DbeScreenPrivRec, *DbeScreenPrivPtr;
+
+#endif /* DBE_STRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxbackend.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxbackend.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface to backend input device support. \see dmxbackend.c \see
+ * dmxcommon.c */
+
+#ifndef _DMXBACKEND_H_
+#define _DMXBACKEND_H_
+
+extern pointer dmxBackendCreatePrivate(DeviceIntPtr pDevice);
+extern void    dmxBackendDestroyPrivate(pointer private);
+extern void    dmxBackendInit(DevicePtr pDev);
+extern void    dmxBackendLateReInit(DevicePtr pDev);
+extern void    dmxBackendMouGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void    dmxBackendKbdGetInfo(DevicePtr pDev, DMXLocalInitInfoPtr info);
+extern void    dmxBackendCollectEvents(DevicePtr pDev,
+                                       dmxMotionProcPtr motion,
+                                       dmxEnqueueProcPtr enqueue,
+                                       dmxCheckSpecialProcPtr checkspecial,
+                                       DMXBlockType block);
+extern void    dmxBackendProcessInput(pointer private);
+extern int     dmxBackendFunctions(pointer private, DMXFunctionType function);
+extern void    dmxBackendUpdatePosition(pointer private, int x, int y);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ops.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/ops.h
@@ -0,0 +1,45 @@
+/****************************************************************************
+*
+*						Realmode X86 Emulator Library
+*
+*            	Copyright (C) 1996-1999 SciTech Software, Inc.
+* 				     Copyright (C) David Mosberger-Tang
+* 					   Copyright (C) 1999 Egbert Eich
+*
+*  ========================================================================
+*
+*  Permission to use, copy, modify, distribute, and sell this software and
+*  its documentation for any purpose is hereby granted without fee,
+*  provided that the above copyright notice appear in all copies and that
+*  both that copyright notice and this permission notice appear in
+*  supporting documentation, and that the name of the authors not be used
+*  in advertising or publicity pertaining to distribution of the software
+*  without specific, written prior permission.  The authors makes no
+*  representations about the suitability of this software for any purpose.
+*  It is provided "as is" without express or implied warranty.
+*
+*  THE AUTHORS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+*  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+*  EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+*  CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+*  USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+*  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+*  PERFORMANCE OF THIS SOFTWARE.
+*
+*  ========================================================================
+*
+* Language:		ANSI C
+* Environment:	Any
+* Developer:    Kendall Bennett
+*
+* Description:  Header file for operand decoding functions.
+*
+****************************************************************************/
+
+#ifndef __X86EMU_OPS_H
+#define __X86EMU_OPS_H
+
+extern void (*x86emu_optab[0x100])(u8 op1);
+extern void (*x86emu_optab2[0x100])(u8 op2);
+
+#endif /* __X86EMU_OPS_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damagestr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/damagestr.h
@@ -0,0 +1,114 @@
+/*
+ * Copyright © 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _DAMAGESTR_H_
+#define _DAMAGESTR_H_
+
+#include "damage.h"
+#include "gcstruct.h"
+#include "privates.h"
+# include "picturestr.h"
+
+typedef struct _damage {
+    DamagePtr		pNext;
+    DamagePtr		pNextWin;
+    RegionRec		damage;
+    
+    DamageReportLevel	damageLevel;
+    Bool		isInternal;
+    void		*closure;
+    Bool		isWindow;
+    DrawablePtr		pDrawable;
+    
+    DamageReportFunc	damageReport;
+    DamageReportFunc	damageReportPostRendering;
+    DamageDestroyFunc	damageDestroy;
+    DamageMarkerFunc	damageMarker;
+
+    Bool		reportAfter;
+    RegionRec		pendingDamage; /* will be flushed post submission at the latest */
+    RegionRec		backupDamage; /* for use with damageMarker */
+    ScreenPtr		pScreen;
+    PrivateRec		*devPrivates;
+} DamageRec;
+
+typedef struct _damageScrPriv {
+    int				internalLevel;
+
+    /*
+     * For DDXen which don't provide GetScreenPixmap, this provides
+     * a place to hook damage for windows on the screen
+     */
+    DamagePtr			pScreenDamage;
+
+    CopyWindowProcPtr		CopyWindow;
+    CloseScreenProcPtr		CloseScreen;
+    CreateGCProcPtr		CreateGC;
+    DestroyPixmapProcPtr	DestroyPixmap;
+    SetWindowPixmapProcPtr	SetWindowPixmap;
+    DestroyWindowProcPtr	DestroyWindow;
+    CompositeProcPtr		Composite;
+    GlyphsProcPtr		Glyphs;
+    AddTrapsProcPtr		AddTraps;
+
+    /* Table of wrappable function pointers */
+    DamageScreenFuncsRec	funcs;
+} DamageScrPrivRec, *DamageScrPrivPtr;
+
+typedef struct _damageGCPriv {
+    GCOps   *ops;
+    GCFuncs *funcs;
+} DamageGCPrivRec, *DamageGCPrivPtr;
+
+/* XXX should move these into damage.c, damageScrPrivateIndex is static */
+#define damageGetScrPriv(pScr) ((DamageScrPrivPtr) \
+    dixLookupPrivate(&(pScr)->devPrivates, damageScrPrivateKey))
+
+#define damageScrPriv(pScr) \
+    DamageScrPrivPtr    pScrPriv = damageGetScrPriv(pScr)
+
+#define damageGetPixPriv(pPix) \
+    dixLookupPrivate(&(pPix)->devPrivates, damagePixPrivateKey)
+
+#define damgeSetPixPriv(pPix,v) \
+    dixSetPrivate(&(pPix)->devPrivates, damagePixPrivateKey, v)
+
+#define damagePixPriv(pPix) \
+    DamagePtr	    pDamage = damageGetPixPriv(pPix)
+
+#define damageGetGCPriv(pGC) \
+    dixLookupPrivate(&(pGC)->devPrivates, damageGCPrivateKey)
+
+#define damageGCPriv(pGC) \
+    DamageGCPrivPtr  pGCPriv = damageGetGCPriv(pGC)
+
+#define damageGetWinPriv(pWin) \
+    ((DamagePtr)dixLookupPrivate(&(pWin)->devPrivates, damageWinPrivateKey))
+
+#define damageSetWinPriv(pWin,d) \
+    dixSetPrivate(&(pWin)->devPrivates, damageWinPrivateKey, d)
+
+#endif /* _DAMAGESTR_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/window.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/window.h
@@ -0,0 +1,269 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef WINDOW_H
+#define WINDOW_H
+
+#include "misc.h"
+#include "region.h"
+#include "screenint.h"
+#include <X11/Xproto.h>
+
+#define TOTALLY_OBSCURED 0
+#define UNOBSCURED 1
+#define OBSCURED 2
+
+#define VisibilityNotViewable	3
+
+/* return values for tree-walking callback procedures */
+#define WT_STOPWALKING		0
+#define WT_WALKCHILDREN		1
+#define WT_DONTWALKCHILDREN	2
+#define WT_NOMATCH 3
+#define NullWindow ((WindowPtr) 0)
+
+/* Forward declaration, we can't include input.h here */
+struct _DeviceIntRec;
+struct _Cursor;
+
+typedef struct _BackingStore *BackingStorePtr;
+typedef struct _Window *WindowPtr;
+
+typedef int (*VisitWindowProcPtr)(
+    WindowPtr /*pWin*/,
+    pointer /*data*/);
+
+extern _X_EXPORT int TraverseTree(
+    WindowPtr /*pWin*/,
+    VisitWindowProcPtr /*func*/,
+    pointer /*data*/);
+
+extern _X_EXPORT int WalkTree(
+    ScreenPtr /*pScreen*/,
+    VisitWindowProcPtr /*func*/,
+    pointer /*data*/);
+
+extern _X_EXPORT Bool CreateRootWindow(
+    ScreenPtr /*pScreen*/);
+
+extern _X_EXPORT void InitRootWindow(
+    WindowPtr /*pWin*/);
+
+typedef WindowPtr (* RealChildHeadProc) (WindowPtr pWin);
+
+extern _X_EXPORT void RegisterRealChildHeadProc (RealChildHeadProc proc);
+
+extern _X_EXPORT WindowPtr RealChildHead(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT WindowPtr CreateWindow(
+    Window /*wid*/,
+    WindowPtr /*pParent*/,
+    int /*x*/,
+    int /*y*/,
+    unsigned int /*w*/,
+    unsigned int /*h*/,
+    unsigned int /*bw*/,
+    unsigned int /*class*/,
+    Mask /*vmask*/,
+    XID* /*vlist*/,
+    int /*depth*/,
+    ClientPtr /*client*/,
+    VisualID /*visual*/,
+    int* /*error*/);
+
+extern _X_EXPORT int DeleteWindow(
+    pointer /*pWin*/,
+    XID /*wid*/);
+
+extern _X_EXPORT int DestroySubwindows(
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/);
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose ChangeWindowAttributes function conflicts here. */
+#ifdef __APPLE__
+#define ChangeWindowAttributes Darwin_X_ChangeWindowAttributes
+#endif
+extern _X_EXPORT int ChangeWindowAttributes(
+    WindowPtr /*pWin*/,
+    Mask /*vmask*/,
+    XID* /*vlist*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int ChangeWindowDeviceCursor(
+    WindowPtr /*pWin*/,
+    struct _DeviceIntRec* /*pDev*/,
+    struct _Cursor* /*pCursor*/);
+
+extern _X_EXPORT struct _Cursor* WindowGetDeviceCursor(
+    WindowPtr /*pWin*/,
+    struct _DeviceIntRec* /*pDev*/);
+
+/* Quartz support on Mac OS X uses the HIToolbox
+   framework whose GetWindowAttributes function conflicts here. */
+#ifdef __APPLE__
+#define GetWindowAttributes(w,c,x) Darwin_X_GetWindowAttributes(w,c,x)
+extern void Darwin_X_GetWindowAttributes(
+#else
+extern _X_EXPORT void GetWindowAttributes(
+#endif
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/,
+    xGetWindowAttributesReply* /* wa */);
+
+extern _X_EXPORT void GravityTranslate(
+    int /*x*/,
+    int /*y*/,
+    int /*oldx*/,
+    int /*oldy*/,
+    int /*dw*/,
+    int /*dh*/,
+    unsigned /*gravity*/,
+    int* /*destx*/,
+    int* /*desty*/);
+
+extern _X_EXPORT int ConfigureWindow(
+    WindowPtr /*pWin*/,
+    Mask /*mask*/,
+    XID* /*vlist*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int CirculateWindow(
+    WindowPtr /*pParent*/,
+    int /*direction*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int ReparentWindow(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pParent*/,
+    int /*x*/,
+    int /*y*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int MapWindow(
+    WindowPtr /*pWin*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT void MapSubwindows(
+    WindowPtr /*pParent*/,
+    ClientPtr /*client*/);
+
+extern _X_EXPORT int UnmapWindow(
+    WindowPtr /*pWin*/,
+    Bool /*fromConfigure*/);
+
+extern _X_EXPORT void UnmapSubwindows(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void HandleSaveSet(
+    ClientPtr /*client*/);
+
+extern _X_EXPORT Bool PointInWindowIsVisible(
+    WindowPtr /*pWin*/,
+    int /*x*/,
+    int /*y*/);
+
+extern _X_EXPORT RegionPtr NotClippedByChildren(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void SendVisibilityNotify(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT int dixSaveScreens(
+    ClientPtr client,
+    int on,
+    int mode);
+
+extern _X_EXPORT int SaveScreens(
+    int on,
+    int mode);
+
+extern _X_EXPORT WindowPtr FindWindowWithOptional(
+    WindowPtr /*w*/);
+
+extern _X_EXPORT void CheckWindowOptionalNeed(
+    WindowPtr /*w*/);
+
+extern _X_EXPORT Bool MakeWindowOptional(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT WindowPtr MoveWindowInStack(
+    WindowPtr /*pWin*/,
+    WindowPtr /*pNextSib*/);
+
+extern _X_EXPORT void SetWinSize(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void SetBorderSize(
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT void ResizeChildrenWinSize(
+    WindowPtr /*pWin*/,
+    int /*dx*/,
+    int /*dy*/,
+    int /*dw*/,
+    int /*dh*/);
+
+extern _X_EXPORT void ShapeExtensionInit(void);
+
+extern _X_EXPORT void SendShapeNotify(
+    WindowPtr /* pWin */,
+    int /* which */ );
+
+extern _X_EXPORT RegionPtr CreateBoundingShape(
+    WindowPtr /* pWin */ );
+
+extern _X_EXPORT RegionPtr CreateClipShape(
+    WindowPtr /* pWin */ );
+
+extern _X_EXPORT void DisableMapUnmapEvents(
+    WindowPtr /* pWin */ );
+extern _X_EXPORT void EnableMapUnmapEvents(
+    WindowPtr /* pWin */ );
+
+#endif /* WINDOW_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compint.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/compint.h
@@ -0,0 +1,329 @@
+/*
+ * Copyright © 2006 Sun Microsystems, Inc.  All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Copyright © 2003 Keith Packard
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and its
+ * documentation for any purpose is hereby granted without fee, provided that
+ * the above copyright notice appear in all copies and that both that
+ * copyright notice and this permission notice appear in supporting
+ * documentation, and that the name of Keith Packard not be used in
+ * advertising or publicity pertaining to distribution of the software without
+ * specific, written prior permission.  Keith Packard makes no
+ * representations about the suitability of this software for any purpose.  It
+ * is provided "as is" without express or implied warranty.
+ *
+ * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+ * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+ * PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef _COMPINT_H_
+#define _COMPINT_H_
+
+#include "misc.h"
+#include "scrnintstr.h"
+#include "os.h"
+#include "regionstr.h"
+#include "validate.h"
+#include "windowstr.h"
+#include "input.h"
+#include "resource.h"
+#include "colormapst.h"
+#include "cursorstr.h"
+#include "dixstruct.h"
+#include "gcstruct.h"
+#include "servermd.h"
+#include "dixevents.h"
+#include "globals.h"
+#include "picturestr.h"
+#include "extnsionst.h"
+#include "privates.h"
+#include "mi.h"
+#include "damage.h"
+#include "damageextint.h"
+#include "xfixes.h"
+#include <X11/extensions/compositeproto.h>
+#include <assert.h>
+
+/*
+ *  enable this for debugging
+ 
+    #define COMPOSITE_DEBUG
+ */
+
+typedef struct _CompClientWindow {
+    struct _CompClientWindow	*next;
+    XID				id;
+    int				update;
+}  CompClientWindowRec, *CompClientWindowPtr;
+
+typedef struct _CompWindow {
+    RegionRec		    borderClip;
+    DamagePtr		    damage;	/* for automatic update mode */
+    Bool		    damageRegistered;
+    Bool		    damaged;
+    int			    update;
+    CompClientWindowPtr	    clients;
+    int			    oldx;
+    int			    oldy;
+    PixmapPtr		    pOldPixmap;
+    int			    borderClipX, borderClipY;
+} CompWindowRec, *CompWindowPtr;
+
+#define COMP_ORIGIN_INVALID	    0x80000000
+
+typedef struct _CompSubwindows {
+    int			    update;
+    CompClientWindowPtr	    clients;
+} CompSubwindowsRec, *CompSubwindowsPtr;
+
+#ifndef COMP_INCLUDE_RGB24_VISUAL
+#define COMP_INCLUDE_RGB24_VISUAL 0
+#endif
+
+typedef struct _CompOverlayClientRec *CompOverlayClientPtr;
+
+typedef struct _CompOverlayClientRec {
+    CompOverlayClientPtr pNext;  
+    ClientPtr            pClient;
+    ScreenPtr            pScreen;
+    XID			 resource;
+} CompOverlayClientRec;
+
+typedef struct _CompScreen {
+    PositionWindowProcPtr	PositionWindow;
+    CopyWindowProcPtr		CopyWindow;
+    CreateWindowProcPtr		CreateWindow;
+    DestroyWindowProcPtr	DestroyWindow;
+    RealizeWindowProcPtr	RealizeWindow;
+    UnrealizeWindowProcPtr	UnrealizeWindow;
+    ClipNotifyProcPtr		ClipNotify;
+    /*
+     * Called from ConfigureWindow, these
+     * three track changes to the offscreen storage
+     * geometry
+     */
+    ConfigNotifyProcPtr         ConfigNotify;
+    MoveWindowProcPtr		MoveWindow;
+    ResizeWindowProcPtr		ResizeWindow;
+    ChangeBorderWidthProcPtr	ChangeBorderWidth;
+    /*
+     * Reparenting has an effect on Subwindows redirect
+     */
+    ReparentWindowProcPtr	ReparentWindow;
+    
+    /*
+     * Colormaps for new visuals better not get installed
+     */
+    InstallColormapProcPtr	InstallColormap;
+
+    /*
+     * Fake backing store via automatic redirection
+     */
+    ChangeWindowAttributesProcPtr ChangeWindowAttributes;
+
+    ScreenBlockHandlerProcPtr	BlockHandler;
+    CloseScreenProcPtr		CloseScreen;
+    Bool			damaged;
+    int				numAlternateVisuals;
+    VisualID			*alternateVisuals;
+
+    WindowPtr                   pOverlayWin;
+    Window			overlayWid;
+    CompOverlayClientPtr        pOverlayClients;
+    
+} CompScreenRec, *CompScreenPtr;
+
+extern DevPrivateKeyRec CompScreenPrivateKeyRec;
+#define CompScreenPrivateKey (&CompScreenPrivateKeyRec)
+
+extern DevPrivateKeyRec CompWindowPrivateKeyRec;
+#define CompWindowPrivateKey (&CompWindowPrivateKeyRec)
+
+extern DevPrivateKeyRec CompSubwindowsPrivateKeyRec;
+#define CompSubwindowsPrivateKey (&CompSubwindowsPrivateKeyRec)
+
+#define GetCompScreen(s) ((CompScreenPtr) \
+    dixLookupPrivate(&(s)->devPrivates, CompScreenPrivateKey))
+#define GetCompWindow(w) ((CompWindowPtr) \
+    dixLookupPrivate(&(w)->devPrivates, CompWindowPrivateKey))
+#define GetCompSubwindows(w) ((CompSubwindowsPtr) \
+    dixLookupPrivate(&(w)->devPrivates, CompSubwindowsPrivateKey))
+
+extern RESTYPE		CompositeClientWindowType;
+extern RESTYPE		CompositeClientSubwindowsType;
+extern RESTYPE		CompositeClientOverlayType;
+
+/*
+ * compalloc.c
+ */
+
+Bool
+compRedirectWindow (ClientPtr pClient, WindowPtr pWin, int update);
+
+void
+compFreeClientWindow (WindowPtr pWin, XID id);
+
+int
+compUnredirectWindow (ClientPtr pClient, WindowPtr pWin, int update);
+
+int
+compRedirectSubwindows (ClientPtr pClient, WindowPtr pWin, int update);
+
+void
+compFreeClientSubwindows (WindowPtr pWin, XID id);
+
+int
+compUnredirectSubwindows (ClientPtr pClient, WindowPtr pWin, int update);
+
+int
+compRedirectOneSubwindow (WindowPtr pParent, WindowPtr pWin);
+
+int
+compUnredirectOneSubwindow (WindowPtr pParent, WindowPtr pWin);
+
+Bool
+compAllocPixmap (WindowPtr pWin);
+
+void
+compFreePixmap (WindowPtr pWin);
+
+Bool
+compReallocPixmap (WindowPtr pWin, int x, int y,
+		   unsigned int w, unsigned int h, int bw);
+
+/*
+ * compext.c
+ */
+
+void
+CompositeExtensionInit (void);
+
+/*
+ * compinit.c
+ */
+
+Bool
+compScreenInit (ScreenPtr pScreen);
+
+/*
+ * compoverlay.c
+ */
+
+void
+compFreeOverlayClient (CompOverlayClientPtr pOcToDel);
+
+CompOverlayClientPtr
+compFindOverlayClient (ScreenPtr pScreen, ClientPtr pClient);
+    
+CompOverlayClientPtr
+compCreateOverlayClient (ScreenPtr pScreen, ClientPtr pClient);
+
+Bool
+compCreateOverlayWindow (ScreenPtr pScreen);
+
+void
+compDestroyOverlayWindow (ScreenPtr pScreen);
+
+/*
+ * compwindow.c
+ */
+
+#ifdef COMPOSITE_DEBUG
+void
+compCheckTree (ScreenPtr pScreen);
+#else
+#define compCheckTree(s)
+#endif
+
+PictFormatPtr
+compWindowFormat (WindowPtr pWin);
+
+void
+compSetPixmap (WindowPtr pWin, PixmapPtr pPixmap);
+
+Bool
+compCheckRedirect (WindowPtr pWin);
+
+Bool
+compPositionWindow (WindowPtr pWin, int x, int y);
+
+Bool
+compRealizeWindow (WindowPtr pWin);
+
+Bool
+compUnrealizeWindow (WindowPtr pWin);
+
+void
+compClipNotify (WindowPtr pWin, int dx, int dy);
+
+void
+compMoveWindow (WindowPtr pWin, int x, int y, WindowPtr pSib, VTKind kind);
+
+void
+compResizeWindow (WindowPtr pWin, int x, int y,
+		  unsigned int w, unsigned int h, WindowPtr pSib);
+
+void
+compChangeBorderWidth (WindowPtr pWin, unsigned int border_width);
+
+void
+compReparentWindow (WindowPtr pWin, WindowPtr pPriorParent);
+
+Bool
+compCreateWindow (WindowPtr pWin);
+
+Bool
+compDestroyWindow (WindowPtr pWin);
+
+void
+compSetRedirectBorderClip (WindowPtr pWin, RegionPtr pRegion);
+
+RegionPtr
+compGetRedirectBorderClip (WindowPtr pWin);
+
+void
+compCopyWindow (WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc);
+
+void
+compWindowUpdate (WindowPtr pWin);
+
+WindowPtr
+CompositeRealChildHead (WindowPtr pWin);
+
+int
+DeleteWindowNoInputDevices(pointer value, XID wid);
+
+int
+compConfigNotify(WindowPtr pWin, int x, int y, int w, int h,
+		 int bw, WindowPtr pSib);
+
+#endif /* _COMPINT_H_ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiwarppointer.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiwarppointer.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2007-2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer, University of South Australia, NICTA
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef WARPDEVP_H
+#define WARPDEVP_H 1
+
+int SProcXIWarpPointer(ClientPtr /* client */);
+int ProcXIWarpPointer(ClientPtr	/* client */);
+
+#endif /* WARPDEVP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/configProcs.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/configProcs.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 1997-2001 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/* Private procs.  Public procs are in xf86Parser.h and xf86Optrec.h */
+
+/* exported functions are/were used by the X Server, and need to be
+ * made public when installing libxf86config */
+
+/* Device.c */
+XF86ConfDevicePtr xf86parseDeviceSection(void);
+void xf86printDeviceSection(FILE *cf, XF86ConfDevicePtr ptr);
+void xf86freeDeviceList(XF86ConfDevicePtr ptr);
+int xf86validateDevice(XF86ConfigPtr p);
+/* Files.c */
+XF86ConfFilesPtr xf86parseFilesSection(void);
+void xf86printFileSection(FILE *cf, XF86ConfFilesPtr ptr);
+void xf86freeFiles(XF86ConfFilesPtr p);
+/* Flags.c */
+XF86ConfFlagsPtr xf86parseFlagsSection(void);
+void xf86printServerFlagsSection(FILE *f, XF86ConfFlagsPtr flags);
+void xf86freeFlags(XF86ConfFlagsPtr flags);
+/* Input.c */
+XF86ConfInputPtr xf86parseInputSection(void);
+void xf86printInputSection(FILE *f, XF86ConfInputPtr ptr);
+void xf86freeInputList(XF86ConfInputPtr ptr);
+int xf86validateInput (XF86ConfigPtr p);
+/* InputClass.c */
+XF86ConfInputClassPtr xf86parseInputClassSection(void);
+void xf86printInputClassSection(FILE *f, XF86ConfInputClassPtr ptr);
+void xf86freeInputClassList(XF86ConfInputClassPtr ptr);
+/* Layout.c */
+XF86ConfLayoutPtr xf86parseLayoutSection(void);
+void xf86printLayoutSection(FILE *cf, XF86ConfLayoutPtr ptr);
+void xf86freeLayoutList(XF86ConfLayoutPtr ptr);
+int xf86validateLayout(XF86ConfigPtr p);
+/* Module.c */
+XF86ConfModulePtr xf86parseModuleSection(void);
+void xf86printModuleSection(FILE *cf, XF86ConfModulePtr ptr);
+extern _X_EXPORT XF86LoadPtr xf86addNewLoadDirective(XF86LoadPtr head, char *name, int type, XF86OptionPtr opts);
+void xf86freeModules(XF86ConfModulePtr ptr);
+/* Monitor.c */
+XF86ConfMonitorPtr xf86parseMonitorSection(void);
+XF86ConfModesPtr xf86parseModesSection(void);
+void xf86printMonitorSection(FILE *cf, XF86ConfMonitorPtr ptr);
+void xf86printModesSection(FILE *cf, XF86ConfModesPtr ptr);
+extern _X_EXPORT void xf86freeMonitorList(XF86ConfMonitorPtr ptr);
+void xf86freeModesList(XF86ConfModesPtr ptr);
+int xf86validateMonitor(XF86ConfigPtr p, XF86ConfScreenPtr screen);
+/* Pointer.c */
+XF86ConfInputPtr xf86parsePointerSection(void);
+/* Screen.c */
+XF86ConfScreenPtr xf86parseScreenSection(void);
+void xf86printScreenSection(FILE *cf, XF86ConfScreenPtr ptr);
+extern _X_EXPORT void xf86freeScreenList(XF86ConfScreenPtr ptr);
+void xf86freeAdaptorLinkList(XF86ConfAdaptorLinkPtr ptr);
+void xf86freeDisplayList(XF86ConfDisplayPtr ptr);
+void xf86freeModeList(XF86ModePtr ptr);
+int xf86validateScreen(XF86ConfigPtr p);
+/* Vendor.c */
+XF86ConfVendorPtr xf86parseVendorSection(void);
+void xf86freeVendorList(XF86ConfVendorPtr p);
+void xf86printVendorSection(FILE * cf, XF86ConfVendorPtr ptr);
+void xf86freeVendorSubList (XF86ConfVendSubPtr ptr);
+/* Video.c */
+XF86ConfVideoAdaptorPtr xf86parseVideoAdaptorSection(void);
+void xf86printVideoAdaptorSection(FILE *cf, XF86ConfVideoAdaptorPtr ptr);
+void xf86freeVideoAdaptorList(XF86ConfVideoAdaptorPtr ptr);
+/* scan.c */
+int xf86getToken(xf86ConfigSymTabRec *tab);
+int xf86getSubToken(char **comment);
+int xf86getSubTokenWithTab(char **comment, xf86ConfigSymTabRec *tab);
+void xf86unGetToken(int token);
+char *xf86tokenString(void);
+void xf86parseError(char *format, ...);
+void xf86validationError(char *format, ...);
+void xf86setSection(char *section);
+int xf86getStringToken(xf86ConfigSymTabRec *tab);
+/* write.c */
+/* DRI.c */
+XF86ConfDRIPtr xf86parseDRISection (void);
+void xf86printDRISection (FILE * cf, XF86ConfDRIPtr ptr);
+void xf86freeDRI (XF86ConfDRIPtr ptr);
+/* Extensions.c */
+XF86ConfExtensionsPtr xf86parseExtensionsSection (void);
+void xf86printExtensionsSection (FILE * cf, XF86ConfExtensionsPtr ptr);
+void xf86freeExtensions (XF86ConfExtensionsPtr ptr);
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#ifndef IN_XSERVER
+/* Externally provided functions */
+void ErrorF(const char *f, ...);
+void VErrorF(const char *f, va_list args);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/colormap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/colormap.h
@@ -0,0 +1,189 @@
+/*
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+*/
+
+#ifndef CMAP_H
+#define CMAP_H 1
+
+#include <X11/Xproto.h>
+#include "screenint.h"
+#include "window.h"
+
+/* these follow X.h's AllocNone and AllocAll */
+#define CM_PSCREEN 2
+#define CM_PWIN	   3
+/* Passed internally in colormap.c */
+#define REDMAP 0
+#define GREENMAP 1
+#define BLUEMAP 2
+#define PSEUDOMAP 3
+#define AllocPrivate (-1)
+#define AllocTemporary (-2)
+#define DynamicClass  1
+
+/* Values for the flags field of a colormap. These should have 1 bit set
+ * and not overlap */
+#define IsDefault 1
+#define AllAllocated 2
+#define BeingCreated 4
+
+
+typedef CARD32 Pixel;
+typedef struct _CMEntry *EntryPtr;
+/* moved to screenint.h: typedef struct _ColormapRec *ColormapPtr */
+typedef struct _colorResource *colorResourcePtr;
+
+extern _X_EXPORT int CreateColormap(
+    Colormap /*mid*/,
+    ScreenPtr /*pScreen*/,
+    VisualPtr /*pVisual*/,
+    ColormapPtr* /*ppcmap*/,
+    int /*alloc*/,
+    int /*client*/);
+
+extern _X_EXPORT int FreeColormap(
+    pointer /*pmap*/,
+    XID /*mid*/);
+
+extern _X_EXPORT int TellLostMap(
+    WindowPtr /*pwin*/,
+    pointer /* Colormap *pmid */);
+
+extern _X_EXPORT int TellGainedMap(
+    WindowPtr /*pwin*/,
+    pointer /* Colormap *pmid */);
+
+extern _X_EXPORT int CopyColormapAndFree(
+    Colormap /*mid*/,
+    ColormapPtr /*pSrc*/,
+    int /*client*/);
+
+extern _X_EXPORT int AllocColor(
+    ColormapPtr /*pmap*/,
+    unsigned short* /*pred*/,
+    unsigned short* /*pgreen*/,
+    unsigned short* /*pblue*/,
+    Pixel* /*pPix*/,
+    int /*client*/);
+
+extern _X_EXPORT void FakeAllocColor(
+    ColormapPtr /*pmap*/,
+    xColorItem * /*item*/);
+
+extern _X_EXPORT void FakeFreeColor(
+    ColormapPtr /*pmap*/,
+    Pixel /*pixel*/);
+
+typedef int (*ColorCompareProcPtr)(
+    EntryPtr /*pent*/,
+    xrgb * /*prgb*/);
+
+extern _X_EXPORT int FindColor(
+    ColormapPtr /*pmap*/,
+    EntryPtr /*pentFirst*/,
+    int /*size*/,
+    xrgb* /*prgb*/,
+    Pixel* /*pPixel*/,
+    int /*channel*/,
+    int /*client*/,
+    ColorCompareProcPtr /*comp*/);
+
+extern _X_EXPORT int QueryColors(
+    ColormapPtr /*pmap*/,
+    int /*count*/,
+    Pixel* /*ppixIn*/,
+    xrgb* /*prgbList*/,
+    ClientPtr client);
+
+extern _X_EXPORT int FreeClientPixels(
+    pointer /*pcr*/,
+    XID /*fakeid*/);
+
+extern _X_EXPORT int AllocColorCells(
+    int /*client*/,
+    ColormapPtr /*pmap*/,
+    int /*colors*/,
+    int /*planes*/,
+    Bool /*contig*/,
+    Pixel* /*ppix*/,
+    Pixel* /*masks*/);
+
+extern _X_EXPORT int AllocColorPlanes(
+    int /*client*/,
+    ColormapPtr /*pmap*/,
+    int /*colors*/,
+    int /*r*/,
+    int /*g*/,
+    int /*b*/,
+    Bool /*contig*/,
+    Pixel* /*pixels*/,
+    Pixel* /*prmask*/,
+    Pixel* /*pgmask*/,
+    Pixel* /*pbmask*/);
+
+extern _X_EXPORT int FreeColors(
+    ColormapPtr /*pmap*/,
+    int /*client*/,
+    int /*count*/,
+    Pixel* /*pixels*/,
+    Pixel /*mask*/);
+
+extern _X_EXPORT int StoreColors(
+    ColormapPtr /*pmap*/,
+    int /*count*/,
+    xColorItem* /*defs*/,
+    ClientPtr client);
+
+extern _X_EXPORT int IsMapInstalled(
+    Colormap /*map*/,
+    WindowPtr /*pWin*/);
+
+extern _X_EXPORT Bool ResizeVisualArray(
+    ScreenPtr /* pScreen */,
+    int /* new_vis_count */,
+    DepthPtr /* depth */);
+
+#endif /* CMAP_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extnsionst.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/extnsionst.h
@@ -0,0 +1,112 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef EXTENSIONSTRUCT_H
+#define EXTENSIONSTRUCT_H 
+
+#include "dix.h"
+#include "misc.h"
+#include "screenint.h"
+#include "extension.h"
+#include "gc.h"
+#include "privates.h"
+
+typedef struct _ExtensionEntry {
+    int index;
+    void (* CloseDown)(	/* called at server shutdown */
+	struct _ExtensionEntry * /* extension */);
+    char *name;               /* extension name */
+    int base;                 /* base request number */
+    int eventBase;            
+    int eventLast;
+    int errorBase;
+    int errorLast;
+    int num_aliases;
+    char **aliases;
+    pointer extPrivate;
+    unsigned short (* MinorOpcode)(	/* called for errors */
+	ClientPtr /* client */);
+    PrivateRec *devPrivates;
+} ExtensionEntry;
+
+/* 
+ * The arguments may be different for extension event swapping functions.
+ * Deal with this by casting when initializing the event's EventSwapVector[]
+ * entries.
+ */
+typedef void (*EventSwapPtr) (xEvent *, xEvent *);
+
+extern _X_EXPORT EventSwapPtr EventSwapVector[128];
+
+extern _X_EXPORT void NotImplemented (	/* FIXME: this may move to another file... */
+	xEvent *,
+	xEvent *) _X_NORETURN;
+
+#define    SetGCVector(pGC, VectorElement, NewRoutineAddress, Atom)    \
+    pGC->VectorElement = NewRoutineAddress;
+
+#define    GetGCValue(pGC, GCElement)    (pGC->GCElement)
+
+extern _X_EXPORT ExtensionEntry *AddExtension(
+    char* /*name*/,
+    int /*NumEvents*/,
+    int /*NumErrors*/,
+    int (* /*MainProc*/)(ClientPtr /*client*/),
+    int (* /*SwappedMainProc*/)(ClientPtr /*client*/),
+    void (* /*CloseDownProc*/)(ExtensionEntry * /*extension*/),
+    unsigned short (* /*MinorOpcodeProc*/)(ClientPtr /*client*/)
+);
+
+extern _X_EXPORT Bool AddExtensionAlias(
+    char* /*alias*/,
+    ExtensionEntry * /*extension*/);
+
+extern _X_EXPORT ExtensionEntry *CheckExtension(const char *extname);
+extern _X_EXPORT ExtensionEntry *GetExtensionEntry(int major);
+
+#endif /* EXTENSIONSTRUCT_H */
+
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/migc.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/migc.h
@@ -0,0 +1,64 @@
+/*
+
+Copyright 1993, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR
+OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall
+not be used in advertising or otherwise to promote the sale, use or
+other dealings in this Software without prior written authorization
+from The Open Group.
+
+*/
+
+
+extern _X_EXPORT void miChangeGC(
+    GCPtr  /*pGC*/,
+    unsigned long /*mask*/
+);
+
+extern _X_EXPORT void miDestroyGC(
+    GCPtr  /*pGC*/
+);
+
+extern _X_EXPORT void miDestroyClip(
+    GCPtr /*pGC*/
+);
+
+extern _X_EXPORT void miChangeClip(
+    GCPtr   /*pGC*/,
+    int     /*type*/,
+    pointer /*pvalue*/,
+    int     /*nrects*/
+);
+
+extern _X_EXPORT void miCopyClip(
+    GCPtr /*pgcDst*/,
+    GCPtr /*pgcSrc*/
+);
+
+extern _X_EXPORT void miCopyGC(
+    GCPtr /*pGCSrc*/,
+    unsigned long /*changes*/,
+    GCPtr /*pGCDst*/
+);
+
+extern _X_EXPORT void miComputeCompositeClip(
+    GCPtr       /*pGC*/,
+    DrawablePtr /*pDrawable*/
+);
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapitemp.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/glapitemp.h
@@ -0,0 +1,6655 @@
+/* DO NOT EDIT - This file generated automatically by gl_apitemp.py (from Mesa) script */
+
+/*
+ * Copyright (C) 1999-2001  Brian Paul   All Rights Reserved.
+ * (C) Copyright IBM Corporation 2004
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL, IBM,
+ * AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+
+#  if (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || (defined(__SUNPRO_C) && (__SUNPRO_C >= 0x590))) && defined(__ELF__)
+#    define HIDDEN  __attribute__((visibility("hidden")))
+#  else
+#    define HIDDEN
+#  endif
+
+/*
+ * This file is a template which generates the OpenGL API entry point
+ * functions.  It should be included by a .c file which first defines
+ * the following macros:
+ *   KEYWORD1 - usually nothing, but might be __declspec(dllexport) on Win32
+ *   KEYWORD2 - usually nothing, but might be __stdcall on Win32
+ *   NAME(n)  - builds the final function name (usually add "gl" prefix)
+ *   DISPATCH(func, args, msg) - code to do dispatch of named function.
+ *                               msg is a printf-style debug message.
+ *   RETURN_DISPATCH(func, args, msg) - code to do dispatch with a return value
+ *
+ * Here is an example which generates the usual OpenGL functions:
+ *   #define KEYWORD1
+ *   #define KEYWORD2
+ *   #define NAME(func)  gl##func
+ *   #define DISPATCH(func, args, msg)                           \
+ *          struct _glapi_table *dispatch = CurrentDispatch;     \
+ *          (*dispatch->func) args
+ *   #define RETURN DISPATCH(func, args, msg)                    \
+ *          struct _glapi_table *dispatch = CurrentDispatch;     \
+ *          return (*dispatch->func) args
+ *
+ */
+
+
+#if defined( NAME )
+#ifndef KEYWORD1
+#define KEYWORD1
+#endif
+
+#ifndef KEYWORD1_ALT
+#define KEYWORD1_ALT HIDDEN
+#endif
+
+#ifndef KEYWORD2
+#define KEYWORD2
+#endif
+
+#ifndef DISPATCH
+#error DISPATCH must be defined
+#endif
+
+#ifndef RETURN_DISPATCH
+#error RETURN_DISPATCH must be defined
+#endif
+
+
+KEYWORD1 void KEYWORD2 NAME(NewList)(GLuint list, GLenum mode)
+{
+   DISPATCH(NewList, (list, mode), (F, "glNewList(%d, 0x%x);\n", list, mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EndList)(void)
+{
+   DISPATCH(EndList, (), (F, "glEndList();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CallList)(GLuint list)
+{
+   DISPATCH(CallList, (list), (F, "glCallList(%d);\n", list));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CallLists)(GLsizei n, GLenum type, const GLvoid * lists)
+{
+   DISPATCH(CallLists, (n, type, lists), (F, "glCallLists(%d, 0x%x, %p);\n", n, type, (const void *) lists));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteLists)(GLuint list, GLsizei range)
+{
+   DISPATCH(DeleteLists, (list, range), (F, "glDeleteLists(%d, %d);\n", list, range));
+}
+
+KEYWORD1 GLuint KEYWORD2 NAME(GenLists)(GLsizei range)
+{
+   RETURN_DISPATCH(GenLists, (range), (F, "glGenLists(%d);\n", range));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ListBase)(GLuint base)
+{
+   DISPATCH(ListBase, (base), (F, "glListBase(%d);\n", base));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Begin)(GLenum mode)
+{
+   DISPATCH(Begin, (mode), (F, "glBegin(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Bitmap)(GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap)
+{
+   DISPATCH(Bitmap, (width, height, xorig, yorig, xmove, ymove, bitmap), (F, "glBitmap(%d, %d, %f, %f, %f, %f, %p);\n", width, height, xorig, yorig, xmove, ymove, (const void *) bitmap));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3b)(GLbyte red, GLbyte green, GLbyte blue)
+{
+   DISPATCH(Color3b, (red, green, blue), (F, "glColor3b(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3bv)(const GLbyte * v)
+{
+   DISPATCH(Color3bv, (v), (F, "glColor3bv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3d)(GLdouble red, GLdouble green, GLdouble blue)
+{
+   DISPATCH(Color3d, (red, green, blue), (F, "glColor3d(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3dv)(const GLdouble * v)
+{
+   DISPATCH(Color3dv, (v), (F, "glColor3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3f)(GLfloat red, GLfloat green, GLfloat blue)
+{
+   DISPATCH(Color3f, (red, green, blue), (F, "glColor3f(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3fv)(const GLfloat * v)
+{
+   DISPATCH(Color3fv, (v), (F, "glColor3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3i)(GLint red, GLint green, GLint blue)
+{
+   DISPATCH(Color3i, (red, green, blue), (F, "glColor3i(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3iv)(const GLint * v)
+{
+   DISPATCH(Color3iv, (v), (F, "glColor3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3s)(GLshort red, GLshort green, GLshort blue)
+{
+   DISPATCH(Color3s, (red, green, blue), (F, "glColor3s(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3sv)(const GLshort * v)
+{
+   DISPATCH(Color3sv, (v), (F, "glColor3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3ub)(GLubyte red, GLubyte green, GLubyte blue)
+{
+   DISPATCH(Color3ub, (red, green, blue), (F, "glColor3ub(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3ubv)(const GLubyte * v)
+{
+   DISPATCH(Color3ubv, (v), (F, "glColor3ubv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3ui)(GLuint red, GLuint green, GLuint blue)
+{
+   DISPATCH(Color3ui, (red, green, blue), (F, "glColor3ui(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3uiv)(const GLuint * v)
+{
+   DISPATCH(Color3uiv, (v), (F, "glColor3uiv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3us)(GLushort red, GLushort green, GLushort blue)
+{
+   DISPATCH(Color3us, (red, green, blue), (F, "glColor3us(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color3usv)(const GLushort * v)
+{
+   DISPATCH(Color3usv, (v), (F, "glColor3usv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4b)(GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha)
+{
+   DISPATCH(Color4b, (red, green, blue, alpha), (F, "glColor4b(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4bv)(const GLbyte * v)
+{
+   DISPATCH(Color4bv, (v), (F, "glColor4bv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4d)(GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha)
+{
+   DISPATCH(Color4d, (red, green, blue, alpha), (F, "glColor4d(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4dv)(const GLdouble * v)
+{
+   DISPATCH(Color4dv, (v), (F, "glColor4dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4f)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
+{
+   DISPATCH(Color4f, (red, green, blue, alpha), (F, "glColor4f(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4fv)(const GLfloat * v)
+{
+   DISPATCH(Color4fv, (v), (F, "glColor4fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4i)(GLint red, GLint green, GLint blue, GLint alpha)
+{
+   DISPATCH(Color4i, (red, green, blue, alpha), (F, "glColor4i(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4iv)(const GLint * v)
+{
+   DISPATCH(Color4iv, (v), (F, "glColor4iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4s)(GLshort red, GLshort green, GLshort blue, GLshort alpha)
+{
+   DISPATCH(Color4s, (red, green, blue, alpha), (F, "glColor4s(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4sv)(const GLshort * v)
+{
+   DISPATCH(Color4sv, (v), (F, "glColor4sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4ub)(GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha)
+{
+   DISPATCH(Color4ub, (red, green, blue, alpha), (F, "glColor4ub(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4ubv)(const GLubyte * v)
+{
+   DISPATCH(Color4ubv, (v), (F, "glColor4ubv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4ui)(GLuint red, GLuint green, GLuint blue, GLuint alpha)
+{
+   DISPATCH(Color4ui, (red, green, blue, alpha), (F, "glColor4ui(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4uiv)(const GLuint * v)
+{
+   DISPATCH(Color4uiv, (v), (F, "glColor4uiv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4us)(GLushort red, GLushort green, GLushort blue, GLushort alpha)
+{
+   DISPATCH(Color4us, (red, green, blue, alpha), (F, "glColor4us(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Color4usv)(const GLushort * v)
+{
+   DISPATCH(Color4usv, (v), (F, "glColor4usv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EdgeFlag)(GLboolean flag)
+{
+   DISPATCH(EdgeFlag, (flag), (F, "glEdgeFlag(%d);\n", flag));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EdgeFlagv)(const GLboolean * flag)
+{
+   DISPATCH(EdgeFlagv, (flag), (F, "glEdgeFlagv(%p);\n", (const void *) flag));
+}
+
+KEYWORD1 void KEYWORD2 NAME(End)(void)
+{
+   DISPATCH(End, (), (F, "glEnd();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexd)(GLdouble c)
+{
+   DISPATCH(Indexd, (c), (F, "glIndexd(%f);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexdv)(const GLdouble * c)
+{
+   DISPATCH(Indexdv, (c), (F, "glIndexdv(%p);\n", (const void *) c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexf)(GLfloat c)
+{
+   DISPATCH(Indexf, (c), (F, "glIndexf(%f);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexfv)(const GLfloat * c)
+{
+   DISPATCH(Indexfv, (c), (F, "glIndexfv(%p);\n", (const void *) c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexi)(GLint c)
+{
+   DISPATCH(Indexi, (c), (F, "glIndexi(%d);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexiv)(const GLint * c)
+{
+   DISPATCH(Indexiv, (c), (F, "glIndexiv(%p);\n", (const void *) c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexs)(GLshort c)
+{
+   DISPATCH(Indexs, (c), (F, "glIndexs(%d);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexsv)(const GLshort * c)
+{
+   DISPATCH(Indexsv, (c), (F, "glIndexsv(%p);\n", (const void *) c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3b)(GLbyte nx, GLbyte ny, GLbyte nz)
+{
+   DISPATCH(Normal3b, (nx, ny, nz), (F, "glNormal3b(%d, %d, %d);\n", nx, ny, nz));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3bv)(const GLbyte * v)
+{
+   DISPATCH(Normal3bv, (v), (F, "glNormal3bv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3d)(GLdouble nx, GLdouble ny, GLdouble nz)
+{
+   DISPATCH(Normal3d, (nx, ny, nz), (F, "glNormal3d(%f, %f, %f);\n", nx, ny, nz));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3dv)(const GLdouble * v)
+{
+   DISPATCH(Normal3dv, (v), (F, "glNormal3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3f)(GLfloat nx, GLfloat ny, GLfloat nz)
+{
+   DISPATCH(Normal3f, (nx, ny, nz), (F, "glNormal3f(%f, %f, %f);\n", nx, ny, nz));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3fv)(const GLfloat * v)
+{
+   DISPATCH(Normal3fv, (v), (F, "glNormal3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3i)(GLint nx, GLint ny, GLint nz)
+{
+   DISPATCH(Normal3i, (nx, ny, nz), (F, "glNormal3i(%d, %d, %d);\n", nx, ny, nz));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3iv)(const GLint * v)
+{
+   DISPATCH(Normal3iv, (v), (F, "glNormal3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3s)(GLshort nx, GLshort ny, GLshort nz)
+{
+   DISPATCH(Normal3s, (nx, ny, nz), (F, "glNormal3s(%d, %d, %d);\n", nx, ny, nz));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Normal3sv)(const GLshort * v)
+{
+   DISPATCH(Normal3sv, (v), (F, "glNormal3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2d)(GLdouble x, GLdouble y)
+{
+   DISPATCH(RasterPos2d, (x, y), (F, "glRasterPos2d(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2dv)(const GLdouble * v)
+{
+   DISPATCH(RasterPos2dv, (v), (F, "glRasterPos2dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2f)(GLfloat x, GLfloat y)
+{
+   DISPATCH(RasterPos2f, (x, y), (F, "glRasterPos2f(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2fv)(const GLfloat * v)
+{
+   DISPATCH(RasterPos2fv, (v), (F, "glRasterPos2fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2i)(GLint x, GLint y)
+{
+   DISPATCH(RasterPos2i, (x, y), (F, "glRasterPos2i(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2iv)(const GLint * v)
+{
+   DISPATCH(RasterPos2iv, (v), (F, "glRasterPos2iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2s)(GLshort x, GLshort y)
+{
+   DISPATCH(RasterPos2s, (x, y), (F, "glRasterPos2s(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos2sv)(const GLshort * v)
+{
+   DISPATCH(RasterPos2sv, (v), (F, "glRasterPos2sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3d)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(RasterPos3d, (x, y, z), (F, "glRasterPos3d(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3dv)(const GLdouble * v)
+{
+   DISPATCH(RasterPos3dv, (v), (F, "glRasterPos3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3f)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(RasterPos3f, (x, y, z), (F, "glRasterPos3f(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3fv)(const GLfloat * v)
+{
+   DISPATCH(RasterPos3fv, (v), (F, "glRasterPos3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3i)(GLint x, GLint y, GLint z)
+{
+   DISPATCH(RasterPos3i, (x, y, z), (F, "glRasterPos3i(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3iv)(const GLint * v)
+{
+   DISPATCH(RasterPos3iv, (v), (F, "glRasterPos3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3s)(GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(RasterPos3s, (x, y, z), (F, "glRasterPos3s(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos3sv)(const GLshort * v)
+{
+   DISPATCH(RasterPos3sv, (v), (F, "glRasterPos3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(RasterPos4d, (x, y, z, w), (F, "glRasterPos4d(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4dv)(const GLdouble * v)
+{
+   DISPATCH(RasterPos4dv, (v), (F, "glRasterPos4dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(RasterPos4f, (x, y, z, w), (F, "glRasterPos4f(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4fv)(const GLfloat * v)
+{
+   DISPATCH(RasterPos4fv, (v), (F, "glRasterPos4fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4i)(GLint x, GLint y, GLint z, GLint w)
+{
+   DISPATCH(RasterPos4i, (x, y, z, w), (F, "glRasterPos4i(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4iv)(const GLint * v)
+{
+   DISPATCH(RasterPos4iv, (v), (F, "glRasterPos4iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4s)(GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(RasterPos4s, (x, y, z, w), (F, "glRasterPos4s(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RasterPos4sv)(const GLshort * v)
+{
+   DISPATCH(RasterPos4sv, (v), (F, "glRasterPos4sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectd)(GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2)
+{
+   DISPATCH(Rectd, (x1, y1, x2, y2), (F, "glRectd(%f, %f, %f, %f);\n", x1, y1, x2, y2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectdv)(const GLdouble * v1, const GLdouble * v2)
+{
+   DISPATCH(Rectdv, (v1, v2), (F, "glRectdv(%p, %p);\n", (const void *) v1, (const void *) v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectf)(GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2)
+{
+   DISPATCH(Rectf, (x1, y1, x2, y2), (F, "glRectf(%f, %f, %f, %f);\n", x1, y1, x2, y2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectfv)(const GLfloat * v1, const GLfloat * v2)
+{
+   DISPATCH(Rectfv, (v1, v2), (F, "glRectfv(%p, %p);\n", (const void *) v1, (const void *) v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Recti)(GLint x1, GLint y1, GLint x2, GLint y2)
+{
+   DISPATCH(Recti, (x1, y1, x2, y2), (F, "glRecti(%d, %d, %d, %d);\n", x1, y1, x2, y2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectiv)(const GLint * v1, const GLint * v2)
+{
+   DISPATCH(Rectiv, (v1, v2), (F, "glRectiv(%p, %p);\n", (const void *) v1, (const void *) v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rects)(GLshort x1, GLshort y1, GLshort x2, GLshort y2)
+{
+   DISPATCH(Rects, (x1, y1, x2, y2), (F, "glRects(%d, %d, %d, %d);\n", x1, y1, x2, y2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rectsv)(const GLshort * v1, const GLshort * v2)
+{
+   DISPATCH(Rectsv, (v1, v2), (F, "glRectsv(%p, %p);\n", (const void *) v1, (const void *) v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1d)(GLdouble s)
+{
+   DISPATCH(TexCoord1d, (s), (F, "glTexCoord1d(%f);\n", s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1dv)(const GLdouble * v)
+{
+   DISPATCH(TexCoord1dv, (v), (F, "glTexCoord1dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1f)(GLfloat s)
+{
+   DISPATCH(TexCoord1f, (s), (F, "glTexCoord1f(%f);\n", s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1fv)(const GLfloat * v)
+{
+   DISPATCH(TexCoord1fv, (v), (F, "glTexCoord1fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1i)(GLint s)
+{
+   DISPATCH(TexCoord1i, (s), (F, "glTexCoord1i(%d);\n", s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1iv)(const GLint * v)
+{
+   DISPATCH(TexCoord1iv, (v), (F, "glTexCoord1iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1s)(GLshort s)
+{
+   DISPATCH(TexCoord1s, (s), (F, "glTexCoord1s(%d);\n", s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord1sv)(const GLshort * v)
+{
+   DISPATCH(TexCoord1sv, (v), (F, "glTexCoord1sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2d)(GLdouble s, GLdouble t)
+{
+   DISPATCH(TexCoord2d, (s, t), (F, "glTexCoord2d(%f, %f);\n", s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2dv)(const GLdouble * v)
+{
+   DISPATCH(TexCoord2dv, (v), (F, "glTexCoord2dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2f)(GLfloat s, GLfloat t)
+{
+   DISPATCH(TexCoord2f, (s, t), (F, "glTexCoord2f(%f, %f);\n", s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2fv)(const GLfloat * v)
+{
+   DISPATCH(TexCoord2fv, (v), (F, "glTexCoord2fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2i)(GLint s, GLint t)
+{
+   DISPATCH(TexCoord2i, (s, t), (F, "glTexCoord2i(%d, %d);\n", s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2iv)(const GLint * v)
+{
+   DISPATCH(TexCoord2iv, (v), (F, "glTexCoord2iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2s)(GLshort s, GLshort t)
+{
+   DISPATCH(TexCoord2s, (s, t), (F, "glTexCoord2s(%d, %d);\n", s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord2sv)(const GLshort * v)
+{
+   DISPATCH(TexCoord2sv, (v), (F, "glTexCoord2sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3d)(GLdouble s, GLdouble t, GLdouble r)
+{
+   DISPATCH(TexCoord3d, (s, t, r), (F, "glTexCoord3d(%f, %f, %f);\n", s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3dv)(const GLdouble * v)
+{
+   DISPATCH(TexCoord3dv, (v), (F, "glTexCoord3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3f)(GLfloat s, GLfloat t, GLfloat r)
+{
+   DISPATCH(TexCoord3f, (s, t, r), (F, "glTexCoord3f(%f, %f, %f);\n", s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3fv)(const GLfloat * v)
+{
+   DISPATCH(TexCoord3fv, (v), (F, "glTexCoord3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3i)(GLint s, GLint t, GLint r)
+{
+   DISPATCH(TexCoord3i, (s, t, r), (F, "glTexCoord3i(%d, %d, %d);\n", s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3iv)(const GLint * v)
+{
+   DISPATCH(TexCoord3iv, (v), (F, "glTexCoord3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3s)(GLshort s, GLshort t, GLshort r)
+{
+   DISPATCH(TexCoord3s, (s, t, r), (F, "glTexCoord3s(%d, %d, %d);\n", s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord3sv)(const GLshort * v)
+{
+   DISPATCH(TexCoord3sv, (v), (F, "glTexCoord3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4d)(GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+{
+   DISPATCH(TexCoord4d, (s, t, r, q), (F, "glTexCoord4d(%f, %f, %f, %f);\n", s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4dv)(const GLdouble * v)
+{
+   DISPATCH(TexCoord4dv, (v), (F, "glTexCoord4dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4f)(GLfloat s, GLfloat t, GLfloat r, GLfloat q)
+{
+   DISPATCH(TexCoord4f, (s, t, r, q), (F, "glTexCoord4f(%f, %f, %f, %f);\n", s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4fv)(const GLfloat * v)
+{
+   DISPATCH(TexCoord4fv, (v), (F, "glTexCoord4fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4i)(GLint s, GLint t, GLint r, GLint q)
+{
+   DISPATCH(TexCoord4i, (s, t, r, q), (F, "glTexCoord4i(%d, %d, %d, %d);\n", s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4iv)(const GLint * v)
+{
+   DISPATCH(TexCoord4iv, (v), (F, "glTexCoord4iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4s)(GLshort s, GLshort t, GLshort r, GLshort q)
+{
+   DISPATCH(TexCoord4s, (s, t, r, q), (F, "glTexCoord4s(%d, %d, %d, %d);\n", s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoord4sv)(const GLshort * v)
+{
+   DISPATCH(TexCoord4sv, (v), (F, "glTexCoord4sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2d)(GLdouble x, GLdouble y)
+{
+   DISPATCH(Vertex2d, (x, y), (F, "glVertex2d(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2dv)(const GLdouble * v)
+{
+   DISPATCH(Vertex2dv, (v), (F, "glVertex2dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2f)(GLfloat x, GLfloat y)
+{
+   DISPATCH(Vertex2f, (x, y), (F, "glVertex2f(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2fv)(const GLfloat * v)
+{
+   DISPATCH(Vertex2fv, (v), (F, "glVertex2fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2i)(GLint x, GLint y)
+{
+   DISPATCH(Vertex2i, (x, y), (F, "glVertex2i(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2iv)(const GLint * v)
+{
+   DISPATCH(Vertex2iv, (v), (F, "glVertex2iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2s)(GLshort x, GLshort y)
+{
+   DISPATCH(Vertex2s, (x, y), (F, "glVertex2s(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex2sv)(const GLshort * v)
+{
+   DISPATCH(Vertex2sv, (v), (F, "glVertex2sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3d)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(Vertex3d, (x, y, z), (F, "glVertex3d(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3dv)(const GLdouble * v)
+{
+   DISPATCH(Vertex3dv, (v), (F, "glVertex3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3f)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(Vertex3f, (x, y, z), (F, "glVertex3f(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3fv)(const GLfloat * v)
+{
+   DISPATCH(Vertex3fv, (v), (F, "glVertex3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3i)(GLint x, GLint y, GLint z)
+{
+   DISPATCH(Vertex3i, (x, y, z), (F, "glVertex3i(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3iv)(const GLint * v)
+{
+   DISPATCH(Vertex3iv, (v), (F, "glVertex3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3s)(GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(Vertex3s, (x, y, z), (F, "glVertex3s(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex3sv)(const GLshort * v)
+{
+   DISPATCH(Vertex3sv, (v), (F, "glVertex3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4d)(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(Vertex4d, (x, y, z, w), (F, "glVertex4d(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4dv)(const GLdouble * v)
+{
+   DISPATCH(Vertex4dv, (v), (F, "glVertex4dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4f)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(Vertex4f, (x, y, z, w), (F, "glVertex4f(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4fv)(const GLfloat * v)
+{
+   DISPATCH(Vertex4fv, (v), (F, "glVertex4fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4i)(GLint x, GLint y, GLint z, GLint w)
+{
+   DISPATCH(Vertex4i, (x, y, z, w), (F, "glVertex4i(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4iv)(const GLint * v)
+{
+   DISPATCH(Vertex4iv, (v), (F, "glVertex4iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4s)(GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(Vertex4s, (x, y, z, w), (F, "glVertex4s(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Vertex4sv)(const GLshort * v)
+{
+   DISPATCH(Vertex4sv, (v), (F, "glVertex4sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClipPlane)(GLenum plane, const GLdouble * equation)
+{
+   DISPATCH(ClipPlane, (plane, equation), (F, "glClipPlane(0x%x, %p);\n", plane, (const void *) equation));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorMaterial)(GLenum face, GLenum mode)
+{
+   DISPATCH(ColorMaterial, (face, mode), (F, "glColorMaterial(0x%x, 0x%x);\n", face, mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CullFace)(GLenum mode)
+{
+   DISPATCH(CullFace, (mode), (F, "glCullFace(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Fogf)(GLenum pname, GLfloat param)
+{
+   DISPATCH(Fogf, (pname, param), (F, "glFogf(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Fogfv)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(Fogfv, (pname, params), (F, "glFogfv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Fogi)(GLenum pname, GLint param)
+{
+   DISPATCH(Fogi, (pname, param), (F, "glFogi(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Fogiv)(GLenum pname, const GLint * params)
+{
+   DISPATCH(Fogiv, (pname, params), (F, "glFogiv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FrontFace)(GLenum mode)
+{
+   DISPATCH(FrontFace, (mode), (F, "glFrontFace(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Hint)(GLenum target, GLenum mode)
+{
+   DISPATCH(Hint, (target, mode), (F, "glHint(0x%x, 0x%x);\n", target, mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Lightf)(GLenum light, GLenum pname, GLfloat param)
+{
+   DISPATCH(Lightf, (light, pname, param), (F, "glLightf(0x%x, 0x%x, %f);\n", light, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Lightfv)(GLenum light, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(Lightfv, (light, pname, params), (F, "glLightfv(0x%x, 0x%x, %p);\n", light, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Lighti)(GLenum light, GLenum pname, GLint param)
+{
+   DISPATCH(Lighti, (light, pname, param), (F, "glLighti(0x%x, 0x%x, %d);\n", light, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Lightiv)(GLenum light, GLenum pname, const GLint * params)
+{
+   DISPATCH(Lightiv, (light, pname, params), (F, "glLightiv(0x%x, 0x%x, %p);\n", light, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LightModelf)(GLenum pname, GLfloat param)
+{
+   DISPATCH(LightModelf, (pname, param), (F, "glLightModelf(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LightModelfv)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(LightModelfv, (pname, params), (F, "glLightModelfv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LightModeli)(GLenum pname, GLint param)
+{
+   DISPATCH(LightModeli, (pname, param), (F, "glLightModeli(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LightModeliv)(GLenum pname, const GLint * params)
+{
+   DISPATCH(LightModeliv, (pname, params), (F, "glLightModeliv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LineStipple)(GLint factor, GLushort pattern)
+{
+   DISPATCH(LineStipple, (factor, pattern), (F, "glLineStipple(%d, %d);\n", factor, pattern));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LineWidth)(GLfloat width)
+{
+   DISPATCH(LineWidth, (width), (F, "glLineWidth(%f);\n", width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Materialf)(GLenum face, GLenum pname, GLfloat param)
+{
+   DISPATCH(Materialf, (face, pname, param), (F, "glMaterialf(0x%x, 0x%x, %f);\n", face, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Materialfv)(GLenum face, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(Materialfv, (face, pname, params), (F, "glMaterialfv(0x%x, 0x%x, %p);\n", face, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Materiali)(GLenum face, GLenum pname, GLint param)
+{
+   DISPATCH(Materiali, (face, pname, param), (F, "glMateriali(0x%x, 0x%x, %d);\n", face, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Materialiv)(GLenum face, GLenum pname, const GLint * params)
+{
+   DISPATCH(Materialiv, (face, pname, params), (F, "glMaterialiv(0x%x, 0x%x, %p);\n", face, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointSize)(GLfloat size)
+{
+   DISPATCH(PointSize, (size), (F, "glPointSize(%f);\n", size));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PolygonMode)(GLenum face, GLenum mode)
+{
+   DISPATCH(PolygonMode, (face, mode), (F, "glPolygonMode(0x%x, 0x%x);\n", face, mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PolygonStipple)(const GLubyte * mask)
+{
+   DISPATCH(PolygonStipple, (mask), (F, "glPolygonStipple(%p);\n", (const void *) mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Scissor)(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(Scissor, (x, y, width, height), (F, "glScissor(%d, %d, %d, %d);\n", x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ShadeModel)(GLenum mode)
+{
+   DISPATCH(ShadeModel, (mode), (F, "glShadeModel(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexParameterf)(GLenum target, GLenum pname, GLfloat param)
+{
+   DISPATCH(TexParameterf, (target, pname, param), (F, "glTexParameterf(0x%x, 0x%x, %f);\n", target, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexParameterfv)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(TexParameterfv, (target, pname, params), (F, "glTexParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexParameteri)(GLenum target, GLenum pname, GLint param)
+{
+   DISPATCH(TexParameteri, (target, pname, param), (F, "glTexParameteri(0x%x, 0x%x, %d);\n", target, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexParameteriv)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(TexParameteriv, (target, pname, params), (F, "glTexParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexImage1D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexImage1D, (target, level, internalformat, width, border, format, type, pixels), (F, "glTexImage1D(0x%x, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, internalformat, width, border, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexImage2D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexImage2D, (target, level, internalformat, width, height, border, format, type, pixels), (F, "glTexImage2D(0x%x, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, internalformat, width, height, border, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexEnvf)(GLenum target, GLenum pname, GLfloat param)
+{
+   DISPATCH(TexEnvf, (target, pname, param), (F, "glTexEnvf(0x%x, 0x%x, %f);\n", target, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexEnvfv)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(TexEnvfv, (target, pname, params), (F, "glTexEnvfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexEnvi)(GLenum target, GLenum pname, GLint param)
+{
+   DISPATCH(TexEnvi, (target, pname, param), (F, "glTexEnvi(0x%x, 0x%x, %d);\n", target, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexEnviv)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(TexEnviv, (target, pname, params), (F, "glTexEnviv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGend)(GLenum coord, GLenum pname, GLdouble param)
+{
+   DISPATCH(TexGend, (coord, pname, param), (F, "glTexGend(0x%x, 0x%x, %f);\n", coord, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGendv)(GLenum coord, GLenum pname, const GLdouble * params)
+{
+   DISPATCH(TexGendv, (coord, pname, params), (F, "glTexGendv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGenf)(GLenum coord, GLenum pname, GLfloat param)
+{
+   DISPATCH(TexGenf, (coord, pname, param), (F, "glTexGenf(0x%x, 0x%x, %f);\n", coord, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGenfv)(GLenum coord, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(TexGenfv, (coord, pname, params), (F, "glTexGenfv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGeni)(GLenum coord, GLenum pname, GLint param)
+{
+   DISPATCH(TexGeni, (coord, pname, param), (F, "glTexGeni(0x%x, 0x%x, %d);\n", coord, pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexGeniv)(GLenum coord, GLenum pname, const GLint * params)
+{
+   DISPATCH(TexGeniv, (coord, pname, params), (F, "glTexGeniv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FeedbackBuffer)(GLsizei size, GLenum type, GLfloat * buffer)
+{
+   DISPATCH(FeedbackBuffer, (size, type, buffer), (F, "glFeedbackBuffer(%d, 0x%x, %p);\n", size, type, (const void *) buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SelectBuffer)(GLsizei size, GLuint * buffer)
+{
+   DISPATCH(SelectBuffer, (size, buffer), (F, "glSelectBuffer(%d, %p);\n", size, (const void *) buffer));
+}
+
+KEYWORD1 GLint KEYWORD2 NAME(RenderMode)(GLenum mode)
+{
+   RETURN_DISPATCH(RenderMode, (mode), (F, "glRenderMode(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(InitNames)(void)
+{
+   DISPATCH(InitNames, (), (F, "glInitNames();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadName)(GLuint name)
+{
+   DISPATCH(LoadName, (name), (F, "glLoadName(%d);\n", name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PassThrough)(GLfloat token)
+{
+   DISPATCH(PassThrough, (token), (F, "glPassThrough(%f);\n", token));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PopName)(void)
+{
+   DISPATCH(PopName, (), (F, "glPopName();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PushName)(GLuint name)
+{
+   DISPATCH(PushName, (name), (F, "glPushName(%d);\n", name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawBuffer)(GLenum mode)
+{
+   DISPATCH(DrawBuffer, (mode), (F, "glDrawBuffer(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Clear)(GLbitfield mask)
+{
+   DISPATCH(Clear, (mask), (F, "glClear(%d);\n", mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClearAccum)(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha)
+{
+   DISPATCH(ClearAccum, (red, green, blue, alpha), (F, "glClearAccum(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClearIndex)(GLfloat c)
+{
+   DISPATCH(ClearIndex, (c), (F, "glClearIndex(%f);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClearColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
+{
+   DISPATCH(ClearColor, (red, green, blue, alpha), (F, "glClearColor(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClearStencil)(GLint s)
+{
+   DISPATCH(ClearStencil, (s), (F, "glClearStencil(%d);\n", s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClearDepth)(GLclampd depth)
+{
+   DISPATCH(ClearDepth, (depth), (F, "glClearDepth(%f);\n", depth));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilMask)(GLuint mask)
+{
+   DISPATCH(StencilMask, (mask), (F, "glStencilMask(%d);\n", mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorMask)(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
+{
+   DISPATCH(ColorMask, (red, green, blue, alpha), (F, "glColorMask(%d, %d, %d, %d);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DepthMask)(GLboolean flag)
+{
+   DISPATCH(DepthMask, (flag), (F, "glDepthMask(%d);\n", flag));
+}
+
+KEYWORD1 void KEYWORD2 NAME(IndexMask)(GLuint mask)
+{
+   DISPATCH(IndexMask, (mask), (F, "glIndexMask(%d);\n", mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Accum)(GLenum op, GLfloat value)
+{
+   DISPATCH(Accum, (op, value), (F, "glAccum(0x%x, %f);\n", op, value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Disable)(GLenum cap)
+{
+   DISPATCH(Disable, (cap), (F, "glDisable(0x%x);\n", cap));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Enable)(GLenum cap)
+{
+   DISPATCH(Enable, (cap), (F, "glEnable(0x%x);\n", cap));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Finish)(void)
+{
+   DISPATCH(Finish, (), (F, "glFinish();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Flush)(void)
+{
+   DISPATCH(Flush, (), (F, "glFlush();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PopAttrib)(void)
+{
+   DISPATCH(PopAttrib, (), (F, "glPopAttrib();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PushAttrib)(GLbitfield mask)
+{
+   DISPATCH(PushAttrib, (mask), (F, "glPushAttrib(%d);\n", mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Map1d)(GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points)
+{
+   DISPATCH(Map1d, (target, u1, u2, stride, order, points), (F, "glMap1d(0x%x, %f, %f, %d, %d, %p);\n", target, u1, u2, stride, order, (const void *) points));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Map1f)(GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points)
+{
+   DISPATCH(Map1f, (target, u1, u2, stride, order, points), (F, "glMap1f(0x%x, %f, %f, %d, %d, %p);\n", target, u1, u2, stride, order, (const void *) points));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Map2d)(GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points)
+{
+   DISPATCH(Map2d, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (F, "glMap2d(0x%x, %f, %f, %d, %d, %f, %f, %d, %d, %p);\n", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (const void *) points));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Map2f)(GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points)
+{
+   DISPATCH(Map2f, (target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points), (F, "glMap2f(0x%x, %f, %f, %d, %d, %f, %f, %d, %d, %p);\n", target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, (const void *) points));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MapGrid1d)(GLint un, GLdouble u1, GLdouble u2)
+{
+   DISPATCH(MapGrid1d, (un, u1, u2), (F, "glMapGrid1d(%d, %f, %f);\n", un, u1, u2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MapGrid1f)(GLint un, GLfloat u1, GLfloat u2)
+{
+   DISPATCH(MapGrid1f, (un, u1, u2), (F, "glMapGrid1f(%d, %f, %f);\n", un, u1, u2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MapGrid2d)(GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2)
+{
+   DISPATCH(MapGrid2d, (un, u1, u2, vn, v1, v2), (F, "glMapGrid2d(%d, %f, %f, %d, %f, %f);\n", un, u1, u2, vn, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MapGrid2f)(GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2)
+{
+   DISPATCH(MapGrid2f, (un, u1, u2, vn, v1, v2), (F, "glMapGrid2f(%d, %f, %f, %d, %f, %f);\n", un, u1, u2, vn, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord1d)(GLdouble u)
+{
+   DISPATCH(EvalCoord1d, (u), (F, "glEvalCoord1d(%f);\n", u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord1dv)(const GLdouble * u)
+{
+   DISPATCH(EvalCoord1dv, (u), (F, "glEvalCoord1dv(%p);\n", (const void *) u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord1f)(GLfloat u)
+{
+   DISPATCH(EvalCoord1f, (u), (F, "glEvalCoord1f(%f);\n", u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord1fv)(const GLfloat * u)
+{
+   DISPATCH(EvalCoord1fv, (u), (F, "glEvalCoord1fv(%p);\n", (const void *) u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord2d)(GLdouble u, GLdouble v)
+{
+   DISPATCH(EvalCoord2d, (u, v), (F, "glEvalCoord2d(%f, %f);\n", u, v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord2dv)(const GLdouble * u)
+{
+   DISPATCH(EvalCoord2dv, (u), (F, "glEvalCoord2dv(%p);\n", (const void *) u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord2f)(GLfloat u, GLfloat v)
+{
+   DISPATCH(EvalCoord2f, (u, v), (F, "glEvalCoord2f(%f, %f);\n", u, v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalCoord2fv)(const GLfloat * u)
+{
+   DISPATCH(EvalCoord2fv, (u), (F, "glEvalCoord2fv(%p);\n", (const void *) u));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalMesh1)(GLenum mode, GLint i1, GLint i2)
+{
+   DISPATCH(EvalMesh1, (mode, i1, i2), (F, "glEvalMesh1(0x%x, %d, %d);\n", mode, i1, i2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalPoint1)(GLint i)
+{
+   DISPATCH(EvalPoint1, (i), (F, "glEvalPoint1(%d);\n", i));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalMesh2)(GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2)
+{
+   DISPATCH(EvalMesh2, (mode, i1, i2, j1, j2), (F, "glEvalMesh2(0x%x, %d, %d, %d, %d);\n", mode, i1, i2, j1, j2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EvalPoint2)(GLint i, GLint j)
+{
+   DISPATCH(EvalPoint2, (i, j), (F, "glEvalPoint2(%d, %d);\n", i, j));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AlphaFunc)(GLenum func, GLclampf ref)
+{
+   DISPATCH(AlphaFunc, (func, ref), (F, "glAlphaFunc(0x%x, %f);\n", func, ref));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendFunc)(GLenum sfactor, GLenum dfactor)
+{
+   DISPATCH(BlendFunc, (sfactor, dfactor), (F, "glBlendFunc(0x%x, 0x%x);\n", sfactor, dfactor));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LogicOp)(GLenum opcode)
+{
+   DISPATCH(LogicOp, (opcode), (F, "glLogicOp(0x%x);\n", opcode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilFunc)(GLenum func, GLint ref, GLuint mask)
+{
+   DISPATCH(StencilFunc, (func, ref, mask), (F, "glStencilFunc(0x%x, %d, %d);\n", func, ref, mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilOp)(GLenum fail, GLenum zfail, GLenum zpass)
+{
+   DISPATCH(StencilOp, (fail, zfail, zpass), (F, "glStencilOp(0x%x, 0x%x, 0x%x);\n", fail, zfail, zpass));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DepthFunc)(GLenum func)
+{
+   DISPATCH(DepthFunc, (func), (F, "glDepthFunc(0x%x);\n", func));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelZoom)(GLfloat xfactor, GLfloat yfactor)
+{
+   DISPATCH(PixelZoom, (xfactor, yfactor), (F, "glPixelZoom(%f, %f);\n", xfactor, yfactor));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelTransferf)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PixelTransferf, (pname, param), (F, "glPixelTransferf(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelTransferi)(GLenum pname, GLint param)
+{
+   DISPATCH(PixelTransferi, (pname, param), (F, "glPixelTransferi(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelStoref)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PixelStoref, (pname, param), (F, "glPixelStoref(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelStorei)(GLenum pname, GLint param)
+{
+   DISPATCH(PixelStorei, (pname, param), (F, "glPixelStorei(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelMapfv)(GLenum map, GLsizei mapsize, const GLfloat * values)
+{
+   DISPATCH(PixelMapfv, (map, mapsize, values), (F, "glPixelMapfv(0x%x, %d, %p);\n", map, mapsize, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelMapuiv)(GLenum map, GLsizei mapsize, const GLuint * values)
+{
+   DISPATCH(PixelMapuiv, (map, mapsize, values), (F, "glPixelMapuiv(0x%x, %d, %p);\n", map, mapsize, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PixelMapusv)(GLenum map, GLsizei mapsize, const GLushort * values)
+{
+   DISPATCH(PixelMapusv, (map, mapsize, values), (F, "glPixelMapusv(0x%x, %d, %p);\n", map, mapsize, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ReadBuffer)(GLenum mode)
+{
+   DISPATCH(ReadBuffer, (mode), (F, "glReadBuffer(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum type)
+{
+   DISPATCH(CopyPixels, (x, y, width, height, type), (F, "glCopyPixels(%d, %d, %d, %d, 0x%x);\n", x, y, width, height, type));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ReadPixels)(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels)
+{
+   DISPATCH(ReadPixels, (x, y, width, height, format, type, pixels), (F, "glReadPixels(%d, %d, %d, %d, 0x%x, 0x%x, %p);\n", x, y, width, height, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawPixels)(GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(DrawPixels, (width, height, format, type, pixels), (F, "glDrawPixels(%d, %d, 0x%x, 0x%x, %p);\n", width, height, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBooleanv)(GLenum pname, GLboolean * params)
+{
+   DISPATCH(GetBooleanv, (pname, params), (F, "glGetBooleanv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetClipPlane)(GLenum plane, GLdouble * equation)
+{
+   DISPATCH(GetClipPlane, (plane, equation), (F, "glGetClipPlane(0x%x, %p);\n", plane, (const void *) equation));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetDoublev)(GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetDoublev, (pname, params), (F, "glGetDoublev(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 GLenum KEYWORD2 NAME(GetError)(void)
+{
+   RETURN_DISPATCH(GetError, (), (F, "glGetError();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetFloatv)(GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetFloatv, (pname, params), (F, "glGetFloatv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetIntegerv)(GLenum pname, GLint * params)
+{
+   DISPATCH(GetIntegerv, (pname, params), (F, "glGetIntegerv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetLightfv)(GLenum light, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetLightfv, (light, pname, params), (F, "glGetLightfv(0x%x, 0x%x, %p);\n", light, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetLightiv)(GLenum light, GLenum pname, GLint * params)
+{
+   DISPATCH(GetLightiv, (light, pname, params), (F, "glGetLightiv(0x%x, 0x%x, %p);\n", light, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetMapdv)(GLenum target, GLenum query, GLdouble * v)
+{
+   DISPATCH(GetMapdv, (target, query, v), (F, "glGetMapdv(0x%x, 0x%x, %p);\n", target, query, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetMapfv)(GLenum target, GLenum query, GLfloat * v)
+{
+   DISPATCH(GetMapfv, (target, query, v), (F, "glGetMapfv(0x%x, 0x%x, %p);\n", target, query, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetMapiv)(GLenum target, GLenum query, GLint * v)
+{
+   DISPATCH(GetMapiv, (target, query, v), (F, "glGetMapiv(0x%x, 0x%x, %p);\n", target, query, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetMaterialfv)(GLenum face, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetMaterialfv, (face, pname, params), (F, "glGetMaterialfv(0x%x, 0x%x, %p);\n", face, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetMaterialiv)(GLenum face, GLenum pname, GLint * params)
+{
+   DISPATCH(GetMaterialiv, (face, pname, params), (F, "glGetMaterialiv(0x%x, 0x%x, %p);\n", face, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetPixelMapfv)(GLenum map, GLfloat * values)
+{
+   DISPATCH(GetPixelMapfv, (map, values), (F, "glGetPixelMapfv(0x%x, %p);\n", map, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetPixelMapuiv)(GLenum map, GLuint * values)
+{
+   DISPATCH(GetPixelMapuiv, (map, values), (F, "glGetPixelMapuiv(0x%x, %p);\n", map, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetPixelMapusv)(GLenum map, GLushort * values)
+{
+   DISPATCH(GetPixelMapusv, (map, values), (F, "glGetPixelMapusv(0x%x, %p);\n", map, (const void *) values));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetPolygonStipple)(GLubyte * mask)
+{
+   DISPATCH(GetPolygonStipple, (mask), (F, "glGetPolygonStipple(%p);\n", (const void *) mask));
+}
+
+KEYWORD1 const GLubyte * KEYWORD2 NAME(GetString)(GLenum name)
+{
+   RETURN_DISPATCH(GetString, (name), (F, "glGetString(0x%x);\n", name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexEnvfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetTexEnvfv, (target, pname, params), (F, "glGetTexEnvfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexEnviv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetTexEnviv, (target, pname, params), (F, "glGetTexEnviv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexGendv)(GLenum coord, GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetTexGendv, (coord, pname, params), (F, "glGetTexGendv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexGenfv)(GLenum coord, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetTexGenfv, (coord, pname, params), (F, "glGetTexGenfv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexGeniv)(GLenum coord, GLenum pname, GLint * params)
+{
+   DISPATCH(GetTexGeniv, (coord, pname, params), (F, "glGetTexGeniv(0x%x, 0x%x, %p);\n", coord, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexImage)(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels)
+{
+   DISPATCH(GetTexImage, (target, level, format, type, pixels), (F, "glGetTexImage(0x%x, %d, 0x%x, 0x%x, %p);\n", target, level, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexParameterfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetTexParameterfv, (target, pname, params), (F, "glGetTexParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetTexParameteriv, (target, pname, params), (F, "glGetTexParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexLevelParameterfv)(GLenum target, GLint level, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetTexLevelParameterfv, (target, level, pname, params), (F, "glGetTexLevelParameterfv(0x%x, %d, 0x%x, %p);\n", target, level, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTexLevelParameteriv)(GLenum target, GLint level, GLenum pname, GLint * params)
+{
+   DISPATCH(GetTexLevelParameteriv, (target, level, pname, params), (F, "glGetTexLevelParameteriv(0x%x, %d, 0x%x, %p);\n", target, level, pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsEnabled)(GLenum cap)
+{
+   RETURN_DISPATCH(IsEnabled, (cap), (F, "glIsEnabled(0x%x);\n", cap));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsList)(GLuint list)
+{
+   RETURN_DISPATCH(IsList, (list), (F, "glIsList(%d);\n", list));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DepthRange)(GLclampd zNear, GLclampd zFar)
+{
+   DISPATCH(DepthRange, (zNear, zFar), (F, "glDepthRange(%f, %f);\n", zNear, zFar));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Frustum)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
+{
+   DISPATCH(Frustum, (left, right, bottom, top, zNear, zFar), (F, "glFrustum(%f, %f, %f, %f, %f, %f);\n", left, right, bottom, top, zNear, zFar));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadIdentity)(void)
+{
+   DISPATCH(LoadIdentity, (), (F, "glLoadIdentity();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadMatrixf)(const GLfloat * m)
+{
+   DISPATCH(LoadMatrixf, (m), (F, "glLoadMatrixf(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadMatrixd)(const GLdouble * m)
+{
+   DISPATCH(LoadMatrixd, (m), (F, "glLoadMatrixd(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MatrixMode)(GLenum mode)
+{
+   DISPATCH(MatrixMode, (mode), (F, "glMatrixMode(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultMatrixf)(const GLfloat * m)
+{
+   DISPATCH(MultMatrixf, (m), (F, "glMultMatrixf(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultMatrixd)(const GLdouble * m)
+{
+   DISPATCH(MultMatrixd, (m), (F, "glMultMatrixd(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Ortho)(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar)
+{
+   DISPATCH(Ortho, (left, right, bottom, top, zNear, zFar), (F, "glOrtho(%f, %f, %f, %f, %f, %f);\n", left, right, bottom, top, zNear, zFar));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PopMatrix)(void)
+{
+   DISPATCH(PopMatrix, (), (F, "glPopMatrix();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PushMatrix)(void)
+{
+   DISPATCH(PushMatrix, (), (F, "glPushMatrix();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rotated)(GLdouble angle, GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(Rotated, (angle, x, y, z), (F, "glRotated(%f, %f, %f, %f);\n", angle, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Rotatef)(GLfloat angle, GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(Rotatef, (angle, x, y, z), (F, "glRotatef(%f, %f, %f, %f);\n", angle, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Scaled)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(Scaled, (x, y, z), (F, "glScaled(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Scalef)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(Scalef, (x, y, z), (F, "glScalef(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Translated)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(Translated, (x, y, z), (F, "glTranslated(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Translatef)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(Translatef, (x, y, z), (F, "glTranslatef(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Viewport)(GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(Viewport, (x, y, width, height), (F, "glViewport(%d, %d, %d, %d);\n", x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ArrayElement)(GLint i)
+{
+   DISPATCH(ArrayElement, (i), (F, "glArrayElement(%d);\n", i));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ArrayElementEXT)(GLint i)
+{
+   DISPATCH(ArrayElement, (i), (F, "glArrayElementEXT(%d);\n", i));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindTexture)(GLenum target, GLuint texture)
+{
+   DISPATCH(BindTexture, (target, texture), (F, "glBindTexture(0x%x, %d);\n", target, texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindTextureEXT)(GLenum target, GLuint texture)
+{
+   DISPATCH(BindTexture, (target, texture), (F, "glBindTextureEXT(0x%x, %d);\n", target, texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(ColorPointer, (size, type, stride, pointer), (F, "glColorPointer(%d, 0x%x, %d, %p);\n", size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DisableClientState)(GLenum array)
+{
+   DISPATCH(DisableClientState, (array), (F, "glDisableClientState(0x%x);\n", array));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawArrays)(GLenum mode, GLint first, GLsizei count)
+{
+   DISPATCH(DrawArrays, (mode, first, count), (F, "glDrawArrays(0x%x, %d, %d);\n", mode, first, count));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawArraysEXT)(GLenum mode, GLint first, GLsizei count)
+{
+   DISPATCH(DrawArrays, (mode, first, count), (F, "glDrawArraysEXT(0x%x, %d, %d);\n", mode, first, count));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawElements)(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices)
+{
+   DISPATCH(DrawElements, (mode, count, type, indices), (F, "glDrawElements(0x%x, %d, 0x%x, %p);\n", mode, count, type, (const void *) indices));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EdgeFlagPointer)(GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(EdgeFlagPointer, (stride, pointer), (F, "glEdgeFlagPointer(%d, %p);\n", stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EnableClientState)(GLenum array)
+{
+   DISPATCH(EnableClientState, (array), (F, "glEnableClientState(0x%x);\n", array));
+}
+
+KEYWORD1 void KEYWORD2 NAME(IndexPointer)(GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(IndexPointer, (type, stride, pointer), (F, "glIndexPointer(0x%x, %d, %p);\n", type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexub)(GLubyte c)
+{
+   DISPATCH(Indexub, (c), (F, "glIndexub(%d);\n", c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Indexubv)(const GLubyte * c)
+{
+   DISPATCH(Indexubv, (c), (F, "glIndexubv(%p);\n", (const void *) c));
+}
+
+KEYWORD1 void KEYWORD2 NAME(InterleavedArrays)(GLenum format, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(InterleavedArrays, (format, stride, pointer), (F, "glInterleavedArrays(0x%x, %d, %p);\n", format, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(NormalPointer)(GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(NormalPointer, (type, stride, pointer), (F, "glNormalPointer(0x%x, %d, %p);\n", type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PolygonOffset)(GLfloat factor, GLfloat units)
+{
+   DISPATCH(PolygonOffset, (factor, units), (F, "glPolygonOffset(%f, %f);\n", factor, units));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoordPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(TexCoordPointer, (size, type, stride, pointer), (F, "glTexCoordPointer(%d, 0x%x, %d, %p);\n", size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(VertexPointer, (size, type, stride, pointer), (F, "glVertexPointer(%d, 0x%x, %d, %p);\n", size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(AreTexturesResident)(GLsizei n, const GLuint * textures, GLboolean * residences)
+{
+   RETURN_DISPATCH(AreTexturesResident, (n, textures, residences), (F, "glAreTexturesResident(%d, %p, %p);\n", n, (const void *) textures, (const void *) residences));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 GLboolean KEYWORD2 NAME(AreTexturesResidentEXT)(GLsizei n, const GLuint * textures, GLboolean * residences)
+{
+   RETURN_DISPATCH(AreTexturesResident, (n, textures, residences), (F, "glAreTexturesResidentEXT(%d, %p, %p);\n", n, (const void *) textures, (const void *) residences));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
+{
+   DISPATCH(CopyTexImage1D, (target, level, internalformat, x, y, width, border), (F, "glCopyTexImage1D(0x%x, %d, 0x%x, %d, %d, %d, %d);\n", target, level, internalformat, x, y, width, border));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexImage1DEXT)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border)
+{
+   DISPATCH(CopyTexImage1D, (target, level, internalformat, x, y, width, border), (F, "glCopyTexImage1DEXT(0x%x, %d, 0x%x, %d, %d, %d, %d);\n", target, level, internalformat, x, y, width, border));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
+{
+   DISPATCH(CopyTexImage2D, (target, level, internalformat, x, y, width, height, border), (F, "glCopyTexImage2D(0x%x, %d, 0x%x, %d, %d, %d, %d, %d);\n", target, level, internalformat, x, y, width, height, border));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexImage2DEXT)(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border)
+{
+   DISPATCH(CopyTexImage2D, (target, level, internalformat, x, y, width, height, border), (F, "glCopyTexImage2DEXT(0x%x, %d, 0x%x, %d, %d, %d, %d, %d);\n", target, level, internalformat, x, y, width, height, border));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyTexSubImage1D, (target, level, xoffset, x, y, width), (F, "glCopyTexSubImage1D(0x%x, %d, %d, %d, %d, %d);\n", target, level, xoffset, x, y, width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage1DEXT)(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyTexSubImage1D, (target, level, xoffset, x, y, width), (F, "glCopyTexSubImage1DEXT(0x%x, %d, %d, %d, %d, %d);\n", target, level, xoffset, x, y, width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyTexSubImage2D, (target, level, xoffset, yoffset, x, y, width, height), (F, "glCopyTexSubImage2D(0x%x, %d, %d, %d, %d, %d, %d, %d);\n", target, level, xoffset, yoffset, x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage2DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyTexSubImage2D, (target, level, xoffset, yoffset, x, y, width, height), (F, "glCopyTexSubImage2DEXT(0x%x, %d, %d, %d, %d, %d, %d, %d);\n", target, level, xoffset, yoffset, x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteTextures)(GLsizei n, const GLuint * textures)
+{
+   DISPATCH(DeleteTextures, (n, textures), (F, "glDeleteTextures(%d, %p);\n", n, (const void *) textures));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 void KEYWORD2 NAME(DeleteTexturesEXT)(GLsizei n, const GLuint * textures)
+{
+   DISPATCH(DeleteTextures, (n, textures), (F, "glDeleteTexturesEXT(%d, %p);\n", n, (const void *) textures));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GenTextures)(GLsizei n, GLuint * textures)
+{
+   DISPATCH(GenTextures, (n, textures), (F, "glGenTextures(%d, %p);\n", n, (const void *) textures));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 void KEYWORD2 NAME(GenTexturesEXT)(GLsizei n, GLuint * textures)
+{
+   DISPATCH(GenTextures, (n, textures), (F, "glGenTexturesEXT(%d, %p);\n", n, (const void *) textures));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetPointerv)(GLenum pname, GLvoid ** params)
+{
+   DISPATCH(GetPointerv, (pname, params), (F, "glGetPointerv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetPointervEXT)(GLenum pname, GLvoid ** params)
+{
+   DISPATCH(GetPointerv, (pname, params), (F, "glGetPointervEXT(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsTexture)(GLuint texture)
+{
+   RETURN_DISPATCH(IsTexture, (texture), (F, "glIsTexture(%d);\n", texture));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 GLboolean KEYWORD2 NAME(IsTextureEXT)(GLuint texture)
+{
+   RETURN_DISPATCH(IsTexture, (texture), (F, "glIsTextureEXT(%d);\n", texture));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(PrioritizeTextures)(GLsizei n, const GLuint * textures, const GLclampf * priorities)
+{
+   DISPATCH(PrioritizeTextures, (n, textures, priorities), (F, "glPrioritizeTextures(%d, %p, %p);\n", n, (const void *) textures, (const void *) priorities));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PrioritizeTexturesEXT)(GLsizei n, const GLuint * textures, const GLclampf * priorities)
+{
+   DISPATCH(PrioritizeTextures, (n, textures, priorities), (F, "glPrioritizeTexturesEXT(%d, %p, %p);\n", n, (const void *) textures, (const void *) priorities));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage1D, (target, level, xoffset, width, format, type, pixels), (F, "glTexSubImage1D(0x%x, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, width, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage1DEXT)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage1D, (target, level, xoffset, width, format, type, pixels), (F, "glTexSubImage1DEXT(0x%x, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, width, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage2D, (target, level, xoffset, yoffset, width, height, format, type, pixels), (F, "glTexSubImage2D(0x%x, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, yoffset, width, height, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage2DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage2D, (target, level, xoffset, yoffset, width, height, format, type, pixels), (F, "glTexSubImage2DEXT(0x%x, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, yoffset, width, height, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PopClientAttrib)(void)
+{
+   DISPATCH(PopClientAttrib, (), (F, "glPopClientAttrib();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PushClientAttrib)(GLbitfield mask)
+{
+   DISPATCH(PushClientAttrib, (mask), (F, "glPushClientAttrib(%d);\n", mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendColor)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
+{
+   DISPATCH(BlendColor, (red, green, blue, alpha), (F, "glBlendColor(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendColorEXT)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
+{
+   DISPATCH(BlendColor, (red, green, blue, alpha), (F, "glBlendColorEXT(%f, %f, %f, %f);\n", red, green, blue, alpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendEquation)(GLenum mode)
+{
+   DISPATCH(BlendEquation, (mode), (F, "glBlendEquation(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendEquationEXT)(GLenum mode)
+{
+   DISPATCH(BlendEquation, (mode), (F, "glBlendEquationEXT(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawRangeElements)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices)
+{
+   DISPATCH(DrawRangeElements, (mode, start, end, count, type, indices), (F, "glDrawRangeElements(0x%x, %d, %d, %d, 0x%x, %p);\n", mode, start, end, count, type, (const void *) indices));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawRangeElementsEXT)(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices)
+{
+   DISPATCH(DrawRangeElements, (mode, start, end, count, type, indices), (F, "glDrawRangeElementsEXT(0x%x, %d, %d, %d, 0x%x, %p);\n", mode, start, end, count, type, (const void *) indices));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorTable)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table)
+{
+   DISPATCH(ColorTable, (target, internalformat, width, format, type, table), (F, "glColorTable(0x%x, 0x%x, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, format, type, (const void *) table));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_339)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_339)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table)
+{
+   DISPATCH(ColorTable, (target, internalformat, width, format, type, table), (F, "glColorTableSGI(0x%x, 0x%x, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, format, type, (const void *) table));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorTableEXT)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table)
+{
+   DISPATCH(ColorTable, (target, internalformat, width, format, type, table), (F, "glColorTableEXT(0x%x, 0x%x, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, format, type, (const void *) table));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorTableParameterfv)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(ColorTableParameterfv, (target, pname, params), (F, "glColorTableParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_340)(GLenum target, GLenum pname, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_340)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(ColorTableParameterfv, (target, pname, params), (F, "glColorTableParameterfvSGI(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorTableParameteriv)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(ColorTableParameteriv, (target, pname, params), (F, "glColorTableParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_341)(GLenum target, GLenum pname, const GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_341)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(ColorTableParameteriv, (target, pname, params), (F, "glColorTableParameterivSGI(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyColorTable)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyColorTable, (target, internalformat, x, y, width), (F, "glCopyColorTable(0x%x, 0x%x, %d, %d, %d);\n", target, internalformat, x, y, width));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_342)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_342)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyColorTable, (target, internalformat, x, y, width), (F, "glCopyColorTableSGI(0x%x, 0x%x, %d, %d, %d);\n", target, internalformat, x, y, width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetColorTable)(GLenum target, GLenum format, GLenum type, GLvoid * table)
+{
+   DISPATCH(GetColorTable, (target, format, type, table), (F, "glGetColorTable(0x%x, 0x%x, 0x%x, %p);\n", target, format, type, (const void *) table));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_343)(GLenum target, GLenum format, GLenum type, GLvoid * table);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_343)(GLenum target, GLenum format, GLenum type, GLvoid * table)
+{
+   DISPATCH(GetColorTable, (target, format, type, table), (F, "glGetColorTableSGI(0x%x, 0x%x, 0x%x, %p);\n", target, format, type, (const void *) table));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 void KEYWORD2 NAME(GetColorTableEXT)(GLenum target, GLenum format, GLenum type, GLvoid * table)
+{
+   DISPATCH(GetColorTable, (target, format, type, table), (F, "glGetColorTableEXT(0x%x, 0x%x, 0x%x, %p);\n", target, format, type, (const void *) table));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetColorTableParameterfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetColorTableParameterfv, (target, pname, params), (F, "glGetColorTableParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_344)(GLenum target, GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_344)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetColorTableParameterfv, (target, pname, params), (F, "glGetColorTableParameterfvSGI(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 void KEYWORD2 NAME(GetColorTableParameterfvEXT)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetColorTableParameterfv, (target, pname, params), (F, "glGetColorTableParameterfvEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetColorTableParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetColorTableParameteriv, (target, pname, params), (F, "glGetColorTableParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_345)(GLenum target, GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_345)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetColorTableParameteriv, (target, pname, params), (F, "glGetColorTableParameterivSGI(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1 void KEYWORD2 NAME(GetColorTableParameterivEXT)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetColorTableParameteriv, (target, pname, params), (F, "glGetColorTableParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(ColorSubTable)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data)
+{
+   DISPATCH(ColorSubTable, (target, start, count, format, type, data), (F, "glColorSubTable(0x%x, %d, %d, 0x%x, 0x%x, %p);\n", target, start, count, format, type, (const void *) data));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_346)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_346)(GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data)
+{
+   DISPATCH(ColorSubTable, (target, start, count, format, type, data), (F, "glColorSubTableEXT(0x%x, %d, %d, 0x%x, 0x%x, %p);\n", target, start, count, format, type, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyColorSubTable)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyColorSubTable, (target, start, x, y, width), (F, "glCopyColorSubTable(0x%x, %d, %d, %d, %d);\n", target, start, x, y, width));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_347)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_347)(GLenum target, GLsizei start, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyColorSubTable, (target, start, x, y, width), (F, "glCopyColorSubTableEXT(0x%x, %d, %d, %d, %d);\n", target, start, x, y, width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionFilter1D)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image)
+{
+   DISPATCH(ConvolutionFilter1D, (target, internalformat, width, format, type, image), (F, "glConvolutionFilter1D(0x%x, 0x%x, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, format, type, (const void *) image));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_348)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_348)(GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image)
+{
+   DISPATCH(ConvolutionFilter1D, (target, internalformat, width, format, type, image), (F, "glConvolutionFilter1DEXT(0x%x, 0x%x, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, format, type, (const void *) image));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionFilter2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image)
+{
+   DISPATCH(ConvolutionFilter2D, (target, internalformat, width, height, format, type, image), (F, "glConvolutionFilter2D(0x%x, 0x%x, %d, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, height, format, type, (const void *) image));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_349)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_349)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image)
+{
+   DISPATCH(ConvolutionFilter2D, (target, internalformat, width, height, format, type, image), (F, "glConvolutionFilter2DEXT(0x%x, 0x%x, %d, %d, 0x%x, 0x%x, %p);\n", target, internalformat, width, height, format, type, (const void *) image));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionParameterf)(GLenum target, GLenum pname, GLfloat params)
+{
+   DISPATCH(ConvolutionParameterf, (target, pname, params), (F, "glConvolutionParameterf(0x%x, 0x%x, %f);\n", target, pname, params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_350)(GLenum target, GLenum pname, GLfloat params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_350)(GLenum target, GLenum pname, GLfloat params)
+{
+   DISPATCH(ConvolutionParameterf, (target, pname, params), (F, "glConvolutionParameterfEXT(0x%x, 0x%x, %f);\n", target, pname, params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionParameterfv)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(ConvolutionParameterfv, (target, pname, params), (F, "glConvolutionParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_351)(GLenum target, GLenum pname, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_351)(GLenum target, GLenum pname, const GLfloat * params)
+{
+   DISPATCH(ConvolutionParameterfv, (target, pname, params), (F, "glConvolutionParameterfvEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionParameteri)(GLenum target, GLenum pname, GLint params)
+{
+   DISPATCH(ConvolutionParameteri, (target, pname, params), (F, "glConvolutionParameteri(0x%x, 0x%x, %d);\n", target, pname, params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_352)(GLenum target, GLenum pname, GLint params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_352)(GLenum target, GLenum pname, GLint params)
+{
+   DISPATCH(ConvolutionParameteri, (target, pname, params), (F, "glConvolutionParameteriEXT(0x%x, 0x%x, %d);\n", target, pname, params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ConvolutionParameteriv)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(ConvolutionParameteriv, (target, pname, params), (F, "glConvolutionParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_353)(GLenum target, GLenum pname, const GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_353)(GLenum target, GLenum pname, const GLint * params)
+{
+   DISPATCH(ConvolutionParameteriv, (target, pname, params), (F, "glConvolutionParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyConvolutionFilter1D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyConvolutionFilter1D, (target, internalformat, x, y, width), (F, "glCopyConvolutionFilter1D(0x%x, 0x%x, %d, %d, %d);\n", target, internalformat, x, y, width));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_354)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_354)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width)
+{
+   DISPATCH(CopyConvolutionFilter1D, (target, internalformat, x, y, width), (F, "glCopyConvolutionFilter1DEXT(0x%x, 0x%x, %d, %d, %d);\n", target, internalformat, x, y, width));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyConvolutionFilter2D)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyConvolutionFilter2D, (target, internalformat, x, y, width, height), (F, "glCopyConvolutionFilter2D(0x%x, 0x%x, %d, %d, %d, %d);\n", target, internalformat, x, y, width, height));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_355)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_355)(GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyConvolutionFilter2D, (target, internalformat, x, y, width, height), (F, "glCopyConvolutionFilter2DEXT(0x%x, 0x%x, %d, %d, %d, %d);\n", target, internalformat, x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetConvolutionFilter)(GLenum target, GLenum format, GLenum type, GLvoid * image)
+{
+   DISPATCH(GetConvolutionFilter, (target, format, type, image), (F, "glGetConvolutionFilter(0x%x, 0x%x, 0x%x, %p);\n", target, format, type, (const void *) image));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_356)(GLenum target, GLenum format, GLenum type, GLvoid * image);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_356)(GLenum target, GLenum format, GLenum type, GLvoid * image)
+{
+   DISPATCH(GetConvolutionFilter, (target, format, type, image), (F, "glGetConvolutionFilterEXT(0x%x, 0x%x, 0x%x, %p);\n", target, format, type, (const void *) image));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetConvolutionParameterfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetConvolutionParameterfv, (target, pname, params), (F, "glGetConvolutionParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_357)(GLenum target, GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_357)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetConvolutionParameterfv, (target, pname, params), (F, "glGetConvolutionParameterfvEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetConvolutionParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetConvolutionParameteriv, (target, pname, params), (F, "glGetConvolutionParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_358)(GLenum target, GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_358)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetConvolutionParameteriv, (target, pname, params), (F, "glGetConvolutionParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetSeparableFilter)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span)
+{
+   DISPATCH(GetSeparableFilter, (target, format, type, row, column, span), (F, "glGetSeparableFilter(0x%x, 0x%x, 0x%x, %p, %p, %p);\n", target, format, type, (const void *) row, (const void *) column, (const void *) span));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_359)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_359)(GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span)
+{
+   DISPATCH(GetSeparableFilter, (target, format, type, row, column, span), (F, "glGetSeparableFilterEXT(0x%x, 0x%x, 0x%x, %p, %p, %p);\n", target, format, type, (const void *) row, (const void *) column, (const void *) span));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(SeparableFilter2D)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column)
+{
+   DISPATCH(SeparableFilter2D, (target, internalformat, width, height, format, type, row, column), (F, "glSeparableFilter2D(0x%x, 0x%x, %d, %d, 0x%x, 0x%x, %p, %p);\n", target, internalformat, width, height, format, type, (const void *) row, (const void *) column));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_360)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_360)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column)
+{
+   DISPATCH(SeparableFilter2D, (target, internalformat, width, height, format, type, row, column), (F, "glSeparableFilter2DEXT(0x%x, 0x%x, %d, %d, 0x%x, 0x%x, %p, %p);\n", target, internalformat, width, height, format, type, (const void *) row, (const void *) column));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetHistogram)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
+{
+   DISPATCH(GetHistogram, (target, reset, format, type, values), (F, "glGetHistogram(0x%x, %d, 0x%x, 0x%x, %p);\n", target, reset, format, type, (const void *) values));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_361)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_361)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
+{
+   DISPATCH(GetHistogram, (target, reset, format, type, values), (F, "glGetHistogramEXT(0x%x, %d, 0x%x, 0x%x, %p);\n", target, reset, format, type, (const void *) values));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetHistogramParameterfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetHistogramParameterfv, (target, pname, params), (F, "glGetHistogramParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_362)(GLenum target, GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_362)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetHistogramParameterfv, (target, pname, params), (F, "glGetHistogramParameterfvEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetHistogramParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetHistogramParameteriv, (target, pname, params), (F, "glGetHistogramParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_363)(GLenum target, GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_363)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetHistogramParameteriv, (target, pname, params), (F, "glGetHistogramParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetMinmax)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
+{
+   DISPATCH(GetMinmax, (target, reset, format, type, values), (F, "glGetMinmax(0x%x, %d, 0x%x, 0x%x, %p);\n", target, reset, format, type, (const void *) values));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_364)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_364)(GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values)
+{
+   DISPATCH(GetMinmax, (target, reset, format, type, values), (F, "glGetMinmaxEXT(0x%x, %d, 0x%x, 0x%x, %p);\n", target, reset, format, type, (const void *) values));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetMinmaxParameterfv)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetMinmaxParameterfv, (target, pname, params), (F, "glGetMinmaxParameterfv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_365)(GLenum target, GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_365)(GLenum target, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetMinmaxParameterfv, (target, pname, params), (F, "glGetMinmaxParameterfvEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(GetMinmaxParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetMinmaxParameteriv, (target, pname, params), (F, "glGetMinmaxParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+#ifndef GLX_INDIRECT_RENDERING
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_366)(GLenum target, GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_366)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetMinmaxParameteriv, (target, pname, params), (F, "glGetMinmaxParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+#endif /* GLX_INDIRECT_RENDERING */
+
+KEYWORD1 void KEYWORD2 NAME(Histogram)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
+{
+   DISPATCH(Histogram, (target, width, internalformat, sink), (F, "glHistogram(0x%x, %d, 0x%x, %d);\n", target, width, internalformat, sink));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_367)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_367)(GLenum target, GLsizei width, GLenum internalformat, GLboolean sink)
+{
+   DISPATCH(Histogram, (target, width, internalformat, sink), (F, "glHistogramEXT(0x%x, %d, 0x%x, %d);\n", target, width, internalformat, sink));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Minmax)(GLenum target, GLenum internalformat, GLboolean sink)
+{
+   DISPATCH(Minmax, (target, internalformat, sink), (F, "glMinmax(0x%x, 0x%x, %d);\n", target, internalformat, sink));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_368)(GLenum target, GLenum internalformat, GLboolean sink);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_368)(GLenum target, GLenum internalformat, GLboolean sink)
+{
+   DISPATCH(Minmax, (target, internalformat, sink), (F, "glMinmaxEXT(0x%x, 0x%x, %d);\n", target, internalformat, sink));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ResetHistogram)(GLenum target)
+{
+   DISPATCH(ResetHistogram, (target), (F, "glResetHistogram(0x%x);\n", target));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_369)(GLenum target);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_369)(GLenum target)
+{
+   DISPATCH(ResetHistogram, (target), (F, "glResetHistogramEXT(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ResetMinmax)(GLenum target)
+{
+   DISPATCH(ResetMinmax, (target), (F, "glResetMinmax(0x%x);\n", target));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_370)(GLenum target);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_370)(GLenum target)
+{
+   DISPATCH(ResetMinmax, (target), (F, "glResetMinmaxEXT(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexImage3D)(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (F, "glTexImage3D(0x%x, %d, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, internalformat, width, height, depth, border, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexImage3DEXT)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexImage3D, (target, level, internalformat, width, height, depth, border, format, type, pixels), (F, "glTexImage3DEXT(0x%x, %d, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, internalformat, width, height, depth, border, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (F, "glTexSubImage3D(0x%x, %d, %d, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexSubImage3DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels)
+{
+   DISPATCH(TexSubImage3D, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels), (F, "glTexSubImage3DEXT(0x%x, %d, %d, %d, %d, %d, %d, %d, 0x%x, 0x%x, %p);\n", target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, (const void *) pixels));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (F, "glCopyTexSubImage3D(0x%x, %d, %d, %d, %d, %d, %d, %d, %d);\n", target, level, xoffset, yoffset, zoffset, x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CopyTexSubImage3DEXT)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height)
+{
+   DISPATCH(CopyTexSubImage3D, (target, level, xoffset, yoffset, zoffset, x, y, width, height), (F, "glCopyTexSubImage3DEXT(0x%x, %d, %d, %d, %d, %d, %d, %d, %d);\n", target, level, xoffset, yoffset, zoffset, x, y, width, height));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ActiveTexture)(GLenum texture)
+{
+   DISPATCH(ActiveTextureARB, (texture), (F, "glActiveTexture(0x%x);\n", texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ActiveTextureARB)(GLenum texture)
+{
+   DISPATCH(ActiveTextureARB, (texture), (F, "glActiveTextureARB(0x%x);\n", texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClientActiveTexture)(GLenum texture)
+{
+   DISPATCH(ClientActiveTextureARB, (texture), (F, "glClientActiveTexture(0x%x);\n", texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ClientActiveTextureARB)(GLenum texture)
+{
+   DISPATCH(ClientActiveTextureARB, (texture), (F, "glClientActiveTextureARB(0x%x);\n", texture));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1d)(GLenum target, GLdouble s)
+{
+   DISPATCH(MultiTexCoord1dARB, (target, s), (F, "glMultiTexCoord1d(0x%x, %f);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1dARB)(GLenum target, GLdouble s)
+{
+   DISPATCH(MultiTexCoord1dARB, (target, s), (F, "glMultiTexCoord1dARB(0x%x, %f);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1dv)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord1dvARB, (target, v), (F, "glMultiTexCoord1dv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1dvARB)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord1dvARB, (target, v), (F, "glMultiTexCoord1dvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1f)(GLenum target, GLfloat s)
+{
+   DISPATCH(MultiTexCoord1fARB, (target, s), (F, "glMultiTexCoord1f(0x%x, %f);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1fARB)(GLenum target, GLfloat s)
+{
+   DISPATCH(MultiTexCoord1fARB, (target, s), (F, "glMultiTexCoord1fARB(0x%x, %f);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1fv)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord1fvARB, (target, v), (F, "glMultiTexCoord1fv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1fvARB)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord1fvARB, (target, v), (F, "glMultiTexCoord1fvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1i)(GLenum target, GLint s)
+{
+   DISPATCH(MultiTexCoord1iARB, (target, s), (F, "glMultiTexCoord1i(0x%x, %d);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1iARB)(GLenum target, GLint s)
+{
+   DISPATCH(MultiTexCoord1iARB, (target, s), (F, "glMultiTexCoord1iARB(0x%x, %d);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1iv)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord1ivARB, (target, v), (F, "glMultiTexCoord1iv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1ivARB)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord1ivARB, (target, v), (F, "glMultiTexCoord1ivARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1s)(GLenum target, GLshort s)
+{
+   DISPATCH(MultiTexCoord1sARB, (target, s), (F, "glMultiTexCoord1s(0x%x, %d);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1sARB)(GLenum target, GLshort s)
+{
+   DISPATCH(MultiTexCoord1sARB, (target, s), (F, "glMultiTexCoord1sARB(0x%x, %d);\n", target, s));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1sv)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord1svARB, (target, v), (F, "glMultiTexCoord1sv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord1svARB)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord1svARB, (target, v), (F, "glMultiTexCoord1svARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2d)(GLenum target, GLdouble s, GLdouble t)
+{
+   DISPATCH(MultiTexCoord2dARB, (target, s, t), (F, "glMultiTexCoord2d(0x%x, %f, %f);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2dARB)(GLenum target, GLdouble s, GLdouble t)
+{
+   DISPATCH(MultiTexCoord2dARB, (target, s, t), (F, "glMultiTexCoord2dARB(0x%x, %f, %f);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2dv)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord2dvARB, (target, v), (F, "glMultiTexCoord2dv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2dvARB)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord2dvARB, (target, v), (F, "glMultiTexCoord2dvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2f)(GLenum target, GLfloat s, GLfloat t)
+{
+   DISPATCH(MultiTexCoord2fARB, (target, s, t), (F, "glMultiTexCoord2f(0x%x, %f, %f);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2fARB)(GLenum target, GLfloat s, GLfloat t)
+{
+   DISPATCH(MultiTexCoord2fARB, (target, s, t), (F, "glMultiTexCoord2fARB(0x%x, %f, %f);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2fv)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord2fvARB, (target, v), (F, "glMultiTexCoord2fv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2fvARB)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord2fvARB, (target, v), (F, "glMultiTexCoord2fvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2i)(GLenum target, GLint s, GLint t)
+{
+   DISPATCH(MultiTexCoord2iARB, (target, s, t), (F, "glMultiTexCoord2i(0x%x, %d, %d);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2iARB)(GLenum target, GLint s, GLint t)
+{
+   DISPATCH(MultiTexCoord2iARB, (target, s, t), (F, "glMultiTexCoord2iARB(0x%x, %d, %d);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2iv)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord2ivARB, (target, v), (F, "glMultiTexCoord2iv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2ivARB)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord2ivARB, (target, v), (F, "glMultiTexCoord2ivARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2s)(GLenum target, GLshort s, GLshort t)
+{
+   DISPATCH(MultiTexCoord2sARB, (target, s, t), (F, "glMultiTexCoord2s(0x%x, %d, %d);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2sARB)(GLenum target, GLshort s, GLshort t)
+{
+   DISPATCH(MultiTexCoord2sARB, (target, s, t), (F, "glMultiTexCoord2sARB(0x%x, %d, %d);\n", target, s, t));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2sv)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord2svARB, (target, v), (F, "glMultiTexCoord2sv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord2svARB)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord2svARB, (target, v), (F, "glMultiTexCoord2svARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3d)(GLenum target, GLdouble s, GLdouble t, GLdouble r)
+{
+   DISPATCH(MultiTexCoord3dARB, (target, s, t, r), (F, "glMultiTexCoord3d(0x%x, %f, %f, %f);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3dARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r)
+{
+   DISPATCH(MultiTexCoord3dARB, (target, s, t, r), (F, "glMultiTexCoord3dARB(0x%x, %f, %f, %f);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3dv)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord3dvARB, (target, v), (F, "glMultiTexCoord3dv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3dvARB)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord3dvARB, (target, v), (F, "glMultiTexCoord3dvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3f)(GLenum target, GLfloat s, GLfloat t, GLfloat r)
+{
+   DISPATCH(MultiTexCoord3fARB, (target, s, t, r), (F, "glMultiTexCoord3f(0x%x, %f, %f, %f);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3fARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r)
+{
+   DISPATCH(MultiTexCoord3fARB, (target, s, t, r), (F, "glMultiTexCoord3fARB(0x%x, %f, %f, %f);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3fv)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord3fvARB, (target, v), (F, "glMultiTexCoord3fv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3fvARB)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord3fvARB, (target, v), (F, "glMultiTexCoord3fvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3i)(GLenum target, GLint s, GLint t, GLint r)
+{
+   DISPATCH(MultiTexCoord3iARB, (target, s, t, r), (F, "glMultiTexCoord3i(0x%x, %d, %d, %d);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3iARB)(GLenum target, GLint s, GLint t, GLint r)
+{
+   DISPATCH(MultiTexCoord3iARB, (target, s, t, r), (F, "glMultiTexCoord3iARB(0x%x, %d, %d, %d);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3iv)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord3ivARB, (target, v), (F, "glMultiTexCoord3iv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3ivARB)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord3ivARB, (target, v), (F, "glMultiTexCoord3ivARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3s)(GLenum target, GLshort s, GLshort t, GLshort r)
+{
+   DISPATCH(MultiTexCoord3sARB, (target, s, t, r), (F, "glMultiTexCoord3s(0x%x, %d, %d, %d);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3sARB)(GLenum target, GLshort s, GLshort t, GLshort r)
+{
+   DISPATCH(MultiTexCoord3sARB, (target, s, t, r), (F, "glMultiTexCoord3sARB(0x%x, %d, %d, %d);\n", target, s, t, r));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3sv)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord3svARB, (target, v), (F, "glMultiTexCoord3sv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord3svARB)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord3svARB, (target, v), (F, "glMultiTexCoord3svARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4d)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+{
+   DISPATCH(MultiTexCoord4dARB, (target, s, t, r, q), (F, "glMultiTexCoord4d(0x%x, %f, %f, %f, %f);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4dARB)(GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q)
+{
+   DISPATCH(MultiTexCoord4dARB, (target, s, t, r, q), (F, "glMultiTexCoord4dARB(0x%x, %f, %f, %f, %f);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4dv)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord4dvARB, (target, v), (F, "glMultiTexCoord4dv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4dvARB)(GLenum target, const GLdouble * v)
+{
+   DISPATCH(MultiTexCoord4dvARB, (target, v), (F, "glMultiTexCoord4dvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4f)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
+{
+   DISPATCH(MultiTexCoord4fARB, (target, s, t, r, q), (F, "glMultiTexCoord4f(0x%x, %f, %f, %f, %f);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4fARB)(GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q)
+{
+   DISPATCH(MultiTexCoord4fARB, (target, s, t, r, q), (F, "glMultiTexCoord4fARB(0x%x, %f, %f, %f, %f);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4fv)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord4fvARB, (target, v), (F, "glMultiTexCoord4fv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4fvARB)(GLenum target, const GLfloat * v)
+{
+   DISPATCH(MultiTexCoord4fvARB, (target, v), (F, "glMultiTexCoord4fvARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4i)(GLenum target, GLint s, GLint t, GLint r, GLint q)
+{
+   DISPATCH(MultiTexCoord4iARB, (target, s, t, r, q), (F, "glMultiTexCoord4i(0x%x, %d, %d, %d, %d);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4iARB)(GLenum target, GLint s, GLint t, GLint r, GLint q)
+{
+   DISPATCH(MultiTexCoord4iARB, (target, s, t, r, q), (F, "glMultiTexCoord4iARB(0x%x, %d, %d, %d, %d);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4iv)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord4ivARB, (target, v), (F, "glMultiTexCoord4iv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4ivARB)(GLenum target, const GLint * v)
+{
+   DISPATCH(MultiTexCoord4ivARB, (target, v), (F, "glMultiTexCoord4ivARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4s)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
+{
+   DISPATCH(MultiTexCoord4sARB, (target, s, t, r, q), (F, "glMultiTexCoord4s(0x%x, %d, %d, %d, %d);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4sARB)(GLenum target, GLshort s, GLshort t, GLshort r, GLshort q)
+{
+   DISPATCH(MultiTexCoord4sARB, (target, s, t, r, q), (F, "glMultiTexCoord4sARB(0x%x, %d, %d, %d, %d);\n", target, s, t, r, q));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4sv)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord4svARB, (target, v), (F, "glMultiTexCoord4sv(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiTexCoord4svARB)(GLenum target, const GLshort * v)
+{
+   DISPATCH(MultiTexCoord4svARB, (target, v), (F, "glMultiTexCoord4svARB(0x%x, %p);\n", target, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AttachShader)(GLuint program, GLuint shader)
+{
+   DISPATCH(AttachShader, (program, shader), (F, "glAttachShader(%d, %d);\n", program, shader));
+}
+
+KEYWORD1 GLuint KEYWORD2 NAME(CreateProgram)(void)
+{
+   RETURN_DISPATCH(CreateProgram, (), (F, "glCreateProgram();\n"));
+}
+
+KEYWORD1 GLuint KEYWORD2 NAME(CreateShader)(GLenum type)
+{
+   RETURN_DISPATCH(CreateShader, (type), (F, "glCreateShader(0x%x);\n", type));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteProgram)(GLuint program)
+{
+   DISPATCH(DeleteProgram, (program), (F, "glDeleteProgram(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteShader)(GLuint program)
+{
+   DISPATCH(DeleteShader, (program), (F, "glDeleteShader(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DetachShader)(GLuint program, GLuint shader)
+{
+   DISPATCH(DetachShader, (program, shader), (F, "glDetachShader(%d, %d);\n", program, shader));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetAttachedShaders)(GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj)
+{
+   DISPATCH(GetAttachedShaders, (program, maxCount, count, obj), (F, "glGetAttachedShaders(%d, %d, %p, %p);\n", program, maxCount, (const void *) count, (const void *) obj));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramInfoLog)(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
+{
+   DISPATCH(GetProgramInfoLog, (program, bufSize, length, infoLog), (F, "glGetProgramInfoLog(%d, %d, %p, %p);\n", program, bufSize, (const void *) length, (const void *) infoLog));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramiv)(GLuint program, GLenum pname, GLint * params)
+{
+   DISPATCH(GetProgramiv, (program, pname, params), (F, "glGetProgramiv(%d, 0x%x, %p);\n", program, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetShaderInfoLog)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
+{
+   DISPATCH(GetShaderInfoLog, (shader, bufSize, length, infoLog), (F, "glGetShaderInfoLog(%d, %d, %p, %p);\n", shader, bufSize, (const void *) length, (const void *) infoLog));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetShaderiv)(GLuint shader, GLenum pname, GLint * params)
+{
+   DISPATCH(GetShaderiv, (shader, pname, params), (F, "glGetShaderiv(%d, 0x%x, %p);\n", shader, pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsProgram)(GLuint program)
+{
+   RETURN_DISPATCH(IsProgram, (program), (F, "glIsProgram(%d);\n", program));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsShader)(GLuint shader)
+{
+   RETURN_DISPATCH(IsShader, (shader), (F, "glIsShader(%d);\n", shader));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilFuncSeparate)(GLenum face, GLenum func, GLint ref, GLuint mask)
+{
+   DISPATCH(StencilFuncSeparate, (face, func, ref, mask), (F, "glStencilFuncSeparate(0x%x, 0x%x, %d, %d);\n", face, func, ref, mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilMaskSeparate)(GLenum face, GLuint mask)
+{
+   DISPATCH(StencilMaskSeparate, (face, mask), (F, "glStencilMaskSeparate(0x%x, %d);\n", face, mask));
+}
+
+KEYWORD1 void KEYWORD2 NAME(StencilOpSeparate)(GLenum face, GLenum sfail, GLenum zfail, GLenum zpass)
+{
+   DISPATCH(StencilOpSeparate, (face, sfail, zfail, zpass), (F, "glStencilOpSeparate(0x%x, 0x%x, 0x%x, 0x%x);\n", face, sfail, zfail, zpass));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_423)(GLenum face, GLenum sfail, GLenum zfail, GLenum zpass);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_423)(GLenum face, GLenum sfail, GLenum zfail, GLenum zpass)
+{
+   DISPATCH(StencilOpSeparate, (face, sfail, zfail, zpass), (F, "glStencilOpSeparateATI(0x%x, 0x%x, 0x%x, 0x%x);\n", face, sfail, zfail, zpass));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix2x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix2x3fv, (location, count, transpose, value), (F, "glUniformMatrix2x3fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix2x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix2x4fv, (location, count, transpose, value), (F, "glUniformMatrix2x4fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix3x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix3x2fv, (location, count, transpose, value), (F, "glUniformMatrix3x2fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix3x4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix3x4fv, (location, count, transpose, value), (F, "glUniformMatrix3x4fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix4x2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix4x2fv, (location, count, transpose, value), (F, "glUniformMatrix4x2fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix4x3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix4x3fv, (location, count, transpose, value), (F, "glUniformMatrix4x3fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadTransposeMatrixd)(const GLdouble * m)
+{
+   DISPATCH(LoadTransposeMatrixdARB, (m), (F, "glLoadTransposeMatrixd(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadTransposeMatrixdARB)(const GLdouble * m)
+{
+   DISPATCH(LoadTransposeMatrixdARB, (m), (F, "glLoadTransposeMatrixdARB(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadTransposeMatrixf)(const GLfloat * m)
+{
+   DISPATCH(LoadTransposeMatrixfARB, (m), (F, "glLoadTransposeMatrixf(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadTransposeMatrixfARB)(const GLfloat * m)
+{
+   DISPATCH(LoadTransposeMatrixfARB, (m), (F, "glLoadTransposeMatrixfARB(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultTransposeMatrixd)(const GLdouble * m)
+{
+   DISPATCH(MultTransposeMatrixdARB, (m), (F, "glMultTransposeMatrixd(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultTransposeMatrixdARB)(const GLdouble * m)
+{
+   DISPATCH(MultTransposeMatrixdARB, (m), (F, "glMultTransposeMatrixdARB(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultTransposeMatrixf)(const GLfloat * m)
+{
+   DISPATCH(MultTransposeMatrixfARB, (m), (F, "glMultTransposeMatrixf(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultTransposeMatrixfARB)(const GLfloat * m)
+{
+   DISPATCH(MultTransposeMatrixfARB, (m), (F, "glMultTransposeMatrixfARB(%p);\n", (const void *) m));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SampleCoverage)(GLclampf value, GLboolean invert)
+{
+   DISPATCH(SampleCoverageARB, (value, invert), (F, "glSampleCoverage(%f, %d);\n", value, invert));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SampleCoverageARB)(GLclampf value, GLboolean invert)
+{
+   DISPATCH(SampleCoverageARB, (value, invert), (F, "glSampleCoverageARB(%f, %d);\n", value, invert));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage1D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage1DARB, (target, level, internalformat, width, border, imageSize, data), (F, "glCompressedTexImage1D(0x%x, %d, 0x%x, %d, %d, %d, %p);\n", target, level, internalformat, width, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage1DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage1DARB, (target, level, internalformat, width, border, imageSize, data), (F, "glCompressedTexImage1DARB(0x%x, %d, 0x%x, %d, %d, %d, %p);\n", target, level, internalformat, width, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage2D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage2DARB, (target, level, internalformat, width, height, border, imageSize, data), (F, "glCompressedTexImage2D(0x%x, %d, 0x%x, %d, %d, %d, %d, %p);\n", target, level, internalformat, width, height, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage2DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage2DARB, (target, level, internalformat, width, height, border, imageSize, data), (F, "glCompressedTexImage2DARB(0x%x, %d, 0x%x, %d, %d, %d, %d, %p);\n", target, level, internalformat, width, height, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage3D)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage3DARB, (target, level, internalformat, width, height, depth, border, imageSize, data), (F, "glCompressedTexImage3D(0x%x, %d, 0x%x, %d, %d, %d, %d, %d, %p);\n", target, level, internalformat, width, height, depth, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexImage3DARB)(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexImage3DARB, (target, level, internalformat, width, height, depth, border, imageSize, data), (F, "glCompressedTexImage3DARB(0x%x, %d, 0x%x, %d, %d, %d, %d, %d, %p);\n", target, level, internalformat, width, height, depth, border, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage1D)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage1DARB, (target, level, xoffset, width, format, imageSize, data), (F, "glCompressedTexSubImage1D(0x%x, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, width, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage1DARB)(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage1DARB, (target, level, xoffset, width, format, imageSize, data), (F, "glCompressedTexSubImage1DARB(0x%x, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, width, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage2D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage2DARB, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (F, "glCompressedTexSubImage2D(0x%x, %d, %d, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, yoffset, width, height, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage2DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage2DARB, (target, level, xoffset, yoffset, width, height, format, imageSize, data), (F, "glCompressedTexSubImage2DARB(0x%x, %d, %d, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, yoffset, width, height, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage3D)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage3DARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (F, "glCompressedTexSubImage3D(0x%x, %d, %d, %d, %d, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompressedTexSubImage3DARB)(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data)
+{
+   DISPATCH(CompressedTexSubImage3DARB, (target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data), (F, "glCompressedTexSubImage3DARB(0x%x, %d, %d, %d, %d, %d, %d, %d, 0x%x, %d, %p);\n", target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCompressedTexImage)(GLenum target, GLint level, GLvoid * img)
+{
+   DISPATCH(GetCompressedTexImageARB, (target, level, img), (F, "glGetCompressedTexImage(0x%x, %d, %p);\n", target, level, (const void *) img));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCompressedTexImageARB)(GLenum target, GLint level, GLvoid * img)
+{
+   DISPATCH(GetCompressedTexImageARB, (target, level, img), (F, "glGetCompressedTexImageARB(0x%x, %d, %p);\n", target, level, (const void *) img));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DisableVertexAttribArray)(GLuint index)
+{
+   DISPATCH(DisableVertexAttribArrayARB, (index), (F, "glDisableVertexAttribArray(%d);\n", index));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DisableVertexAttribArrayARB)(GLuint index)
+{
+   DISPATCH(DisableVertexAttribArrayARB, (index), (F, "glDisableVertexAttribArrayARB(%d);\n", index));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EnableVertexAttribArray)(GLuint index)
+{
+   DISPATCH(EnableVertexAttribArrayARB, (index), (F, "glEnableVertexAttribArray(%d);\n", index));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EnableVertexAttribArrayARB)(GLuint index)
+{
+   DISPATCH(EnableVertexAttribArrayARB, (index), (F, "glEnableVertexAttribArrayARB(%d);\n", index));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramEnvParameterdvARB)(GLenum target, GLuint index, GLdouble * params)
+{
+   DISPATCH(GetProgramEnvParameterdvARB, (target, index, params), (F, "glGetProgramEnvParameterdvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramEnvParameterfvARB)(GLenum target, GLuint index, GLfloat * params)
+{
+   DISPATCH(GetProgramEnvParameterfvARB, (target, index, params), (F, "glGetProgramEnvParameterfvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramLocalParameterdvARB)(GLenum target, GLuint index, GLdouble * params)
+{
+   DISPATCH(GetProgramLocalParameterdvARB, (target, index, params), (F, "glGetProgramLocalParameterdvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramLocalParameterfvARB)(GLenum target, GLuint index, GLfloat * params)
+{
+   DISPATCH(GetProgramLocalParameterfvARB, (target, index, params), (F, "glGetProgramLocalParameterfvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramStringARB)(GLenum target, GLenum pname, GLvoid * string)
+{
+   DISPATCH(GetProgramStringARB, (target, pname, string), (F, "glGetProgramStringARB(0x%x, 0x%x, %p);\n", target, pname, (const void *) string));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramivARB)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetProgramivARB, (target, pname, params), (F, "glGetProgramivARB(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribdv)(GLuint index, GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetVertexAttribdvARB, (index, pname, params), (F, "glGetVertexAttribdv(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribdvARB)(GLuint index, GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetVertexAttribdvARB, (index, pname, params), (F, "glGetVertexAttribdvARB(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribfv)(GLuint index, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetVertexAttribfvARB, (index, pname, params), (F, "glGetVertexAttribfv(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribfvARB)(GLuint index, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetVertexAttribfvARB, (index, pname, params), (F, "glGetVertexAttribfvARB(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribiv)(GLuint index, GLenum pname, GLint * params)
+{
+   DISPATCH(GetVertexAttribivARB, (index, pname, params), (F, "glGetVertexAttribiv(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribivARB)(GLuint index, GLenum pname, GLint * params)
+{
+   DISPATCH(GetVertexAttribivARB, (index, pname, params), (F, "glGetVertexAttribivARB(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramEnvParameter4dARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(ProgramEnvParameter4dARB, (target, index, x, y, z, w), (F, "glProgramEnvParameter4dARB(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameter4dNV)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(ProgramEnvParameter4dARB, (target, index, x, y, z, w), (F, "glProgramParameter4dNV(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramEnvParameter4dvARB)(GLenum target, GLuint index, const GLdouble * params)
+{
+   DISPATCH(ProgramEnvParameter4dvARB, (target, index, params), (F, "glProgramEnvParameter4dvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameter4dvNV)(GLenum target, GLuint index, const GLdouble * params)
+{
+   DISPATCH(ProgramEnvParameter4dvARB, (target, index, params), (F, "glProgramParameter4dvNV(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramEnvParameter4fARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(ProgramEnvParameter4fARB, (target, index, x, y, z, w), (F, "glProgramEnvParameter4fARB(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameter4fNV)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(ProgramEnvParameter4fARB, (target, index, x, y, z, w), (F, "glProgramParameter4fNV(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramEnvParameter4fvARB)(GLenum target, GLuint index, const GLfloat * params)
+{
+   DISPATCH(ProgramEnvParameter4fvARB, (target, index, params), (F, "glProgramEnvParameter4fvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameter4fvNV)(GLenum target, GLuint index, const GLfloat * params)
+{
+   DISPATCH(ProgramEnvParameter4fvARB, (target, index, params), (F, "glProgramParameter4fvNV(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramLocalParameter4dARB)(GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(ProgramLocalParameter4dARB, (target, index, x, y, z, w), (F, "glProgramLocalParameter4dARB(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramLocalParameter4dvARB)(GLenum target, GLuint index, const GLdouble * params)
+{
+   DISPATCH(ProgramLocalParameter4dvARB, (target, index, params), (F, "glProgramLocalParameter4dvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramLocalParameter4fARB)(GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(ProgramLocalParameter4fARB, (target, index, x, y, z, w), (F, "glProgramLocalParameter4fARB(0x%x, %d, %f, %f, %f, %f);\n", target, index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramLocalParameter4fvARB)(GLenum target, GLuint index, const GLfloat * params)
+{
+   DISPATCH(ProgramLocalParameter4fvARB, (target, index, params), (F, "glProgramLocalParameter4fvARB(0x%x, %d, %p);\n", target, index, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramStringARB)(GLenum target, GLenum format, GLsizei len, const GLvoid * string)
+{
+   DISPATCH(ProgramStringARB, (target, format, len, string), (F, "glProgramStringARB(0x%x, 0x%x, %d, %p);\n", target, format, len, (const void *) string));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1d)(GLuint index, GLdouble x)
+{
+   DISPATCH(VertexAttrib1dARB, (index, x), (F, "glVertexAttrib1d(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1dARB)(GLuint index, GLdouble x)
+{
+   DISPATCH(VertexAttrib1dARB, (index, x), (F, "glVertexAttrib1dARB(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1dv)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib1dvARB, (index, v), (F, "glVertexAttrib1dv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1dvARB)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib1dvARB, (index, v), (F, "glVertexAttrib1dvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1f)(GLuint index, GLfloat x)
+{
+   DISPATCH(VertexAttrib1fARB, (index, x), (F, "glVertexAttrib1f(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1fARB)(GLuint index, GLfloat x)
+{
+   DISPATCH(VertexAttrib1fARB, (index, x), (F, "glVertexAttrib1fARB(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1fv)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib1fvARB, (index, v), (F, "glVertexAttrib1fv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1fvARB)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib1fvARB, (index, v), (F, "glVertexAttrib1fvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1s)(GLuint index, GLshort x)
+{
+   DISPATCH(VertexAttrib1sARB, (index, x), (F, "glVertexAttrib1s(%d, %d);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1sARB)(GLuint index, GLshort x)
+{
+   DISPATCH(VertexAttrib1sARB, (index, x), (F, "glVertexAttrib1sARB(%d, %d);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1sv)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib1svARB, (index, v), (F, "glVertexAttrib1sv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1svARB)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib1svARB, (index, v), (F, "glVertexAttrib1svARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2d)(GLuint index, GLdouble x, GLdouble y)
+{
+   DISPATCH(VertexAttrib2dARB, (index, x, y), (F, "glVertexAttrib2d(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2dARB)(GLuint index, GLdouble x, GLdouble y)
+{
+   DISPATCH(VertexAttrib2dARB, (index, x, y), (F, "glVertexAttrib2dARB(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2dv)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib2dvARB, (index, v), (F, "glVertexAttrib2dv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2dvARB)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib2dvARB, (index, v), (F, "glVertexAttrib2dvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2f)(GLuint index, GLfloat x, GLfloat y)
+{
+   DISPATCH(VertexAttrib2fARB, (index, x, y), (F, "glVertexAttrib2f(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2fARB)(GLuint index, GLfloat x, GLfloat y)
+{
+   DISPATCH(VertexAttrib2fARB, (index, x, y), (F, "glVertexAttrib2fARB(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2fv)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib2fvARB, (index, v), (F, "glVertexAttrib2fv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2fvARB)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib2fvARB, (index, v), (F, "glVertexAttrib2fvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2s)(GLuint index, GLshort x, GLshort y)
+{
+   DISPATCH(VertexAttrib2sARB, (index, x, y), (F, "glVertexAttrib2s(%d, %d, %d);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2sARB)(GLuint index, GLshort x, GLshort y)
+{
+   DISPATCH(VertexAttrib2sARB, (index, x, y), (F, "glVertexAttrib2sARB(%d, %d, %d);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2sv)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib2svARB, (index, v), (F, "glVertexAttrib2sv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2svARB)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib2svARB, (index, v), (F, "glVertexAttrib2svARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3d)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(VertexAttrib3dARB, (index, x, y, z), (F, "glVertexAttrib3d(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3dARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(VertexAttrib3dARB, (index, x, y, z), (F, "glVertexAttrib3dARB(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3dv)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib3dvARB, (index, v), (F, "glVertexAttrib3dv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3dvARB)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib3dvARB, (index, v), (F, "glVertexAttrib3dvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3f)(GLuint index, GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(VertexAttrib3fARB, (index, x, y, z), (F, "glVertexAttrib3f(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3fARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(VertexAttrib3fARB, (index, x, y, z), (F, "glVertexAttrib3fARB(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3fv)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib3fvARB, (index, v), (F, "glVertexAttrib3fv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3fvARB)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib3fvARB, (index, v), (F, "glVertexAttrib3fvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3s)(GLuint index, GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(VertexAttrib3sARB, (index, x, y, z), (F, "glVertexAttrib3s(%d, %d, %d, %d);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3sARB)(GLuint index, GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(VertexAttrib3sARB, (index, x, y, z), (F, "glVertexAttrib3sARB(%d, %d, %d, %d);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3sv)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib3svARB, (index, v), (F, "glVertexAttrib3sv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3svARB)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib3svARB, (index, v), (F, "glVertexAttrib3svARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nbv)(GLuint index, const GLbyte * v)
+{
+   DISPATCH(VertexAttrib4NbvARB, (index, v), (F, "glVertexAttrib4Nbv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NbvARB)(GLuint index, const GLbyte * v)
+{
+   DISPATCH(VertexAttrib4NbvARB, (index, v), (F, "glVertexAttrib4NbvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Niv)(GLuint index, const GLint * v)
+{
+   DISPATCH(VertexAttrib4NivARB, (index, v), (F, "glVertexAttrib4Niv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NivARB)(GLuint index, const GLint * v)
+{
+   DISPATCH(VertexAttrib4NivARB, (index, v), (F, "glVertexAttrib4NivARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nsv)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib4NsvARB, (index, v), (F, "glVertexAttrib4Nsv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NsvARB)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib4NsvARB, (index, v), (F, "glVertexAttrib4NsvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nub)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
+{
+   DISPATCH(VertexAttrib4NubARB, (index, x, y, z, w), (F, "glVertexAttrib4Nub(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NubARB)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
+{
+   DISPATCH(VertexAttrib4NubARB, (index, x, y, z, w), (F, "glVertexAttrib4NubARB(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nubv)(GLuint index, const GLubyte * v)
+{
+   DISPATCH(VertexAttrib4NubvARB, (index, v), (F, "glVertexAttrib4Nubv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NubvARB)(GLuint index, const GLubyte * v)
+{
+   DISPATCH(VertexAttrib4NubvARB, (index, v), (F, "glVertexAttrib4NubvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nuiv)(GLuint index, const GLuint * v)
+{
+   DISPATCH(VertexAttrib4NuivARB, (index, v), (F, "glVertexAttrib4Nuiv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NuivARB)(GLuint index, const GLuint * v)
+{
+   DISPATCH(VertexAttrib4NuivARB, (index, v), (F, "glVertexAttrib4NuivARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4Nusv)(GLuint index, const GLushort * v)
+{
+   DISPATCH(VertexAttrib4NusvARB, (index, v), (F, "glVertexAttrib4Nusv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4NusvARB)(GLuint index, const GLushort * v)
+{
+   DISPATCH(VertexAttrib4NusvARB, (index, v), (F, "glVertexAttrib4NusvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4bv)(GLuint index, const GLbyte * v)
+{
+   DISPATCH(VertexAttrib4bvARB, (index, v), (F, "glVertexAttrib4bv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4bvARB)(GLuint index, const GLbyte * v)
+{
+   DISPATCH(VertexAttrib4bvARB, (index, v), (F, "glVertexAttrib4bvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4d)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(VertexAttrib4dARB, (index, x, y, z, w), (F, "glVertexAttrib4d(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4dARB)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(VertexAttrib4dARB, (index, x, y, z, w), (F, "glVertexAttrib4dARB(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4dv)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib4dvARB, (index, v), (F, "glVertexAttrib4dv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4dvARB)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib4dvARB, (index, v), (F, "glVertexAttrib4dvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4f)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(VertexAttrib4fARB, (index, x, y, z, w), (F, "glVertexAttrib4f(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4fARB)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(VertexAttrib4fARB, (index, x, y, z, w), (F, "glVertexAttrib4fARB(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4fv)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib4fvARB, (index, v), (F, "glVertexAttrib4fv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4fvARB)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib4fvARB, (index, v), (F, "glVertexAttrib4fvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4iv)(GLuint index, const GLint * v)
+{
+   DISPATCH(VertexAttrib4ivARB, (index, v), (F, "glVertexAttrib4iv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4ivARB)(GLuint index, const GLint * v)
+{
+   DISPATCH(VertexAttrib4ivARB, (index, v), (F, "glVertexAttrib4ivARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4s)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(VertexAttrib4sARB, (index, x, y, z, w), (F, "glVertexAttrib4s(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4sARB)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(VertexAttrib4sARB, (index, x, y, z, w), (F, "glVertexAttrib4sARB(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4sv)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib4svARB, (index, v), (F, "glVertexAttrib4sv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4svARB)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib4svARB, (index, v), (F, "glVertexAttrib4svARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4ubv)(GLuint index, const GLubyte * v)
+{
+   DISPATCH(VertexAttrib4ubvARB, (index, v), (F, "glVertexAttrib4ubv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4ubvARB)(GLuint index, const GLubyte * v)
+{
+   DISPATCH(VertexAttrib4ubvARB, (index, v), (F, "glVertexAttrib4ubvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4uiv)(GLuint index, const GLuint * v)
+{
+   DISPATCH(VertexAttrib4uivARB, (index, v), (F, "glVertexAttrib4uiv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4uivARB)(GLuint index, const GLuint * v)
+{
+   DISPATCH(VertexAttrib4uivARB, (index, v), (F, "glVertexAttrib4uivARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4usv)(GLuint index, const GLushort * v)
+{
+   DISPATCH(VertexAttrib4usvARB, (index, v), (F, "glVertexAttrib4usv(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4usvARB)(GLuint index, const GLushort * v)
+{
+   DISPATCH(VertexAttrib4usvARB, (index, v), (F, "glVertexAttrib4usvARB(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribPointer)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(VertexAttribPointerARB, (index, size, type, normalized, stride, pointer), (F, "glVertexAttribPointer(%d, %d, 0x%x, %d, %d, %p);\n", index, size, type, normalized, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribPointerARB)(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(VertexAttribPointerARB, (index, size, type, normalized, stride, pointer), (F, "glVertexAttribPointerARB(%d, %d, 0x%x, %d, %d, %p);\n", index, size, type, normalized, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindBuffer)(GLenum target, GLuint buffer)
+{
+   DISPATCH(BindBufferARB, (target, buffer), (F, "glBindBuffer(0x%x, %d);\n", target, buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindBufferARB)(GLenum target, GLuint buffer)
+{
+   DISPATCH(BindBufferARB, (target, buffer), (F, "glBindBufferARB(0x%x, %d);\n", target, buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BufferData)(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage)
+{
+   DISPATCH(BufferDataARB, (target, size, data, usage), (F, "glBufferData(0x%x, %d, %p, 0x%x);\n", target, size, (const void *) data, usage));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BufferDataARB)(GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage)
+{
+   DISPATCH(BufferDataARB, (target, size, data, usage), (F, "glBufferDataARB(0x%x, %d, %p, 0x%x);\n", target, size, (const void *) data, usage));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data)
+{
+   DISPATCH(BufferSubDataARB, (target, offset, size, data), (F, "glBufferSubData(0x%x, %d, %d, %p);\n", target, offset, size, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BufferSubDataARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data)
+{
+   DISPATCH(BufferSubDataARB, (target, offset, size, data), (F, "glBufferSubDataARB(0x%x, %d, %d, %p);\n", target, offset, size, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteBuffers)(GLsizei n, const GLuint * buffer)
+{
+   DISPATCH(DeleteBuffersARB, (n, buffer), (F, "glDeleteBuffers(%d, %p);\n", n, (const void *) buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteBuffersARB)(GLsizei n, const GLuint * buffer)
+{
+   DISPATCH(DeleteBuffersARB, (n, buffer), (F, "glDeleteBuffersARB(%d, %p);\n", n, (const void *) buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenBuffers)(GLsizei n, GLuint * buffer)
+{
+   DISPATCH(GenBuffersARB, (n, buffer), (F, "glGenBuffers(%d, %p);\n", n, (const void *) buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenBuffersARB)(GLsizei n, GLuint * buffer)
+{
+   DISPATCH(GenBuffersARB, (n, buffer), (F, "glGenBuffersARB(%d, %p);\n", n, (const void *) buffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferParameteriv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetBufferParameterivARB, (target, pname, params), (F, "glGetBufferParameteriv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferParameterivARB)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetBufferParameterivARB, (target, pname, params), (F, "glGetBufferParameterivARB(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferPointerv)(GLenum target, GLenum pname, GLvoid ** params)
+{
+   DISPATCH(GetBufferPointervARB, (target, pname, params), (F, "glGetBufferPointerv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferPointervARB)(GLenum target, GLenum pname, GLvoid ** params)
+{
+   DISPATCH(GetBufferPointervARB, (target, pname, params), (F, "glGetBufferPointervARB(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferSubData)(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data)
+{
+   DISPATCH(GetBufferSubDataARB, (target, offset, size, data), (F, "glGetBufferSubData(0x%x, %d, %d, %p);\n", target, offset, size, (const void *) data));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetBufferSubDataARB)(GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data)
+{
+   DISPATCH(GetBufferSubDataARB, (target, offset, size, data), (F, "glGetBufferSubDataARB(0x%x, %d, %d, %p);\n", target, offset, size, (const void *) data));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsBuffer)(GLuint buffer)
+{
+   RETURN_DISPATCH(IsBufferARB, (buffer), (F, "glIsBuffer(%d);\n", buffer));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsBufferARB)(GLuint buffer)
+{
+   RETURN_DISPATCH(IsBufferARB, (buffer), (F, "glIsBufferARB(%d);\n", buffer));
+}
+
+KEYWORD1 GLvoid * KEYWORD2 NAME(MapBuffer)(GLenum target, GLenum access)
+{
+   RETURN_DISPATCH(MapBufferARB, (target, access), (F, "glMapBuffer(0x%x, 0x%x);\n", target, access));
+}
+
+KEYWORD1 GLvoid * KEYWORD2 NAME(MapBufferARB)(GLenum target, GLenum access)
+{
+   RETURN_DISPATCH(MapBufferARB, (target, access), (F, "glMapBufferARB(0x%x, 0x%x);\n", target, access));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(UnmapBuffer)(GLenum target)
+{
+   RETURN_DISPATCH(UnmapBufferARB, (target), (F, "glUnmapBuffer(0x%x);\n", target));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(UnmapBufferARB)(GLenum target)
+{
+   RETURN_DISPATCH(UnmapBufferARB, (target), (F, "glUnmapBufferARB(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BeginQuery)(GLenum target, GLuint id)
+{
+   DISPATCH(BeginQueryARB, (target, id), (F, "glBeginQuery(0x%x, %d);\n", target, id));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BeginQueryARB)(GLenum target, GLuint id)
+{
+   DISPATCH(BeginQueryARB, (target, id), (F, "glBeginQueryARB(0x%x, %d);\n", target, id));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteQueries)(GLsizei n, const GLuint * ids)
+{
+   DISPATCH(DeleteQueriesARB, (n, ids), (F, "glDeleteQueries(%d, %p);\n", n, (const void *) ids));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteQueriesARB)(GLsizei n, const GLuint * ids)
+{
+   DISPATCH(DeleteQueriesARB, (n, ids), (F, "glDeleteQueriesARB(%d, %p);\n", n, (const void *) ids));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EndQuery)(GLenum target)
+{
+   DISPATCH(EndQueryARB, (target), (F, "glEndQuery(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EndQueryARB)(GLenum target)
+{
+   DISPATCH(EndQueryARB, (target), (F, "glEndQueryARB(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenQueries)(GLsizei n, GLuint * ids)
+{
+   DISPATCH(GenQueriesARB, (n, ids), (F, "glGenQueries(%d, %p);\n", n, (const void *) ids));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenQueriesARB)(GLsizei n, GLuint * ids)
+{
+   DISPATCH(GenQueriesARB, (n, ids), (F, "glGenQueriesARB(%d, %p);\n", n, (const void *) ids));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryObjectiv)(GLuint id, GLenum pname, GLint * params)
+{
+   DISPATCH(GetQueryObjectivARB, (id, pname, params), (F, "glGetQueryObjectiv(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryObjectivARB)(GLuint id, GLenum pname, GLint * params)
+{
+   DISPATCH(GetQueryObjectivARB, (id, pname, params), (F, "glGetQueryObjectivARB(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryObjectuiv)(GLuint id, GLenum pname, GLuint * params)
+{
+   DISPATCH(GetQueryObjectuivARB, (id, pname, params), (F, "glGetQueryObjectuiv(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryObjectuivARB)(GLuint id, GLenum pname, GLuint * params)
+{
+   DISPATCH(GetQueryObjectuivARB, (id, pname, params), (F, "glGetQueryObjectuivARB(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryiv)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetQueryivARB, (target, pname, params), (F, "glGetQueryiv(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetQueryivARB)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetQueryivARB, (target, pname, params), (F, "glGetQueryivARB(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsQuery)(GLuint id)
+{
+   RETURN_DISPATCH(IsQueryARB, (id), (F, "glIsQuery(%d);\n", id));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsQueryARB)(GLuint id)
+{
+   RETURN_DISPATCH(IsQueryARB, (id), (F, "glIsQueryARB(%d);\n", id));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AttachObjectARB)(GLhandleARB containerObj, GLhandleARB obj)
+{
+   DISPATCH(AttachObjectARB, (containerObj, obj), (F, "glAttachObjectARB(%d, %d);\n", containerObj, obj));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompileShader)(GLuint shader)
+{
+   DISPATCH(CompileShaderARB, (shader), (F, "glCompileShader(%d);\n", shader));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CompileShaderARB)(GLhandleARB shader)
+{
+   DISPATCH(CompileShaderARB, (shader), (F, "glCompileShaderARB(%d);\n", shader));
+}
+
+KEYWORD1 GLhandleARB KEYWORD2 NAME(CreateProgramObjectARB)(void)
+{
+   RETURN_DISPATCH(CreateProgramObjectARB, (), (F, "glCreateProgramObjectARB();\n"));
+}
+
+KEYWORD1 GLhandleARB KEYWORD2 NAME(CreateShaderObjectARB)(GLenum shaderType)
+{
+   RETURN_DISPATCH(CreateShaderObjectARB, (shaderType), (F, "glCreateShaderObjectARB(0x%x);\n", shaderType));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteObjectARB)(GLhandleARB obj)
+{
+   DISPATCH(DeleteObjectARB, (obj), (F, "glDeleteObjectARB(%d);\n", obj));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DetachObjectARB)(GLhandleARB containerObj, GLhandleARB attachedObj)
+{
+   DISPATCH(DetachObjectARB, (containerObj, attachedObj), (F, "glDetachObjectARB(%d, %d);\n", containerObj, attachedObj));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetActiveUniform)(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
+{
+   DISPATCH(GetActiveUniformARB, (program, index, bufSize, length, size, type, name), (F, "glGetActiveUniform(%d, %d, %d, %p, %p, %p, %p);\n", program, index, bufSize, (const void *) length, (const void *) size, (const void *) type, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetActiveUniformARB)(GLhandleARB program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name)
+{
+   DISPATCH(GetActiveUniformARB, (program, index, bufSize, length, size, type, name), (F, "glGetActiveUniformARB(%d, %d, %d, %p, %p, %p, %p);\n", program, index, bufSize, (const void *) length, (const void *) size, (const void *) type, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetAttachedObjectsARB)(GLhandleARB containerObj, GLsizei maxLength, GLsizei * length, GLhandleARB * infoLog)
+{
+   DISPATCH(GetAttachedObjectsARB, (containerObj, maxLength, length, infoLog), (F, "glGetAttachedObjectsARB(%d, %d, %p, %p);\n", containerObj, maxLength, (const void *) length, (const void *) infoLog));
+}
+
+KEYWORD1 GLhandleARB KEYWORD2 NAME(GetHandleARB)(GLenum pname)
+{
+   RETURN_DISPATCH(GetHandleARB, (pname), (F, "glGetHandleARB(0x%x);\n", pname));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetInfoLogARB)(GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog)
+{
+   DISPATCH(GetInfoLogARB, (obj, maxLength, length, infoLog), (F, "glGetInfoLogARB(%d, %d, %p, %p);\n", obj, maxLength, (const void *) length, (const void *) infoLog));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetObjectParameterfvARB)(GLhandleARB obj, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetObjectParameterfvARB, (obj, pname, params), (F, "glGetObjectParameterfvARB(%d, 0x%x, %p);\n", obj, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetObjectParameterivARB)(GLhandleARB obj, GLenum pname, GLint * params)
+{
+   DISPATCH(GetObjectParameterivARB, (obj, pname, params), (F, "glGetObjectParameterivARB(%d, 0x%x, %p);\n", obj, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetShaderSource)(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source)
+{
+   DISPATCH(GetShaderSourceARB, (shader, bufSize, length, source), (F, "glGetShaderSource(%d, %d, %p, %p);\n", shader, bufSize, (const void *) length, (const void *) source));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetShaderSourceARB)(GLhandleARB shader, GLsizei bufSize, GLsizei * length, GLcharARB * source)
+{
+   DISPATCH(GetShaderSourceARB, (shader, bufSize, length, source), (F, "glGetShaderSourceARB(%d, %d, %p, %p);\n", shader, bufSize, (const void *) length, (const void *) source));
+}
+
+KEYWORD1 GLint KEYWORD2 NAME(GetUniformLocation)(GLuint program, const GLchar * name)
+{
+   RETURN_DISPATCH(GetUniformLocationARB, (program, name), (F, "glGetUniformLocation(%d, %p);\n", program, (const void *) name));
+}
+
+KEYWORD1 GLint KEYWORD2 NAME(GetUniformLocationARB)(GLhandleARB program, const GLcharARB * name)
+{
+   RETURN_DISPATCH(GetUniformLocationARB, (program, name), (F, "glGetUniformLocationARB(%d, %p);\n", program, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetUniformfv)(GLuint program, GLint location, GLfloat * params)
+{
+   DISPATCH(GetUniformfvARB, (program, location, params), (F, "glGetUniformfv(%d, %d, %p);\n", program, location, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetUniformfvARB)(GLhandleARB program, GLint location, GLfloat * params)
+{
+   DISPATCH(GetUniformfvARB, (program, location, params), (F, "glGetUniformfvARB(%d, %d, %p);\n", program, location, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetUniformiv)(GLuint program, GLint location, GLint * params)
+{
+   DISPATCH(GetUniformivARB, (program, location, params), (F, "glGetUniformiv(%d, %d, %p);\n", program, location, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetUniformivARB)(GLhandleARB program, GLint location, GLint * params)
+{
+   DISPATCH(GetUniformivARB, (program, location, params), (F, "glGetUniformivARB(%d, %d, %p);\n", program, location, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LinkProgram)(GLuint program)
+{
+   DISPATCH(LinkProgramARB, (program), (F, "glLinkProgram(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LinkProgramARB)(GLhandleARB program)
+{
+   DISPATCH(LinkProgramARB, (program), (F, "glLinkProgramARB(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ShaderSource)(GLuint shader, GLsizei count, const GLchar ** string, const GLint * length)
+{
+   DISPATCH(ShaderSourceARB, (shader, count, string, length), (F, "glShaderSource(%d, %d, %p, %p);\n", shader, count, (const void *) string, (const void *) length));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ShaderSourceARB)(GLhandleARB shader, GLsizei count, const GLcharARB ** string, const GLint * length)
+{
+   DISPATCH(ShaderSourceARB, (shader, count, string, length), (F, "glShaderSourceARB(%d, %d, %p, %p);\n", shader, count, (const void *) string, (const void *) length));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1f)(GLint location, GLfloat v0)
+{
+   DISPATCH(Uniform1fARB, (location, v0), (F, "glUniform1f(%d, %f);\n", location, v0));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1fARB)(GLint location, GLfloat v0)
+{
+   DISPATCH(Uniform1fARB, (location, v0), (F, "glUniform1fARB(%d, %f);\n", location, v0));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1fv)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform1fvARB, (location, count, value), (F, "glUniform1fv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1fvARB)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform1fvARB, (location, count, value), (F, "glUniform1fvARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1i)(GLint location, GLint v0)
+{
+   DISPATCH(Uniform1iARB, (location, v0), (F, "glUniform1i(%d, %d);\n", location, v0));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1iARB)(GLint location, GLint v0)
+{
+   DISPATCH(Uniform1iARB, (location, v0), (F, "glUniform1iARB(%d, %d);\n", location, v0));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1iv)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform1ivARB, (location, count, value), (F, "glUniform1iv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform1ivARB)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform1ivARB, (location, count, value), (F, "glUniform1ivARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2f)(GLint location, GLfloat v0, GLfloat v1)
+{
+   DISPATCH(Uniform2fARB, (location, v0, v1), (F, "glUniform2f(%d, %f, %f);\n", location, v0, v1));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2fARB)(GLint location, GLfloat v0, GLfloat v1)
+{
+   DISPATCH(Uniform2fARB, (location, v0, v1), (F, "glUniform2fARB(%d, %f, %f);\n", location, v0, v1));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2fv)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform2fvARB, (location, count, value), (F, "glUniform2fv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2fvARB)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform2fvARB, (location, count, value), (F, "glUniform2fvARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2i)(GLint location, GLint v0, GLint v1)
+{
+   DISPATCH(Uniform2iARB, (location, v0, v1), (F, "glUniform2i(%d, %d, %d);\n", location, v0, v1));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2iARB)(GLint location, GLint v0, GLint v1)
+{
+   DISPATCH(Uniform2iARB, (location, v0, v1), (F, "glUniform2iARB(%d, %d, %d);\n", location, v0, v1));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2iv)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform2ivARB, (location, count, value), (F, "glUniform2iv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform2ivARB)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform2ivARB, (location, count, value), (F, "glUniform2ivARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
+{
+   DISPATCH(Uniform3fARB, (location, v0, v1, v2), (F, "glUniform3f(%d, %f, %f, %f);\n", location, v0, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3fARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
+{
+   DISPATCH(Uniform3fARB, (location, v0, v1, v2), (F, "glUniform3fARB(%d, %f, %f, %f);\n", location, v0, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3fv)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform3fvARB, (location, count, value), (F, "glUniform3fv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3fvARB)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform3fvARB, (location, count, value), (F, "glUniform3fvARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3i)(GLint location, GLint v0, GLint v1, GLint v2)
+{
+   DISPATCH(Uniform3iARB, (location, v0, v1, v2), (F, "glUniform3i(%d, %d, %d, %d);\n", location, v0, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3iARB)(GLint location, GLint v0, GLint v1, GLint v2)
+{
+   DISPATCH(Uniform3iARB, (location, v0, v1, v2), (F, "glUniform3iARB(%d, %d, %d, %d);\n", location, v0, v1, v2));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3iv)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform3ivARB, (location, count, value), (F, "glUniform3iv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform3ivARB)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform3ivARB, (location, count, value), (F, "glUniform3ivARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4f)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
+{
+   DISPATCH(Uniform4fARB, (location, v0, v1, v2, v3), (F, "glUniform4f(%d, %f, %f, %f, %f);\n", location, v0, v1, v2, v3));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4fARB)(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
+{
+   DISPATCH(Uniform4fARB, (location, v0, v1, v2, v3), (F, "glUniform4fARB(%d, %f, %f, %f, %f);\n", location, v0, v1, v2, v3));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4fv)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform4fvARB, (location, count, value), (F, "glUniform4fv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4fvARB)(GLint location, GLsizei count, const GLfloat * value)
+{
+   DISPATCH(Uniform4fvARB, (location, count, value), (F, "glUniform4fvARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4i)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+   DISPATCH(Uniform4iARB, (location, v0, v1, v2, v3), (F, "glUniform4i(%d, %d, %d, %d, %d);\n", location, v0, v1, v2, v3));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4iARB)(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
+{
+   DISPATCH(Uniform4iARB, (location, v0, v1, v2, v3), (F, "glUniform4iARB(%d, %d, %d, %d, %d);\n", location, v0, v1, v2, v3));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4iv)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform4ivARB, (location, count, value), (F, "glUniform4iv(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(Uniform4ivARB)(GLint location, GLsizei count, const GLint * value)
+{
+   DISPATCH(Uniform4ivARB, (location, count, value), (F, "glUniform4ivARB(%d, %d, %p);\n", location, count, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix2fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix2fvARB, (location, count, transpose, value), (F, "glUniformMatrix2fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix2fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix2fvARB, (location, count, transpose, value), (F, "glUniformMatrix2fvARB(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix3fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix3fvARB, (location, count, transpose, value), (F, "glUniformMatrix3fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix3fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix3fvARB, (location, count, transpose, value), (F, "glUniformMatrix3fvARB(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix4fv)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix4fvARB, (location, count, transpose, value), (F, "glUniformMatrix4fv(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UniformMatrix4fvARB)(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
+{
+   DISPATCH(UniformMatrix4fvARB, (location, count, transpose, value), (F, "glUniformMatrix4fvARB(%d, %d, %d, %p);\n", location, count, transpose, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UseProgram)(GLuint program)
+{
+   DISPATCH(UseProgramObjectARB, (program), (F, "glUseProgram(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UseProgramObjectARB)(GLhandleARB program)
+{
+   DISPATCH(UseProgramObjectARB, (program), (F, "glUseProgramObjectARB(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ValidateProgram)(GLuint program)
+{
+   DISPATCH(ValidateProgramARB, (program), (F, "glValidateProgram(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ValidateProgramARB)(GLhandleARB program)
+{
+   DISPATCH(ValidateProgramARB, (program), (F, "glValidateProgramARB(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindAttribLocation)(GLuint program, GLuint index, const GLchar * name)
+{
+   DISPATCH(BindAttribLocationARB, (program, index, name), (F, "glBindAttribLocation(%d, %d, %p);\n", program, index, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindAttribLocationARB)(GLhandleARB program, GLuint index, const GLcharARB * name)
+{
+   DISPATCH(BindAttribLocationARB, (program, index, name), (F, "glBindAttribLocationARB(%d, %d, %p);\n", program, index, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetActiveAttrib)(GLuint program, GLuint index, GLsizei  bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
+{
+   DISPATCH(GetActiveAttribARB, (program, index, bufSize, length, size, type, name), (F, "glGetActiveAttrib(%d, %d, %d, %p, %p, %p, %p);\n", program, index, bufSize, (const void *) length, (const void *) size, (const void *) type, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetActiveAttribARB)(GLhandleARB program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name)
+{
+   DISPATCH(GetActiveAttribARB, (program, index, bufSize, length, size, type, name), (F, "glGetActiveAttribARB(%d, %d, %d, %p, %p, %p, %p);\n", program, index, bufSize, (const void *) length, (const void *) size, (const void *) type, (const void *) name));
+}
+
+KEYWORD1 GLint KEYWORD2 NAME(GetAttribLocation)(GLuint program, const GLchar * name)
+{
+   RETURN_DISPATCH(GetAttribLocationARB, (program, name), (F, "glGetAttribLocation(%d, %p);\n", program, (const void *) name));
+}
+
+KEYWORD1 GLint KEYWORD2 NAME(GetAttribLocationARB)(GLhandleARB program, const GLcharARB * name)
+{
+   RETURN_DISPATCH(GetAttribLocationARB, (program, name), (F, "glGetAttribLocationARB(%d, %p);\n", program, (const void *) name));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawBuffers)(GLsizei n, const GLenum * bufs)
+{
+   DISPATCH(DrawBuffersARB, (n, bufs), (F, "glDrawBuffers(%d, %p);\n", n, (const void *) bufs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawBuffersARB)(GLsizei n, const GLenum * bufs)
+{
+   DISPATCH(DrawBuffersARB, (n, bufs), (F, "glDrawBuffersARB(%d, %p);\n", n, (const void *) bufs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DrawBuffersATI)(GLsizei n, const GLenum * bufs)
+{
+   DISPATCH(DrawBuffersARB, (n, bufs), (F, "glDrawBuffersATI(%d, %p);\n", n, (const void *) bufs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PolygonOffsetEXT)(GLfloat factor, GLfloat bias)
+{
+   DISPATCH(PolygonOffsetEXT, (factor, bias), (F, "glPolygonOffsetEXT(%f, %f);\n", factor, bias));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_562)(GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_562)(GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetPixelTexGenParameterfvSGIS, (pname, params), (F, "glGetPixelTexGenParameterfvSGIS(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_563)(GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_563)(GLenum pname, GLint * params)
+{
+   DISPATCH(GetPixelTexGenParameterivSGIS, (pname, params), (F, "glGetPixelTexGenParameterivSGIS(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_564)(GLenum pname, GLfloat param);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_564)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PixelTexGenParameterfSGIS, (pname, param), (F, "glPixelTexGenParameterfSGIS(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_565)(GLenum pname, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_565)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(PixelTexGenParameterfvSGIS, (pname, params), (F, "glPixelTexGenParameterfvSGIS(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_566)(GLenum pname, GLint param);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_566)(GLenum pname, GLint param)
+{
+   DISPATCH(PixelTexGenParameteriSGIS, (pname, param), (F, "glPixelTexGenParameteriSGIS(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_567)(GLenum pname, const GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_567)(GLenum pname, const GLint * params)
+{
+   DISPATCH(PixelTexGenParameterivSGIS, (pname, params), (F, "glPixelTexGenParameterivSGIS(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_568)(GLclampf value, GLboolean invert);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_568)(GLclampf value, GLboolean invert)
+{
+   DISPATCH(SampleMaskSGIS, (value, invert), (F, "glSampleMaskSGIS(%f, %d);\n", value, invert));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_569)(GLenum pattern);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_569)(GLenum pattern)
+{
+   DISPATCH(SamplePatternSGIS, (pattern), (F, "glSamplePatternSGIS(0x%x);\n", pattern));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer)
+{
+   DISPATCH(ColorPointerEXT, (size, type, stride, count, pointer), (F, "glColorPointerEXT(%d, 0x%x, %d, %d, %p);\n", size, type, stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EdgeFlagPointerEXT)(GLsizei stride, GLsizei count, const GLboolean * pointer)
+{
+   DISPATCH(EdgeFlagPointerEXT, (stride, count, pointer), (F, "glEdgeFlagPointerEXT(%d, %d, %p);\n", stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(IndexPointerEXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer)
+{
+   DISPATCH(IndexPointerEXT, (type, stride, count, pointer), (F, "glIndexPointerEXT(0x%x, %d, %d, %p);\n", type, stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(NormalPointerEXT)(GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer)
+{
+   DISPATCH(NormalPointerEXT, (type, stride, count, pointer), (F, "glNormalPointerEXT(0x%x, %d, %d, %p);\n", type, stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TexCoordPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer)
+{
+   DISPATCH(TexCoordPointerEXT, (size, type, stride, count, pointer), (F, "glTexCoordPointerEXT(%d, 0x%x, %d, %d, %p);\n", size, type, stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexPointerEXT)(GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer)
+{
+   DISPATCH(VertexPointerEXT, (size, type, stride, count, pointer), (F, "glVertexPointerEXT(%d, 0x%x, %d, %d, %p);\n", size, type, stride, count, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterf)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PointParameterfEXT, (pname, param), (F, "glPointParameterf(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterfARB)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PointParameterfEXT, (pname, param), (F, "glPointParameterfARB(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterfEXT)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PointParameterfEXT, (pname, param), (F, "glPointParameterfEXT(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_576)(GLenum pname, GLfloat param);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_576)(GLenum pname, GLfloat param)
+{
+   DISPATCH(PointParameterfEXT, (pname, param), (F, "glPointParameterfSGIS(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterfv)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(PointParameterfvEXT, (pname, params), (F, "glPointParameterfv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterfvARB)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(PointParameterfvEXT, (pname, params), (F, "glPointParameterfvARB(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterfvEXT)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(PointParameterfvEXT, (pname, params), (F, "glPointParameterfvEXT(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_577)(GLenum pname, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_577)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(PointParameterfvEXT, (pname, params), (F, "glPointParameterfvSGIS(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LockArraysEXT)(GLint first, GLsizei count)
+{
+   DISPATCH(LockArraysEXT, (first, count), (F, "glLockArraysEXT(%d, %d);\n", first, count));
+}
+
+KEYWORD1 void KEYWORD2 NAME(UnlockArraysEXT)(void)
+{
+   DISPATCH(UnlockArraysEXT, (), (F, "glUnlockArraysEXT();\n"));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_580)(GLenum pname, GLdouble * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_580)(GLenum pname, GLdouble * params)
+{
+   DISPATCH(CullParameterdvEXT, (pname, params), (F, "glCullParameterdvEXT(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_581)(GLenum pname, GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_581)(GLenum pname, GLfloat * params)
+{
+   DISPATCH(CullParameterfvEXT, (pname, params), (F, "glCullParameterfvEXT(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3b)(GLbyte red, GLbyte green, GLbyte blue)
+{
+   DISPATCH(SecondaryColor3bEXT, (red, green, blue), (F, "glSecondaryColor3b(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3bEXT)(GLbyte red, GLbyte green, GLbyte blue)
+{
+   DISPATCH(SecondaryColor3bEXT, (red, green, blue), (F, "glSecondaryColor3bEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3bv)(const GLbyte * v)
+{
+   DISPATCH(SecondaryColor3bvEXT, (v), (F, "glSecondaryColor3bv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3bvEXT)(const GLbyte * v)
+{
+   DISPATCH(SecondaryColor3bvEXT, (v), (F, "glSecondaryColor3bvEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3d)(GLdouble red, GLdouble green, GLdouble blue)
+{
+   DISPATCH(SecondaryColor3dEXT, (red, green, blue), (F, "glSecondaryColor3d(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3dEXT)(GLdouble red, GLdouble green, GLdouble blue)
+{
+   DISPATCH(SecondaryColor3dEXT, (red, green, blue), (F, "glSecondaryColor3dEXT(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3dv)(const GLdouble * v)
+{
+   DISPATCH(SecondaryColor3dvEXT, (v), (F, "glSecondaryColor3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3dvEXT)(const GLdouble * v)
+{
+   DISPATCH(SecondaryColor3dvEXT, (v), (F, "glSecondaryColor3dvEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3f)(GLfloat red, GLfloat green, GLfloat blue)
+{
+   DISPATCH(SecondaryColor3fEXT, (red, green, blue), (F, "glSecondaryColor3f(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3fEXT)(GLfloat red, GLfloat green, GLfloat blue)
+{
+   DISPATCH(SecondaryColor3fEXT, (red, green, blue), (F, "glSecondaryColor3fEXT(%f, %f, %f);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3fv)(const GLfloat * v)
+{
+   DISPATCH(SecondaryColor3fvEXT, (v), (F, "glSecondaryColor3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3fvEXT)(const GLfloat * v)
+{
+   DISPATCH(SecondaryColor3fvEXT, (v), (F, "glSecondaryColor3fvEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3i)(GLint red, GLint green, GLint blue)
+{
+   DISPATCH(SecondaryColor3iEXT, (red, green, blue), (F, "glSecondaryColor3i(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3iEXT)(GLint red, GLint green, GLint blue)
+{
+   DISPATCH(SecondaryColor3iEXT, (red, green, blue), (F, "glSecondaryColor3iEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3iv)(const GLint * v)
+{
+   DISPATCH(SecondaryColor3ivEXT, (v), (F, "glSecondaryColor3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ivEXT)(const GLint * v)
+{
+   DISPATCH(SecondaryColor3ivEXT, (v), (F, "glSecondaryColor3ivEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3s)(GLshort red, GLshort green, GLshort blue)
+{
+   DISPATCH(SecondaryColor3sEXT, (red, green, blue), (F, "glSecondaryColor3s(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3sEXT)(GLshort red, GLshort green, GLshort blue)
+{
+   DISPATCH(SecondaryColor3sEXT, (red, green, blue), (F, "glSecondaryColor3sEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3sv)(const GLshort * v)
+{
+   DISPATCH(SecondaryColor3svEXT, (v), (F, "glSecondaryColor3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3svEXT)(const GLshort * v)
+{
+   DISPATCH(SecondaryColor3svEXT, (v), (F, "glSecondaryColor3svEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ub)(GLubyte red, GLubyte green, GLubyte blue)
+{
+   DISPATCH(SecondaryColor3ubEXT, (red, green, blue), (F, "glSecondaryColor3ub(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ubEXT)(GLubyte red, GLubyte green, GLubyte blue)
+{
+   DISPATCH(SecondaryColor3ubEXT, (red, green, blue), (F, "glSecondaryColor3ubEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ubv)(const GLubyte * v)
+{
+   DISPATCH(SecondaryColor3ubvEXT, (v), (F, "glSecondaryColor3ubv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ubvEXT)(const GLubyte * v)
+{
+   DISPATCH(SecondaryColor3ubvEXT, (v), (F, "glSecondaryColor3ubvEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3ui)(GLuint red, GLuint green, GLuint blue)
+{
+   DISPATCH(SecondaryColor3uiEXT, (red, green, blue), (F, "glSecondaryColor3ui(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3uiEXT)(GLuint red, GLuint green, GLuint blue)
+{
+   DISPATCH(SecondaryColor3uiEXT, (red, green, blue), (F, "glSecondaryColor3uiEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3uiv)(const GLuint * v)
+{
+   DISPATCH(SecondaryColor3uivEXT, (v), (F, "glSecondaryColor3uiv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3uivEXT)(const GLuint * v)
+{
+   DISPATCH(SecondaryColor3uivEXT, (v), (F, "glSecondaryColor3uivEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3us)(GLushort red, GLushort green, GLushort blue)
+{
+   DISPATCH(SecondaryColor3usEXT, (red, green, blue), (F, "glSecondaryColor3us(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3usEXT)(GLushort red, GLushort green, GLushort blue)
+{
+   DISPATCH(SecondaryColor3usEXT, (red, green, blue), (F, "glSecondaryColor3usEXT(%d, %d, %d);\n", red, green, blue));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3usv)(const GLushort * v)
+{
+   DISPATCH(SecondaryColor3usvEXT, (v), (F, "glSecondaryColor3usv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColor3usvEXT)(const GLushort * v)
+{
+   DISPATCH(SecondaryColor3usvEXT, (v), (F, "glSecondaryColor3usvEXT(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColorPointer)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(SecondaryColorPointerEXT, (size, type, stride, pointer), (F, "glSecondaryColorPointer(%d, 0x%x, %d, %p);\n", size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SecondaryColorPointerEXT)(GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(SecondaryColorPointerEXT, (size, type, stride, pointer), (F, "glSecondaryColorPointerEXT(%d, 0x%x, %d, %p);\n", size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiDrawArrays)(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount)
+{
+   DISPATCH(MultiDrawArraysEXT, (mode, first, count, primcount), (F, "glMultiDrawArrays(0x%x, %p, %p, %d);\n", mode, (const void *) first, (const void *) count, primcount));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiDrawArraysEXT)(GLenum mode, GLint * first, GLsizei * count, GLsizei primcount)
+{
+   DISPATCH(MultiDrawArraysEXT, (mode, first, count, primcount), (F, "glMultiDrawArraysEXT(0x%x, %p, %p, %d);\n", mode, (const void *) first, (const void *) count, primcount));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiDrawElements)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid ** indices, GLsizei primcount)
+{
+   DISPATCH(MultiDrawElementsEXT, (mode, count, type, indices, primcount), (F, "glMultiDrawElements(0x%x, %p, 0x%x, %p, %d);\n", mode, (const void *) count, type, (const void *) indices, primcount));
+}
+
+KEYWORD1 void KEYWORD2 NAME(MultiDrawElementsEXT)(GLenum mode, const GLsizei * count, GLenum type, const GLvoid ** indices, GLsizei primcount)
+{
+   DISPATCH(MultiDrawElementsEXT, (mode, count, type, indices, primcount), (F, "glMultiDrawElementsEXT(0x%x, %p, 0x%x, %p, %d);\n", mode, (const void *) count, type, (const void *) indices, primcount));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordPointer)(GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(FogCoordPointerEXT, (type, stride, pointer), (F, "glFogCoordPointer(0x%x, %d, %p);\n", type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordPointerEXT)(GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(FogCoordPointerEXT, (type, stride, pointer), (F, "glFogCoordPointerEXT(0x%x, %d, %p);\n", type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordd)(GLdouble coord)
+{
+   DISPATCH(FogCoorddEXT, (coord), (F, "glFogCoordd(%f);\n", coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoorddEXT)(GLdouble coord)
+{
+   DISPATCH(FogCoorddEXT, (coord), (F, "glFogCoorddEXT(%f);\n", coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoorddv)(const GLdouble * coord)
+{
+   DISPATCH(FogCoorddvEXT, (coord), (F, "glFogCoorddv(%p);\n", (const void *) coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoorddvEXT)(const GLdouble * coord)
+{
+   DISPATCH(FogCoorddvEXT, (coord), (F, "glFogCoorddvEXT(%p);\n", (const void *) coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordf)(GLfloat coord)
+{
+   DISPATCH(FogCoordfEXT, (coord), (F, "glFogCoordf(%f);\n", coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordfEXT)(GLfloat coord)
+{
+   DISPATCH(FogCoordfEXT, (coord), (F, "glFogCoordfEXT(%f);\n", coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordfv)(const GLfloat * coord)
+{
+   DISPATCH(FogCoordfvEXT, (coord), (F, "glFogCoordfv(%p);\n", (const void *) coord));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FogCoordfvEXT)(const GLfloat * coord)
+{
+   DISPATCH(FogCoordfvEXT, (coord), (F, "glFogCoordfvEXT(%p);\n", (const void *) coord));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_606)(GLenum mode);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_606)(GLenum mode)
+{
+   DISPATCH(PixelTexGenSGIX, (mode), (F, "glPixelTexGenSGIX(0x%x);\n", mode));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendFuncSeparate)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
+{
+   DISPATCH(BlendFuncSeparateEXT, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (F, "glBlendFuncSeparate(0x%x, 0x%x, 0x%x, 0x%x);\n", sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendFuncSeparateEXT)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
+{
+   DISPATCH(BlendFuncSeparateEXT, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (F, "glBlendFuncSeparateEXT(0x%x, 0x%x, 0x%x, 0x%x);\n", sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_607)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_607)(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
+{
+   DISPATCH(BlendFuncSeparateEXT, (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha), (F, "glBlendFuncSeparateINGR(0x%x, 0x%x, 0x%x, 0x%x);\n", sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FlushVertexArrayRangeNV)(void)
+{
+   DISPATCH(FlushVertexArrayRangeNV, (), (F, "glFlushVertexArrayRangeNV();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexArrayRangeNV)(GLsizei length, const GLvoid * pointer)
+{
+   DISPATCH(VertexArrayRangeNV, (length, pointer), (F, "glVertexArrayRangeNV(%d, %p);\n", length, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerInputNV)(GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
+{
+   DISPATCH(CombinerInputNV, (stage, portion, variable, input, mapping, componentUsage), (F, "glCombinerInputNV(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x);\n", stage, portion, variable, input, mapping, componentUsage));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerOutputNV)(GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum)
+{
+   DISPATCH(CombinerOutputNV, (stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum), (F, "glCombinerOutputNV(0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, %d, %d, %d);\n", stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerParameterfNV)(GLenum pname, GLfloat param)
+{
+   DISPATCH(CombinerParameterfNV, (pname, param), (F, "glCombinerParameterfNV(0x%x, %f);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerParameterfvNV)(GLenum pname, const GLfloat * params)
+{
+   DISPATCH(CombinerParameterfvNV, (pname, params), (F, "glCombinerParameterfvNV(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerParameteriNV)(GLenum pname, GLint param)
+{
+   DISPATCH(CombinerParameteriNV, (pname, param), (F, "glCombinerParameteriNV(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(CombinerParameterivNV)(GLenum pname, const GLint * params)
+{
+   DISPATCH(CombinerParameterivNV, (pname, params), (F, "glCombinerParameterivNV(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FinalCombinerInputNV)(GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage)
+{
+   DISPATCH(FinalCombinerInputNV, (variable, input, mapping, componentUsage), (F, "glFinalCombinerInputNV(0x%x, 0x%x, 0x%x, 0x%x);\n", variable, input, mapping, componentUsage));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCombinerInputParameterfvNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetCombinerInputParameterfvNV, (stage, portion, variable, pname, params), (F, "glGetCombinerInputParameterfvNV(0x%x, 0x%x, 0x%x, 0x%x, %p);\n", stage, portion, variable, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCombinerInputParameterivNV)(GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params)
+{
+   DISPATCH(GetCombinerInputParameterivNV, (stage, portion, variable, pname, params), (F, "glGetCombinerInputParameterivNV(0x%x, 0x%x, 0x%x, 0x%x, %p);\n", stage, portion, variable, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCombinerOutputParameterfvNV)(GLenum stage, GLenum portion, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetCombinerOutputParameterfvNV, (stage, portion, pname, params), (F, "glGetCombinerOutputParameterfvNV(0x%x, 0x%x, 0x%x, %p);\n", stage, portion, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetCombinerOutputParameterivNV)(GLenum stage, GLenum portion, GLenum pname, GLint * params)
+{
+   DISPATCH(GetCombinerOutputParameterivNV, (stage, portion, pname, params), (F, "glGetCombinerOutputParameterivNV(0x%x, 0x%x, 0x%x, %p);\n", stage, portion, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetFinalCombinerInputParameterfvNV)(GLenum variable, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetFinalCombinerInputParameterfvNV, (variable, pname, params), (F, "glGetFinalCombinerInputParameterfvNV(0x%x, 0x%x, %p);\n", variable, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetFinalCombinerInputParameterivNV)(GLenum variable, GLenum pname, GLint * params)
+{
+   DISPATCH(GetFinalCombinerInputParameterivNV, (variable, pname, params), (F, "glGetFinalCombinerInputParameterivNV(0x%x, 0x%x, %p);\n", variable, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ResizeBuffersMESA)(void)
+{
+   DISPATCH(ResizeBuffersMESA, (), (F, "glResizeBuffersMESA();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2d)(GLdouble x, GLdouble y)
+{
+   DISPATCH(WindowPos2dMESA, (x, y), (F, "glWindowPos2d(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2dARB)(GLdouble x, GLdouble y)
+{
+   DISPATCH(WindowPos2dMESA, (x, y), (F, "glWindowPos2dARB(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2dMESA)(GLdouble x, GLdouble y)
+{
+   DISPATCH(WindowPos2dMESA, (x, y), (F, "glWindowPos2dMESA(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2dv)(const GLdouble * v)
+{
+   DISPATCH(WindowPos2dvMESA, (v), (F, "glWindowPos2dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2dvARB)(const GLdouble * v)
+{
+   DISPATCH(WindowPos2dvMESA, (v), (F, "glWindowPos2dvARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2dvMESA)(const GLdouble * v)
+{
+   DISPATCH(WindowPos2dvMESA, (v), (F, "glWindowPos2dvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2f)(GLfloat x, GLfloat y)
+{
+   DISPATCH(WindowPos2fMESA, (x, y), (F, "glWindowPos2f(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2fARB)(GLfloat x, GLfloat y)
+{
+   DISPATCH(WindowPos2fMESA, (x, y), (F, "glWindowPos2fARB(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2fMESA)(GLfloat x, GLfloat y)
+{
+   DISPATCH(WindowPos2fMESA, (x, y), (F, "glWindowPos2fMESA(%f, %f);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2fv)(const GLfloat * v)
+{
+   DISPATCH(WindowPos2fvMESA, (v), (F, "glWindowPos2fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2fvARB)(const GLfloat * v)
+{
+   DISPATCH(WindowPos2fvMESA, (v), (F, "glWindowPos2fvARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2fvMESA)(const GLfloat * v)
+{
+   DISPATCH(WindowPos2fvMESA, (v), (F, "glWindowPos2fvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2i)(GLint x, GLint y)
+{
+   DISPATCH(WindowPos2iMESA, (x, y), (F, "glWindowPos2i(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2iARB)(GLint x, GLint y)
+{
+   DISPATCH(WindowPos2iMESA, (x, y), (F, "glWindowPos2iARB(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2iMESA)(GLint x, GLint y)
+{
+   DISPATCH(WindowPos2iMESA, (x, y), (F, "glWindowPos2iMESA(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2iv)(const GLint * v)
+{
+   DISPATCH(WindowPos2ivMESA, (v), (F, "glWindowPos2iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2ivARB)(const GLint * v)
+{
+   DISPATCH(WindowPos2ivMESA, (v), (F, "glWindowPos2ivARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2ivMESA)(const GLint * v)
+{
+   DISPATCH(WindowPos2ivMESA, (v), (F, "glWindowPos2ivMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2s)(GLshort x, GLshort y)
+{
+   DISPATCH(WindowPos2sMESA, (x, y), (F, "glWindowPos2s(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2sARB)(GLshort x, GLshort y)
+{
+   DISPATCH(WindowPos2sMESA, (x, y), (F, "glWindowPos2sARB(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2sMESA)(GLshort x, GLshort y)
+{
+   DISPATCH(WindowPos2sMESA, (x, y), (F, "glWindowPos2sMESA(%d, %d);\n", x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2sv)(const GLshort * v)
+{
+   DISPATCH(WindowPos2svMESA, (v), (F, "glWindowPos2sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2svARB)(const GLshort * v)
+{
+   DISPATCH(WindowPos2svMESA, (v), (F, "glWindowPos2svARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos2svMESA)(const GLshort * v)
+{
+   DISPATCH(WindowPos2svMESA, (v), (F, "glWindowPos2svMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3d)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(WindowPos3dMESA, (x, y, z), (F, "glWindowPos3d(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3dARB)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(WindowPos3dMESA, (x, y, z), (F, "glWindowPos3dARB(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3dMESA)(GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(WindowPos3dMESA, (x, y, z), (F, "glWindowPos3dMESA(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3dv)(const GLdouble * v)
+{
+   DISPATCH(WindowPos3dvMESA, (v), (F, "glWindowPos3dv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3dvARB)(const GLdouble * v)
+{
+   DISPATCH(WindowPos3dvMESA, (v), (F, "glWindowPos3dvARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3dvMESA)(const GLdouble * v)
+{
+   DISPATCH(WindowPos3dvMESA, (v), (F, "glWindowPos3dvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3f)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(WindowPos3fMESA, (x, y, z), (F, "glWindowPos3f(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3fARB)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(WindowPos3fMESA, (x, y, z), (F, "glWindowPos3fARB(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3fMESA)(GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(WindowPos3fMESA, (x, y, z), (F, "glWindowPos3fMESA(%f, %f, %f);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3fv)(const GLfloat * v)
+{
+   DISPATCH(WindowPos3fvMESA, (v), (F, "glWindowPos3fv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3fvARB)(const GLfloat * v)
+{
+   DISPATCH(WindowPos3fvMESA, (v), (F, "glWindowPos3fvARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3fvMESA)(const GLfloat * v)
+{
+   DISPATCH(WindowPos3fvMESA, (v), (F, "glWindowPos3fvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3i)(GLint x, GLint y, GLint z)
+{
+   DISPATCH(WindowPos3iMESA, (x, y, z), (F, "glWindowPos3i(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3iARB)(GLint x, GLint y, GLint z)
+{
+   DISPATCH(WindowPos3iMESA, (x, y, z), (F, "glWindowPos3iARB(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3iMESA)(GLint x, GLint y, GLint z)
+{
+   DISPATCH(WindowPos3iMESA, (x, y, z), (F, "glWindowPos3iMESA(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3iv)(const GLint * v)
+{
+   DISPATCH(WindowPos3ivMESA, (v), (F, "glWindowPos3iv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3ivARB)(const GLint * v)
+{
+   DISPATCH(WindowPos3ivMESA, (v), (F, "glWindowPos3ivARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3ivMESA)(const GLint * v)
+{
+   DISPATCH(WindowPos3ivMESA, (v), (F, "glWindowPos3ivMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3s)(GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(WindowPos3sMESA, (x, y, z), (F, "glWindowPos3s(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3sARB)(GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(WindowPos3sMESA, (x, y, z), (F, "glWindowPos3sARB(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3sMESA)(GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(WindowPos3sMESA, (x, y, z), (F, "glWindowPos3sMESA(%d, %d, %d);\n", x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3sv)(const GLshort * v)
+{
+   DISPATCH(WindowPos3svMESA, (v), (F, "glWindowPos3sv(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3svARB)(const GLshort * v)
+{
+   DISPATCH(WindowPos3svMESA, (v), (F, "glWindowPos3svARB(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos3svMESA)(const GLshort * v)
+{
+   DISPATCH(WindowPos3svMESA, (v), (F, "glWindowPos3svMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4dMESA)(GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(WindowPos4dMESA, (x, y, z, w), (F, "glWindowPos4dMESA(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4dvMESA)(const GLdouble * v)
+{
+   DISPATCH(WindowPos4dvMESA, (v), (F, "glWindowPos4dvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4fMESA)(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(WindowPos4fMESA, (x, y, z, w), (F, "glWindowPos4fMESA(%f, %f, %f, %f);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4fvMESA)(const GLfloat * v)
+{
+   DISPATCH(WindowPos4fvMESA, (v), (F, "glWindowPos4fvMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4iMESA)(GLint x, GLint y, GLint z, GLint w)
+{
+   DISPATCH(WindowPos4iMESA, (x, y, z, w), (F, "glWindowPos4iMESA(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4ivMESA)(const GLint * v)
+{
+   DISPATCH(WindowPos4ivMESA, (v), (F, "glWindowPos4ivMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4sMESA)(GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(WindowPos4sMESA, (x, y, z, w), (F, "glWindowPos4sMESA(%d, %d, %d, %d);\n", x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(WindowPos4svMESA)(const GLshort * v)
+{
+   DISPATCH(WindowPos4svMESA, (v), (F, "glWindowPos4svMESA(%p);\n", (const void *) v));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_648)(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_648)(const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride)
+{
+   DISPATCH(MultiModeDrawArraysIBM, (mode, first, count, primcount, modestride), (F, "glMultiModeDrawArraysIBM(%p, %p, %p, %d, %d);\n", (const void *) mode, (const void *) first, (const void *) count, primcount, modestride));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_649)(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_649)(const GLenum * mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei primcount, GLint modestride)
+{
+   DISPATCH(MultiModeDrawElementsIBM, (mode, count, type, indices, primcount, modestride), (F, "glMultiModeDrawElementsIBM(%p, %p, 0x%x, %p, %d, %d);\n", (const void *) mode, (const void *) count, type, (const void *) indices, primcount, modestride));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_650)(GLsizei n, const GLuint * fences);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_650)(GLsizei n, const GLuint * fences)
+{
+   DISPATCH(DeleteFencesNV, (n, fences), (F, "glDeleteFencesNV(%d, %p);\n", n, (const void *) fences));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_651)(GLuint fence);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_651)(GLuint fence)
+{
+   DISPATCH(FinishFenceNV, (fence), (F, "glFinishFenceNV(%d);\n", fence));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_652)(GLsizei n, GLuint * fences);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_652)(GLsizei n, GLuint * fences)
+{
+   DISPATCH(GenFencesNV, (n, fences), (F, "glGenFencesNV(%d, %p);\n", n, (const void *) fences));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_653)(GLuint fence, GLenum pname, GLint * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_653)(GLuint fence, GLenum pname, GLint * params)
+{
+   DISPATCH(GetFenceivNV, (fence, pname, params), (F, "glGetFenceivNV(%d, 0x%x, %p);\n", fence, pname, (const void *) params));
+}
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_654)(GLuint fence);
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_654)(GLuint fence)
+{
+   RETURN_DISPATCH(IsFenceNV, (fence), (F, "glIsFenceNV(%d);\n", fence));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_655)(GLuint fence, GLenum condition);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_655)(GLuint fence, GLenum condition)
+{
+   DISPATCH(SetFenceNV, (fence, condition), (F, "glSetFenceNV(%d, 0x%x);\n", fence, condition));
+}
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_656)(GLuint fence);
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_656)(GLuint fence)
+{
+   RETURN_DISPATCH(TestFenceNV, (fence), (F, "glTestFenceNV(%d);\n", fence));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(AreProgramsResidentNV)(GLsizei n, const GLuint * ids, GLboolean * residences)
+{
+   RETURN_DISPATCH(AreProgramsResidentNV, (n, ids, residences), (F, "glAreProgramsResidentNV(%d, %p, %p);\n", n, (const void *) ids, (const void *) residences));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindProgramARB)(GLenum target, GLuint program)
+{
+   DISPATCH(BindProgramNV, (target, program), (F, "glBindProgramARB(0x%x, %d);\n", target, program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindProgramNV)(GLenum target, GLuint program)
+{
+   DISPATCH(BindProgramNV, (target, program), (F, "glBindProgramNV(0x%x, %d);\n", target, program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteProgramsARB)(GLsizei n, const GLuint * programs)
+{
+   DISPATCH(DeleteProgramsNV, (n, programs), (F, "glDeleteProgramsARB(%d, %p);\n", n, (const void *) programs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteProgramsNV)(GLsizei n, const GLuint * programs)
+{
+   DISPATCH(DeleteProgramsNV, (n, programs), (F, "glDeleteProgramsNV(%d, %p);\n", n, (const void *) programs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ExecuteProgramNV)(GLenum target, GLuint id, const GLfloat * params)
+{
+   DISPATCH(ExecuteProgramNV, (target, id, params), (F, "glExecuteProgramNV(0x%x, %d, %p);\n", target, id, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenProgramsARB)(GLsizei n, GLuint * programs)
+{
+   DISPATCH(GenProgramsNV, (n, programs), (F, "glGenProgramsARB(%d, %p);\n", n, (const void *) programs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenProgramsNV)(GLsizei n, GLuint * programs)
+{
+   DISPATCH(GenProgramsNV, (n, programs), (F, "glGenProgramsNV(%d, %p);\n", n, (const void *) programs));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramParameterdvNV)(GLenum target, GLuint index, GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetProgramParameterdvNV, (target, index, pname, params), (F, "glGetProgramParameterdvNV(0x%x, %d, 0x%x, %p);\n", target, index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramParameterfvNV)(GLenum target, GLuint index, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetProgramParameterfvNV, (target, index, pname, params), (F, "glGetProgramParameterfvNV(0x%x, %d, 0x%x, %p);\n", target, index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramStringNV)(GLuint id, GLenum pname, GLubyte * program)
+{
+   DISPATCH(GetProgramStringNV, (id, pname, program), (F, "glGetProgramStringNV(%d, 0x%x, %p);\n", id, pname, (const void *) program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramivNV)(GLuint id, GLenum pname, GLint * params)
+{
+   DISPATCH(GetProgramivNV, (id, pname, params), (F, "glGetProgramivNV(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetTrackMatrixivNV)(GLenum target, GLuint address, GLenum pname, GLint * params)
+{
+   DISPATCH(GetTrackMatrixivNV, (target, address, pname, params), (F, "glGetTrackMatrixivNV(0x%x, %d, 0x%x, %p);\n", target, address, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribPointerv)(GLuint index, GLenum pname, GLvoid ** pointer)
+{
+   DISPATCH(GetVertexAttribPointervNV, (index, pname, pointer), (F, "glGetVertexAttribPointerv(%d, 0x%x, %p);\n", index, pname, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribPointervARB)(GLuint index, GLenum pname, GLvoid ** pointer)
+{
+   DISPATCH(GetVertexAttribPointervNV, (index, pname, pointer), (F, "glGetVertexAttribPointervARB(%d, 0x%x, %p);\n", index, pname, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribPointervNV)(GLuint index, GLenum pname, GLvoid ** pointer)
+{
+   DISPATCH(GetVertexAttribPointervNV, (index, pname, pointer), (F, "glGetVertexAttribPointervNV(%d, 0x%x, %p);\n", index, pname, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribdvNV)(GLuint index, GLenum pname, GLdouble * params)
+{
+   DISPATCH(GetVertexAttribdvNV, (index, pname, params), (F, "glGetVertexAttribdvNV(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribfvNV)(GLuint index, GLenum pname, GLfloat * params)
+{
+   DISPATCH(GetVertexAttribfvNV, (index, pname, params), (F, "glGetVertexAttribfvNV(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetVertexAttribivNV)(GLuint index, GLenum pname, GLint * params)
+{
+   DISPATCH(GetVertexAttribivNV, (index, pname, params), (F, "glGetVertexAttribivNV(%d, 0x%x, %p);\n", index, pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsProgramARB)(GLuint program)
+{
+   RETURN_DISPATCH(IsProgramNV, (program), (F, "glIsProgramARB(%d);\n", program));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsProgramNV)(GLuint program)
+{
+   RETURN_DISPATCH(IsProgramNV, (program), (F, "glIsProgramNV(%d);\n", program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(LoadProgramNV)(GLenum target, GLuint id, GLsizei len, const GLubyte * program)
+{
+   DISPATCH(LoadProgramNV, (target, id, len, program), (F, "glLoadProgramNV(0x%x, %d, %d, %p);\n", target, id, len, (const void *) program));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameters4dvNV)(GLenum target, GLuint index, GLuint num, const GLdouble * params)
+{
+   DISPATCH(ProgramParameters4dvNV, (target, index, num, params), (F, "glProgramParameters4dvNV(0x%x, %d, %d, %p);\n", target, index, num, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramParameters4fvNV)(GLenum target, GLuint index, GLuint num, const GLfloat * params)
+{
+   DISPATCH(ProgramParameters4fvNV, (target, index, num, params), (F, "glProgramParameters4fvNV(0x%x, %d, %d, %p);\n", target, index, num, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RequestResidentProgramsNV)(GLsizei n, const GLuint * ids)
+{
+   DISPATCH(RequestResidentProgramsNV, (n, ids), (F, "glRequestResidentProgramsNV(%d, %p);\n", n, (const void *) ids));
+}
+
+KEYWORD1 void KEYWORD2 NAME(TrackMatrixNV)(GLenum target, GLuint address, GLenum matrix, GLenum transform)
+{
+   DISPATCH(TrackMatrixNV, (target, address, matrix, transform), (F, "glTrackMatrixNV(0x%x, %d, 0x%x, 0x%x);\n", target, address, matrix, transform));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1dNV)(GLuint index, GLdouble x)
+{
+   DISPATCH(VertexAttrib1dNV, (index, x), (F, "glVertexAttrib1dNV(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1dvNV)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib1dvNV, (index, v), (F, "glVertexAttrib1dvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1fNV)(GLuint index, GLfloat x)
+{
+   DISPATCH(VertexAttrib1fNV, (index, x), (F, "glVertexAttrib1fNV(%d, %f);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1fvNV)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib1fvNV, (index, v), (F, "glVertexAttrib1fvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1sNV)(GLuint index, GLshort x)
+{
+   DISPATCH(VertexAttrib1sNV, (index, x), (F, "glVertexAttrib1sNV(%d, %d);\n", index, x));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib1svNV)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib1svNV, (index, v), (F, "glVertexAttrib1svNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2dNV)(GLuint index, GLdouble x, GLdouble y)
+{
+   DISPATCH(VertexAttrib2dNV, (index, x, y), (F, "glVertexAttrib2dNV(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2dvNV)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib2dvNV, (index, v), (F, "glVertexAttrib2dvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2fNV)(GLuint index, GLfloat x, GLfloat y)
+{
+   DISPATCH(VertexAttrib2fNV, (index, x, y), (F, "glVertexAttrib2fNV(%d, %f, %f);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2fvNV)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib2fvNV, (index, v), (F, "glVertexAttrib2fvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2sNV)(GLuint index, GLshort x, GLshort y)
+{
+   DISPATCH(VertexAttrib2sNV, (index, x, y), (F, "glVertexAttrib2sNV(%d, %d, %d);\n", index, x, y));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib2svNV)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib2svNV, (index, v), (F, "glVertexAttrib2svNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z)
+{
+   DISPATCH(VertexAttrib3dNV, (index, x, y, z), (F, "glVertexAttrib3dNV(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3dvNV)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib3dvNV, (index, v), (F, "glVertexAttrib3dvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3fNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z)
+{
+   DISPATCH(VertexAttrib3fNV, (index, x, y, z), (F, "glVertexAttrib3fNV(%d, %f, %f, %f);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3fvNV)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib3fvNV, (index, v), (F, "glVertexAttrib3fvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3sNV)(GLuint index, GLshort x, GLshort y, GLshort z)
+{
+   DISPATCH(VertexAttrib3sNV, (index, x, y, z), (F, "glVertexAttrib3sNV(%d, %d, %d, %d);\n", index, x, y, z));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib3svNV)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib3svNV, (index, v), (F, "glVertexAttrib3svNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4dNV)(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(VertexAttrib4dNV, (index, x, y, z, w), (F, "glVertexAttrib4dNV(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4dvNV)(GLuint index, const GLdouble * v)
+{
+   DISPATCH(VertexAttrib4dvNV, (index, v), (F, "glVertexAttrib4dvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4fNV)(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(VertexAttrib4fNV, (index, x, y, z, w), (F, "glVertexAttrib4fNV(%d, %f, %f, %f, %f);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4fvNV)(GLuint index, const GLfloat * v)
+{
+   DISPATCH(VertexAttrib4fvNV, (index, v), (F, "glVertexAttrib4fvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4sNV)(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w)
+{
+   DISPATCH(VertexAttrib4sNV, (index, x, y, z, w), (F, "glVertexAttrib4sNV(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4svNV)(GLuint index, const GLshort * v)
+{
+   DISPATCH(VertexAttrib4svNV, (index, v), (F, "glVertexAttrib4svNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4ubNV)(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w)
+{
+   DISPATCH(VertexAttrib4ubNV, (index, x, y, z, w), (F, "glVertexAttrib4ubNV(%d, %d, %d, %d, %d);\n", index, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttrib4ubvNV)(GLuint index, const GLubyte * v)
+{
+   DISPATCH(VertexAttrib4ubvNV, (index, v), (F, "glVertexAttrib4ubvNV(%d, %p);\n", index, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribPointerNV)(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer)
+{
+   DISPATCH(VertexAttribPointerNV, (index, size, type, stride, pointer), (F, "glVertexAttribPointerNV(%d, %d, 0x%x, %d, %p);\n", index, size, type, stride, (const void *) pointer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs1dvNV)(GLuint index, GLsizei n, const GLdouble * v)
+{
+   DISPATCH(VertexAttribs1dvNV, (index, n, v), (F, "glVertexAttribs1dvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs1fvNV)(GLuint index, GLsizei n, const GLfloat * v)
+{
+   DISPATCH(VertexAttribs1fvNV, (index, n, v), (F, "glVertexAttribs1fvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs1svNV)(GLuint index, GLsizei n, const GLshort * v)
+{
+   DISPATCH(VertexAttribs1svNV, (index, n, v), (F, "glVertexAttribs1svNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs2dvNV)(GLuint index, GLsizei n, const GLdouble * v)
+{
+   DISPATCH(VertexAttribs2dvNV, (index, n, v), (F, "glVertexAttribs2dvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs2fvNV)(GLuint index, GLsizei n, const GLfloat * v)
+{
+   DISPATCH(VertexAttribs2fvNV, (index, n, v), (F, "glVertexAttribs2fvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs2svNV)(GLuint index, GLsizei n, const GLshort * v)
+{
+   DISPATCH(VertexAttribs2svNV, (index, n, v), (F, "glVertexAttribs2svNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs3dvNV)(GLuint index, GLsizei n, const GLdouble * v)
+{
+   DISPATCH(VertexAttribs3dvNV, (index, n, v), (F, "glVertexAttribs3dvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs3fvNV)(GLuint index, GLsizei n, const GLfloat * v)
+{
+   DISPATCH(VertexAttribs3fvNV, (index, n, v), (F, "glVertexAttribs3fvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs3svNV)(GLuint index, GLsizei n, const GLshort * v)
+{
+   DISPATCH(VertexAttribs3svNV, (index, n, v), (F, "glVertexAttribs3svNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs4dvNV)(GLuint index, GLsizei n, const GLdouble * v)
+{
+   DISPATCH(VertexAttribs4dvNV, (index, n, v), (F, "glVertexAttribs4dvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs4fvNV)(GLuint index, GLsizei n, const GLfloat * v)
+{
+   DISPATCH(VertexAttribs4fvNV, (index, n, v), (F, "glVertexAttribs4fvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs4svNV)(GLuint index, GLsizei n, const GLshort * v)
+{
+   DISPATCH(VertexAttribs4svNV, (index, n, v), (F, "glVertexAttribs4svNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(VertexAttribs4ubvNV)(GLuint index, GLsizei n, const GLubyte * v)
+{
+   DISPATCH(VertexAttribs4ubvNV, (index, n, v), (F, "glVertexAttribs4ubvNV(%d, %d, %p);\n", index, n, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AlphaFragmentOp1ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
+{
+   DISPATCH(AlphaFragmentOp1ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod), (F, "glAlphaFragmentOp1ATI(0x%x, %d, %d, %d, %d, %d);\n", op, dst, dstMod, arg1, arg1Rep, arg1Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AlphaFragmentOp2ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
+{
+   DISPATCH(AlphaFragmentOp2ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (F, "glAlphaFragmentOp2ATI(0x%x, %d, %d, %d, %d, %d, %d, %d, %d);\n", op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(AlphaFragmentOp3ATI)(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
+{
+   DISPATCH(AlphaFragmentOp3ATI, (op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (F, "glAlphaFragmentOp3ATI(0x%x, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d);\n", op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BeginFragmentShaderATI)(void)
+{
+   DISPATCH(BeginFragmentShaderATI, (), (F, "glBeginFragmentShaderATI();\n"));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindFragmentShaderATI)(GLuint id)
+{
+   DISPATCH(BindFragmentShaderATI, (id), (F, "glBindFragmentShaderATI(%d);\n", id));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorFragmentOp1ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod)
+{
+   DISPATCH(ColorFragmentOp1ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod), (F, "glColorFragmentOp1ATI(0x%x, %d, %d, %d, %d, %d, %d);\n", op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorFragmentOp2ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod)
+{
+   DISPATCH(ColorFragmentOp2ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod), (F, "glColorFragmentOp2ATI(0x%x, %d, %d, %d, %d, %d, %d, %d, %d, %d);\n", op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ColorFragmentOp3ATI)(GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod)
+{
+   DISPATCH(ColorFragmentOp3ATI, (op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod), (F, "glColorFragmentOp3ATI(0x%x, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d);\n", op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteFragmentShaderATI)(GLuint id)
+{
+   DISPATCH(DeleteFragmentShaderATI, (id), (F, "glDeleteFragmentShaderATI(%d);\n", id));
+}
+
+KEYWORD1 void KEYWORD2 NAME(EndFragmentShaderATI)(void)
+{
+   DISPATCH(EndFragmentShaderATI, (), (F, "glEndFragmentShaderATI();\n"));
+}
+
+KEYWORD1 GLuint KEYWORD2 NAME(GenFragmentShadersATI)(GLuint range)
+{
+   RETURN_DISPATCH(GenFragmentShadersATI, (range), (F, "glGenFragmentShadersATI(%d);\n", range));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PassTexCoordATI)(GLuint dst, GLuint coord, GLenum swizzle)
+{
+   DISPATCH(PassTexCoordATI, (dst, coord, swizzle), (F, "glPassTexCoordATI(%d, %d, 0x%x);\n", dst, coord, swizzle));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SampleMapATI)(GLuint dst, GLuint interp, GLenum swizzle)
+{
+   DISPATCH(SampleMapATI, (dst, interp, swizzle), (F, "glSampleMapATI(%d, %d, 0x%x);\n", dst, interp, swizzle));
+}
+
+KEYWORD1 void KEYWORD2 NAME(SetFragmentShaderConstantATI)(GLuint dst, const GLfloat * value)
+{
+   DISPATCH(SetFragmentShaderConstantATI, (dst, value), (F, "glSetFragmentShaderConstantATI(%d, %p);\n", dst, (const void *) value));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameteri)(GLenum pname, GLint param)
+{
+   DISPATCH(PointParameteriNV, (pname, param), (F, "glPointParameteri(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameteriNV)(GLenum pname, GLint param)
+{
+   DISPATCH(PointParameteriNV, (pname, param), (F, "glPointParameteriNV(0x%x, %d);\n", pname, param));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameteriv)(GLenum pname, const GLint * params)
+{
+   DISPATCH(PointParameterivNV, (pname, params), (F, "glPointParameteriv(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(PointParameterivNV)(GLenum pname, const GLint * params)
+{
+   DISPATCH(PointParameterivNV, (pname, params), (F, "glPointParameterivNV(0x%x, %p);\n", pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_733)(GLenum face);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_733)(GLenum face)
+{
+   DISPATCH(ActiveStencilFaceEXT, (face), (F, "glActiveStencilFaceEXT(0x%x);\n", face));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_734)(GLuint array);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_734)(GLuint array)
+{
+   DISPATCH(BindVertexArrayAPPLE, (array), (F, "glBindVertexArrayAPPLE(%d);\n", array));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_735)(GLsizei n, const GLuint * arrays);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_735)(GLsizei n, const GLuint * arrays)
+{
+   DISPATCH(DeleteVertexArraysAPPLE, (n, arrays), (F, "glDeleteVertexArraysAPPLE(%d, %p);\n", n, (const void *) arrays));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_736)(GLsizei n, GLuint * arrays);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_736)(GLsizei n, GLuint * arrays)
+{
+   DISPATCH(GenVertexArraysAPPLE, (n, arrays), (F, "glGenVertexArraysAPPLE(%d, %p);\n", n, (const void *) arrays));
+}
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_737)(GLuint array);
+
+KEYWORD1_ALT GLboolean KEYWORD2 NAME(_dispatch_stub_737)(GLuint array)
+{
+   RETURN_DISPATCH(IsVertexArrayAPPLE, (array), (F, "glIsVertexArrayAPPLE(%d);\n", array));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramNamedParameterdvNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble * params)
+{
+   DISPATCH(GetProgramNamedParameterdvNV, (id, len, name, params), (F, "glGetProgramNamedParameterdvNV(%d, %d, %p, %p);\n", id, len, (const void *) name, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetProgramNamedParameterfvNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat * params)
+{
+   DISPATCH(GetProgramNamedParameterfvNV, (id, len, name, params), (F, "glGetProgramNamedParameterfvNV(%d, %d, %p, %p);\n", id, len, (const void *) name, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramNamedParameter4dNV)(GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w)
+{
+   DISPATCH(ProgramNamedParameter4dNV, (id, len, name, x, y, z, w), (F, "glProgramNamedParameter4dNV(%d, %d, %p, %f, %f, %f, %f);\n", id, len, (const void *) name, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramNamedParameter4dvNV)(GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v)
+{
+   DISPATCH(ProgramNamedParameter4dvNV, (id, len, name, v), (F, "glProgramNamedParameter4dvNV(%d, %d, %p, %p);\n", id, len, (const void *) name, (const void *) v));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramNamedParameter4fNV)(GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
+{
+   DISPATCH(ProgramNamedParameter4fNV, (id, len, name, x, y, z, w), (F, "glProgramNamedParameter4fNV(%d, %d, %p, %f, %f, %f, %f);\n", id, len, (const void *) name, x, y, z, w));
+}
+
+KEYWORD1 void KEYWORD2 NAME(ProgramNamedParameter4fvNV)(GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v)
+{
+   DISPATCH(ProgramNamedParameter4fvNV, (id, len, name, v), (F, "glProgramNamedParameter4fvNV(%d, %d, %p, %p);\n", id, len, (const void *) name, (const void *) v));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_744)(GLclampd zmin, GLclampd zmax);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_744)(GLclampd zmin, GLclampd zmax)
+{
+   DISPATCH(DepthBoundsEXT, (zmin, zmax), (F, "glDepthBoundsEXT(%f, %f);\n", zmin, zmax));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BlendEquationSeparate)(GLenum modeRGB, GLenum modeA)
+{
+   DISPATCH(BlendEquationSeparateEXT, (modeRGB, modeA), (F, "glBlendEquationSeparate(0x%x, 0x%x);\n", modeRGB, modeA));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_745)(GLenum modeRGB, GLenum modeA);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_745)(GLenum modeRGB, GLenum modeA)
+{
+   DISPATCH(BlendEquationSeparateEXT, (modeRGB, modeA), (F, "glBlendEquationSeparateEXT(0x%x, 0x%x);\n", modeRGB, modeA));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindFramebufferEXT)(GLenum target, GLuint framebuffer)
+{
+   DISPATCH(BindFramebufferEXT, (target, framebuffer), (F, "glBindFramebufferEXT(0x%x, %d);\n", target, framebuffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(BindRenderbufferEXT)(GLenum target, GLuint renderbuffer)
+{
+   DISPATCH(BindRenderbufferEXT, (target, renderbuffer), (F, "glBindRenderbufferEXT(0x%x, %d);\n", target, renderbuffer));
+}
+
+KEYWORD1 GLenum KEYWORD2 NAME(CheckFramebufferStatusEXT)(GLenum target)
+{
+   RETURN_DISPATCH(CheckFramebufferStatusEXT, (target), (F, "glCheckFramebufferStatusEXT(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteFramebuffersEXT)(GLsizei n, const GLuint * framebuffers)
+{
+   DISPATCH(DeleteFramebuffersEXT, (n, framebuffers), (F, "glDeleteFramebuffersEXT(%d, %p);\n", n, (const void *) framebuffers));
+}
+
+KEYWORD1 void KEYWORD2 NAME(DeleteRenderbuffersEXT)(GLsizei n, const GLuint * renderbuffers)
+{
+   DISPATCH(DeleteRenderbuffersEXT, (n, renderbuffers), (F, "glDeleteRenderbuffersEXT(%d, %p);\n", n, (const void *) renderbuffers));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FramebufferRenderbufferEXT)(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
+{
+   DISPATCH(FramebufferRenderbufferEXT, (target, attachment, renderbuffertarget, renderbuffer), (F, "glFramebufferRenderbufferEXT(0x%x, 0x%x, 0x%x, %d);\n", target, attachment, renderbuffertarget, renderbuffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FramebufferTexture1DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
+{
+   DISPATCH(FramebufferTexture1DEXT, (target, attachment, textarget, texture, level), (F, "glFramebufferTexture1DEXT(0x%x, 0x%x, 0x%x, %d, %d);\n", target, attachment, textarget, texture, level));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FramebufferTexture2DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
+{
+   DISPATCH(FramebufferTexture2DEXT, (target, attachment, textarget, texture, level), (F, "glFramebufferTexture2DEXT(0x%x, 0x%x, 0x%x, %d, %d);\n", target, attachment, textarget, texture, level));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FramebufferTexture3DEXT)(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset)
+{
+   DISPATCH(FramebufferTexture3DEXT, (target, attachment, textarget, texture, level, zoffset), (F, "glFramebufferTexture3DEXT(0x%x, 0x%x, 0x%x, %d, %d, %d);\n", target, attachment, textarget, texture, level, zoffset));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenFramebuffersEXT)(GLsizei n, GLuint * framebuffers)
+{
+   DISPATCH(GenFramebuffersEXT, (n, framebuffers), (F, "glGenFramebuffersEXT(%d, %p);\n", n, (const void *) framebuffers));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenRenderbuffersEXT)(GLsizei n, GLuint * renderbuffers)
+{
+   DISPATCH(GenRenderbuffersEXT, (n, renderbuffers), (F, "glGenRenderbuffersEXT(%d, %p);\n", n, (const void *) renderbuffers));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GenerateMipmapEXT)(GLenum target)
+{
+   DISPATCH(GenerateMipmapEXT, (target), (F, "glGenerateMipmapEXT(0x%x);\n", target));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetFramebufferAttachmentParameterivEXT)(GLenum target, GLenum attachment, GLenum pname, GLint * params)
+{
+   DISPATCH(GetFramebufferAttachmentParameterivEXT, (target, attachment, pname, params), (F, "glGetFramebufferAttachmentParameterivEXT(0x%x, 0x%x, 0x%x, %p);\n", target, attachment, pname, (const void *) params));
+}
+
+KEYWORD1 void KEYWORD2 NAME(GetRenderbufferParameterivEXT)(GLenum target, GLenum pname, GLint * params)
+{
+   DISPATCH(GetRenderbufferParameterivEXT, (target, pname, params), (F, "glGetRenderbufferParameterivEXT(0x%x, 0x%x, %p);\n", target, pname, (const void *) params));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsFramebufferEXT)(GLuint framebuffer)
+{
+   RETURN_DISPATCH(IsFramebufferEXT, (framebuffer), (F, "glIsFramebufferEXT(%d);\n", framebuffer));
+}
+
+KEYWORD1 GLboolean KEYWORD2 NAME(IsRenderbufferEXT)(GLuint renderbuffer)
+{
+   RETURN_DISPATCH(IsRenderbufferEXT, (renderbuffer), (F, "glIsRenderbufferEXT(%d);\n", renderbuffer));
+}
+
+KEYWORD1 void KEYWORD2 NAME(RenderbufferStorageEXT)(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
+{
+   DISPATCH(RenderbufferStorageEXT, (target, internalformat, width, height), (F, "glRenderbufferStorageEXT(0x%x, 0x%x, %d, %d);\n", target, internalformat, width, height));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_763)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_763)(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
+{
+   DISPATCH(BlitFramebufferEXT, (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter), (F, "glBlitFramebufferEXT(%d, %d, %d, %d, %d, %d, %d, %d, %d, 0x%x);\n", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter));
+}
+
+KEYWORD1 void KEYWORD2 NAME(FramebufferTextureLayerEXT)(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer)
+{
+   DISPATCH(FramebufferTextureLayerEXT, (target, attachment, texture, level, layer), (F, "glFramebufferTextureLayerEXT(0x%x, 0x%x, %d, %d, %d);\n", target, attachment, texture, level, layer));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_765)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_765)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask)
+{
+   DISPATCH(StencilFuncSeparateATI, (frontfunc, backfunc, ref, mask), (F, "glStencilFuncSeparateATI(0x%x, 0x%x, %d, %d);\n", frontfunc, backfunc, ref, mask));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_766)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_766)(GLenum target, GLuint index, GLsizei count, const GLfloat * params)
+{
+   DISPATCH(ProgramEnvParameters4fvEXT, (target, index, count, params), (F, "glProgramEnvParameters4fvEXT(0x%x, %d, %d, %p);\n", target, index, count, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_767)(GLenum target, GLuint index, GLsizei count, const GLfloat * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_767)(GLenum target, GLuint index, GLsizei count, const GLfloat * params)
+{
+   DISPATCH(ProgramLocalParameters4fvEXT, (target, index, count, params), (F, "glProgramLocalParameters4fvEXT(0x%x, %d, %d, %p);\n", target, index, count, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_768)(GLuint id, GLenum pname, GLint64EXT * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_768)(GLuint id, GLenum pname, GLint64EXT * params)
+{
+   DISPATCH(GetQueryObjecti64vEXT, (id, pname, params), (F, "glGetQueryObjecti64vEXT(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_769)(GLuint id, GLenum pname, GLuint64EXT * params);
+
+KEYWORD1_ALT void KEYWORD2 NAME(_dispatch_stub_769)(GLuint id, GLenum pname, GLuint64EXT * params)
+{
+   DISPATCH(GetQueryObjectui64vEXT, (id, pname, params), (F, "glGetQueryObjectui64vEXT(%d, 0x%x, %p);\n", id, pname, (const void *) params));
+}
+
+
+#endif /* defined( NAME ) */
+
+/*
+ * This is how a dispatch table can be initialized with all the functions
+ * we generated above.
+ */
+#ifdef DISPATCH_TABLE_NAME
+
+#ifndef TABLE_ENTRY
+#error TABLE_ENTRY must be defined
+#endif
+
+static _glapi_proc DISPATCH_TABLE_NAME[] = {
+   TABLE_ENTRY(NewList),
+   TABLE_ENTRY(EndList),
+   TABLE_ENTRY(CallList),
+   TABLE_ENTRY(CallLists),
+   TABLE_ENTRY(DeleteLists),
+   TABLE_ENTRY(GenLists),
+   TABLE_ENTRY(ListBase),
+   TABLE_ENTRY(Begin),
+   TABLE_ENTRY(Bitmap),
+   TABLE_ENTRY(Color3b),
+   TABLE_ENTRY(Color3bv),
+   TABLE_ENTRY(Color3d),
+   TABLE_ENTRY(Color3dv),
+   TABLE_ENTRY(Color3f),
+   TABLE_ENTRY(Color3fv),
+   TABLE_ENTRY(Color3i),
+   TABLE_ENTRY(Color3iv),
+   TABLE_ENTRY(Color3s),
+   TABLE_ENTRY(Color3sv),
+   TABLE_ENTRY(Color3ub),
+   TABLE_ENTRY(Color3ubv),
+   TABLE_ENTRY(Color3ui),
+   TABLE_ENTRY(Color3uiv),
+   TABLE_ENTRY(Color3us),
+   TABLE_ENTRY(Color3usv),
+   TABLE_ENTRY(Color4b),
+   TABLE_ENTRY(Color4bv),
+   TABLE_ENTRY(Color4d),
+   TABLE_ENTRY(Color4dv),
+   TABLE_ENTRY(Color4f),
+   TABLE_ENTRY(Color4fv),
+   TABLE_ENTRY(Color4i),
+   TABLE_ENTRY(Color4iv),
+   TABLE_ENTRY(Color4s),
+   TABLE_ENTRY(Color4sv),
+   TABLE_ENTRY(Color4ub),
+   TABLE_ENTRY(Color4ubv),
+   TABLE_ENTRY(Color4ui),
+   TABLE_ENTRY(Color4uiv),
+   TABLE_ENTRY(Color4us),
+   TABLE_ENTRY(Color4usv),
+   TABLE_ENTRY(EdgeFlag),
+   TABLE_ENTRY(EdgeFlagv),
+   TABLE_ENTRY(End),
+   TABLE_ENTRY(Indexd),
+   TABLE_ENTRY(Indexdv),
+   TABLE_ENTRY(Indexf),
+   TABLE_ENTRY(Indexfv),
+   TABLE_ENTRY(Indexi),
+   TABLE_ENTRY(Indexiv),
+   TABLE_ENTRY(Indexs),
+   TABLE_ENTRY(Indexsv),
+   TABLE_ENTRY(Normal3b),
+   TABLE_ENTRY(Normal3bv),
+   TABLE_ENTRY(Normal3d),
+   TABLE_ENTRY(Normal3dv),
+   TABLE_ENTRY(Normal3f),
+   TABLE_ENTRY(Normal3fv),
+   TABLE_ENTRY(Normal3i),
+   TABLE_ENTRY(Normal3iv),
+   TABLE_ENTRY(Normal3s),
+   TABLE_ENTRY(Normal3sv),
+   TABLE_ENTRY(RasterPos2d),
+   TABLE_ENTRY(RasterPos2dv),
+   TABLE_ENTRY(RasterPos2f),
+   TABLE_ENTRY(RasterPos2fv),
+   TABLE_ENTRY(RasterPos2i),
+   TABLE_ENTRY(RasterPos2iv),
+   TABLE_ENTRY(RasterPos2s),
+   TABLE_ENTRY(RasterPos2sv),
+   TABLE_ENTRY(RasterPos3d),
+   TABLE_ENTRY(RasterPos3dv),
+   TABLE_ENTRY(RasterPos3f),
+   TABLE_ENTRY(RasterPos3fv),
+   TABLE_ENTRY(RasterPos3i),
+   TABLE_ENTRY(RasterPos3iv),
+   TABLE_ENTRY(RasterPos3s),
+   TABLE_ENTRY(RasterPos3sv),
+   TABLE_ENTRY(RasterPos4d),
+   TABLE_ENTRY(RasterPos4dv),
+   TABLE_ENTRY(RasterPos4f),
+   TABLE_ENTRY(RasterPos4fv),
+   TABLE_ENTRY(RasterPos4i),
+   TABLE_ENTRY(RasterPos4iv),
+   TABLE_ENTRY(RasterPos4s),
+   TABLE_ENTRY(RasterPos4sv),
+   TABLE_ENTRY(Rectd),
+   TABLE_ENTRY(Rectdv),
+   TABLE_ENTRY(Rectf),
+   TABLE_ENTRY(Rectfv),
+   TABLE_ENTRY(Recti),
+   TABLE_ENTRY(Rectiv),
+   TABLE_ENTRY(Rects),
+   TABLE_ENTRY(Rectsv),
+   TABLE_ENTRY(TexCoord1d),
+   TABLE_ENTRY(TexCoord1dv),
+   TABLE_ENTRY(TexCoord1f),
+   TABLE_ENTRY(TexCoord1fv),
+   TABLE_ENTRY(TexCoord1i),
+   TABLE_ENTRY(TexCoord1iv),
+   TABLE_ENTRY(TexCoord1s),
+   TABLE_ENTRY(TexCoord1sv),
+   TABLE_ENTRY(TexCoord2d),
+   TABLE_ENTRY(TexCoord2dv),
+   TABLE_ENTRY(TexCoord2f),
+   TABLE_ENTRY(TexCoord2fv),
+   TABLE_ENTRY(TexCoord2i),
+   TABLE_ENTRY(TexCoord2iv),
+   TABLE_ENTRY(TexCoord2s),
+   TABLE_ENTRY(TexCoord2sv),
+   TABLE_ENTRY(TexCoord3d),
+   TABLE_ENTRY(TexCoord3dv),
+   TABLE_ENTRY(TexCoord3f),
+   TABLE_ENTRY(TexCoord3fv),
+   TABLE_ENTRY(TexCoord3i),
+   TABLE_ENTRY(TexCoord3iv),
+   TABLE_ENTRY(TexCoord3s),
+   TABLE_ENTRY(TexCoord3sv),
+   TABLE_ENTRY(TexCoord4d),
+   TABLE_ENTRY(TexCoord4dv),
+   TABLE_ENTRY(TexCoord4f),
+   TABLE_ENTRY(TexCoord4fv),
+   TABLE_ENTRY(TexCoord4i),
+   TABLE_ENTRY(TexCoord4iv),
+   TABLE_ENTRY(TexCoord4s),
+   TABLE_ENTRY(TexCoord4sv),
+   TABLE_ENTRY(Vertex2d),
+   TABLE_ENTRY(Vertex2dv),
+   TABLE_ENTRY(Vertex2f),
+   TABLE_ENTRY(Vertex2fv),
+   TABLE_ENTRY(Vertex2i),
+   TABLE_ENTRY(Vertex2iv),
+   TABLE_ENTRY(Vertex2s),
+   TABLE_ENTRY(Vertex2sv),
+   TABLE_ENTRY(Vertex3d),
+   TABLE_ENTRY(Vertex3dv),
+   TABLE_ENTRY(Vertex3f),
+   TABLE_ENTRY(Vertex3fv),
+   TABLE_ENTRY(Vertex3i),
+   TABLE_ENTRY(Vertex3iv),
+   TABLE_ENTRY(Vertex3s),
+   TABLE_ENTRY(Vertex3sv),
+   TABLE_ENTRY(Vertex4d),
+   TABLE_ENTRY(Vertex4dv),
+   TABLE_ENTRY(Vertex4f),
+   TABLE_ENTRY(Vertex4fv),
+   TABLE_ENTRY(Vertex4i),
+   TABLE_ENTRY(Vertex4iv),
+   TABLE_ENTRY(Vertex4s),
+   TABLE_ENTRY(Vertex4sv),
+   TABLE_ENTRY(ClipPlane),
+   TABLE_ENTRY(ColorMaterial),
+   TABLE_ENTRY(CullFace),
+   TABLE_ENTRY(Fogf),
+   TABLE_ENTRY(Fogfv),
+   TABLE_ENTRY(Fogi),
+   TABLE_ENTRY(Fogiv),
+   TABLE_ENTRY(FrontFace),
+   TABLE_ENTRY(Hint),
+   TABLE_ENTRY(Lightf),
+   TABLE_ENTRY(Lightfv),
+   TABLE_ENTRY(Lighti),
+   TABLE_ENTRY(Lightiv),
+   TABLE_ENTRY(LightModelf),
+   TABLE_ENTRY(LightModelfv),
+   TABLE_ENTRY(LightModeli),
+   TABLE_ENTRY(LightModeliv),
+   TABLE_ENTRY(LineStipple),
+   TABLE_ENTRY(LineWidth),
+   TABLE_ENTRY(Materialf),
+   TABLE_ENTRY(Materialfv),
+   TABLE_ENTRY(Materiali),
+   TABLE_ENTRY(Materialiv),
+   TABLE_ENTRY(PointSize),
+   TABLE_ENTRY(PolygonMode),
+   TABLE_ENTRY(PolygonStipple),
+   TABLE_ENTRY(Scissor),
+   TABLE_ENTRY(ShadeModel),
+   TABLE_ENTRY(TexParameterf),
+   TABLE_ENTRY(TexParameterfv),
+   TABLE_ENTRY(TexParameteri),
+   TABLE_ENTRY(TexParameteriv),
+   TABLE_ENTRY(TexImage1D),
+   TABLE_ENTRY(TexImage2D),
+   TABLE_ENTRY(TexEnvf),
+   TABLE_ENTRY(TexEnvfv),
+   TABLE_ENTRY(TexEnvi),
+   TABLE_ENTRY(TexEnviv),
+   TABLE_ENTRY(TexGend),
+   TABLE_ENTRY(TexGendv),
+   TABLE_ENTRY(TexGenf),
+   TABLE_ENTRY(TexGenfv),
+   TABLE_ENTRY(TexGeni),
+   TABLE_ENTRY(TexGeniv),
+   TABLE_ENTRY(FeedbackBuffer),
+   TABLE_ENTRY(SelectBuffer),
+   TABLE_ENTRY(RenderMode),
+   TABLE_ENTRY(InitNames),
+   TABLE_ENTRY(LoadName),
+   TABLE_ENTRY(PassThrough),
+   TABLE_ENTRY(PopName),
+   TABLE_ENTRY(PushName),
+   TABLE_ENTRY(DrawBuffer),
+   TABLE_ENTRY(Clear),
+   TABLE_ENTRY(ClearAccum),
+   TABLE_ENTRY(ClearIndex),
+   TABLE_ENTRY(ClearColor),
+   TABLE_ENTRY(ClearStencil),
+   TABLE_ENTRY(ClearDepth),
+   TABLE_ENTRY(StencilMask),
+   TABLE_ENTRY(ColorMask),
+   TABLE_ENTRY(DepthMask),
+   TABLE_ENTRY(IndexMask),
+   TABLE_ENTRY(Accum),
+   TABLE_ENTRY(Disable),
+   TABLE_ENTRY(Enable),
+   TABLE_ENTRY(Finish),
+   TABLE_ENTRY(Flush),
+   TABLE_ENTRY(PopAttrib),
+   TABLE_ENTRY(PushAttrib),
+   TABLE_ENTRY(Map1d),
+   TABLE_ENTRY(Map1f),
+   TABLE_ENTRY(Map2d),
+   TABLE_ENTRY(Map2f),
+   TABLE_ENTRY(MapGrid1d),
+   TABLE_ENTRY(MapGrid1f),
+   TABLE_ENTRY(MapGrid2d),
+   TABLE_ENTRY(MapGrid2f),
+   TABLE_ENTRY(EvalCoord1d),
+   TABLE_ENTRY(EvalCoord1dv),
+   TABLE_ENTRY(EvalCoord1f),
+   TABLE_ENTRY(EvalCoord1fv),
+   TABLE_ENTRY(EvalCoord2d),
+   TABLE_ENTRY(EvalCoord2dv),
+   TABLE_ENTRY(EvalCoord2f),
+   TABLE_ENTRY(EvalCoord2fv),
+   TABLE_ENTRY(EvalMesh1),
+   TABLE_ENTRY(EvalPoint1),
+   TABLE_ENTRY(EvalMesh2),
+   TABLE_ENTRY(EvalPoint2),
+   TABLE_ENTRY(AlphaFunc),
+   TABLE_ENTRY(BlendFunc),
+   TABLE_ENTRY(LogicOp),
+   TABLE_ENTRY(StencilFunc),
+   TABLE_ENTRY(StencilOp),
+   TABLE_ENTRY(DepthFunc),
+   TABLE_ENTRY(PixelZoom),
+   TABLE_ENTRY(PixelTransferf),
+   TABLE_ENTRY(PixelTransferi),
+   TABLE_ENTRY(PixelStoref),
+   TABLE_ENTRY(PixelStorei),
+   TABLE_ENTRY(PixelMapfv),
+   TABLE_ENTRY(PixelMapuiv),
+   TABLE_ENTRY(PixelMapusv),
+   TABLE_ENTRY(ReadBuffer),
+   TABLE_ENTRY(CopyPixels),
+   TABLE_ENTRY(ReadPixels),
+   TABLE_ENTRY(DrawPixels),
+   TABLE_ENTRY(GetBooleanv),
+   TABLE_ENTRY(GetClipPlane),
+   TABLE_ENTRY(GetDoublev),
+   TABLE_ENTRY(GetError),
+   TABLE_ENTRY(GetFloatv),
+   TABLE_ENTRY(GetIntegerv),
+   TABLE_ENTRY(GetLightfv),
+   TABLE_ENTRY(GetLightiv),
+   TABLE_ENTRY(GetMapdv),
+   TABLE_ENTRY(GetMapfv),
+   TABLE_ENTRY(GetMapiv),
+   TABLE_ENTRY(GetMaterialfv),
+   TABLE_ENTRY(GetMaterialiv),
+   TABLE_ENTRY(GetPixelMapfv),
+   TABLE_ENTRY(GetPixelMapuiv),
+   TABLE_ENTRY(GetPixelMapusv),
+   TABLE_ENTRY(GetPolygonStipple),
+   TABLE_ENTRY(GetString),
+   TABLE_ENTRY(GetTexEnvfv),
+   TABLE_ENTRY(GetTexEnviv),
+   TABLE_ENTRY(GetTexGendv),
+   TABLE_ENTRY(GetTexGenfv),
+   TABLE_ENTRY(GetTexGeniv),
+   TABLE_ENTRY(GetTexImage),
+   TABLE_ENTRY(GetTexParameterfv),
+   TABLE_ENTRY(GetTexParameteriv),
+   TABLE_ENTRY(GetTexLevelParameterfv),
+   TABLE_ENTRY(GetTexLevelParameteriv),
+   TABLE_ENTRY(IsEnabled),
+   TABLE_ENTRY(IsList),
+   TABLE_ENTRY(DepthRange),
+   TABLE_ENTRY(Frustum),
+   TABLE_ENTRY(LoadIdentity),
+   TABLE_ENTRY(LoadMatrixf),
+   TABLE_ENTRY(LoadMatrixd),
+   TABLE_ENTRY(MatrixMode),
+   TABLE_ENTRY(MultMatrixf),
+   TABLE_ENTRY(MultMatrixd),
+   TABLE_ENTRY(Ortho),
+   TABLE_ENTRY(PopMatrix),
+   TABLE_ENTRY(PushMatrix),
+   TABLE_ENTRY(Rotated),
+   TABLE_ENTRY(Rotatef),
+   TABLE_ENTRY(Scaled),
+   TABLE_ENTRY(Scalef),
+   TABLE_ENTRY(Translated),
+   TABLE_ENTRY(Translatef),
+   TABLE_ENTRY(Viewport),
+   TABLE_ENTRY(ArrayElement),
+   TABLE_ENTRY(BindTexture),
+   TABLE_ENTRY(ColorPointer),
+   TABLE_ENTRY(DisableClientState),
+   TABLE_ENTRY(DrawArrays),
+   TABLE_ENTRY(DrawElements),
+   TABLE_ENTRY(EdgeFlagPointer),
+   TABLE_ENTRY(EnableClientState),
+   TABLE_ENTRY(IndexPointer),
+   TABLE_ENTRY(Indexub),
+   TABLE_ENTRY(Indexubv),
+   TABLE_ENTRY(InterleavedArrays),
+   TABLE_ENTRY(NormalPointer),
+   TABLE_ENTRY(PolygonOffset),
+   TABLE_ENTRY(TexCoordPointer),
+   TABLE_ENTRY(VertexPointer),
+   TABLE_ENTRY(AreTexturesResident),
+   TABLE_ENTRY(CopyTexImage1D),
+   TABLE_ENTRY(CopyTexImage2D),
+   TABLE_ENTRY(CopyTexSubImage1D),
+   TABLE_ENTRY(CopyTexSubImage2D),
+   TABLE_ENTRY(DeleteTextures),
+   TABLE_ENTRY(GenTextures),
+   TABLE_ENTRY(GetPointerv),
+   TABLE_ENTRY(IsTexture),
+   TABLE_ENTRY(PrioritizeTextures),
+   TABLE_ENTRY(TexSubImage1D),
+   TABLE_ENTRY(TexSubImage2D),
+   TABLE_ENTRY(PopClientAttrib),
+   TABLE_ENTRY(PushClientAttrib),
+   TABLE_ENTRY(BlendColor),
+   TABLE_ENTRY(BlendEquation),
+   TABLE_ENTRY(DrawRangeElements),
+   TABLE_ENTRY(ColorTable),
+   TABLE_ENTRY(ColorTableParameterfv),
+   TABLE_ENTRY(ColorTableParameteriv),
+   TABLE_ENTRY(CopyColorTable),
+   TABLE_ENTRY(GetColorTable),
+   TABLE_ENTRY(GetColorTableParameterfv),
+   TABLE_ENTRY(GetColorTableParameteriv),
+   TABLE_ENTRY(ColorSubTable),
+   TABLE_ENTRY(CopyColorSubTable),
+   TABLE_ENTRY(ConvolutionFilter1D),
+   TABLE_ENTRY(ConvolutionFilter2D),
+   TABLE_ENTRY(ConvolutionParameterf),
+   TABLE_ENTRY(ConvolutionParameterfv),
+   TABLE_ENTRY(ConvolutionParameteri),
+   TABLE_ENTRY(ConvolutionParameteriv),
+   TABLE_ENTRY(CopyConvolutionFilter1D),
+   TABLE_ENTRY(CopyConvolutionFilter2D),
+   TABLE_ENTRY(GetConvolutionFilter),
+   TABLE_ENTRY(GetConvolutionParameterfv),
+   TABLE_ENTRY(GetConvolutionParameteriv),
+   TABLE_ENTRY(GetSeparableFilter),
+   TABLE_ENTRY(SeparableFilter2D),
+   TABLE_ENTRY(GetHistogram),
+   TABLE_ENTRY(GetHistogramParameterfv),
+   TABLE_ENTRY(GetHistogramParameteriv),
+   TABLE_ENTRY(GetMinmax),
+   TABLE_ENTRY(GetMinmaxParameterfv),
+   TABLE_ENTRY(GetMinmaxParameteriv),
+   TABLE_ENTRY(Histogram),
+   TABLE_ENTRY(Minmax),
+   TABLE_ENTRY(ResetHistogram),
+   TABLE_ENTRY(ResetMinmax),
+   TABLE_ENTRY(TexImage3D),
+   TABLE_ENTRY(TexSubImage3D),
+   TABLE_ENTRY(CopyTexSubImage3D),
+   TABLE_ENTRY(ActiveTextureARB),
+   TABLE_ENTRY(ClientActiveTextureARB),
+   TABLE_ENTRY(MultiTexCoord1dARB),
+   TABLE_ENTRY(MultiTexCoord1dvARB),
+   TABLE_ENTRY(MultiTexCoord1fARB),
+   TABLE_ENTRY(MultiTexCoord1fvARB),
+   TABLE_ENTRY(MultiTexCoord1iARB),
+   TABLE_ENTRY(MultiTexCoord1ivARB),
+   TABLE_ENTRY(MultiTexCoord1sARB),
+   TABLE_ENTRY(MultiTexCoord1svARB),
+   TABLE_ENTRY(MultiTexCoord2dARB),
+   TABLE_ENTRY(MultiTexCoord2dvARB),
+   TABLE_ENTRY(MultiTexCoord2fARB),
+   TABLE_ENTRY(MultiTexCoord2fvARB),
+   TABLE_ENTRY(MultiTexCoord2iARB),
+   TABLE_ENTRY(MultiTexCoord2ivARB),
+   TABLE_ENTRY(MultiTexCoord2sARB),
+   TABLE_ENTRY(MultiTexCoord2svARB),
+   TABLE_ENTRY(MultiTexCoord3dARB),
+   TABLE_ENTRY(MultiTexCoord3dvARB),
+   TABLE_ENTRY(MultiTexCoord3fARB),
+   TABLE_ENTRY(MultiTexCoord3fvARB),
+   TABLE_ENTRY(MultiTexCoord3iARB),
+   TABLE_ENTRY(MultiTexCoord3ivARB),
+   TABLE_ENTRY(MultiTexCoord3sARB),
+   TABLE_ENTRY(MultiTexCoord3svARB),
+   TABLE_ENTRY(MultiTexCoord4dARB),
+   TABLE_ENTRY(MultiTexCoord4dvARB),
+   TABLE_ENTRY(MultiTexCoord4fARB),
+   TABLE_ENTRY(MultiTexCoord4fvARB),
+   TABLE_ENTRY(MultiTexCoord4iARB),
+   TABLE_ENTRY(MultiTexCoord4ivARB),
+   TABLE_ENTRY(MultiTexCoord4sARB),
+   TABLE_ENTRY(MultiTexCoord4svARB),
+   TABLE_ENTRY(AttachShader),
+   TABLE_ENTRY(CreateProgram),
+   TABLE_ENTRY(CreateShader),
+   TABLE_ENTRY(DeleteProgram),
+   TABLE_ENTRY(DeleteShader),
+   TABLE_ENTRY(DetachShader),
+   TABLE_ENTRY(GetAttachedShaders),
+   TABLE_ENTRY(GetProgramInfoLog),
+   TABLE_ENTRY(GetProgramiv),
+   TABLE_ENTRY(GetShaderInfoLog),
+   TABLE_ENTRY(GetShaderiv),
+   TABLE_ENTRY(IsProgram),
+   TABLE_ENTRY(IsShader),
+   TABLE_ENTRY(StencilFuncSeparate),
+   TABLE_ENTRY(StencilMaskSeparate),
+   TABLE_ENTRY(StencilOpSeparate),
+   TABLE_ENTRY(UniformMatrix2x3fv),
+   TABLE_ENTRY(UniformMatrix2x4fv),
+   TABLE_ENTRY(UniformMatrix3x2fv),
+   TABLE_ENTRY(UniformMatrix3x4fv),
+   TABLE_ENTRY(UniformMatrix4x2fv),
+   TABLE_ENTRY(UniformMatrix4x3fv),
+   TABLE_ENTRY(LoadTransposeMatrixdARB),
+   TABLE_ENTRY(LoadTransposeMatrixfARB),
+   TABLE_ENTRY(MultTransposeMatrixdARB),
+   TABLE_ENTRY(MultTransposeMatrixfARB),
+   TABLE_ENTRY(SampleCoverageARB),
+   TABLE_ENTRY(CompressedTexImage1DARB),
+   TABLE_ENTRY(CompressedTexImage2DARB),
+   TABLE_ENTRY(CompressedTexImage3DARB),
+   TABLE_ENTRY(CompressedTexSubImage1DARB),
+   TABLE_ENTRY(CompressedTexSubImage2DARB),
+   TABLE_ENTRY(CompressedTexSubImage3DARB),
+   TABLE_ENTRY(GetCompressedTexImageARB),
+   TABLE_ENTRY(DisableVertexAttribArrayARB),
+   TABLE_ENTRY(EnableVertexAttribArrayARB),
+   TABLE_ENTRY(GetProgramEnvParameterdvARB),
+   TABLE_ENTRY(GetProgramEnvParameterfvARB),
+   TABLE_ENTRY(GetProgramLocalParameterdvARB),
+   TABLE_ENTRY(GetProgramLocalParameterfvARB),
+   TABLE_ENTRY(GetProgramStringARB),
+   TABLE_ENTRY(GetProgramivARB),
+   TABLE_ENTRY(GetVertexAttribdvARB),
+   TABLE_ENTRY(GetVertexAttribfvARB),
+   TABLE_ENTRY(GetVertexAttribivARB),
+   TABLE_ENTRY(ProgramEnvParameter4dARB),
+   TABLE_ENTRY(ProgramEnvParameter4dvARB),
+   TABLE_ENTRY(ProgramEnvParameter4fARB),
+   TABLE_ENTRY(ProgramEnvParameter4fvARB),
+   TABLE_ENTRY(ProgramLocalParameter4dARB),
+   TABLE_ENTRY(ProgramLocalParameter4dvARB),
+   TABLE_ENTRY(ProgramLocalParameter4fARB),
+   TABLE_ENTRY(ProgramLocalParameter4fvARB),
+   TABLE_ENTRY(ProgramStringARB),
+   TABLE_ENTRY(VertexAttrib1dARB),
+   TABLE_ENTRY(VertexAttrib1dvARB),
+   TABLE_ENTRY(VertexAttrib1fARB),
+   TABLE_ENTRY(VertexAttrib1fvARB),
+   TABLE_ENTRY(VertexAttrib1sARB),
+   TABLE_ENTRY(VertexAttrib1svARB),
+   TABLE_ENTRY(VertexAttrib2dARB),
+   TABLE_ENTRY(VertexAttrib2dvARB),
+   TABLE_ENTRY(VertexAttrib2fARB),
+   TABLE_ENTRY(VertexAttrib2fvARB),
+   TABLE_ENTRY(VertexAttrib2sARB),
+   TABLE_ENTRY(VertexAttrib2svARB),
+   TABLE_ENTRY(VertexAttrib3dARB),
+   TABLE_ENTRY(VertexAttrib3dvARB),
+   TABLE_ENTRY(VertexAttrib3fARB),
+   TABLE_ENTRY(VertexAttrib3fvARB),
+   TABLE_ENTRY(VertexAttrib3sARB),
+   TABLE_ENTRY(VertexAttrib3svARB),
+   TABLE_ENTRY(VertexAttrib4NbvARB),
+   TABLE_ENTRY(VertexAttrib4NivARB),
+   TABLE_ENTRY(VertexAttrib4NsvARB),
+   TABLE_ENTRY(VertexAttrib4NubARB),
+   TABLE_ENTRY(VertexAttrib4NubvARB),
+   TABLE_ENTRY(VertexAttrib4NuivARB),
+   TABLE_ENTRY(VertexAttrib4NusvARB),
+   TABLE_ENTRY(VertexAttrib4bvARB),
+   TABLE_ENTRY(VertexAttrib4dARB),
+   TABLE_ENTRY(VertexAttrib4dvARB),
+   TABLE_ENTRY(VertexAttrib4fARB),
+   TABLE_ENTRY(VertexAttrib4fvARB),
+   TABLE_ENTRY(VertexAttrib4ivARB),
+   TABLE_ENTRY(VertexAttrib4sARB),
+   TABLE_ENTRY(VertexAttrib4svARB),
+   TABLE_ENTRY(VertexAttrib4ubvARB),
+   TABLE_ENTRY(VertexAttrib4uivARB),
+   TABLE_ENTRY(VertexAttrib4usvARB),
+   TABLE_ENTRY(VertexAttribPointerARB),
+   TABLE_ENTRY(BindBufferARB),
+   TABLE_ENTRY(BufferDataARB),
+   TABLE_ENTRY(BufferSubDataARB),
+   TABLE_ENTRY(DeleteBuffersARB),
+   TABLE_ENTRY(GenBuffersARB),
+   TABLE_ENTRY(GetBufferParameterivARB),
+   TABLE_ENTRY(GetBufferPointervARB),
+   TABLE_ENTRY(GetBufferSubDataARB),
+   TABLE_ENTRY(IsBufferARB),
+   TABLE_ENTRY(MapBufferARB),
+   TABLE_ENTRY(UnmapBufferARB),
+   TABLE_ENTRY(BeginQueryARB),
+   TABLE_ENTRY(DeleteQueriesARB),
+   TABLE_ENTRY(EndQueryARB),
+   TABLE_ENTRY(GenQueriesARB),
+   TABLE_ENTRY(GetQueryObjectivARB),
+   TABLE_ENTRY(GetQueryObjectuivARB),
+   TABLE_ENTRY(GetQueryivARB),
+   TABLE_ENTRY(IsQueryARB),
+   TABLE_ENTRY(AttachObjectARB),
+   TABLE_ENTRY(CompileShaderARB),
+   TABLE_ENTRY(CreateProgramObjectARB),
+   TABLE_ENTRY(CreateShaderObjectARB),
+   TABLE_ENTRY(DeleteObjectARB),
+   TABLE_ENTRY(DetachObjectARB),
+   TABLE_ENTRY(GetActiveUniformARB),
+   TABLE_ENTRY(GetAttachedObjectsARB),
+   TABLE_ENTRY(GetHandleARB),
+   TABLE_ENTRY(GetInfoLogARB),
+   TABLE_ENTRY(GetObjectParameterfvARB),
+   TABLE_ENTRY(GetObjectParameterivARB),
+   TABLE_ENTRY(GetShaderSourceARB),
+   TABLE_ENTRY(GetUniformLocationARB),
+   TABLE_ENTRY(GetUniformfvARB),
+   TABLE_ENTRY(GetUniformivARB),
+   TABLE_ENTRY(LinkProgramARB),
+   TABLE_ENTRY(ShaderSourceARB),
+   TABLE_ENTRY(Uniform1fARB),
+   TABLE_ENTRY(Uniform1fvARB),
+   TABLE_ENTRY(Uniform1iARB),
+   TABLE_ENTRY(Uniform1ivARB),
+   TABLE_ENTRY(Uniform2fARB),
+   TABLE_ENTRY(Uniform2fvARB),
+   TABLE_ENTRY(Uniform2iARB),
+   TABLE_ENTRY(Uniform2ivARB),
+   TABLE_ENTRY(Uniform3fARB),
+   TABLE_ENTRY(Uniform3fvARB),
+   TABLE_ENTRY(Uniform3iARB),
+   TABLE_ENTRY(Uniform3ivARB),
+   TABLE_ENTRY(Uniform4fARB),
+   TABLE_ENTRY(Uniform4fvARB),
+   TABLE_ENTRY(Uniform4iARB),
+   TABLE_ENTRY(Uniform4ivARB),
+   TABLE_ENTRY(UniformMatrix2fvARB),
+   TABLE_ENTRY(UniformMatrix3fvARB),
+   TABLE_ENTRY(UniformMatrix4fvARB),
+   TABLE_ENTRY(UseProgramObjectARB),
+   TABLE_ENTRY(ValidateProgramARB),
+   TABLE_ENTRY(BindAttribLocationARB),
+   TABLE_ENTRY(GetActiveAttribARB),
+   TABLE_ENTRY(GetAttribLocationARB),
+   TABLE_ENTRY(DrawBuffersARB),
+   TABLE_ENTRY(PolygonOffsetEXT),
+   TABLE_ENTRY(_dispatch_stub_562),
+   TABLE_ENTRY(_dispatch_stub_563),
+   TABLE_ENTRY(_dispatch_stub_564),
+   TABLE_ENTRY(_dispatch_stub_565),
+   TABLE_ENTRY(_dispatch_stub_566),
+   TABLE_ENTRY(_dispatch_stub_567),
+   TABLE_ENTRY(_dispatch_stub_568),
+   TABLE_ENTRY(_dispatch_stub_569),
+   TABLE_ENTRY(ColorPointerEXT),
+   TABLE_ENTRY(EdgeFlagPointerEXT),
+   TABLE_ENTRY(IndexPointerEXT),
+   TABLE_ENTRY(NormalPointerEXT),
+   TABLE_ENTRY(TexCoordPointerEXT),
+   TABLE_ENTRY(VertexPointerEXT),
+   TABLE_ENTRY(PointParameterfEXT),
+   TABLE_ENTRY(PointParameterfvEXT),
+   TABLE_ENTRY(LockArraysEXT),
+   TABLE_ENTRY(UnlockArraysEXT),
+   TABLE_ENTRY(_dispatch_stub_580),
+   TABLE_ENTRY(_dispatch_stub_581),
+   TABLE_ENTRY(SecondaryColor3bEXT),
+   TABLE_ENTRY(SecondaryColor3bvEXT),
+   TABLE_ENTRY(SecondaryColor3dEXT),
+   TABLE_ENTRY(SecondaryColor3dvEXT),
+   TABLE_ENTRY(SecondaryColor3fEXT),
+   TABLE_ENTRY(SecondaryColor3fvEXT),
+   TABLE_ENTRY(SecondaryColor3iEXT),
+   TABLE_ENTRY(SecondaryColor3ivEXT),
+   TABLE_ENTRY(SecondaryColor3sEXT),
+   TABLE_ENTRY(SecondaryColor3svEXT),
+   TABLE_ENTRY(SecondaryColor3ubEXT),
+   TABLE_ENTRY(SecondaryColor3ubvEXT),
+   TABLE_ENTRY(SecondaryColor3uiEXT),
+   TABLE_ENTRY(SecondaryColor3uivEXT),
+   TABLE_ENTRY(SecondaryColor3usEXT),
+   TABLE_ENTRY(SecondaryColor3usvEXT),
+   TABLE_ENTRY(SecondaryColorPointerEXT),
+   TABLE_ENTRY(MultiDrawArraysEXT),
+   TABLE_ENTRY(MultiDrawElementsEXT),
+   TABLE_ENTRY(FogCoordPointerEXT),
+   TABLE_ENTRY(FogCoorddEXT),
+   TABLE_ENTRY(FogCoorddvEXT),
+   TABLE_ENTRY(FogCoordfEXT),
+   TABLE_ENTRY(FogCoordfvEXT),
+   TABLE_ENTRY(_dispatch_stub_606),
+   TABLE_ENTRY(BlendFuncSeparateEXT),
+   TABLE_ENTRY(FlushVertexArrayRangeNV),
+   TABLE_ENTRY(VertexArrayRangeNV),
+   TABLE_ENTRY(CombinerInputNV),
+   TABLE_ENTRY(CombinerOutputNV),
+   TABLE_ENTRY(CombinerParameterfNV),
+   TABLE_ENTRY(CombinerParameterfvNV),
+   TABLE_ENTRY(CombinerParameteriNV),
+   TABLE_ENTRY(CombinerParameterivNV),
+   TABLE_ENTRY(FinalCombinerInputNV),
+   TABLE_ENTRY(GetCombinerInputParameterfvNV),
+   TABLE_ENTRY(GetCombinerInputParameterivNV),
+   TABLE_ENTRY(GetCombinerOutputParameterfvNV),
+   TABLE_ENTRY(GetCombinerOutputParameterivNV),
+   TABLE_ENTRY(GetFinalCombinerInputParameterfvNV),
+   TABLE_ENTRY(GetFinalCombinerInputParameterivNV),
+   TABLE_ENTRY(ResizeBuffersMESA),
+   TABLE_ENTRY(WindowPos2dMESA),
+   TABLE_ENTRY(WindowPos2dvMESA),
+   TABLE_ENTRY(WindowPos2fMESA),
+   TABLE_ENTRY(WindowPos2fvMESA),
+   TABLE_ENTRY(WindowPos2iMESA),
+   TABLE_ENTRY(WindowPos2ivMESA),
+   TABLE_ENTRY(WindowPos2sMESA),
+   TABLE_ENTRY(WindowPos2svMESA),
+   TABLE_ENTRY(WindowPos3dMESA),
+   TABLE_ENTRY(WindowPos3dvMESA),
+   TABLE_ENTRY(WindowPos3fMESA),
+   TABLE_ENTRY(WindowPos3fvMESA),
+   TABLE_ENTRY(WindowPos3iMESA),
+   TABLE_ENTRY(WindowPos3ivMESA),
+   TABLE_ENTRY(WindowPos3sMESA),
+   TABLE_ENTRY(WindowPos3svMESA),
+   TABLE_ENTRY(WindowPos4dMESA),
+   TABLE_ENTRY(WindowPos4dvMESA),
+   TABLE_ENTRY(WindowPos4fMESA),
+   TABLE_ENTRY(WindowPos4fvMESA),
+   TABLE_ENTRY(WindowPos4iMESA),
+   TABLE_ENTRY(WindowPos4ivMESA),
+   TABLE_ENTRY(WindowPos4sMESA),
+   TABLE_ENTRY(WindowPos4svMESA),
+   TABLE_ENTRY(_dispatch_stub_648),
+   TABLE_ENTRY(_dispatch_stub_649),
+   TABLE_ENTRY(_dispatch_stub_650),
+   TABLE_ENTRY(_dispatch_stub_651),
+   TABLE_ENTRY(_dispatch_stub_652),
+   TABLE_ENTRY(_dispatch_stub_653),
+   TABLE_ENTRY(_dispatch_stub_654),
+   TABLE_ENTRY(_dispatch_stub_655),
+   TABLE_ENTRY(_dispatch_stub_656),
+   TABLE_ENTRY(AreProgramsResidentNV),
+   TABLE_ENTRY(BindProgramNV),
+   TABLE_ENTRY(DeleteProgramsNV),
+   TABLE_ENTRY(ExecuteProgramNV),
+   TABLE_ENTRY(GenProgramsNV),
+   TABLE_ENTRY(GetProgramParameterdvNV),
+   TABLE_ENTRY(GetProgramParameterfvNV),
+   TABLE_ENTRY(GetProgramStringNV),
+   TABLE_ENTRY(GetProgramivNV),
+   TABLE_ENTRY(GetTrackMatrixivNV),
+   TABLE_ENTRY(GetVertexAttribPointervNV),
+   TABLE_ENTRY(GetVertexAttribdvNV),
+   TABLE_ENTRY(GetVertexAttribfvNV),
+   TABLE_ENTRY(GetVertexAttribivNV),
+   TABLE_ENTRY(IsProgramNV),
+   TABLE_ENTRY(LoadProgramNV),
+   TABLE_ENTRY(ProgramParameters4dvNV),
+   TABLE_ENTRY(ProgramParameters4fvNV),
+   TABLE_ENTRY(RequestResidentProgramsNV),
+   TABLE_ENTRY(TrackMatrixNV),
+   TABLE_ENTRY(VertexAttrib1dNV),
+   TABLE_ENTRY(VertexAttrib1dvNV),
+   TABLE_ENTRY(VertexAttrib1fNV),
+   TABLE_ENTRY(VertexAttrib1fvNV),
+   TABLE_ENTRY(VertexAttrib1sNV),
+   TABLE_ENTRY(VertexAttrib1svNV),
+   TABLE_ENTRY(VertexAttrib2dNV),
+   TABLE_ENTRY(VertexAttrib2dvNV),
+   TABLE_ENTRY(VertexAttrib2fNV),
+   TABLE_ENTRY(VertexAttrib2fvNV),
+   TABLE_ENTRY(VertexAttrib2sNV),
+   TABLE_ENTRY(VertexAttrib2svNV),
+   TABLE_ENTRY(VertexAttrib3dNV),
+   TABLE_ENTRY(VertexAttrib3dvNV),
+   TABLE_ENTRY(VertexAttrib3fNV),
+   TABLE_ENTRY(VertexAttrib3fvNV),
+   TABLE_ENTRY(VertexAttrib3sNV),
+   TABLE_ENTRY(VertexAttrib3svNV),
+   TABLE_ENTRY(VertexAttrib4dNV),
+   TABLE_ENTRY(VertexAttrib4dvNV),
+   TABLE_ENTRY(VertexAttrib4fNV),
+   TABLE_ENTRY(VertexAttrib4fvNV),
+   TABLE_ENTRY(VertexAttrib4sNV),
+   TABLE_ENTRY(VertexAttrib4svNV),
+   TABLE_ENTRY(VertexAttrib4ubNV),
+   TABLE_ENTRY(VertexAttrib4ubvNV),
+   TABLE_ENTRY(VertexAttribPointerNV),
+   TABLE_ENTRY(VertexAttribs1dvNV),
+   TABLE_ENTRY(VertexAttribs1fvNV),
+   TABLE_ENTRY(VertexAttribs1svNV),
+   TABLE_ENTRY(VertexAttribs2dvNV),
+   TABLE_ENTRY(VertexAttribs2fvNV),
+   TABLE_ENTRY(VertexAttribs2svNV),
+   TABLE_ENTRY(VertexAttribs3dvNV),
+   TABLE_ENTRY(VertexAttribs3fvNV),
+   TABLE_ENTRY(VertexAttribs3svNV),
+   TABLE_ENTRY(VertexAttribs4dvNV),
+   TABLE_ENTRY(VertexAttribs4fvNV),
+   TABLE_ENTRY(VertexAttribs4svNV),
+   TABLE_ENTRY(VertexAttribs4ubvNV),
+   TABLE_ENTRY(AlphaFragmentOp1ATI),
+   TABLE_ENTRY(AlphaFragmentOp2ATI),
+   TABLE_ENTRY(AlphaFragmentOp3ATI),
+   TABLE_ENTRY(BeginFragmentShaderATI),
+   TABLE_ENTRY(BindFragmentShaderATI),
+   TABLE_ENTRY(ColorFragmentOp1ATI),
+   TABLE_ENTRY(ColorFragmentOp2ATI),
+   TABLE_ENTRY(ColorFragmentOp3ATI),
+   TABLE_ENTRY(DeleteFragmentShaderATI),
+   TABLE_ENTRY(EndFragmentShaderATI),
+   TABLE_ENTRY(GenFragmentShadersATI),
+   TABLE_ENTRY(PassTexCoordATI),
+   TABLE_ENTRY(SampleMapATI),
+   TABLE_ENTRY(SetFragmentShaderConstantATI),
+   TABLE_ENTRY(PointParameteriNV),
+   TABLE_ENTRY(PointParameterivNV),
+   TABLE_ENTRY(_dispatch_stub_733),
+   TABLE_ENTRY(_dispatch_stub_734),
+   TABLE_ENTRY(_dispatch_stub_735),
+   TABLE_ENTRY(_dispatch_stub_736),
+   TABLE_ENTRY(_dispatch_stub_737),
+   TABLE_ENTRY(GetProgramNamedParameterdvNV),
+   TABLE_ENTRY(GetProgramNamedParameterfvNV),
+   TABLE_ENTRY(ProgramNamedParameter4dNV),
+   TABLE_ENTRY(ProgramNamedParameter4dvNV),
+   TABLE_ENTRY(ProgramNamedParameter4fNV),
+   TABLE_ENTRY(ProgramNamedParameter4fvNV),
+   TABLE_ENTRY(_dispatch_stub_744),
+   TABLE_ENTRY(_dispatch_stub_745),
+   TABLE_ENTRY(BindFramebufferEXT),
+   TABLE_ENTRY(BindRenderbufferEXT),
+   TABLE_ENTRY(CheckFramebufferStatusEXT),
+   TABLE_ENTRY(DeleteFramebuffersEXT),
+   TABLE_ENTRY(DeleteRenderbuffersEXT),
+   TABLE_ENTRY(FramebufferRenderbufferEXT),
+   TABLE_ENTRY(FramebufferTexture1DEXT),
+   TABLE_ENTRY(FramebufferTexture2DEXT),
+   TABLE_ENTRY(FramebufferTexture3DEXT),
+   TABLE_ENTRY(GenFramebuffersEXT),
+   TABLE_ENTRY(GenRenderbuffersEXT),
+   TABLE_ENTRY(GenerateMipmapEXT),
+   TABLE_ENTRY(GetFramebufferAttachmentParameterivEXT),
+   TABLE_ENTRY(GetRenderbufferParameterivEXT),
+   TABLE_ENTRY(IsFramebufferEXT),
+   TABLE_ENTRY(IsRenderbufferEXT),
+   TABLE_ENTRY(RenderbufferStorageEXT),
+   TABLE_ENTRY(_dispatch_stub_763),
+   TABLE_ENTRY(FramebufferTextureLayerEXT),
+   TABLE_ENTRY(_dispatch_stub_765),
+   TABLE_ENTRY(_dispatch_stub_766),
+   TABLE_ENTRY(_dispatch_stub_767),
+   TABLE_ENTRY(_dispatch_stub_768),
+   TABLE_ENTRY(_dispatch_stub_769),
+   /* A whole bunch of no-op functions.  These might be called
+    * when someone tries to call a dynamically-registered
+    * extension function without a current rendering context.
+    */
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+   TABLE_ENTRY(Unused),
+};
+#endif /* DISPATCH_TABLE_NAME */
+
+
+/*
+ * This is just used to silence compiler warnings.
+ * We list the functions which are not otherwise used.
+ */
+#ifdef UNUSED_TABLE_NAME
+static _glapi_proc UNUSED_TABLE_NAME[] = {
+   TABLE_ENTRY(ArrayElementEXT),
+   TABLE_ENTRY(BindTextureEXT),
+   TABLE_ENTRY(DrawArraysEXT),
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(AreTexturesResidentEXT),
+#endif
+   TABLE_ENTRY(CopyTexImage1DEXT),
+   TABLE_ENTRY(CopyTexImage2DEXT),
+   TABLE_ENTRY(CopyTexSubImage1DEXT),
+   TABLE_ENTRY(CopyTexSubImage2DEXT),
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(DeleteTexturesEXT),
+#endif
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(GenTexturesEXT),
+#endif
+   TABLE_ENTRY(GetPointervEXT),
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(IsTextureEXT),
+#endif
+   TABLE_ENTRY(PrioritizeTexturesEXT),
+   TABLE_ENTRY(TexSubImage1DEXT),
+   TABLE_ENTRY(TexSubImage2DEXT),
+   TABLE_ENTRY(BlendColorEXT),
+   TABLE_ENTRY(BlendEquationEXT),
+   TABLE_ENTRY(DrawRangeElementsEXT),
+   TABLE_ENTRY(ColorTableEXT),
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(GetColorTableEXT),
+#endif
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(GetColorTableParameterfvEXT),
+#endif
+#ifndef GLX_INDIRECT_RENDERING
+   TABLE_ENTRY(GetColorTableParameterivEXT),
+#endif
+   TABLE_ENTRY(TexImage3DEXT),
+   TABLE_ENTRY(TexSubImage3DEXT),
+   TABLE_ENTRY(CopyTexSubImage3DEXT),
+   TABLE_ENTRY(ActiveTexture),
+   TABLE_ENTRY(ClientActiveTexture),
+   TABLE_ENTRY(MultiTexCoord1d),
+   TABLE_ENTRY(MultiTexCoord1dv),
+   TABLE_ENTRY(MultiTexCoord1f),
+   TABLE_ENTRY(MultiTexCoord1fv),
+   TABLE_ENTRY(MultiTexCoord1i),
+   TABLE_ENTRY(MultiTexCoord1iv),
+   TABLE_ENTRY(MultiTexCoord1s),
+   TABLE_ENTRY(MultiTexCoord1sv),
+   TABLE_ENTRY(MultiTexCoord2d),
+   TABLE_ENTRY(MultiTexCoord2dv),
+   TABLE_ENTRY(MultiTexCoord2f),
+   TABLE_ENTRY(MultiTexCoord2fv),
+   TABLE_ENTRY(MultiTexCoord2i),
+   TABLE_ENTRY(MultiTexCoord2iv),
+   TABLE_ENTRY(MultiTexCoord2s),
+   TABLE_ENTRY(MultiTexCoord2sv),
+   TABLE_ENTRY(MultiTexCoord3d),
+   TABLE_ENTRY(MultiTexCoord3dv),
+   TABLE_ENTRY(MultiTexCoord3f),
+   TABLE_ENTRY(MultiTexCoord3fv),
+   TABLE_ENTRY(MultiTexCoord3i),
+   TABLE_ENTRY(MultiTexCoord3iv),
+   TABLE_ENTRY(MultiTexCoord3s),
+   TABLE_ENTRY(MultiTexCoord3sv),
+   TABLE_ENTRY(MultiTexCoord4d),
+   TABLE_ENTRY(MultiTexCoord4dv),
+   TABLE_ENTRY(MultiTexCoord4f),
+   TABLE_ENTRY(MultiTexCoord4fv),
+   TABLE_ENTRY(MultiTexCoord4i),
+   TABLE_ENTRY(MultiTexCoord4iv),
+   TABLE_ENTRY(MultiTexCoord4s),
+   TABLE_ENTRY(MultiTexCoord4sv),
+   TABLE_ENTRY(LoadTransposeMatrixd),
+   TABLE_ENTRY(LoadTransposeMatrixf),
+   TABLE_ENTRY(MultTransposeMatrixd),
+   TABLE_ENTRY(MultTransposeMatrixf),
+   TABLE_ENTRY(SampleCoverage),
+   TABLE_ENTRY(CompressedTexImage1D),
+   TABLE_ENTRY(CompressedTexImage2D),
+   TABLE_ENTRY(CompressedTexImage3D),
+   TABLE_ENTRY(CompressedTexSubImage1D),
+   TABLE_ENTRY(CompressedTexSubImage2D),
+   TABLE_ENTRY(CompressedTexSubImage3D),
+   TABLE_ENTRY(GetCompressedTexImage),
+   TABLE_ENTRY(DisableVertexAttribArray),
+   TABLE_ENTRY(EnableVertexAttribArray),
+   TABLE_ENTRY(GetVertexAttribdv),
+   TABLE_ENTRY(GetVertexAttribfv),
+   TABLE_ENTRY(GetVertexAttribiv),
+   TABLE_ENTRY(ProgramParameter4dNV),
+   TABLE_ENTRY(ProgramParameter4dvNV),
+   TABLE_ENTRY(ProgramParameter4fNV),
+   TABLE_ENTRY(ProgramParameter4fvNV),
+   TABLE_ENTRY(VertexAttrib1d),
+   TABLE_ENTRY(VertexAttrib1dv),
+   TABLE_ENTRY(VertexAttrib1f),
+   TABLE_ENTRY(VertexAttrib1fv),
+   TABLE_ENTRY(VertexAttrib1s),
+   TABLE_ENTRY(VertexAttrib1sv),
+   TABLE_ENTRY(VertexAttrib2d),
+   TABLE_ENTRY(VertexAttrib2dv),
+   TABLE_ENTRY(VertexAttrib2f),
+   TABLE_ENTRY(VertexAttrib2fv),
+   TABLE_ENTRY(VertexAttrib2s),
+   TABLE_ENTRY(VertexAttrib2sv),
+   TABLE_ENTRY(VertexAttrib3d),
+   TABLE_ENTRY(VertexAttrib3dv),
+   TABLE_ENTRY(VertexAttrib3f),
+   TABLE_ENTRY(VertexAttrib3fv),
+   TABLE_ENTRY(VertexAttrib3s),
+   TABLE_ENTRY(VertexAttrib3sv),
+   TABLE_ENTRY(VertexAttrib4Nbv),
+   TABLE_ENTRY(VertexAttrib4Niv),
+   TABLE_ENTRY(VertexAttrib4Nsv),
+   TABLE_ENTRY(VertexAttrib4Nub),
+   TABLE_ENTRY(VertexAttrib4Nubv),
+   TABLE_ENTRY(VertexAttrib4Nuiv),
+   TABLE_ENTRY(VertexAttrib4Nusv),
+   TABLE_ENTRY(VertexAttrib4bv),
+   TABLE_ENTRY(VertexAttrib4d),
+   TABLE_ENTRY(VertexAttrib4dv),
+   TABLE_ENTRY(VertexAttrib4f),
+   TABLE_ENTRY(VertexAttrib4fv),
+   TABLE_ENTRY(VertexAttrib4iv),
+   TABLE_ENTRY(VertexAttrib4s),
+   TABLE_ENTRY(VertexAttrib4sv),
+   TABLE_ENTRY(VertexAttrib4ubv),
+   TABLE_ENTRY(VertexAttrib4uiv),
+   TABLE_ENTRY(VertexAttrib4usv),
+   TABLE_ENTRY(VertexAttribPointer),
+   TABLE_ENTRY(BindBuffer),
+   TABLE_ENTRY(BufferData),
+   TABLE_ENTRY(BufferSubData),
+   TABLE_ENTRY(DeleteBuffers),
+   TABLE_ENTRY(GenBuffers),
+   TABLE_ENTRY(GetBufferParameteriv),
+   TABLE_ENTRY(GetBufferPointerv),
+   TABLE_ENTRY(GetBufferSubData),
+   TABLE_ENTRY(IsBuffer),
+   TABLE_ENTRY(MapBuffer),
+   TABLE_ENTRY(UnmapBuffer),
+   TABLE_ENTRY(BeginQuery),
+   TABLE_ENTRY(DeleteQueries),
+   TABLE_ENTRY(EndQuery),
+   TABLE_ENTRY(GenQueries),
+   TABLE_ENTRY(GetQueryObjectiv),
+   TABLE_ENTRY(GetQueryObjectuiv),
+   TABLE_ENTRY(GetQueryiv),
+   TABLE_ENTRY(IsQuery),
+   TABLE_ENTRY(CompileShader),
+   TABLE_ENTRY(GetActiveUniform),
+   TABLE_ENTRY(GetShaderSource),
+   TABLE_ENTRY(GetUniformLocation),
+   TABLE_ENTRY(GetUniformfv),
+   TABLE_ENTRY(GetUniformiv),
+   TABLE_ENTRY(LinkProgram),
+   TABLE_ENTRY(ShaderSource),
+   TABLE_ENTRY(Uniform1f),
+   TABLE_ENTRY(Uniform1fv),
+   TABLE_ENTRY(Uniform1i),
+   TABLE_ENTRY(Uniform1iv),
+   TABLE_ENTRY(Uniform2f),
+   TABLE_ENTRY(Uniform2fv),
+   TABLE_ENTRY(Uniform2i),
+   TABLE_ENTRY(Uniform2iv),
+   TABLE_ENTRY(Uniform3f),
+   TABLE_ENTRY(Uniform3fv),
+   TABLE_ENTRY(Uniform3i),
+   TABLE_ENTRY(Uniform3iv),
+   TABLE_ENTRY(Uniform4f),
+   TABLE_ENTRY(Uniform4fv),
+   TABLE_ENTRY(Uniform4i),
+   TABLE_ENTRY(Uniform4iv),
+   TABLE_ENTRY(UniformMatrix2fv),
+   TABLE_ENTRY(UniformMatrix3fv),
+   TABLE_ENTRY(UniformMatrix4fv),
+   TABLE_ENTRY(UseProgram),
+   TABLE_ENTRY(ValidateProgram),
+   TABLE_ENTRY(BindAttribLocation),
+   TABLE_ENTRY(GetActiveAttrib),
+   TABLE_ENTRY(GetAttribLocation),
+   TABLE_ENTRY(DrawBuffers),
+   TABLE_ENTRY(DrawBuffersATI),
+   TABLE_ENTRY(PointParameterf),
+   TABLE_ENTRY(PointParameterfARB),
+   TABLE_ENTRY(PointParameterfv),
+   TABLE_ENTRY(PointParameterfvARB),
+   TABLE_ENTRY(SecondaryColor3b),
+   TABLE_ENTRY(SecondaryColor3bv),
+   TABLE_ENTRY(SecondaryColor3d),
+   TABLE_ENTRY(SecondaryColor3dv),
+   TABLE_ENTRY(SecondaryColor3f),
+   TABLE_ENTRY(SecondaryColor3fv),
+   TABLE_ENTRY(SecondaryColor3i),
+   TABLE_ENTRY(SecondaryColor3iv),
+   TABLE_ENTRY(SecondaryColor3s),
+   TABLE_ENTRY(SecondaryColor3sv),
+   TABLE_ENTRY(SecondaryColor3ub),
+   TABLE_ENTRY(SecondaryColor3ubv),
+   TABLE_ENTRY(SecondaryColor3ui),
+   TABLE_ENTRY(SecondaryColor3uiv),
+   TABLE_ENTRY(SecondaryColor3us),
+   TABLE_ENTRY(SecondaryColor3usv),
+   TABLE_ENTRY(SecondaryColorPointer),
+   TABLE_ENTRY(MultiDrawArrays),
+   TABLE_ENTRY(MultiDrawElements),
+   TABLE_ENTRY(FogCoordPointer),
+   TABLE_ENTRY(FogCoordd),
+   TABLE_ENTRY(FogCoorddv),
+   TABLE_ENTRY(FogCoordf),
+   TABLE_ENTRY(FogCoordfv),
+   TABLE_ENTRY(BlendFuncSeparate),
+   TABLE_ENTRY(WindowPos2d),
+   TABLE_ENTRY(WindowPos2dARB),
+   TABLE_ENTRY(WindowPos2dv),
+   TABLE_ENTRY(WindowPos2dvARB),
+   TABLE_ENTRY(WindowPos2f),
+   TABLE_ENTRY(WindowPos2fARB),
+   TABLE_ENTRY(WindowPos2fv),
+   TABLE_ENTRY(WindowPos2fvARB),
+   TABLE_ENTRY(WindowPos2i),
+   TABLE_ENTRY(WindowPos2iARB),
+   TABLE_ENTRY(WindowPos2iv),
+   TABLE_ENTRY(WindowPos2ivARB),
+   TABLE_ENTRY(WindowPos2s),
+   TABLE_ENTRY(WindowPos2sARB),
+   TABLE_ENTRY(WindowPos2sv),
+   TABLE_ENTRY(WindowPos2svARB),
+   TABLE_ENTRY(WindowPos3d),
+   TABLE_ENTRY(WindowPos3dARB),
+   TABLE_ENTRY(WindowPos3dv),
+   TABLE_ENTRY(WindowPos3dvARB),
+   TABLE_ENTRY(WindowPos3f),
+   TABLE_ENTRY(WindowPos3fARB),
+   TABLE_ENTRY(WindowPos3fv),
+   TABLE_ENTRY(WindowPos3fvARB),
+   TABLE_ENTRY(WindowPos3i),
+   TABLE_ENTRY(WindowPos3iARB),
+   TABLE_ENTRY(WindowPos3iv),
+   TABLE_ENTRY(WindowPos3ivARB),
+   TABLE_ENTRY(WindowPos3s),
+   TABLE_ENTRY(WindowPos3sARB),
+   TABLE_ENTRY(WindowPos3sv),
+   TABLE_ENTRY(WindowPos3svARB),
+   TABLE_ENTRY(BindProgramARB),
+   TABLE_ENTRY(DeleteProgramsARB),
+   TABLE_ENTRY(GenProgramsARB),
+   TABLE_ENTRY(GetVertexAttribPointerv),
+   TABLE_ENTRY(GetVertexAttribPointervARB),
+   TABLE_ENTRY(IsProgramARB),
+   TABLE_ENTRY(PointParameteri),
+   TABLE_ENTRY(PointParameteriv),
+   TABLE_ENTRY(BlendEquationSeparate),
+};
+#endif /*UNUSED_TABLE_NAME*/
+
+
+#  undef KEYWORD1
+#  undef KEYWORD1_ALT
+#  undef KEYWORD2
+#  undef NAME
+#  undef DISPATCH
+#  undef RETURN_DISPATCH
+#  undef DISPATCH_TABLE_NAME
+#  undef UNUSED_TABLE_NAME
+#  undef TABLE_ENTRY
+#  undef HIDDEN
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dristruct.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dristruct.h
@@ -0,0 +1,129 @@
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Jens Owen <jens@tungstengraphics.com>
+ *
+ */
+
+#ifndef DRI_STRUCT_H
+#define DRI_STRUCT_H
+
+#include "xf86drm.h"
+#include "xf86Crtc.h"
+
+
+#define DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin) ((DRIDrawablePrivPtr) \
+    dixLookupPrivate(&(pWin)->devPrivates, DRIWindowPrivKey))
+#define DRI_DRAWABLE_PRIV_FROM_PIXMAP(pPix) ((DRIDrawablePrivPtr) \
+    dixLookupPrivate(&(pPix)->devPrivates, DRIWindowPrivKey))
+
+typedef struct _DRIDrawablePrivRec
+{
+    drm_drawable_t		hwDrawable;
+    int			drawableIndex;
+    ScreenPtr		pScreen;
+    int 		refCount;
+    int 		nrects;
+} DRIDrawablePrivRec, *DRIDrawablePrivPtr;
+
+struct _DRIContextPrivRec
+{
+    drm_context_t		hwContext;
+    ScreenPtr		pScreen;
+    Bool     		valid3D;
+    DRIContextFlags     flags;
+    void**     		pContextStore;
+};
+
+#define DRI_SCREEN_PRIV(pScreen) ((DRIScreenPrivPtr) \
+    (dixPrivateKeyRegistered(DRIScreenPrivKey) ?			\
+     dixLookupPrivate(&(pScreen)->devPrivates, DRIScreenPrivKey) : NULL))
+
+#define DRI_SCREEN_PRIV_FROM_INDEX(screenIndex) ((DRIScreenPrivPtr) \
+    dixLookupPrivate(&screenInfo.screens[screenIndex]->devPrivates, \
+		     DRIScreenPrivKey))
+
+#define DRI_ENT_PRIV(pScrn)  \
+    ((DRIEntPrivIndex < 0) ? \
+     NULL:		     \
+     ((DRIEntPrivPtr)(xf86GetEntityPrivate((pScrn)->entityList[0], \
+					   DRIEntPrivIndex)->ptr)))
+
+typedef struct _DRIScreenPrivRec
+{
+    Bool		directRenderingSupport;
+    int			drmFD;	      /* File descriptor for /dev/video/?   */
+    drm_handle_t   	hSAREA;	      /* Handle to SAREA, for mapping       */
+    XF86DRISAREAPtr	pSAREA;	      /* Mapped pointer to SAREA            */
+    drm_context_t          myContext;    /* DDX Driver's context               */
+    DRIContextPrivPtr   myContextPriv;/* Pointer to server's private area   */
+    DRIContextPrivPtr   lastPartial3DContext;  /* last one partially saved  */
+    void**		hiddenContextStore;    /* hidden X context          */
+    void**		partial3DContextStore; /* parital 3D context        */
+    DRIInfoPtr		pDriverInfo;
+    int                 nrWindows;
+    int                 nrWindowsVisible;
+    int                 nrWalked;
+    drm_clip_rect_t  private_buffer_rect; /* management of private buffers */
+    DrawablePtr         fullscreen; /* pointer to fullscreen drawable */
+    drm_clip_rect_t  fullscreen_rect; /* fake rect for fullscreen mode */
+    DRIWrappedFuncsRec	wrap;
+    DestroyWindowProcPtr DestroyWindow;
+    DrawablePtr		DRIDrawables[SAREA_MAX_DRAWABLES];
+    DRIContextPrivPtr   dummyCtxPriv; /* Pointer to dummy context */
+    Bool		createDummyCtx;
+    Bool		createDummyCtxPriv;
+    Bool		grabbedDRILock;
+    Bool		drmSIGIOHandlerInstalled;
+    Bool		wrapped;
+    Bool		windowsTouched;
+    int			lockRefCount;
+    drm_handle_t        hLSAREA;      /* Handle to SAREA containing lock, for mapping */
+    XF86DRILSAREAPtr    pLSAREA;      /* Mapped pointer to SAREA containing lock */
+    int*                pLockRefCount;
+    int*                pLockingContext;
+    xf86_crtc_notify_proc_ptr	xf86_crtc_notify;
+} DRIScreenPrivRec, *DRIScreenPrivPtr;
+
+
+typedef struct _DRIEntPrivRec {
+    int drmFD;
+    Bool drmOpened;
+    Bool sAreaGrabbed;
+    drm_handle_t hLSAREA;
+    XF86DRILSAREAPtr pLSAREA;
+    unsigned long sAreaSize;
+    int lockRefCount;
+    int lockingContext;
+    ScreenPtr resOwner;
+    Bool keepFDOpen;
+    int refCount;
+} DRIEntPrivRec, *DRIEntPrivPtr;
+
+#endif /* DRI_STRUCT_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxstat.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxstat.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright 2002 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ *
+ */
+
+/** \file
+ * Interface for statistic gathering interface. \see dmxstat.c */
+
+#ifndef _DMXSTAT_H_
+#define _DMXSTAT_H_
+
+#define DMX_STAT_LENGTH     10  /**< number of events for moving average */
+#define DMX_STAT_INTERVAL 1000  /**< msec between printouts */
+#define DMX_STAT_BINS        3  /**< number of bins */
+#define DMX_STAT_BIN0    10000  /**< us for bin[0] */
+#define DMX_STAT_BINMULT   100  /**< multiplier for next bin[] */
+
+extern int         dmxStatInterval; /**< Only for dmxstat.c and dmxsync.c */
+extern void        dmxStatActivate(const char *interval, const char *displays);
+extern DMXStatInfo *dmxStatAlloc(void);
+extern void        dmxStatFree(DMXStatInfo *);
+extern void        dmxStatInit(void);
+extern void        dmxStatSync(DMXScreenInfo *dmxScreen,
+                               struct timeval *stop, struct timeval *start,
+                               unsigned long pending);
+
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/scoasm.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/scoasm.h
@@ -0,0 +1,142 @@
+
+/*
+ * Copyright (c) 1996 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+/*
+ * scoasm.h - used to define inline versions of certain functions which
+ * do NOT appear in sys/inline.h.
+ */
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#if defined(__SCO__) && defined(__USLC__)
+#ifndef _SCOASM_HDR_INC
+#define _SCOASM_HDR_INC
+
+asm     void outl(port,val)
+{
+%reg	port,val;
+	movl	port, %edx
+	movl	val, %eax
+	outl	(%dx)
+%reg	port; mem	val;
+	movl	port, %edx
+	movl    val, %eax
+	outl	(%dx)
+%mem	port; reg	val;
+	movw	port, %dx
+	movl	val, %eax
+	outl	(%dx)
+%mem	port,val;
+	movw	port, %dx
+	movl    val, %eax
+	outl	(%dx)
+}
+
+asm	void outw(port,val)
+{
+%reg	port,val;
+	movl	port, %edx
+	movl	val, %eax
+	data16
+	outl	(%dx)
+%reg	port; mem	val;
+	movl	port, %edx
+	movw	val, %ax
+	data16
+	outl	(%dx)
+%mem	port; reg	val;
+	movw	port, %dx
+	movl	val, %eax
+	data16
+	outl	(%dx)
+%mem	port,val;
+	movw	port, %dx
+	movw	val, %ax
+	data16
+	outl	(%dx)
+}
+
+asm	void outb(port,val)
+{
+%reg	port,val;
+	movl	port, %edx
+	movl	val, %eax
+	outb	(%dx)
+%reg	port; mem	val;
+	movl	port, %edx
+	movb	val, %al
+	outb	(%dx)
+%mem	port; reg	val;
+	movw	port, %dx
+	movl	val, %eax
+	outb	(%dx)
+%mem	port,val;
+	movw	port, %dx
+	movb	val, %al
+	outb	(%dx)
+}
+
+asm     int inl(port)
+{
+%reg	port;
+	movl	port, %edx
+	inl	(%dx)
+%mem	port;
+	movw	port, %dx
+	inl	(%dx)
+}
+
+asm	int inw(port)
+{
+%reg	port;
+	subl    %eax, %eax
+	movl	port, %edx
+	data16
+	inl	(%dx)
+%mem	port;
+	subl    %eax, %eax
+	movw	port, %dx
+	data16
+	inl	(%dx)
+}
+
+asm	int inb(port)
+{
+%reg	port;
+	subl    %eax, %eax
+	movl	port, %edx
+	inb	(%dx)
+%mem	port;
+	subl    %eax, %eax
+	movw	port, %dx
+	inb	(%dx)
+}
+
+#endif /* _SCOASM_HDR_INC */
+#endif /* __SCO__ && __USLC__ */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiproperty.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/xiproperty.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright © 2008 Peter Hutterer
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ *
+ * Author: Peter Hutterer
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#ifndef XIPROPERTY_H
+#define XIPROPERTY_H 1
+
+int ProcXListDeviceProperties     (ClientPtr client);
+int ProcXChangeDeviceProperty     (ClientPtr client);
+int ProcXDeleteDeviceProperty     (ClientPtr client);
+int ProcXGetDeviceProperty        (ClientPtr client);
+
+/* request swapping */
+int SProcXListDeviceProperties    (ClientPtr client);
+int SProcXChangeDeviceProperty    (ClientPtr client);
+int SProcXDeleteDeviceProperty    (ClientPtr client);
+int SProcXGetDeviceProperty       (ClientPtr client);
+
+/* reply swapping */
+void SRepXListDeviceProperties(ClientPtr client, int size,
+                               xListDevicePropertiesReply *rep);
+void SRepXGetDeviceProperty(ClientPtr client, int size,
+                            xGetDevicePropertyReply *rep);
+
+/* XI2 request/reply handling  */
+int ProcXIListProperties        (ClientPtr client);
+int ProcXIChangeProperty        (ClientPtr client);
+int ProcXIDeleteProperty        (ClientPtr client);
+int ProcXIGetProperty           (ClientPtr client);
+
+int SProcXIListProperties       (ClientPtr client);
+int SProcXIChangeProperty       (ClientPtr client);
+int SProcXIDeleteProperty       (ClientPtr client);
+int SProcXIGetProperty          (ClientPtr client);
+
+void SRepXIListProperties(ClientPtr client, int size,
+                          xXIListPropertiesReply *rep);
+void SRepXIGetProperty(ClientPtr client, int size,
+                       xXIGetPropertyReply *rep);
+
+void XIResetProperties(void);
+
+#endif /* XIPROPERTY_H */
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxmap.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/dmxmap.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2003 Red Hat Inc., Durham, North Carolina.
+ *
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation on the rights to use, copy, modify, merge,
+ * publish, distribute, sublicense, and/or sell copies of the Software,
+ * and to permit persons to whom the Software is furnished to do so,
+ * subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial
+ * portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NON-INFRINGEMENT.  IN NO EVENT SHALL RED HAT AND/OR THEIR SUPPLIERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+/*
+ * Authors:
+ *   Rickard E. (Rik) Faith <faith@redhat.com>
+ */
+
+/** \file
+ * Interface to XInput event mapping support.  \see dmxmap.c */
+
+#ifndef _DMXMAP_H_
+#define _DMXMAP_H_
+extern void dmxMapInsert(DMXLocalInputInfoPtr dmxLocal,
+                         int remoteEvent, int serverEvent);
+extern void dmxMapClear(DMXLocalInputInfoPtr dmxLocal);
+extern int  dmxMapLookup(DMXLocalInputInfoPtr dmxLocal, int remoteEvent);
+#endif
Index: src/VBox/Additions/x11/x11include/xorg-server-1.9.0/pixmapstr.h
===================================================================
--- /dev/null
+++ src/VBox/Additions/x11/x11include/xorg-server-1.9.0/pixmapstr.h
@@ -0,0 +1,86 @@
+/***********************************************************
+
+Copyright 1987, 1998  The Open Group
+
+Permission to use, copy, modify, distribute, and sell this software and its
+documentation for any purpose is hereby granted without fee, provided that
+the above copyright notice appear in all copies and that both that
+copyright notice and this permission notice appear in supporting
+documentation.
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of The Open Group shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from The Open Group.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+
+#ifndef PIXMAPSTRUCT_H
+#define PIXMAPSTRUCT_H
+#include "pixmap.h"
+#include "screenint.h"
+#include "regionstr.h"
+#include "privates.h"
+
+typedef struct _Drawable {
+    unsigned char	type;	/* DRAWABLE_<type> */
+    unsigned char	class;	/* specific to type */
+    unsigned char	depth;
+    unsigned char	bitsPerPixel;
+    XID			id;	/* resource id */
+    short		x;	/* window: screen absolute, pixmap: 0 */
+    short		y;	/* window: screen absolute, pixmap: 0 */
+    unsigned short	width;
+    unsigned short	height;
+    ScreenPtr		pScreen;
+    unsigned long	serialNumber;
+} DrawableRec;
+
+/*
+ * PIXMAP -- device dependent 
+ */
+
+typedef struct _Pixmap {
+    DrawableRec		drawable;
+    PrivateRec		*devPrivates;
+    int			refcnt;
+    int			devKind; /* This is the pitch of the pixmap, typically width*bpp/8. */
+    DevUnion		devPrivate; /* When !NULL, devPrivate.ptr points to the raw pixel data. */
+#ifdef COMPOSITE
+    short		screen_x;
+    short		screen_y;
+#endif
+    unsigned		usage_hint; /* see CREATE_PIXMAP_USAGE_* */
+} PixmapRec;
+
+#endif /* PIXMAPSTRUCT_H */
